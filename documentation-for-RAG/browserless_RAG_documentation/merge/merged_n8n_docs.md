# n8n Documentation


## Advanced

### waitForNavigation | Browserless.io
Original URL: https://docs.browserless.io/bql-schema/operations/mutations/wait-for-navigation

[Skip to main content](https://docs.browserless.io/bql-schema/operations/mutations/wait-for-navigation#__docusaurus_skipToContent_fallback)


Waits for a navigation even to fire, useful for clicking an element and waiting for a page load of some

Example:

```codeBlockLines_p187
mutation WaitForNavigation {
  goto(url: "https://example.com") {
    status
  }

  waitForNavigation(waitUntil: load) {
    status
  }
}

```

```codeBlockLines_p187
waitForNavigation(
  timeout: Float
  waitUntil: WaitUntilGoto = load
): HTTPResponse

```

### Arguments [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/wait-for-navigation\#arguments "Direct link to Arguments")

#### [`waitForNavigation.timeout`](https://docs.browserless.io/bql-schema/operations/mutations/wait-for-navigation\#)Â â—Â [`Float`](https://docs.browserless.io/bql-schema/types/scalars/float) scalar [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/wait-for-navigation\#waitfornavigationtimeoutfloat- "Direct link to waitfornavigationtimeoutfloat-")

The maximum amount of time, in milliseconds, to wait for the page to load, overriding any defaults. Default timeout is 30 seconds, or 30000.

#### [`waitForNavigation.waitUntil`](https://docs.browserless.io/bql-schema/operations/mutations/wait-for-navigation\#)Â â—Â [`WaitUntilGoto`](https://docs.browserless.io/bql-schema/types/enums/wait-until-goto) enum [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/wait-for-navigation\#waitfornavigationwaituntilwaituntilgoto- "Direct link to waitfornavigationwaituntilwaituntilgoto-")

When to consider the page fully-loaded and proceed with further execution

### Type [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/wait-for-navigation\#type "Direct link to Type")

#### [`HTTPResponse`](https://docs.browserless.io/bql-schema/types/objects/httpresponse) object [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/wait-for-navigation\#httpresponse- "Direct link to httpresponse-")

Response returned after a navigation event

- [Arguments](https://docs.browserless.io/bql-schema/operations/mutations/wait-for-navigation#arguments)
- [Type](https://docs.browserless.io/bql-schema/operations/mutations/wait-for-navigation#type)

---

### waitForRequest | Browserless.io
Original URL: https://docs.browserless.io/bql-schema/operations/mutations/wait-for-request

[Skip to main content](https://docs.browserless.io/bql-schema/operations/mutations/wait-for-request#__docusaurus_skipToContent_fallback)


Waits for the browser to make a particular request

Example:

```codeBlockLines_p187
mutation WaitForRequest {
  goto(url: "https://browserless.io") {
    status
  }

  waitForRequest(method: GET) {
    time
  }
}

```

```codeBlockLines_p187
waitForRequest(
  method: Method
  timeout: Float
  url: String
): WaitForRequest

```

### Arguments [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/wait-for-request\#arguments "Direct link to Arguments")

#### [`waitForRequest.method`](https://docs.browserless.io/bql-schema/operations/mutations/wait-for-request\#)Â â—Â [`Method`](https://docs.browserless.io/bql-schema/types/enums/method) enum [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/wait-for-request\#waitforrequestmethodmethod- "Direct link to waitforrequestmethodmethod-")

The method of the request to wait for

#### [`waitForRequest.timeout`](https://docs.browserless.io/bql-schema/operations/mutations/wait-for-request\#)Â â—Â [`Float`](https://docs.browserless.io/bql-schema/types/scalars/float) scalar [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/wait-for-request\#waitforrequesttimeoutfloat- "Direct link to waitforrequesttimeoutfloat-")

How long to wait for the request to be made before timing out, overriding any defaults. Default timeout is 30 seconds, or 30000.

#### [`waitForRequest.url`](https://docs.browserless.io/bql-schema/operations/mutations/wait-for-request\#)Â â—Â [`String`](https://docs.browserless.io/bql-schema/types/scalars/string) scalar [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/wait-for-request\#waitforrequesturlstring- "Direct link to waitforrequesturlstring-")

The pattern of the request URL to wait for, using glob-style pattern-matching

### Type [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/wait-for-request\#type "Direct link to Type")

#### [`WaitForRequest`](https://docs.browserless.io/bql-schema/types/objects/wait-for-request) object [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/wait-for-request\#waitforrequest- "Direct link to waitforrequest-")

Response returned after a particular network request has been sent

- [Arguments](https://docs.browserless.io/bql-schema/operations/mutations/wait-for-request#arguments)
- [Type](https://docs.browserless.io/bql-schema/operations/mutations/wait-for-request#type)

---

### waitForResponse | Browserless.io
Original URL: https://docs.browserless.io/bql-schema/operations/mutations/wait-for-response

[Skip to main content](https://docs.browserless.io/bql-schema/operations/mutations/wait-for-response#__docusaurus_skipToContent_fallback)


Waits for a particular network response to be made back to the browser

Example:

```codeBlockLines_p187
mutation WaitForResponse {
  goto(url: "https://browserless.io") {
    status
  }

  waitForResponse(codes: [200]) {
    time
  }
}

```

```codeBlockLines_p187
waitForResponse(
  codes: [Int]
  statuses: [Int]
  url: String
): WaitForResponse

```

### Arguments [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/wait-for-response\#arguments "Direct link to Arguments")

#### [`waitForResponse.codes`](https://docs.browserless.io/bql-schema/operations/mutations/wait-for-response\#)Â â—Â [`[Int]`](https://docs.browserless.io/bql-schema/types/scalars/int) deprecatedlistscalar [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/wait-for-response\#waitforresponsecodesint--- "Direct link to waitforresponsecodesint---")

DEPRECATED

Use `statuses` field instead as it is more consistent in BrowserQL.

The HTTP Response code(s) of the URL to wait for. Can be a single HTTP code or a list of desired codes

#### [`waitForResponse.statuses`](https://docs.browserless.io/bql-schema/operations/mutations/wait-for-response\#)Â â—Â [`[Int]`](https://docs.browserless.io/bql-schema/types/scalars/int) listscalar [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/wait-for-response\#waitforresponsestatusesint-- "Direct link to waitforresponsestatusesint--")

The HTTP Response code(s) of the URL to wait for. Can be a single HTTP code or a list of desired codes

#### [`waitForResponse.url`](https://docs.browserless.io/bql-schema/operations/mutations/wait-for-response\#)Â â—Â [`String`](https://docs.browserless.io/bql-schema/types/scalars/string) scalar [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/wait-for-response\#waitforresponseurlstring- "Direct link to waitforresponseurlstring-")

The pattern of the response URL to wait for, using glob-style pattern-matching

### Type [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/wait-for-response\#type "Direct link to Type")

#### [`WaitForResponse`](https://docs.browserless.io/bql-schema/types/objects/wait-for-response) object [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/wait-for-response\#waitforresponse- "Direct link to waitforresponse-")

Response returned after a particular network response has been received

- [Arguments](https://docs.browserless.io/bql-schema/operations/mutations/wait-for-response#arguments)
- [Type](https://docs.browserless.io/bql-schema/operations/mutations/wait-for-response#type)

---

### waitForSelector | Browserless.io
Original URL: https://docs.browserless.io/bql-schema/operations/mutations/wait-for-selector

[Skip to main content](https://docs.browserless.io/bql-schema/operations/mutations/wait-for-selector#__docusaurus_skipToContent_fallback)


Waits for a given selector to be present in the DOM, with optional visibility

Example:

```codeBlockLines_p187
mutation WaitForSelector {
  goto(url: "https://example.com") {
    status
  }

  waitForSelector(selector: "h1") {
    time
  }
}

```

```codeBlockLines_p187
waitForSelector(
  selector: String!
  timeout: Float
  visible: Boolean = false
): WaitForSelector

```

### Arguments [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/wait-for-selector\#arguments "Direct link to Arguments")

#### [`waitForSelector.selector`](https://docs.browserless.io/bql-schema/operations/mutations/wait-for-selector\#)Â â—Â [`String!`](https://docs.browserless.io/bql-schema/types/scalars/string) non-nullscalar [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/wait-for-selector\#waitforselectorselectorstring-- "Direct link to waitforselectorselectorstring--")

The selector to wait for until present in the DOM

#### [`waitForSelector.timeout`](https://docs.browserless.io/bql-schema/operations/mutations/wait-for-selector\#)Â â—Â [`Float`](https://docs.browserless.io/bql-schema/types/scalars/float) scalar [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/wait-for-selector\#waitforselectortimeoutfloat- "Direct link to waitforselectortimeoutfloat-")

When waiting for a selector applies a timeout to wait for in milliseconds, overriding any defaults. Default timeout is 30 seconds, or 30000.

#### [`waitForSelector.visible`](https://docs.browserless.io/bql-schema/operations/mutations/wait-for-selector\#)Â â—Â [`Boolean`](https://docs.browserless.io/bql-schema/types/scalars/boolean) scalar [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/wait-for-selector\#waitforselectorvisibleboolean- "Direct link to waitforselectorvisibleboolean-")

Whether or not to consider the element as present only if it's visible

### Type [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/wait-for-selector\#type "Direct link to Type")

#### [`WaitForSelector`](https://docs.browserless.io/bql-schema/types/objects/wait-for-selector) object [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/wait-for-selector\#waitforselector- "Direct link to waitforselector-")

Response returned after a particular selector has been found in the DOM

- [Arguments](https://docs.browserless.io/bql-schema/operations/mutations/wait-for-selector#arguments)
- [Type](https://docs.browserless.io/bql-schema/operations/mutations/wait-for-selector#type)

---

### waitForTimeout | Browserless.io
Original URL: https://docs.browserless.io/bql-schema/operations/mutations/wait-for-timeout

[Skip to main content](https://docs.browserless.io/bql-schema/operations/mutations/wait-for-timeout#__docusaurus_skipToContent_fallback)


Wait for a period of time, defined in milliseconds

Example:

```codeBlockLines_p187
mutation WaitForTimeout {
  waitForTimeout(time: 1000) {
    time
  }
}

```

```codeBlockLines_p187
waitForTimeout(
  time: Float!
): WaitForTimeout

```

### Arguments [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/wait-for-timeout\#arguments "Direct link to Arguments")

#### [`waitForTimeout.time`](https://docs.browserless.io/bql-schema/operations/mutations/wait-for-timeout\#)Â â—Â [`Float!`](https://docs.browserless.io/bql-schema/types/scalars/float) non-nullscalar [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/wait-for-timeout\#waitfortimeouttimefloat-- "Direct link to waitfortimeouttimefloat--")

The amount of time to wait for, in milliseconds

### Type [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/wait-for-timeout\#type "Direct link to Type")

#### [`WaitForTimeout`](https://docs.browserless.io/bql-schema/types/objects/wait-for-timeout) object [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/wait-for-timeout\#waitfortimeout- "Direct link to waitfortimeout-")

Response returned after having waited for a selector to appear in the DOM

- [Arguments](https://docs.browserless.io/bql-schema/operations/mutations/wait-for-timeout#arguments)
- [Type](https://docs.browserless.io/bql-schema/operations/mutations/wait-for-timeout#type)

---

### WaitUntilGoto | Browserless.io
Original URL: https://docs.browserless.io/bql-schema/types/enums/wait-until-goto

[Skip to main content](https://docs.browserless.io/bql-schema/types/enums/wait-until-goto#__docusaurus_skipToContent_fallback)


Options for when to consider the page has loaded and proceed with further execution

```codeBlockLines_p187
enum WaitUntilGoto {
  domContentLoaded
  load
  commit
  firstMeaningfulPaint
  firstContentfulPaint
  interactiveTime
  networkIdle
}

```

### Values [â€‹](https://docs.browserless.io/bql-schema/types/enums/wait-until-goto\#values "Direct link to Values")

#### [`WaitUntilGoto.domContentLoaded`](https://docs.browserless.io/bql-schema/types/enums/wait-until-goto\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/wait-until-goto\#waituntilgotodomcontentloaded "Direct link to waituntilgotodomcontentloaded")

Fired when the DOMContentLoaded event is fired

#### [`WaitUntilGoto.load`](https://docs.browserless.io/bql-schema/types/enums/wait-until-goto\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/wait-until-goto\#waituntilgotoload "Direct link to waituntilgotoload")

Fired when the 'load' event occurs

#### [`WaitUntilGoto.commit`](https://docs.browserless.io/bql-schema/types/enums/wait-until-goto\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/wait-until-goto\#waituntilgotocommit "Direct link to waituntilgotocommit")

Fired when network response is received and the document started loading

#### [`WaitUntilGoto.firstMeaningfulPaint`](https://docs.browserless.io/bql-schema/types/enums/wait-until-goto\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/wait-until-goto\#waituntilgotofirstmeaningfulpaint "Direct link to waituntilgotofirstmeaningfulpaint")

Indicates when the primary content of a page is visible to the user

#### [`WaitUntilGoto.firstContentfulPaint`](https://docs.browserless.io/bql-schema/types/enums/wait-until-goto\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/wait-until-goto\#waituntilgotofirstcontentfulpaint "Direct link to waituntilgotofirstcontentfulpaint")

The render time of the largest image or text block visible in the viewport, relative to when the user first navigated to the page

#### [`WaitUntilGoto.interactiveTime`](https://docs.browserless.io/bql-schema/types/enums/wait-until-goto\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/wait-until-goto\#waituntilgotointeractivetime "Direct link to waituntilgotointeractivetime")

Use with caution: Chrome's best guess as to when the page becomes interactable

#### [`WaitUntilGoto.networkIdle`](https://docs.browserless.io/bql-schema/types/enums/wait-until-goto\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/wait-until-goto\#waituntilgotonetworkidle "Direct link to waituntilgotonetworkidle")

Use with caution: Fired when there are no network connections for at least 500 ms

### Member Of [â€‹](https://docs.browserless.io/bql-schema/types/enums/wait-until-goto\#member-of "Direct link to Member Of")

[`goto`](https://docs.browserless.io/bql-schema/operations/mutations/goto) mutationÂ â—Â [`waitForNavigation`](https://docs.browserless.io/bql-schema/operations/mutations/wait-for-navigation) mutation

- [Values](https://docs.browserless.io/bql-schema/types/enums/wait-until-goto#values)
- [Member Of](https://docs.browserless.io/bql-schema/types/enums/wait-until-goto#member-of)

---

### WaitUntilHistory | Browserless.io
Original URL: https://docs.browserless.io/bql-schema/types/enums/wait-until-history

[Skip to main content](https://docs.browserless.io/bql-schema/types/enums/wait-until-history#__docusaurus_skipToContent_fallback)


The different stages of the browser's loading process

```codeBlockLines_p187
enum WaitUntilHistory {
  commit
  domContentLoaded
  load
  networkIdle
}

```

### Values [â€‹](https://docs.browserless.io/bql-schema/types/enums/wait-until-history\#values "Direct link to Values")

#### [`WaitUntilHistory.commit`](https://docs.browserless.io/bql-schema/types/enums/wait-until-history\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/wait-until-history\#waituntilhistorycommit "Direct link to waituntilhistorycommit")

Fired when network response is received and the document started loading

#### [`WaitUntilHistory.domContentLoaded`](https://docs.browserless.io/bql-schema/types/enums/wait-until-history\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/wait-until-history\#waituntilhistorydomcontentloaded "Direct link to waituntilhistorydomcontentloaded")

Fired when the DOMContentLoaded event is fired

#### [`WaitUntilHistory.load`](https://docs.browserless.io/bql-schema/types/enums/wait-until-history\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/wait-until-history\#waituntilhistoryload "Direct link to waituntilhistoryload")

Fired when the 'load' event occurs

#### [`WaitUntilHistory.networkIdle`](https://docs.browserless.io/bql-schema/types/enums/wait-until-history\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/wait-until-history\#waituntilhistorynetworkidle "Direct link to waituntilhistorynetworkidle")

Use with caution: Fired when there are no network connections for at least 500 ms

### Member Of [â€‹](https://docs.browserless.io/bql-schema/types/enums/wait-until-history\#member-of "Direct link to Member Of")

[`back`](https://docs.browserless.io/bql-schema/operations/mutations/back) mutationÂ â—Â [`content`](https://docs.browserless.io/bql-schema/operations/mutations/content) mutationÂ â—Â [`forward`](https://docs.browserless.io/bql-schema/operations/mutations/forward) mutationÂ â—Â [`reload`](https://docs.browserless.io/bql-schema/operations/mutations/reload) mutation

- [Values](https://docs.browserless.io/bql-schema/types/enums/wait-until-history#values)
- [Member Of](https://docs.browserless.io/bql-schema/types/enums/wait-until-history#member-of)

---

### WaitForRequest | Browserless.io
Original URL: https://docs.browserless.io/bql-schema/types/objects/wait-for-request

[Skip to main content](https://docs.browserless.io/bql-schema/types/objects/wait-for-request#__docusaurus_skipToContent_fallback)


Response returned after a particular network request has been sent

```codeBlockLines_p187
type WaitForRequest {
  time: Float
  url: String
}

```

### Fields [â€‹](https://docs.browserless.io/bql-schema/types/objects/wait-for-request\#fields "Direct link to Fields")

#### [`WaitForRequest.time`](https://docs.browserless.io/bql-schema/types/objects/wait-for-request\#)Â â—Â [`Float`](https://docs.browserless.io/bql-schema/types/scalars/float) scalar [â€‹](https://docs.browserless.io/bql-schema/types/objects/wait-for-request\#waitforrequesttimefloat- "Direct link to waitforrequesttimefloat-")

The period of time elapsed, in milliseconds, waited for

#### [`WaitForRequest.url`](https://docs.browserless.io/bql-schema/types/objects/wait-for-request\#)Â â—Â [`String`](https://docs.browserless.io/bql-schema/types/scalars/string) scalar [â€‹](https://docs.browserless.io/bql-schema/types/objects/wait-for-request\#waitforrequesturlstring- "Direct link to waitforrequesturlstring-")

The URL parameter used to match the response with

### Returned By [â€‹](https://docs.browserless.io/bql-schema/types/objects/wait-for-request\#returned-by "Direct link to Returned By")

[`waitForRequest`](https://docs.browserless.io/bql-schema/operations/mutations/wait-for-request) mutation

- [Fields](https://docs.browserless.io/bql-schema/types/objects/wait-for-request#fields)
- [Returned By](https://docs.browserless.io/bql-schema/types/objects/wait-for-request#returned-by)

---

### WaitForResponse | Browserless.io
Original URL: https://docs.browserless.io/bql-schema/types/objects/wait-for-response

[Skip to main content](https://docs.browserless.io/bql-schema/types/objects/wait-for-response#__docusaurus_skipToContent_fallback)


Response returned after a particular network response has been received

```codeBlockLines_p187
type WaitForResponse {
  time: Float
  status: Int
  url: String
}

```

### Fields [â€‹](https://docs.browserless.io/bql-schema/types/objects/wait-for-response\#fields "Direct link to Fields")

#### [`WaitForResponse.time`](https://docs.browserless.io/bql-schema/types/objects/wait-for-response\#)Â â—Â [`Float`](https://docs.browserless.io/bql-schema/types/scalars/float) scalar [â€‹](https://docs.browserless.io/bql-schema/types/objects/wait-for-response\#waitforresponsetimefloat- "Direct link to waitforresponsetimefloat-")

The period of time elapsed, in milliseconds, waited for

#### [`WaitForResponse.status`](https://docs.browserless.io/bql-schema/types/objects/wait-for-response\#)Â â—Â [`Int`](https://docs.browserless.io/bql-schema/types/scalars/int) scalar [â€‹](https://docs.browserless.io/bql-schema/types/objects/wait-for-response\#waitforresponsestatusint- "Direct link to waitforresponsestatusint-")

The status code response of the response

#### [`WaitForResponse.url`](https://docs.browserless.io/bql-schema/types/objects/wait-for-response\#)Â â—Â [`String`](https://docs.browserless.io/bql-schema/types/scalars/string) scalar [â€‹](https://docs.browserless.io/bql-schema/types/objects/wait-for-response\#waitforresponseurlstring- "Direct link to waitforresponseurlstring-")

The URL parameter used to match the response with

### Returned By [â€‹](https://docs.browserless.io/bql-schema/types/objects/wait-for-response\#returned-by "Direct link to Returned By")

[`waitForResponse`](https://docs.browserless.io/bql-schema/operations/mutations/wait-for-response) mutation

- [Fields](https://docs.browserless.io/bql-schema/types/objects/wait-for-response#fields)
- [Returned By](https://docs.browserless.io/bql-schema/types/objects/wait-for-response#returned-by)

---

### WaitForSelector | Browserless.io
Original URL: https://docs.browserless.io/bql-schema/types/objects/wait-for-selector

[Skip to main content](https://docs.browserless.io/bql-schema/types/objects/wait-for-selector#__docusaurus_skipToContent_fallback)


Response returned after a particular selector has been found in the DOM

```codeBlockLines_p187
type WaitForSelector {
  height: Float
  selector: String
  time: Float
  y: Float
  x: Float
  width: Float
}

```

### Fields [â€‹](https://docs.browserless.io/bql-schema/types/objects/wait-for-selector\#fields "Direct link to Fields")

#### [`WaitForSelector.height`](https://docs.browserless.io/bql-schema/types/objects/wait-for-selector\#)Â â—Â [`Float`](https://docs.browserless.io/bql-schema/types/scalars/float) scalar [â€‹](https://docs.browserless.io/bql-schema/types/objects/wait-for-selector\#waitforselectorheightfloat- "Direct link to waitforselectorheightfloat-")

The height, in pixels, of the element

#### [`WaitForSelector.selector`](https://docs.browserless.io/bql-schema/types/objects/wait-for-selector\#)Â â—Â [`String`](https://docs.browserless.io/bql-schema/types/scalars/string) scalar [â€‹](https://docs.browserless.io/bql-schema/types/objects/wait-for-selector\#waitforselectorselectorstring- "Direct link to waitforselectorselectorstring-")

The selector waited for

#### [`WaitForSelector.time`](https://docs.browserless.io/bql-schema/types/objects/wait-for-selector\#)Â â—Â [`Float`](https://docs.browserless.io/bql-schema/types/scalars/float) scalar [â€‹](https://docs.browserless.io/bql-schema/types/objects/wait-for-selector\#waitforselectortimefloat- "Direct link to waitforselectortimefloat-")

The period of time elapsed, in milliseconds, waited for

#### [`WaitForSelector.y`](https://docs.browserless.io/bql-schema/types/objects/wait-for-selector\#)Â â—Â [`Float`](https://docs.browserless.io/bql-schema/types/scalars/float) scalar [â€‹](https://docs.browserless.io/bql-schema/types/objects/wait-for-selector\#waitforselectoryfloat- "Direct link to waitforselectoryfloat-")

The position, in pixels, top of the viewport

#### [`WaitForSelector.x`](https://docs.browserless.io/bql-schema/types/objects/wait-for-selector\#)Â â—Â [`Float`](https://docs.browserless.io/bql-schema/types/scalars/float) scalar [â€‹](https://docs.browserless.io/bql-schema/types/objects/wait-for-selector\#waitforselectorxfloat- "Direct link to waitforselectorxfloat-")

The position, in pixels, left of the viewport

#### [`WaitForSelector.width`](https://docs.browserless.io/bql-schema/types/objects/wait-for-selector\#)Â â—Â [`Float`](https://docs.browserless.io/bql-schema/types/scalars/float) scalar [â€‹](https://docs.browserless.io/bql-schema/types/objects/wait-for-selector\#waitforselectorwidthfloat- "Direct link to waitforselectorwidthfloat-")

The width, in pixels, of the element

### Returned By [â€‹](https://docs.browserless.io/bql-schema/types/objects/wait-for-selector\#returned-by "Direct link to Returned By")

[`waitForSelector`](https://docs.browserless.io/bql-schema/operations/mutations/wait-for-selector) mutation

- [Fields](https://docs.browserless.io/bql-schema/types/objects/wait-for-selector#fields)
- [Returned By](https://docs.browserless.io/bql-schema/types/objects/wait-for-selector#returned-by)

---

### WaitForTimeout | Browserless.io
Original URL: https://docs.browserless.io/bql-schema/types/objects/wait-for-timeout

[Skip to main content](https://docs.browserless.io/bql-schema/types/objects/wait-for-timeout#__docusaurus_skipToContent_fallback)


Response returned after having waited for a selector to appear in the DOM

```codeBlockLines_p187
type WaitForTimeout {
  time: Float
}

```

### Fields [â€‹](https://docs.browserless.io/bql-schema/types/objects/wait-for-timeout\#fields "Direct link to Fields")

#### [`WaitForTimeout.time`](https://docs.browserless.io/bql-schema/types/objects/wait-for-timeout\#)Â â—Â [`Float`](https://docs.browserless.io/bql-schema/types/scalars/float) scalar [â€‹](https://docs.browserless.io/bql-schema/types/objects/wait-for-timeout\#waitfortimeouttimefloat- "Direct link to waitfortimeouttimefloat-")

The period of time elapsed, in milliseconds, waited for

### Returned By [â€‹](https://docs.browserless.io/bql-schema/types/objects/wait-for-timeout\#returned-by "Direct link to Returned By")

[`waitForTimeout`](https://docs.browserless.io/bql-schema/operations/mutations/wait-for-timeout) mutation

- [Fields](https://docs.browserless.io/bql-schema/types/objects/wait-for-timeout#fields)
- [Returned By](https://docs.browserless.io/bql-schema/types/objects/wait-for-timeout#returned-by)

---

### Advanced Options | Browserless.io
Original URL: https://docs.browserless.io/browserql/writing-bql/advanced-options

[Skip to main content](https://docs.browserless.io/browserql/writing-bql/advanced-options#__docusaurus_skipToContent_fallback)


BrowserQL offers advanced options allows developers to create dynamic, condition-based workflows, capture visual data, and interact programmatically with web pages. These options enhance the flexibility of web automation, making it possible to tackle complex scenarios with ease. Below, youâ€™ll find detailed examples and use cases to help you with these advanced features.

- [Conditional Behaviors](https://docs.browserless.io/browserql/writing-bql/advanced-options#conditional-behaviors)
- [Scraping Structured Data](https://docs.browserless.io/browserql/writing-bql/advanced-options#scraping-structured-data)
- [Taking Screenshots](https://docs.browserless.io/browserql/writing-bql/advanced-options#taking-screenshots)
- [Generating PDFs](https://docs.browserless.io/browserql/writing-bql/advanced-options#generating-pdfs)

## Conditional Behaviors [â€‹](https://docs.browserless.io/browserql/writing-bql/advanced-options\#conditional-behaviors "Direct link to Conditional Behaviors")

You can use `if` or `ifnot` mutations to trigger nested work branches based on specific conditions. A common use case for this is when a browser interaction receives a 403 code, indicating the need to use a verification or captcha-solving mutation.

The example below will only trigger the `verify` mutation when the `goto` returns a 403 code:

```codeBlockLines_p187
mutation ConditionalCase {
  goto(url: "https://www.browserless.io/", waitUntil: domContentLoaded) {
    status
  }
  if(response: {codes: 403}) {
    waitForTimeout(time: 2000) {
      time
    }
    verify(type: cloudflare) {
      solved
    }
  }
}

```

Now, a `ifnot` can be used to treat cases where the code isn't 403. For example, the code below retrieves the page's title when any other code is returned:

```codeBlockLines_p187
mutation ConditionalCase {
  goto(url: "https://www.browserless.io/", waitUntil: domContentLoaded) {
    status
  }
  if(response: {codes: 403}) {
    waitForTimeout(time: 2000) {
      time
    }
    verify(type: cloudflare) {
      solved
    }
  }

  ifnot(response: {codes: 403}) {
    title {
      title
    }
  }
}

```

This example opens up two different work branches, one that will be triggered when a code 403 is received, and a second one to handle when any other code is returned.

## Scraping Structured Data [â€‹](https://docs.browserless.io/browserql/writing-bql/advanced-options\#scraping-structured-data "Direct link to Scraping Structured Data")

Many pages have structure to them where one can infer a data hierarchy. This can simple things like a list of products, their prices, and even reviews. In such cases where you run into these hierarchies we heavily recommend using the `mapSelector` query to "map" over this data and return a well structured response.

This query allows you to functionally "map" over repetitive, hierarchical data in the page and extract data. This query is very powerful in that you can get _any_ kind of data out of the page, including data in attributes, textual data, or even further nested data.

Let's take a look at the Hacker News as an example. This site has posts that are easily retrieved by mapping over the `submission` class on the page. In BrowserQL, this would look like this:

```codeBlockLines_p187
mutation MapHN {
  goto(url: "https://news.ycombinator.com/", waitUntil: domContentLoaded) {
    status
  }

  posts: mapSelector(selector: ".post") {
    itemId: id
  }
}

```

Here, we're using the `post` class as a way to target each post on the page, and then we ask for the "id" attribute of the post. We also are using aliases to further give semantic meaning to these actions as well so it's clear what we're getting in response. When ran this will return a data structure like so:

```codeBlockLines_p187
{
  "data": {
    "goto": {
      "status": 200
    },
    "posts": [\
      {\
        "itemId": "43128253"\
      },\
      {\
        "itemId": "43130732"\
      },\
    ...\
}\
\
```\
\
Taking this a step further, we can now map over each _post_ and get more details like author, rank, and even comment count. Since these each have their own repetitive structure within the page, we can nest a second `mapSelector` call and get that nested data:\
\
```codeBlockLines_p187\
mutation MapHN {\
  goto(url: "https://news.ycombinator.com", waitUntil: networkIdle) {\
    status\
  }\
\
  # Iterate over each submission\
  posts: mapSelector(selector: ".submission") {\
    itemId: id\
\
    # Get the ranking of the submission\
    rank: mapSelector(selector: ".rank", wait: true) {\
      rank: innerText\
    }\
\
    # Get the link of the submission\
    link: mapSelector(selector: ".titleline > a", wait: true) {\
      # You can query for arbitrary tags attributes as well by using the "attribute" mechanism.\
      link: attribute(name: "href") {\
        value\
      }\
    }\
  }\
}\
\
```\
\
When using a nested `mapSelector` this will keep hierarchy intact. This means that each "rank" and "link" in the data will be the items that are nested in each submission.\
\
Finally, since mapping is a functional programming concept, this means that all responses returned are iterable, meaning an array of items even if it is just a single item. In this case, rank and links are a single item in an array.\
\
## Taking Screenshots [â€‹](https://docs.browserless.io/browserql/writing-bql/advanced-options\#taking-screenshots "Direct link to Taking Screenshots")\
\
BrowserQL can be used to take screenshots from any website. With the screenshot mutator, you can generate any image, and BQL will return a base64 encoded string of the new image.\
\
For example, the code below takes a picture of [https://example.com/](https://example.com/), focusing on the middle section using the `clip` argument to define the image's size, and screen position.\
\
- Screenshot\
- With Selector\
- Response\
\
```codeBlockLines_p187\
mutation TakeScreenshot {\
  goto(url: "https://example.com/") {\
    status\
  }\
  screenshot(clip: {width: 720, height: 300, x: 150, y: 65}) {\
    base64\
  }\
}\
\
```\
\
```codeBlockLines_p187\
mutation TakeScreenshot {\
  goto(url: "https://example.com/") {\
    status\
  }\
  screenshot(selector: "div.logo_footer.w-embed") {\
    base64\
  }\
}\
\
```\
\
```codeBlockLines_p187\
{\
  "data": {\
    "goto": {\
      "status": 200\
    },\
    "screenshot": {\
      "base64": "iVBORw0KGgoAAAANSUhEUgAAAtAAAAEsCAIAAABl...AAEA6ggMAAEhHcAAAAOkIDgAAIB3BAQAApCM4AACAdAQHAACQjuAAAADS/QfLjprKnsPc9AAAAABJRU5ErkJggg=="\
    }\
  }\
}\
\
```\
\
Available arguments\
\
Refer to the [Mutation Reference](https://docs.browserless.io/bql-schema/operations/mutations/screenshot) page for full details on the available arguments and response from the screenshot mutation.\
\
Now, with the image's base64, you can use it, as exemplified below, replacing `<PASTE_YOUR_BASE64_HERE>` with your base64 string:\
\
- HTML\
- Save File\
\
```codeBlockLines_p187\
<!DOCTYPE html>\
<html>\
<head>\
    <title>Base64 Image Viewer</title>\
</head>\
<body>\
    <img src="data:image/png;base64,<PASTE_YOUR_BASE64_HERE>" alt="Base64 Image">\
</body>\
</html>\
\
```\
\
```codeBlockLines_p187\
import base64\
\
# Base64 string\
base64_string = "<PASTE_YOUR_BASE64_HERE>"\
\
# Decode and save as a file\
with open("output.png", "wb") as file:\
    file.write(base64.b64decode(base64_string))\
\
```\
\
## Generating PDFs [â€‹](https://docs.browserless.io/browserql/writing-bql/advanced-options\#generating-pdfs "Direct link to Generating PDFs")\
\
Similarly to taking screenshots, there is the `pdf` mutation to generate PDFs. BQL will generate a base64 encoded string from any website.\
\
```codeBlockLines_p187\
mutation GetPDF {\
  goto(url: "https://example.com/") {\
    status\
  }\
  pdf {\
    base64\
  }\
}\
\
```\
\
Available arguments\
\
Refer to the [Mutation Reference](https://docs.browserless.io/bql-schema/operations/mutations/pdf) page for full details on the available arguments and response from the pdf mutation.\
\
With the PDF's base64 string, you can generate the PDF file, or make it downloadable in your own site.\
\
- HTML\
- Save File\
\
```codeBlockLines_p187\
<!DOCTYPE html>\
<html>\
<head>\
    <title>Base64 PDF Viewer</title>\
</head>\
<body>\
    <iframe src="data:application/pdf;base64,<PASTE_YOUR_BASE64_HERE>" width="600" height="400"></iframe>\
    <a href="data:application/pdf;base64,<PASTE_YOUR_BASE64_HERE>" download="document.pdf">Download PDF</a>\
</body>\
</html>\
\
```\
\
```codeBlockLines_p187\
import base64\
\
# Base64 string\
base64_string = "<PASTE_YOUR_BASE64_HERE>"\
\
# Decode and save as a file\
with open("output_document.pdf", "wb") as file:\
    file.write(base64.b64decode(base64_string))\
\
```\
\
- [Conditional Behaviors](https://docs.browserless.io/browserql/writing-bql/advanced-options#conditional-behaviors)\
- [Scraping Structured Data](https://docs.browserless.io/browserql/writing-bql/advanced-options#scraping-structured-data)\
- [Taking Screenshots](https://docs.browserless.io/browserql/writing-bql/advanced-options#taking-screenshots)\
- [Generating PDFs](https://docs.browserless.io/browserql/writing-bql/advanced-options#generating-pdfs)

---

### Waiting for Things | Browserless.io
Original URL: https://docs.browserless.io/nav-options/waiting

[Skip to main content](https://docs.browserless.io/nav-options/waiting#__docusaurus_skipToContent_fallback)


- PDF
- Screenshot

BrowserQL offers 5 different ways to wait for preconditions to be met on the page before returning the response. These are:

- [waitForNavigation](https://docs.browserless.io/nav-options/waiting#waitfornavigation)
- [waitForRequest](https://docs.browserless.io/nav-options/waiting#waitforrequest)
- [waitForResponse](https://docs.browserless.io/nav-options/waiting#waitforresponse)
- [waitForSelector](https://docs.browserless.io/nav-options/waiting#waitforselector)
- [waitForTimeout](https://docs.browserless.io/nav-options/waiting#waitfortimeout)

BQL Schemas

For more details on BQL mutations, refer to the [BrowserQL Schema](https://docs.browserless.io/bql-schema/schema) reference pages.

Rest API

[Generating PDFs](https://docs.browserless.io/rest-apis/pdf) and [Taking Screenshots](https://docs.browserless.io/rest-apis/screenshot) can also be done with Browserless Rest API.

## waitForNavigation [â€‹](https://docs.browserless.io/nav-options/waiting\#waitfornavigation "Direct link to waitForNavigation")

Waits for a navigation even to fire, useful for clicking an element and waiting for a page load.

The object can have any of these values:

- `timeout`: Float, optional â€” The maximum amount of time, in milliseconds, to wait for the page to load, overriding any defaults. Default timeout is 30 seconds, or 30000.
- `waitUntil`: [WaitUntilGoto enum](https://docs.browserless.io/bql-schema/types/enums/wait-until-goto), optional â€” When to consider the page fully-loaded and proceed with further execution

- PDF
- Screenshot

- BQL Query
- cURL
- Javascript
- Python
- Java
- C#

```codeBlockLines_p187
mutation PDF {
  goto(url: "https://example.com/") {
    status
  }

  waitForNavigation(waitUntil: load) {
    status
  }
}

```

```codeBlockLines_p187
curl --request POST \
  --url 'https://production-sfo.browserless.io/chromium/bql?token=YOUR_API_TOKEN_HERE' \
  --header 'Content-Type: application/json' \
  --data '{"query":"mutation PDF {\n  goto(url: \"https://example.com/\") {\n    status\n  }\n\n  waitForNavigation(waitUntil: load) {\n    status\n  }\n}","variables":"","operationName":"PDF"}'

```

```codeBlockLines_p187
const endpoint = "https://production-sfo.browserless.io/chromium/bql";
const token = "YOUR_API_TOKEN_HERE";

const options = {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json',
  },
  body: JSON.stringify({"query":"mutation PDF {\n  goto(url: \"https://example.com/\") {\n    status\n  }\n\n  waitForNavigation(waitUntil: load) {\n    status\n  }\n}","variables":"","operationName":"PDF"})
};

const url = `${endpoint}?token=${token}`;
const response = await fetch(url, options);
const data = await response.json();

console.log(data);

```

```codeBlockLines_p187
import requests

endpoint = "https://production-sfo.browserless.io/chromium/bql"
query_string = {
    "token": "YOUR_API_TOKEN_HERE",
}
headers = {
    "Content-Type": "application/json",
}
payload = {
    "query": "mutation PDF {\n  goto(url: \"https://example.com/\") {\n    status\n  }\n\n  waitForNavigation(waitUntil: load) {\n    status\n  }\n}",
    "variables": None,
    "operationName": "PDF",
}

response = requests.post(endpoint, params=query_string, headers=headers, json=payload)
print(response.json())

```

```codeBlockLines_p187
String url = "https://production-sfo.browserless.io/chromium/bql";
String token = "YOUR_API_TOKEN_HERE";
String endpoint = String.format("%s?token=%s%s%s", url, token);

HttpResponse<String> response = Unirest.post(endpoint)
    .header("Content-Type", "application/json")
    .body({"query":"mutation PDF {\n  goto(url: \"https://example.com/\") {\n    status\n  }\n\n  waitForNavigation(waitUntil: load) {\n    status\n  }\n}","variables":"","operationName":"PDF"})
    .asString();

```

```codeBlockLines_p187
string url = "https://production-sfo.browserless.io/chromium/bql";
string token = "YOUR_API_TOKEN_HERE";
string endpoint = $"{url}?token={token}";

var payload = new
{
    query = @"mutation PDF {
  goto(url: ""https://example.com/"") {
    status
  }

  waitForNavigation(waitUntil: load) {
    status
  }
}",
    variables = "",
    operationName = "PDF"
};

using (var client = new HttpClient())
{
    var jsonPayload = System.Text.Json.JsonSerializer.Serialize(payload);
    var content = new StringContent(jsonPayload, Encoding.UTF8, "application/json");

    var response = await client.PostAsync(endpoint, content);
    string responseBody = await response.Content.ReadAsStringAsync();

    Console.WriteLine(responseBody);
}

```

- BQL Query
- cURL
- Javascript
- Python
- Java
- C#

```codeBlockLines_p187
mutation Screenshot {
  goto(url: "https://example.com/") {
    status
  }

  waitForNavigation(waitUntil: load) {
    status
  }
}

```

```codeBlockLines_p187
curl --request POST \
  --url 'https://production-sfo.browserless.io/chromium/bql?token=YOUR_API_TOKEN_HERE' \
  --header 'Content-Type: application/json' \
  --data '{"query":"mutation Screenshot {\n  goto(url: \"https://example.com/\") {\n    status\n  }\n\n  waitForNavigation(waitUntil: load) {\n    status\n  }\n}","variables":"","operationName":"PDF"}'

```

```codeBlockLines_p187
const endpoint = "https://production-sfo.browserless.io/chromium/bql";
const token = "YOUR_API_TOKEN_HERE";

const options = {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json',
  },
  body: JSON.stringify({"query":"mutation Screenshot {\n  goto(url: \"https://example.com/\") {\n    status\n  }\n\n  waitForNavigation(waitUntil: load) {\n    status\n  }\n}","variables":"","operationName":"PDF"})
};

const url = `${endpoint}?token=${token}`;
const response = await fetch(url, options);
const data = await response.json();

console.log(data);

```

```codeBlockLines_p187
import requests

endpoint = "https://production-sfo.browserless.io/chromium/bql"
query_string = {
    "token": "YOUR_API_TOKEN_HERE",
}
headers = {
    "Content-Type": "application/json",
}
payload = {
    "query": "mutation Screenshot {\n  goto(url: \"https://example.com/\") {\n    status\n  }\n\n  waitForNavigation(waitUntil: load) {\n    status\n  }\n}",
    "variables": None,
    "operationName": "PDF",
}

response = requests.post(endpoint, params=query_string, headers=headers, json=payload)
print(response.json())

```

```codeBlockLines_p187
String url = "https://production-sfo.browserless.io/chromium/bql";
String token = "YOUR_API_TOKEN_HERE";
String endpoint = String.format("%s?token=%s%s%s", url, token);

HttpResponse<String> response = Unirest.post(endpoint)
    .header("Content-Type", "application/json")
    .body({"query":"mutation Screenshot {\n  goto(url: \"https://example.com/\") {\n    status\n  }\n\n  waitForNavigation(waitUntil: load) {\n    status\n  }\n}","variables":"","operationName":"PDF"})
    .asString();

```

```codeBlockLines_p187
string url = "https://production-sfo.browserless.io/chromium/bql";
string token = "YOUR_API_TOKEN_HERE";
string endpoint = $"{url}?token={token}";

var payload = new
{
    query = @"mutation Screenshot {
  goto(url: ""https://example.com/"") {
    status
  }

  waitForNavigation(waitUntil: load) {
    status
  }
}",
    variables = "",
    operationName = "PDF"
};

using (var client = new HttpClient())
{
    var jsonPayload = System.Text.Json.JsonSerializer.Serialize(payload);
    var content = new StringContent(jsonPayload, Encoding.UTF8, "application/json");

    var response = await client.PostAsync(endpoint, content);
    string responseBody = await response.Content.ReadAsStringAsync();

    Console.WriteLine(responseBody);
}

```

## waitForRequest [â€‹](https://docs.browserless.io/nav-options/waiting\#waitforrequest "Direct link to waitForRequest")

Waits for the browser to make a particular request.

The object can have any of these values:

- `method`: [Method](https://docs.browserless.io/bql-schema/types/enums/method), optional â€” The method of the request to wait for.
- `timeout`: Float, optional â€” How long to wait for the request to be made before timing out, overriding any defaults. Default timeout is 30 seconds, or 30000.
- `url`: String, optional â€” The pattern of the request URL to wait for, using glob-style pattern-matching.

- PDF
- Screenshot

- BQL Query
- cURL
- Javascript
- Python
- Java
- C#

```codeBlockLines_p187
mutation PDF {
  goto(url: "https://example.com/") {
    status
  }

  waitForRequest(method: GET) {
    time
  }
}

```

```codeBlockLines_p187
curl --request POST \
  --url 'https://production-sfo.browserless.io/chromium/bql?token=YOUR_API_TOKEN_HERE' \
  --header 'Content-Type: application/json' \
  --data '{"query":"mutation PDF {\n  goto(url: \"https://example.com/\") {\n    status\n  }\n\n  waitForRequest(method: GET) {\n    time\n  }\n}","variables":"","operationName":"PDF"}'

```

```codeBlockLines_p187
const endpoint = "https://production-sfo.browserless.io/chromium/bql";
const token = "YOUR_API_TOKEN_HERE";

const options = {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json',
  },
  body: JSON.stringify({"query":"mutation PDF {\n  goto(url: \"https://example.com/\") {\n    status\n  }\n\n  waitForRequest(method: GET) {\n    time\n  }\n}","variables":"","operationName":"PDF"})
};

const url = `${endpoint}?token=${token}`;
const response = await fetch(url, options);
const data = await response.json();

console.log(data);

```

```codeBlockLines_p187
import requests

endpoint = "https://production-sfo.browserless.io/chromium/bql"
query_string = {
    "token": "YOUR_API_TOKEN_HERE",
}
headers = {
    "Content-Type": "application/json",
}
payload = {
    "query": "mutation PDF {\n  goto(url: \"https://example.com/\") {\n    status\n  }\n\n  waitForRequest(method: GET) {\n    time\n  }\n}",
    "variables": None,
    "operationName": "PDF",
}

response = requests.post(endpoint, params=query_string, headers=headers, json=payload)
print(response.json())

```

```codeBlockLines_p187
String url = "https://production-sfo.browserless.io/chromium/bql";
String token = "YOUR_API_TOKEN_HERE";
String endpoint = String.format("%s?token=%s%s%s", url, token);

HttpResponse<String> response = Unirest.post(endpoint)
    .header("Content-Type", "application/json")
    .body({"query":"mutation PDF {\n  goto(url: \"https://example.com/\") {\n    status\n  }\n\n  waitForRequest(method: GET) {\n    time\n  }\n}","variables":"","operationName":"PDF"})
    .asString();

```

```codeBlockLines_p187
string url = "https://production-sfo.browserless.io/chromium/bql";
string token = "YOUR_API_TOKEN_HERE";
string endpoint = $"{url}?token={token}";

var payload = new
{
    query = @"mutation PDF {
  goto(url: ""https://example.com/"") {
    status
  }

  waitForRequest(method: GET) {
    time
  }
}",
    variables = "",
    operationName = "PDF"
};

using (var client = new HttpClient())
{
    var jsonPayload = System.Text.Json.JsonSerializer.Serialize(payload);
    var content = new StringContent(jsonPayload, Encoding.UTF8, "application/json");

    var response = await client.PostAsync(endpoint, content);
    string responseBody = await response.Content.ReadAsStringAsync();

    Console.WriteLine(responseBody);
}

```

- BQL Query
- cURL
- Javascript
- Python
- Java
- C#

```codeBlockLines_p187
mutation Screenshot {
  goto(url: "https://example.com/") {
    status
  }

  waitForRequest(method: GET) {
    time
  }
}

```

```codeBlockLines_p187
curl --request POST \
  --url 'https://production-sfo.browserless.io/chromium/bql?token=YOUR_API_TOKEN_HERE' \
  --header 'Content-Type: application/json' \
  --data '{"query":"mutation Screenshot {\n  goto(url: \"https://example.com/\") {\n    status\n  }\n\n  waitForRequest(method: GET) {\n    time\n  }\n}","variables":"","operationName":"PDF"}'

```

```codeBlockLines_p187
const endpoint = "https://production-sfo.browserless.io/chromium/bql";
const token = "YOUR_API_TOKEN_HERE";

const options = {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json',
  },
  body: JSON.stringify({"query":"mutation Screenshot {\n  goto(url: \"https://example.com/\") {\n    status\n  }\n\n  waitForRequest(method: GET) {\n    time\n  }\n}","variables":"","operationName":"PDF"})
};

const url = `${endpoint}?token=${token}`;
const response = await fetch(url, options);
const data = await response.json();

console.log(data);

```

```codeBlockLines_p187
import requests

endpoint = "https://production-sfo.browserless.io/chromium/bql"
query_string = {
    "token": "YOUR_API_TOKEN_HERE",
}
headers = {
    "Content-Type": "application/json",
}
payload = {
    "query": "mutation Screenshot {\n  goto(url: \"https://example.com/\") {\n    status\n  }\n\n  waitForRequest(method: GET) {\n    time\n  }\n}",
    "variables": None,
    "operationName": "PDF",
}

response = requests.post(endpoint, params=query_string, headers=headers, json=payload)
print(response.json())

```

```codeBlockLines_p187
String url = "https://production-sfo.browserless.io/chromium/bql";
String token = "YOUR_API_TOKEN_HERE";
String endpoint = String.format("%s?token=%s%s%s", url, token);

HttpResponse<String> response = Unirest.post(endpoint)
    .header("Content-Type", "application/json")
    .body({"query":"mutation Screenshot {\n  goto(url: \"https://example.com/\") {\n    status\n  }\n\n  waitForRequest(method: GET) {\n    time\n  }\n}","variables":"","operationName":"PDF"})
    .asString();

```

```codeBlockLines_p187
string url = "https://production-sfo.browserless.io/chromium/bql";
string token = "YOUR_API_TOKEN_HERE";
string endpoint = $"{url}?token={token}";

var payload = new
{
    query = @"mutation Screenshot {
  goto(url: ""https://example.com/"") {
    status
  }

  waitForRequest(method: GET) {
    time
  }
}",
    variables = "",
    operationName = "PDF"
};

using (var client = new HttpClient())
{
    var jsonPayload = System.Text.Json.JsonSerializer.Serialize(payload);
    var content = new StringContent(jsonPayload, Encoding.UTF8, "application/json");

    var response = await client.PostAsync(endpoint, content);
    string responseBody = await response.Content.ReadAsStringAsync();

    Console.WriteLine(responseBody);
}

```

## waitForResponse [â€‹](https://docs.browserless.io/nav-options/waiting\#waitforresponse "Direct link to waitForResponse")

Waits for a particular network response to be made back to the browser.

The object can have any of these values:

- `statuses`: \[int\] list, optional â€” The HTTP Response code(s) of the URL to wait for. Can be a single HTTP code or a list of desired codes.
- `url`: String, optional â€” The pattern of the response URL to wait for, using glob-style pattern-matching.

- PDF
- Screenshot

- BQL Query
- cURL
- Javascript
- Python
- Java
- C#

```codeBlockLines_p187
mutation PDF {
  goto(url: "https://example.com/") {
    status
  }

  waitForResponse(codes: [200]) {
    time
  }
}

```

```codeBlockLines_p187
curl --request POST \
  --url 'https://production-sfo.browserless.io/chromium/bql?token=YOUR_API_TOKEN_HERE' \
  --header 'Content-Type: application/json' \
  --data '{"query":"mutation PDF {\n  goto(url: \"https://example.com/\") {\n    status\n  }\n\n  waitForResponse(codes: [200]) {\n    time\n  }\n}","variables":"","operationName":"PDF"}'

```

```codeBlockLines_p187
const endpoint = "https://production-sfo.browserless.io/chromium/bql";
const token = "YOUR_API_TOKEN_HERE";

const options = {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json',
  },
  body: JSON.stringify({"query":"mutation PDF {\n  goto(url: \"https://example.com/\") {\n    status\n  }\n\n  waitForResponse(codes: [200]) {\n    time\n  }\n}","variables":"","operationName":"PDF"})
};

const url = `${endpoint}?token=${token}`;
const response = await fetch(url, options);
const data = await response.json();

console.log(data);

```

```codeBlockLines_p187
import requests

endpoint = "https://production-sfo.browserless.io/chromium/bql"
query_string = {
    "token": "YOUR_API_TOKEN_HERE",
}
headers = {
    "Content-Type": "application/json",
}
payload = {
    "query": "mutation PDF {\n  goto(url: \"https://example.com/\") {\n    status\n  }\n\n  waitForResponse(codes: [200]) {\n    time\n  }\n}",
    "variables": None,
    "operationName": "PDF",
}

response = requests.post(endpoint, params=query_string, headers=headers, json=payload)
print(response.json())

```

```codeBlockLines_p187
String url = "https://production-sfo.browserless.io/chromium/bql";
String token = "YOUR_API_TOKEN_HERE";
String endpoint = String.format("%s?token=%s%s%s", url, token);

HttpResponse<String> response = Unirest.post(endpoint)
    .header("Content-Type", "application/json")
    .body({"query":"mutation PDF {\n  goto(url: \"https://example.com/\") {\n    status\n  }\n\n  waitForResponse(codes: [200]) {\n    time\n  }\n}","variables":"","operationName":"PDF"})
    .asString();

```

```codeBlockLines_p187
string url = "https://production-sfo.browserless.io/chromium/bql";
string token = "YOUR_API_TOKEN_HERE";
string endpoint = $"{url}?token={token}";

var payload = new
{
    query = @"mutation PDF {
  goto(url: ""https://example.com/"") {
    status
  }

  waitForResponse(codes: [200]) {
    time
  }
}",
    variables = "",
    operationName = "PDF"
};

using (var client = new HttpClient())
{
    var jsonPayload = System.Text.Json.JsonSerializer.Serialize(payload);
    var content = new StringContent(jsonPayload, Encoding.UTF8, "application/json");

    var response = await client.PostAsync(endpoint, content);
    string responseBody = await response.Content.ReadAsStringAsync();

    Console.WriteLine(responseBody);
}

```

- BQL Query
- cURL
- Javascript
- Python
- Java
- C#

```codeBlockLines_p187
mutation Screenshot {
  goto(url: "https://example.com/") {
    status
  }

  waitForResponse(codes: [200]) {
    time
  }
}

```

```codeBlockLines_p187
curl --request POST \
  --url 'https://production-sfo.browserless.io/chromium/bql?token=YOUR_API_TOKEN_HERE' \
  --header 'Content-Type: application/json' \
  --data '{"query":"mutation Screenshot {\n  goto(url: \"https://example.com/\") {\n    status\n  }\n\n  waitForResponse(codes: [200]) {\n    time\n  }\n}","variables":"","operationName":"PDF"}'

```

```codeBlockLines_p187
const endpoint = "https://production-sfo.browserless.io/chromium/bql";
const token = "YOUR_API_TOKEN_HERE";

const options = {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json',
  },
  body: JSON.stringify({"query":"mutation Screenshot {\n  goto(url: \"https://example.com/\") {\n    status\n  }\n\n  waitForResponse(codes: [200]) {\n    time\n  }\n}","variables":"","operationName":"PDF"})
};

const url = `${endpoint}?token=${token}`;
const response = await fetch(url, options);
const data = await response.json();

console.log(data);

```

```codeBlockLines_p187
import requests

endpoint = "https://production-sfo.browserless.io/chromium/bql"
query_string = {
    "token": "YOUR_API_TOKEN_HERE",
}
headers = {
    "Content-Type": "application/json",
}
payload = {
    "query": "mutation Screenshot {\n  goto(url: \"https://example.com/\") {\n    status\n  }\n\n  waitForResponse(codes: [200]) {\n    time\n  }\n}",
    "variables": None,
    "operationName": "PDF",
}

response = requests.post(endpoint, params=query_string, headers=headers, json=payload)
print(response.json())

```

```codeBlockLines_p187
String url = "https://production-sfo.browserless.io/chromium/bql";
String token = "YOUR_API_TOKEN_HERE";
String endpoint = String.format("%s?token=%s%s%s", url, token);

HttpResponse<String> response = Unirest.post(endpoint)
    .header("Content-Type", "application/json")
    .body({"query":"mutation Screenshot {\n  goto(url: \"https://example.com/\") {\n    status\n  }\n\n  waitForResponse(codes: [200]) {\n    time\n  }\n}","variables":"","operationName":"PDF"})
    .asString();

```

```codeBlockLines_p187
string url = "https://production-sfo.browserless.io/chromium/bql";
string token = "YOUR_API_TOKEN_HERE";
string endpoint = $"{url}?token={token}";

var payload = new
{
    query = @"mutation Screenshot {
  goto(url: ""https://example.com/"") {
    status
  }

  waitForResponse(codes: [200]) {
    time
  }
}",
    variables = "",
    operationName = "PDF"
};

using (var client = new HttpClient())
{
    var jsonPayload = System.Text.Json.JsonSerializer.Serialize(payload);
    var content = new StringContent(jsonPayload, Encoding.UTF8, "application/json");

    var response = await client.PostAsync(endpoint, content);
    string responseBody = await response.Content.ReadAsStringAsync();

    Console.WriteLine(responseBody);
}

```

## waitForSelector [â€‹](https://docs.browserless.io/nav-options/waiting\#waitforselector "Direct link to waitForSelector")

Wait for a selector to appear in page. If at the moment of calling the method the selector already exists, the method will return immediately. If the selector doesn't appear after the timeout milliseconds of waiting, the function will throw.

The object can have any of these values:

- `selector`: String, required â€” A valid CSS selector.
- `timeout`: Number, optional â€” Maximum number of milliseconds to wait for the selector before failing.
- `visible`: Boolean, optional â€” Wait for the selected element to be present in DOM and to be visible, i.e. to not have `display: none` or `visibility: hidden` CSS properties.

- PDF
- Screenshot

- BQL Query
- cURL
- Javascript
- Python
- Java
- C#

```codeBlockLines_p187
mutation PDF {
  goto(url: "https://example.com/") {
    status
  }

  waitForSelector(selector: "h1" timeout: 5000) {
    selector
  }
}

```

```codeBlockLines_p187
curl --request POST \
  --url 'https://production-sfo.browserless.io/chromium/bql?token=YOUR_API_TOKEN_HERE' \
  --header 'Content-Type: application/json' \
  --data '{"query":"mutation PDF {\n  goto(url: \"https://example.com/\") {\n    status\n  }\n\n  waitForSelector(selector: \"h1\" timeout: 5000) {\n    selector\n  }\n}","variables":"","operationName":"PDF"}'

```

```codeBlockLines_p187
const endpoint = "https://production-sfo.browserless.io/chromium/bql";
const token = "YOUR_API_TOKEN_HERE";

const options = {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json',
  },
  body: JSON.stringify({"query":"mutation PDF {\n  goto(url: \"https://example.com/\") {\n    status\n  }\n\n  waitForSelector(selector: \"h1\" timeout: 5000) {\n    selector\n  }\n}","variables":"","operationName":"PDF"})
};

const url = `${endpoint}?token=${token}`;
const response = await fetch(url, options);
const data = await response.json();

console.log(data);

```

```codeBlockLines_p187
import requests

endpoint = "https://production-sfo.browserless.io/chromium/bql"
query_string = {
    "token": "YOUR_API_TOKEN_HERE",
}
headers = {
    "Content-Type": "application/json",
}
payload = {
    "query": "mutation PDF {\n  goto(url: \"https://example.com/\") {\n    status\n  }\n\n  waitForSelector(selector: \"h1\" timeout: 5000) {\n    selector\n  }\n}",
    "variables": None,
    "operationName": "PDF",
}

response = requests.post(endpoint, params=query_string, headers=headers, json=payload)
print(response.json())

```

```codeBlockLines_p187
String url = "https://production-sfo.browserless.io/chromium/bql";
String token = "YOUR_API_TOKEN_HERE";
String endpoint = String.format("%s?token=%s%s%s", url, token);

HttpResponse<String> response = Unirest.post(endpoint)
    .header("Content-Type", "application/json")
    .body({"query":"mutation PDF {\n  goto(url: \"https://example.com/\") {\n    status\n  }\n\n  waitForSelector(selector: \"h1\" timeout: 5000) {\n    selector\n  }\n}","variables":"","operationName":"PDF"})
    .asString();

```

```codeBlockLines_p187
string url = "https://production-sfo.browserless.io/chromium/bql";
string token = "YOUR_API_TOKEN_HERE";
string endpoint = $"{url}?token={token}";

var payload = new
{
    query = @"mutation PDF {
  goto(url: ""https://example.com/"") {
    status
  }

  waitForSelector(selector: ""h1"" timeout: 5000) {
    selector
  }
}",
    variables = "",
    operationName = "PDF"
};

using (var client = new HttpClient())
{
    var jsonPayload = System.Text.Json.JsonSerializer.Serialize(payload);
    var content = new StringContent(jsonPayload, Encoding.UTF8, "application/json");

    var response = await client.PostAsync(endpoint, content);
    string responseBody = await response.Content.ReadAsStringAsync();

    Console.WriteLine(responseBody);
}

```

- BQL Query
- cURL
- Javascript
- Python
- Java
- C#

```codeBlockLines_p187
mutation Screenshot {
  goto(url: "https://example.com/") {
    status
  }

  waitForSelector(selector: "h1" timeout: 5000) {
    selector
  }
}

```

```codeBlockLines_p187
curl --request POST \
  --url 'https://production-sfo.browserless.io/chromium/bql?token=YOUR_API_TOKEN_HERE' \
  --header 'Content-Type: application/json' \
  --data '{"query":"mutation Screenshot {\n  goto(url: \"https://example.com/\") {\n    status\n  }\n\n  waitForSelector(selector: \"h1\" timeout: 5000) {\n    selector\n  }\n}","variables":"","operationName":"PDF"}'

```

```codeBlockLines_p187
const endpoint = "https://production-sfo.browserless.io/chromium/bql";
const token = "YOUR_API_TOKEN_HERE";

const options = {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json',
  },
  body: JSON.stringify({"query":"mutation Screenshot {\n  goto(url: \"https://example.com/\") {\n    status\n  }\n\n  waitForSelector(selector: \"h1\" timeout: 5000) {\n    selector\n  }\n}","variables":"","operationName":"PDF"})
};

const url = `${endpoint}?token=${token}`;
const response = await fetch(url, options);
const data = await response.json();

console.log(data);

```

```codeBlockLines_p187
import requests

endpoint = "https://production-sfo.browserless.io/chromium/bql"
query_string = {
    "token": "YOUR_API_TOKEN_HERE",
}
headers = {
    "Content-Type": "application/json",
}
payload = {
    "query": "mutation Screenshot {\n  goto(url: \"https://example.com/\") {\n    status\n  }\n\n  waitForSelector(selector: \"h1\" timeout: 5000) {\n    selector\n  }\n}",
    "variables": None,
    "operationName": "PDF",
}

response = requests.post(endpoint, params=query_string, headers=headers, json=payload)
print(response.json())

```

```codeBlockLines_p187
String url = "https://production-sfo.browserless.io/chromium/bql";
String token = "YOUR_API_TOKEN_HERE";
String endpoint = String.format("%s?token=%s%s%s", url, token);

HttpResponse<String> response = Unirest.post(endpoint)
    .header("Content-Type", "application/json")
    .body({"query":"mutation Screenshot {\n  goto(url: \"https://example.com/\") {\n    status\n  }\n\n  waitForSelector(selector: \"h1\" timeout: 5000) {\n    selector\n  }\n}","variables":"","operationName":"PDF"})
    .asString();

```

```codeBlockLines_p187
string url = "https://production-sfo.browserless.io/chromium/bql";
string token = "YOUR_API_TOKEN_HERE";
string endpoint = $"{url}?token={token}";

var payload = new
{
    query = @"mutation Screenshot {
  goto(url: ""https://example.com/"") {
    status
  }

  waitForSelector(selector: ""h1"" timeout: 5000) {
    selector
  }
}",
    variables = "",
    operationName = "PDF"
};

using (var client = new HttpClient())
{
    var jsonPayload = System.Text.Json.JsonSerializer.Serialize(payload);
    var content = new StringContent(jsonPayload, Encoding.UTF8, "application/json");

    var response = await client.PostAsync(endpoint, content);
    string responseBody = await response.Content.ReadAsStringAsync();

    Console.WriteLine(responseBody);
}

```

## waitForTimeout [â€‹](https://docs.browserless.io/nav-options/waiting\#waitfortimeout "Direct link to waitForTimeout")

Wait for a period of time, defined in milliseconds.

The object needs the following value:

- `time`: Float, required - The amount of time to wait for, in milliseconds.

- PDF
- Screenshot

- BQL Query
- cURL
- Javascript
- Python
- Java
- C#

```codeBlockLines_p187
mutation PDF {
  goto(url: "https://example.com/") {
    status
  }

  waitForTimeout(time: 1000) {
    time
  }
}

```

```codeBlockLines_p187
curl --request POST \
  --url 'https://production-sfo.browserless.io/chromium/bql?token=YOUR_API_TOKEN_HERE' \
  --header 'Content-Type: application/json' \
  --data '{"query":"mutation PDF {\n  goto(url: \"https://example.com/\") {\n    status\n  }\n\n  waitForTimeout(time: 1000) {\n    time\n  }\n}","variables":"","operationName":"PDF"}'

```

```codeBlockLines_p187
const endpoint = "https://production-sfo.browserless.io/chromium/bql";
const token = "YOUR_API_TOKEN_HERE";

const options = {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json',
  },
  body: JSON.stringify({"query":"mutation PDF {\n  goto(url: \"https://example.com/\") {\n    status\n  }\n\n  waitForTimeout(time: 1000) {\n    time\n  }\n}","variables":"","operationName":"PDF"})
};

const url = `${endpoint}?token=${token}`;
const response = await fetch(url, options);
const data = await response.json();

console.log(data);

```

```codeBlockLines_p187
import requests

endpoint = "https://production-sfo.browserless.io/chromium/bql"
query_string = {
    "token": "YOUR_API_TOKEN_HERE",
}
headers = {
    "Content-Type": "application/json",
}
payload = {
    "query": "mutation PDF {\n  goto(url: \"https://example.com/\") {\n    status\n  }\n\n  waitForTimeout(time: 1000) {\n    time\n  }\n}",
    "variables": None,
    "operationName": "PDF",
}

response = requests.post(endpoint, params=query_string, headers=headers, json=payload)
print(response.json())

```

```codeBlockLines_p187
String url = "https://production-sfo.browserless.io/chromium/bql";
String token = "YOUR_API_TOKEN_HERE";
String endpoint = String.format("%s?token=%s%s%s", url, token);

HttpResponse<String> response = Unirest.post(endpoint)
    .header("Content-Type", "application/json")
    .body({"query":"mutation PDF {\n  goto(url: \"https://example.com/\") {\n    status\n  }\n\n  waitForTimeout(time: 1000) {\n    time\n  }\n}","variables":"","operationName":"PDF"})
    .asString();

```

```codeBlockLines_p187
string url = "https://production-sfo.browserless.io/chromium/bql";
string token = "YOUR_API_TOKEN_HERE";
string endpoint = $"{url}?token={token}";

var payload = new
{
    query = @"mutation PDF {
  goto(url: ""https://example.com/"") {
    status
  }

  waitForTimeout(time: 1000) {
    time
  }
}",
    variables = "",
    operationName = "PDF"
};

using (var client = new HttpClient())
{
    var jsonPayload = System.Text.Json.JsonSerializer.Serialize(payload);
    var content = new StringContent(jsonPayload, Encoding.UTF8, "application/json");

    var response = await client.PostAsync(endpoint, content);
    string responseBody = await response.Content.ReadAsStringAsync();

    Console.WriteLine(responseBody);
}

```

- BQL Query
- cURL
- Javascript
- Python
- Java
- C#

```codeBlockLines_p187
mutation Screenshot {
  goto(url: "https://example.com/") {
    status
  }

  waitForTimeout(time: 1000) {
    time
  }
}

```

```codeBlockLines_p187
curl --request POST \
  --url 'https://production-sfo.browserless.io/chromium/bql?token=YOUR_API_TOKEN_HERE' \
  --header 'Content-Type: application/json' \
  --data '{"query":"mutation Screenshot {\n  goto(url: \"https://example.com/\") {\n    status\n  }\n\n  waitForTimeout(time: 1000) {\n    time\n  }\n}","variables":"","operationName":"PDF"}'

```

```codeBlockLines_p187
const endpoint = "https://production-sfo.browserless.io/chromium/bql";
const token = "YOUR_API_TOKEN_HERE";

const options = {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json',
  },
  body: JSON.stringify({"query":"mutation Screenshot {\n  goto(url: \"https://example.com/\") {\n    status\n  }\n\n  waitForTimeout(time: 1000) {\n    time\n  }\n}","variables":"","operationName":"PDF"})
};

const url = `${endpoint}?token=${token}`;
const response = await fetch(url, options);
const data = await response.json();

console.log(data);

```

```codeBlockLines_p187
import requests

endpoint = "https://production-sfo.browserless.io/chromium/bql"
query_string = {
    "token": "YOUR_API_TOKEN_HERE",
}
headers = {
    "Content-Type": "application/json",
}
payload = {
    "query": "mutation Screenshot {\n  goto(url: \"https://example.com/\") {\n    status\n  }\n\n  waitForTimeout(time: 1000) {\n    time\n  }\n}",
    "variables": None,
    "operationName": "PDF",
}

response = requests.post(endpoint, params=query_string, headers=headers, json=payload)
print(response.json())

```

```codeBlockLines_p187
String url = "https://production-sfo.browserless.io/chromium/bql";
String token = "YOUR_API_TOKEN_HERE";
String endpoint = String.format("%s?token=%s%s%s", url, token);

HttpResponse<String> response = Unirest.post(endpoint)
    .header("Content-Type", "application/json")
    .body({"query":"mutation Screenshot {\n  goto(url: \"https://example.com/\") {\n    status\n  }\n\n  waitForTimeout(time: 1000) {\n    time\n  }\n}","variables":"","operationName":"PDF"})
    .asString();

```

```codeBlockLines_p187
string url = "https://production-sfo.browserless.io/chromium/bql";
string token = "YOUR_API_TOKEN_HERE";
string endpoint = $"{url}?token={token}";

var payload = new
{
    query = @"mutation Screenshot {
  goto(url: ""https://example.com/"") {
    status
  }

  waitForTimeout(time: 1000) {
    time
  }
}",
    variables = "",
    operationName = "PDF"
};

using (var client = new HttpClient())
{
    var jsonPayload = System.Text.Json.JsonSerializer.Serialize(payload);
    var content = new StringContent(jsonPayload, Encoding.UTF8, "application/json");

    var response = await client.PostAsync(endpoint, content);
    string responseBody = await response.Content.ReadAsStringAsync();

    Console.WriteLine(responseBody);
}

```

- [waitForNavigation](https://docs.browserless.io/nav-options/waiting#waitfornavigation)
- [waitForRequest](https://docs.browserless.io/nav-options/waiting#waitforrequest)
- [waitForResponse](https://docs.browserless.io/nav-options/waiting#waitforresponse)
- [waitForSelector](https://docs.browserless.io/nav-options/waiting#waitforselector)
- [waitForTimeout](https://docs.browserless.io/nav-options/waiting#waitfortimeout)

---

### Browserless.io
Original URL: https://docs.browserless.io/pdf/waiting

[Skip to main content](https://docs.browserless.io/pdf/waiting#__docusaurus_skipToContent_fallback)

# Page Not Found

We could not find what you were looking for.

Please contact the owner of the site that linked you to the original URL and let them know their link is broken.

---


## Integrations

### Browser Use Integration | Browserless.io
Original URL: https://docs.browserless.io/ai-integrations/browser-use/python

[Skip to main content](https://docs.browserless.io/ai-integrations/browser-use/python#__docusaurus_skipToContent_fallback)


[Browser Use](https://github.com/browser-use/browser-use) is a Python library that allows AI agents to control a browser. By integrating Browserless with Browser Use, you can provide your AI applications with powerful web browsing capabilities without managing browser infrastructure.

## Prerequisites [â€‹](https://docs.browserless.io/ai-integrations/browser-use/python\#prerequisites "Direct link to Prerequisites")

- Python 3.11 or higher
- An active Browserless API Token (available in your [account dashboard](https://account.browserless.io/))

## Step-by-Step Setup [â€‹](https://docs.browserless.io/ai-integrations/browser-use/python\#step-by-step-setup "Direct link to Step-by-Step Setup")

**1\. Get your API Key**

Go to your [Browserless Account Dashboard](https://account.browserless.io/) and copy your API token.

Then set the `BROWSERLESS_API_TOKEN` environment variable in your `.env` file:

- .env file
- Command line

```codeBlockLines_p187
BROWSERLESS_API_TOKEN=your-token-here
ANTHROPIC_API_KEY=your-anthropic-key-here

```

```codeBlockLines_p187
export BROWSERLESS_API_TOKEN=your-token-here
export ANTHROPIC_API_KEY=your-anthropic-key-here

```

**2\. Create a virtual environment**

Set up a Python virtual environment to manage your dependencies:

- venv
- conda

```codeBlockLines_p187
python -m venv .venv
source .venv/bin/activate  # On Windows: .venv\Scripts\activate

```

```codeBlockLines_p187
conda create -n browser-use-env python=3.10
conda activate browser-use-env

```

**3\. Install required packages**

Install Browser Use and other required packages:

- pip
- Poetry

```codeBlockLines_p187
pip install browser-use python-dotenv langchain-anthropic

```

```codeBlockLines_p187
poetry add browser-use python-dotenv langchain-anthropic

```

**4\. Create the browser\_session.py file**

Create a file named `browser_session.py` with the following complete code:

```codeBlockLines_p187
from typing import Optional
from browser_use.browser.context import BrowserSession, BrowserContext, BrowserContextConfig
from playwright.async_api import Page, BrowserContext as PlaywrightContext

class ExtendedBrowserSession(BrowserSession):
    """Extended version of BrowserSession that includes current_page"""
    def __init__(
        self,
        context: PlaywrightContext,
        cached_state: Optional[dict] = None,
        current_page: Optional[Page] = None
    ):
        super().__init__(context=context, cached_state=cached_state)
        self.current_page = current_page

class UseBrowserlessContext(BrowserContext):
    async def _initialize_session(self) -> ExtendedBrowserSession:
        """Initialize a browser session using existing Browserless page.

        Returns:
            ExtendedBrowserSession: The initialized browser session with current page.
        """
        playwright_browser = await self.browser.get_playwright_browser()
        context = await self._create_context(playwright_browser)
        self._add_new_page_listener(context)

        self.session = ExtendedBrowserSession(
            context=context,
            cached_state=None,
        )

        # Get existing page or create new one
        self.session.current_page = context.pages[0] if context.pages else await context.new_page()

        # Initialize session state
        self.session.cached_state = await self._update_state()

        return self.session

```

**5\. Create the main.py file**

Create a new file named `main.py` with the following complete code:

```codeBlockLines_p187
from dotenv import load_dotenv
import os
import asyncio
from browser_use import Browser, BrowserConfig, Agent
from browser_session import UseBrowserlessContext, ExtendedBrowserSession
from browser_use.browser.context import BrowserContextConfig
from langchain_anthropic import ChatAnthropic

async def setup_browser() -> tuple[Browser, UseBrowserlessContext]:
    """Set up browser and context configurations.

    Returns:
        tuple[Browser, UseBrowserlessContext]: Configured browser and context.
    """
    # Browserless connection URL with token (using CDP)
    browserless_url = f"wss://production-sfo.browserless.io?token={os.environ['BROWSERLESS_API_TOKEN']}&proxy=residential"

    browser = Browser(config=BrowserConfig(cdp_url=browserless_url))
    context = UseBrowserlessContext(
        browser,
        BrowserContextConfig(
            wait_for_network_idle_page_load_time=10.0,
            highlight_elements=True,
        )
    )

    return browser, context

async def setup_agent(browser: Browser, context: UseBrowserlessContext) -> Agent:
    """Set up the browser automation agent.

    Args:
        browser: Configured browser instance
        context: Browser context for the agent

    Returns:
        Agent: Configured automation agent
    """
    llm = ChatAnthropic(
        model_name="claude-3-5-sonnet-20240620",
        temperature=0.0,
        timeout=100,
    )

    return Agent(
        task="go to https://example.com, navigate the site and report what you found",
        llm=llm,
        browser=browser,
        browser_context=context,
    )

async def main():
    load_dotenv()

    browser, context = await setup_browser()
    print("Browser and context initialized")

    session = await context.get_session()
    print("Session obtained")

    try:
        agent = await setup_agent(browser, context)
        print("Agent configured, running now...")
        await agent.run()
    finally:
        # Close the browser
        print("Closing browser")
        await browser.close()

if __name__ == "__main__":
    asyncio.run(main())

```

**6\. Run your application**

Run your application with the following command:

```codeBlockLines_p187
python main.py

```

You should see output indicating that the browser is initialized and the agent is running.

## How It Works [â€‹](https://docs.browserless.io/ai-integrations/browser-use/python\#how-it-works "Direct link to How It Works")

**1\. Connection Setup**: Browser Use connects to Browserless using the WebSocket endpoint with your API token
**2\. Agent Configuration**: The AI agent is configured with a task and a language model
**3\. Automation**: The agent uses the browser to navigate and interact with websites
**4\. LLM Integration**: The agent leverages an LLM (like Claude) to interpret web content and make decisions

## Additional Configuration [â€‹](https://docs.browserless.io/ai-integrations/browser-use/python\#additional-configuration "Direct link to Additional Configuration")

### Proxy Support [â€‹](https://docs.browserless.io/ai-integrations/browser-use/python\#proxy-support "Direct link to Proxy Support")

You can enable a residential proxy for improved website compatibility:

```codeBlockLines_p187
browserless_url = f"wss://production-sfo.browserless.io?token={os.environ['BROWSERLESS_API_TOKEN']}&proxy=residential"

```

### Context Configuration [â€‹](https://docs.browserless.io/ai-integrations/browser-use/python\#context-configuration "Direct link to Context Configuration")

Customize the browser context with additional settings:

```codeBlockLines_p187
context = UseBrowserlessContext(
    browser,
    BrowserContextConfig(
        wait_for_network_idle_page_load_time=10.0,
        highlight_elements=True,
        # Additional configuration options
        user_agent="Custom User Agent",
        viewport_size={"width": 1920, "height": 1080},
        ignore_https_errors=True,
    )
)

```

## Advanced Features [â€‹](https://docs.browserless.io/ai-integrations/browser-use/python\#advanced-features "Direct link to Advanced Features")

### CDP Events and LiveURL [â€‹](https://docs.browserless.io/ai-integrations/browser-use/python\#cdp-events-and-liveurl "Direct link to CDP Events and LiveURL")

Browserless provides powerful Chrome DevTools Protocol (CDP) events that can enhance your browser automation. Here are some key features:

1. **LiveURL for User Interaction**







```codeBlockLines_p187
# Create a CDP session
cdp = await page.createCDPSession()

# Generate a LiveURL for user interaction
response = await cdp.send('Browserless.liveURL', {
       "timeout": 600000  # 10 minutes timeout
})
live_url = response["liveURL"]
print(f"Share this URL with users: {live_url}")

# Wait for user to complete interaction
future = asyncio.Future()
cdp.on('Browserless.liveComplete', lambda: future.set_result(True))
await future

```











For more details, see our [LiveURL Documentation](https://docs.browserless.io/baas/session-management/recording-liveurl).

2. **Captcha Detection**







```codeBlockLines_p187
# Listen for captcha detection
cdp.on('Browserless.captchaFound', lambda: print('Captcha detected!'))

# Solve captcha automatically
response = await cdp.send('Browserless.solveCaptcha', {
       "appearTimeout": 20000
})
solved, error = response.get("solved"), response.get("error")

```











Learn more about handling captchas in our [Hybrid Automation Guide](https://docs.browserless.io/baas/hybrid-automation).

3. **Session Recording**







```codeBlockLines_p187
# Start recording the session
await cdp.send("Browserless.startRecording")

# ... perform actions ...

# Stop recording and save
response = await cdp.send("Browserless.stopRecording")
with open("recording.webm", "wb") as f:
       f.write(response.value)

```











See our [Recording Documentation](https://docs.browserless.io/baas/session-management/recording-liveurl) for more details.


### Complete Example with CDP Events [â€‹](https://docs.browserless.io/ai-integrations/browser-use/python\#complete-example-with-cdp-events "Direct link to Complete Example with CDP Events")

Here's a complete example that combines LiveURL, captcha handling, and session recording:

```codeBlockLines_p187
from browser_use import Browser, BrowserConfig, Agent
from browser_session import UseBrowserlessContext, ExtendedBrowserSession
from browser_use.browser.context import BrowserContextConfig
from langchain_anthropic import ChatAnthropic
import asyncio
import os

async def setup_browser() -> tuple[Browser, UseBrowserlessContext]:
    browserless_url = f"wss://production-sfo.browserless.io?token={os.environ['BROWSERLESS_API_TOKEN']}"

    browser = Browser(config=BrowserConfig(cdp_url=browserless_url))
    context = UseBrowserlessContext(
        browser,
        BrowserContextConfig(
            wait_for_network_idle_page_load_time=10.0,
            highlight_elements=True,
        )
    )

    return browser, context

async def main():
    browser, context = await setup_browser()
    session = await context.get_session()

    try:
        # Create CDP session
        cdp = await session.current_page.createCDPSession()

        # Start recording
        await cdp.send("Browserless.startRecording")

        # Generate LiveURL
        response = await cdp.send('Browserless.liveURL', {
            "timeout": 600000
        })
        live_url = response["liveURL"]
        print(f"Share this URL with users: {live_url}")

        # Handle captcha if detected
        cdp.on('Browserless.captchaFound', lambda: print('Captcha detected!'))

        # Wait for user interaction
        future = asyncio.Future()
        cdp.on('Browserless.liveComplete', lambda: future.set_result(True))
        await future

        # Stop recording and save
        response = await cdp.send("Browserless.stopRecording")
        with open("recording.webm", "wb") as f:
            f.write(response.value)

    finally:
        await browser.close()

if __name__ == "__main__":
    asyncio.run(main())

```

For more information about CDP events and features, please refer to:

- [Browserless CDP Events Documentation](https://docs.browserless.io/baas/session-management/recording-liveurl)
- [Hybrid Automation Guide](https://docs.browserless.io/baas/hybrid-automation)
- [BrowserQL Integration](https://docs.browserless.io/browserql/recipes/hybrid-bql-playwright)

## Advanced Usage [â€‹](https://docs.browserless.io/ai-integrations/browser-use/python\#advanced-usage "Direct link to Advanced Usage")

For more advanced usage scenarios, please refer to:

- [Browser Use Documentation](https://github.com/browser-use/browser-use)
- [Browserless BaaS Documentation](https://docs.browserless.io/baas/start)
- [Integrating with other LLM providers](https://docs.browserless.io/ai-integrations/start)

- [Prerequisites](https://docs.browserless.io/ai-integrations/browser-use/python#prerequisites)
- [Step-by-Step Setup](https://docs.browserless.io/ai-integrations/browser-use/python#step-by-step-setup)
- [How It Works](https://docs.browserless.io/ai-integrations/browser-use/python#how-it-works)
- [Additional Configuration](https://docs.browserless.io/ai-integrations/browser-use/python#additional-configuration)
  - [Proxy Support](https://docs.browserless.io/ai-integrations/browser-use/python#proxy-support)
  - [Context Configuration](https://docs.browserless.io/ai-integrations/browser-use/python#context-configuration)
- [Advanced Features](https://docs.browserless.io/ai-integrations/browser-use/python#advanced-features)
  - [CDP Events and LiveURL](https://docs.browserless.io/ai-integrations/browser-use/python#cdp-events-and-liveurl)
  - [Complete Example with CDP Events](https://docs.browserless.io/ai-integrations/browser-use/python#complete-example-with-cdp-events)
- [Advanced Usage](https://docs.browserless.io/ai-integrations/browser-use/python#advanced-usage)

---

### Langchain Integration | Browserless.io
Original URL: https://docs.browserless.io/ai-integrations/langchain

[Skip to main content](https://docs.browserless.io/ai-integrations/langchain#__docusaurus_skipToContent_fallback)


[LangChain](https://www.langchain.com/) is a framework for developing applications powered by language models. By integrating Browserless with LangChain, you can provide your AI applications with powerful web scraping and content processing capabilities without managing browser infrastructure.

## Prerequisites [â€‹](https://docs.browserless.io/ai-integrations/langchain\#prerequisites "Direct link to Prerequisites")

- Python 3.8 or higher
- An active Browserless API Token (available in your [account dashboard](https://account.browserless.io/))
- Basic understanding of LangChain concepts

## Step-by-Step Setup [â€‹](https://docs.browserless.io/ai-integrations/langchain\#step-by-step-setup "Direct link to Step-by-Step Setup")

**1\. Get your API Key**

Go to your [Browserless Account Dashboard](https://account.browserless.io/) and copy your API token.

Then set the `BROWSERLESS_API_TOKEN` environment variable in your `.env` file:

- .env file
- Command line

```codeBlockLines_p187
BROWSERLESS_API_TOKEN=your-token-here

```

```codeBlockLines_p187
export BROWSERLESS_API_TOKEN=your-token-here

```

**2\. Create a virtual environment**

Set up a Python virtual environment to manage your dependencies:

- venv
- conda

```codeBlockLines_p187
python -m venv .venv
source .venv/bin/activate  # On Windows: .venv\Scripts\activate

```

```codeBlockLines_p187
conda create -n langchain-env python=3.8
conda activate langchain-env

```

**3\. Install required packages**

Install LangChain and other required packages:

- pip
- Poetry

```codeBlockLines_p187
pip install langchain-community python-dotenv

```

```codeBlockLines_p187
poetry add langchain-community python-dotenv

```

**4\. Create your first script**

Create a file named `scraper.py` with the following complete code:

```codeBlockLines_p187
from dotenv import load_dotenv
import os
from langchain_community.document_loaders import BrowserlessLoader

def main():
    # Load environment variables
    load_dotenv()

    # Initialize the loader with your API token
    loader = BrowserlessLoader(
        api_token=os.getenv("BROWSERLESS_API_TOKEN"),
        urls=["https://example.com"],
        text_content=True  # Get text content instead of raw HTML
    )

    # Load and process the documents
    documents = loader.load()

    # Print the results
    for doc in documents:
        print(f"Source: {doc.metadata.get('source')}")
        print(f"Content: {doc.page_content[:200]}...")

if __name__ == "__main__":
    main()

```

**5\. Run your application**

Run your application with the following command:

```codeBlockLines_p187
python scraper.py

```

You should see output showing the scraped content from the example website.

## How It Works [â€‹](https://docs.browserless.io/ai-integrations/langchain\#how-it-works "Direct link to How It Works")

**1\. Connection Setup**: BrowserlessLoader connects to Browserless using your API token
**2\. Content Loading**: The loader fetches and processes web content
**3\. Document Creation**: Content is converted into LangChain Documents
**4\. Processing**: Documents can be further processed with LangChain's tools

## Advanced Configuration [â€‹](https://docs.browserless.io/ai-integrations/langchain\#advanced-configuration "Direct link to Advanced Configuration")

### Multiple URLs [â€‹](https://docs.browserless.io/ai-integrations/langchain\#multiple-urls "Direct link to Multiple URLs")

Process multiple websites in a single operation:

```codeBlockLines_p187
loader = BrowserlessLoader(
    api_token=api_token,
    urls=[\
        "https://example1.com",\
        "https://example2.com",\
        "https://example3.com"\
    ]
)

```

### Raw HTML Mode [â€‹](https://docs.browserless.io/ai-integrations/langchain\#raw-html-mode "Direct link to Raw HTML Mode")

Get raw HTML content instead of text:

```codeBlockLines_p187
loader = BrowserlessLoader(
    api_token=api_token,
    urls=["https://example.com"],
    text_content=False
)

```

## Performance Optimization [â€‹](https://docs.browserless.io/ai-integrations/langchain\#performance-optimization "Direct link to Performance Optimization")

1. **Batch Processing**
   - Process multiple URLs in batches
   - Implement proper error handling
   - Use async/await for better performance
2. **Resource Management**
   - Monitor memory usage
   - Implement proper cleanup
   - Handle timeouts appropriately

## Security Best Practices [â€‹](https://docs.browserless.io/ai-integrations/langchain\#security-best-practices "Direct link to Security Best Practices")

1. **API Token Management**
   - Never commit tokens to version control
   - Use environment variables
   - Rotate tokens regularly
2. **Input Validation**
   - Validate URLs before processing
   - Implement rate limiting
   - Handle sensitive data appropriately

## Common Use Cases [â€‹](https://docs.browserless.io/ai-integrations/langchain\#common-use-cases "Direct link to Common Use Cases")

### News Aggregation [â€‹](https://docs.browserless.io/ai-integrations/langchain\#news-aggregation "Direct link to News Aggregation")

```codeBlockLines_p187
def aggregate_news(api_token, news_sites):
    loader = BrowserlessLoader(
        api_token=api_token,
        urls=news_sites,
        text_content=True
    )
    documents = loader.load()

    # Process and analyze the news content
    for doc in documents:
        print(f"Source: {doc.metadata.get('source')}")
        print(f"Content: {doc.page_content[:200]}...")

```

### Content Analysis [â€‹](https://docs.browserless.io/ai-integrations/langchain\#content-analysis "Direct link to Content Analysis")

```codeBlockLines_p187
from langchain.text_splitter import RecursiveCharacterTextSplitter

def analyze_content(api_token, url):
    # Load content
    loader = BrowserlessLoader(
        api_token=api_token,
        urls=[url],
        text_content=True
    )
    documents = loader.load()

    # Split content into chunks
    text_splitter = RecursiveCharacterTextSplitter(
        chunk_size=1000,
        chunk_overlap=200
    )
    chunks = text_splitter.split_documents(documents)

    # Process chunks
    for chunk in chunks:
        print(f"Chunk: {chunk.page_content[:100]}...")

```

For more advanced usage scenarios, please refer to:

- [LangChain Documentation](https://www.langchain.com/docs)
- [Browserless BaaS Documentation](https://docs.browserless.io/baas/start)
- [Integrating with other LLM providers](https://docs.browserless.io/ai-integrations/start)

- [Prerequisites](https://docs.browserless.io/ai-integrations/langchain#prerequisites)
- [Step-by-Step Setup](https://docs.browserless.io/ai-integrations/langchain#step-by-step-setup)
- [How It Works](https://docs.browserless.io/ai-integrations/langchain#how-it-works)
- [Advanced Configuration](https://docs.browserless.io/ai-integrations/langchain#advanced-configuration)
  - [Multiple URLs](https://docs.browserless.io/ai-integrations/langchain#multiple-urls)
  - [Raw HTML Mode](https://docs.browserless.io/ai-integrations/langchain#raw-html-mode)
- [Performance Optimization](https://docs.browserless.io/ai-integrations/langchain#performance-optimization)
- [Security Best Practices](https://docs.browserless.io/ai-integrations/langchain#security-best-practices)
- [Common Use Cases](https://docs.browserless.io/ai-integrations/langchain#common-use-cases)
  - [News Aggregation](https://docs.browserless.io/ai-integrations/langchain#news-aggregation)
  - [Content Analysis](https://docs.browserless.io/ai-integrations/langchain#content-analysis)

---

### AI Integrations | Browserless.io
Original URL: https://docs.browserless.io/ai-integrations/start

[Skip to main content](https://docs.browserless.io/ai-integrations/start#__docusaurus_skipToContent_fallback)


Browserless provides powerful capabilities for AI applications that need web browsing functionality. Our AI integrations allow you to easily add browser automation to your AI-powered applications.

## Available Integrations [â€‹](https://docs.browserless.io/ai-integrations/start\#available-integrations "Direct link to Available Integrations")

- [Browser Use](https://docs.browserless.io/ai-integrations/browser-use/python) \- Use Python's Browser Use library with Browserless for AI-based web browsing
- [Vercel AI SDK](https://docs.browserless.io/ai-integrations/vercel-ai-sdk) \- Connect Browserless to applications built with Vercel AI SDK
- [Langchain](https://docs.browserless.io/ai-integrations/langchain) \- Integrate Browserless with Langchain applications

Choose the integration that best fits your development environment and get started quickly with Browserless's powerful browser automation capabilities.

- [Available Integrations](https://docs.browserless.io/ai-integrations/start#available-integrations)

---

### Vercel AI SDK Integration | Browserless.io
Original URL: https://docs.browserless.io/ai-integrations/vercel-ai-sdk

[Skip to main content](https://docs.browserless.io/ai-integrations/vercel-ai-sdk#__docusaurus_skipToContent_fallback)


This guide demonstrates how to build a fully functional AI-powered browser automation application using Browserless.io, Vercel AI SDK, and Next.js. The application allows AI agents to control browsers through natural language instructions, enabling tasks like web scraping, form filling, and content extraction.

## Introduction [â€‹](https://docs.browserless.io/ai-integrations/vercel-ai-sdk\#introduction "Direct link to Introduction")

This integration combines three powerful technologies:

- **Browserless.io**: A headless browser service that provides browser automation capabilities
- **Vercel AI SDK**: A toolkit for building AI-powered applications
- **Next.js**: A React framework for building web applications

Together, these technologies enable you to create applications where AI can understand and execute browser automation tasks through natural language.

## Prerequisites [â€‹](https://docs.browserless.io/ai-integrations/vercel-ai-sdk\#prerequisites "Direct link to Prerequisites")

- Node.js 18 or higher
- Vercel account
- Browserless.io API token
- OpenAI API key (or other supported LLM provider)

## Step 1: Project Setup [â€‹](https://docs.browserless.io/ai-integrations/vercel-ai-sdk\#step-1-project-setup "Direct link to Step 1: Project Setup")

### Create a Next.js Project [â€‹](https://docs.browserless.io/ai-integrations/vercel-ai-sdk\#create-a-nextjs-project "Direct link to Create a Next.js Project")

```codeBlockLines_p187
npx create-next-app@latest browserless-ai
cd browserless-ai

```

### Install Required Packages [â€‹](https://docs.browserless.io/ai-integrations/vercel-ai-sdk\#install-required-packages "Direct link to Install Required Packages")

```codeBlockLines_p187
npm install @vercel/ai @browserless/ai puppeteer-core openai zod prettier

```

### Configure Environment Variables [â€‹](https://docs.browserless.io/ai-integrations/vercel-ai-sdk\#configure-environment-variables "Direct link to Configure Environment Variables")

Create a `.env.local` file in your project root:

```codeBlockLines_p187
BROWSERLESS_API_KEY=your_browserless_api_key
OPENAI_API_KEY=your_openai_api_key

```

## Step 2: Core Components [â€‹](https://docs.browserless.io/ai-integrations/vercel-ai-sdk\#step-2-core-components "Direct link to Step 2: Core Components")

### Browser Service [â€‹](https://docs.browserless.io/ai-integrations/vercel-ai-sdk\#browser-service "Direct link to Browser Service")

Create `src/lib/browser.ts`:

```codeBlockLines_p187
import puppeteer from 'puppeteer-core';
import { z } from 'zod';

// Schema for browser settings
const BrowserSettingsSchema = z.object({
  viewport: z.object({
    width: z.number().default(1920),
    height: z.number().default(1080),
  }),
  userAgent: z.string().optional(),
  timeout: z.number().default(30000),
});

export type BrowserSettings = z.infer<typeof BrowserSettingsSchema>;

export class BrowserlessService {
  private static instance: BrowserlessService;
  private browser: puppeteer.Browser | null = null;
  private settings: BrowserSettings;

  private constructor(settings: Partial<BrowserSettings> = {}) {
    this.settings = BrowserSettingsSchema.parse(settings);
  }

  static getInstance(settings?: Partial<BrowserSettings>): BrowserlessService {
    if (!BrowserlessService.instance) {
      BrowserlessService.instance = new BrowserlessService(settings);
    }
    return BrowserlessService.instance;
  }

  async getBrowser(): Promise<puppeteer.Browser> {
    if (!this.browser) {
      this.browser = await puppeteer.connect({
        browserWSEndpoint: `wss://production-sfo.browserless.io?token=${process.env.BROWSERLESS_API_KEY}`,
        defaultViewport: this.settings.viewport,
      });
    }
    return this.browser;
  }

  async close() {
    if (this.browser) {
      await this.browser.close();
      this.browser = null;
    }
  }
}

```

### AI Route Handler [â€‹](https://docs.browserless.io/ai-integrations/vercel-ai-sdk\#ai-route-handler "Direct link to AI Route Handler")

Create `src/app/api/chat/route.ts`:

```codeBlockLines_p187
import { OpenAIStream, StreamingTextResponse } from 'ai';
import { BrowserlessService } from '@/lib/browser';
import OpenAI from 'openai';
import { z } from 'zod';

// Schema for chat messages
const MessageSchema = z.object({
  role: z.enum(['user', 'assistant', 'system']),
  content: z.string(),
});

const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY,
});

export async function POST(req: Request) {
  try {
    const { messages } = await req.json();

    // Validate messages
    const validatedMessages = z.array(MessageSchema).parse(messages);

    const browserService = BrowserlessService.getInstance();
    const browser = await browserService.getBrowser();
    const page = await browser.newPage();

    // Process the message and perform browser actions
    const response = await openai.chat.completions.create({
      model: 'gpt-4-turbo',
      stream: true,
      messages: [\
        {\
          role: 'system',\
          content: `You are a browser automation assistant. You can:\
          1. Navigate to URLs\
          2. Extract information from pages\
          3. Fill out forms\
          4. Take screenshots\
          5. Click elements\
          6. Type text\
          Always respond with clear instructions for the browser.`\
        },\
        ...validatedMessages,\
      ],
    });

    const stream = OpenAIStream(response, {
      async onCompletion(completion) {
        try {
          // Process the AI's response and perform browser actions
          if (completion.includes('navigate to')) {
            const url = completion.match(/navigate to (https?:\/\/[^\s]+)/)?.[1];
            if (url) {
              await page.goto(url, { waitUntil: 'networkidle0' });
            }
          }

          if (completion.includes('click')) {
            const selector = completion.match(/click "([^"]+)"/)?.[1];
            if (selector) {
              await page.click(selector);
            }
          }

          if (completion.includes('type')) {
            const [selector, text] = completion.match(/type "([^"]+)" into "([^"]+)"/)?.slice(1) || [];
            if (selector && text) {
              await page.type(selector, text);
            }
          }

          // Add more action handlers as needed
        } catch (error) {
          console.error('Error executing browser action:', error);
        }
      },
    });

    return new StreamingTextResponse(stream);
  } catch (error) {
    console.error('Error processing request:', error);
    return new Response(
      JSON.stringify({ error: 'Failed to process request' }),
      { status: 500 }
    );
  }
}

```

### Chat Interface [â€‹](https://docs.browserless.io/ai-integrations/vercel-ai-sdk\#chat-interface "Direct link to Chat Interface")

Create `src/app/page.tsx`:

```codeBlockLines_p187
'use client';

import { useChat } from 'ai/react';
import { useState } from 'react';

export default function Chat() {
  const { messages, input, handleInputChange, handleSubmit, isLoading } = useChat();
  const [isProcessing, setIsProcessing] = useState(false);

  return (
    <div className="flex flex-col w-full max-w-2xl mx-auto p-4">
      <div className="flex-1 overflow-y-auto mb-4">
        {messages.map((message) => (
          <div
            key={message.id}
            className={`p-4 mb-4 rounded-lg ${
              message.role === 'user'
                ? 'bg-blue-100 ml-auto'
                : 'bg-gray-100 mr-auto'
            }`}
          >
            <div className="whitespace-pre-wrap">{message.content}</div>
          </div>
        ))}
      </div>

      <form onSubmit={handleSubmit} className="flex gap-2">
        <input
          className="flex-1 p-2 border border-gray-300 rounded-lg"
          value={input}
          placeholder="Ask the AI to perform browser actions..."
          onChange={handleInputChange}
          disabled={isLoading || isProcessing}
        />
        <button
          type="submit"
          className="px-4 py-2 bg-blue-500 text-white rounded-lg disabled:opacity-50"
          disabled={isLoading || isProcessing}
        >
          Send
        </button>
      </form>
    </div>
  );
}

```

## Step 3: Advanced Features [â€‹](https://docs.browserless.io/ai-integrations/vercel-ai-sdk\#step-3-advanced-features "Direct link to Step 3: Advanced Features")

### Session Management [â€‹](https://docs.browserless.io/ai-integrations/vercel-ai-sdk\#session-management "Direct link to Session Management")

Create `src/lib/session.ts`:

```codeBlockLines_p187
import { BrowserlessService } from './browser';
import puppeteer from 'puppeteer-core';

export class BrowserSession {
  private static sessions: Map<string, {
    page: puppeteer.Page;
    lastActive: number;
  }> = new Map();
  private static readonly SESSION_TIMEOUT = 30 * 60 * 1000; // 30 minutes

  static async getSession(sessionId: string): Promise<puppeteer.Page> {
    const session = this.sessions.get(sessionId);

    if (session && Date.now() - session.lastActive < this.SESSION_TIMEOUT) {
      session.lastActive = Date.now();
      return session.page;
    }

    const browser = await BrowserlessService.getInstance().getBrowser();
    const page = await browser.newPage();

    this.sessions.set(sessionId, {
      page,
      lastActive: Date.now(),
    });

    return page;
  }

  static async cleanup() {
    const now = Date.now();
    for (const [sessionId, session] of this.sessions.entries()) {
      if (now - session.lastActive > this.SESSION_TIMEOUT) {
        await session.page.close();
        this.sessions.delete(sessionId);
      }
    }
  }
}

```

### Error Handling Middleware [â€‹](https://docs.browserless.io/ai-integrations/vercel-ai-sdk\#error-handling-middleware "Direct link to Error Handling Middleware")

Create `src/middleware.ts`:

```codeBlockLines_p187
import { NextResponse } from 'next/server';
import { z } from 'zod';

export async function middleware(request: Request) {
  try {
    // Add rate limiting
    const ip = request.headers.get('x-forwarded-for') || 'unknown';
    // Implement your rate limiting logic here

    // Validate request body
    if (request.method === 'POST') {
      const body = await request.json();
      // Add your validation logic here
    }

    return NextResponse.next();
  } catch (error) {
    console.error('Middleware error:', error);
    return new NextResponse(
      JSON.stringify({ error: 'Internal server error' }),
      { status: 500 }
    );
  }
}

```

## Step 4: Testing [â€‹](https://docs.browserless.io/ai-integrations/vercel-ai-sdk\#step-4-testing "Direct link to Step 4: Testing")

### Local Testing [â€‹](https://docs.browserless.io/ai-integrations/vercel-ai-sdk\#local-testing "Direct link to Local Testing")

1. Start the development server:

```codeBlockLines_p187
npm run dev

```

2. Test the API endpoints:

```codeBlockLines_p187
curl -X POST http://localhost:3000/api/chat \
  -H "Content-Type: application/json" \
  -d '{"messages": [{"role": "user", "content": "Navigate to example.com"}]}'

```

### Production Testing [â€‹](https://docs.browserless.io/ai-integrations/vercel-ai-sdk\#production-testing "Direct link to Production Testing")

1. Deploy to Vercel:

```codeBlockLines_p187
vercel

```

2. Test the deployed endpoints:

```codeBlockLines_p187
curl -X POST https://your-app.vercel.app/api/chat \
  -H "Content-Type: application/json" \
  -d '{"messages": [{"role": "user", "content": "Navigate to example.com"}]}'

```

## Step 5: Deployment [â€‹](https://docs.browserless.io/ai-integrations/vercel-ai-sdk\#step-5-deployment "Direct link to Step 5: Deployment")

### Vercel Deployment [â€‹](https://docs.browserless.io/ai-integrations/vercel-ai-sdk\#vercel-deployment "Direct link to Vercel Deployment")

1. Push your code to GitHub
2. Import the project in Vercel
3. Add your environment variables:
   - `BROWSERLESS_API_KEY`
   - `OPENAI_API_KEY`
4. Deploy!

### Environment Configuration [â€‹](https://docs.browserless.io/ai-integrations/vercel-ai-sdk\#environment-configuration "Direct link to Environment Configuration")

Configure your Vercel project settings:

```codeBlockLines_p187
{
  "buildCommand": "next build",
  "outputDirectory": ".next",
  "framework": "nextjs",
  "installCommand": "npm install",
  "regions": ["sfo1"]
}

```

## Best Practices [â€‹](https://docs.browserless.io/ai-integrations/vercel-ai-sdk\#best-practices "Direct link to Best Practices")

1. **Resource Management**
   - Always close browser pages when done
   - Implement session timeouts
   - Clean up unused resources
2. **Error Handling**
   - Implement comprehensive error handling
   - Log errors appropriately
   - Provide meaningful error messages
3. **Security**
   - Validate all inputs
   - Implement rate limiting
   - Use environment variables for sensitive data
4. **Performance**
   - Use appropriate timeouts
   - Implement caching where possible
   - Optimize browser operations
5. **Monitoring**
   - Set up error tracking
   - Monitor API usage
   - Track performance metrics

## Troubleshooting [â€‹](https://docs.browserless.io/ai-integrations/vercel-ai-sdk\#troubleshooting "Direct link to Troubleshooting")

### Common Issues [â€‹](https://docs.browserless.io/ai-integrations/vercel-ai-sdk\#common-issues "Direct link to Common Issues")

1. **Connection Errors**
   - Check your Browserless.io API key
   - Verify network connectivity
   - Check firewall settings
2. **Timeout Errors**
   - Increase timeout values
   - Optimize browser operations
   - Implement retry logic
3. **Rate Limit Errors**
   - Implement proper rate limiting
   - Monitor API usage
   - Consider upgrading your plan

### Debugging Tips [â€‹](https://docs.browserless.io/ai-integrations/vercel-ai-sdk\#debugging-tips "Direct link to Debugging Tips")

1. Enable verbose logging:

```codeBlockLines_p187
process.env.DEBUG = 'browserless:*';

```

2. Use the Browserless.io dashboard to monitor sessions

3. Implement request logging:


```codeBlockLines_p187
console.log('Request:', {
  url: request.url,
  method: request.method,
  headers: Object.fromEntries(request.headers),
});

```

## Additional Resources [â€‹](https://docs.browserless.io/ai-integrations/vercel-ai-sdk\#additional-resources "Direct link to Additional Resources")

- [Browserless.io Documentation](https://docs.browserless.io/)
- [Vercel AI SDK Documentation](https://sdk.vercel.ai/docs)
- [Next.js Documentation](https://nextjs.org/docs)
- [OpenAI API Documentation](https://platform.openai.com/docs/api-reference)

- [Introduction](https://docs.browserless.io/ai-integrations/vercel-ai-sdk#introduction)
- [Prerequisites](https://docs.browserless.io/ai-integrations/vercel-ai-sdk#prerequisites)
- [Step 1: Project Setup](https://docs.browserless.io/ai-integrations/vercel-ai-sdk#step-1-project-setup)
  - [Create a Next.js Project](https://docs.browserless.io/ai-integrations/vercel-ai-sdk#create-a-nextjs-project)
  - [Install Required Packages](https://docs.browserless.io/ai-integrations/vercel-ai-sdk#install-required-packages)
  - [Configure Environment Variables](https://docs.browserless.io/ai-integrations/vercel-ai-sdk#configure-environment-variables)
- [Step 2: Core Components](https://docs.browserless.io/ai-integrations/vercel-ai-sdk#step-2-core-components)
  - [Browser Service](https://docs.browserless.io/ai-integrations/vercel-ai-sdk#browser-service)
  - [AI Route Handler](https://docs.browserless.io/ai-integrations/vercel-ai-sdk#ai-route-handler)
  - [Chat Interface](https://docs.browserless.io/ai-integrations/vercel-ai-sdk#chat-interface)
- [Step 3: Advanced Features](https://docs.browserless.io/ai-integrations/vercel-ai-sdk#step-3-advanced-features)
  - [Session Management](https://docs.browserless.io/ai-integrations/vercel-ai-sdk#session-management)
  - [Error Handling Middleware](https://docs.browserless.io/ai-integrations/vercel-ai-sdk#error-handling-middleware)
- [Step 4: Testing](https://docs.browserless.io/ai-integrations/vercel-ai-sdk#step-4-testing)
  - [Local Testing](https://docs.browserless.io/ai-integrations/vercel-ai-sdk#local-testing)
  - [Production Testing](https://docs.browserless.io/ai-integrations/vercel-ai-sdk#production-testing)
- [Step 5: Deployment](https://docs.browserless.io/ai-integrations/vercel-ai-sdk#step-5-deployment)
  - [Vercel Deployment](https://docs.browserless.io/ai-integrations/vercel-ai-sdk#vercel-deployment)
  - [Environment Configuration](https://docs.browserless.io/ai-integrations/vercel-ai-sdk#environment-configuration)
- [Best Practices](https://docs.browserless.io/ai-integrations/vercel-ai-sdk#best-practices)
- [Troubleshooting](https://docs.browserless.io/ai-integrations/vercel-ai-sdk#troubleshooting)
  - [Common Issues](https://docs.browserless.io/ai-integrations/vercel-ai-sdk#common-issues)
  - [Debugging Tips](https://docs.browserless.io/ai-integrations/vercel-ai-sdk#debugging-tips)
- [Additional Resources](https://docs.browserless.io/ai-integrations/vercel-ai-sdk#additional-resources)

---


## Other

### Docs | Browserless.io
Original URL: https://docs.browserless.io/

[Skip to main content](https://docs.browserless.io/#__docusaurus_skipToContent_fallback)

# Browserless Documentation

![Overview](https://docs.browserless.io/img/homepage/card-overview-browserless.svg)

### Overview

Learn about all browserless offerings, compare APIs, and find connection URLs:

- [API Comparison](https://docs.browserless.io/overview/comparison)
- [Connection URLs](https://docs.browserless.io/overview/connection-urls)
- [Launch Parameters](https://docs.browserless.io/overview/launch-parameters)

![BrowserQL](https://docs.browserless.io/img/homepage/card-browser-ql-browserless.svg)

### BrowserQL

Our GraphQL-based stealth-first automation API with human-like behavior and advanced bot detection bypass:

- [Bot Detection](https://docs.browserless.io/browserql/bot-detection/accessing-pages)
- [Captcha Solving](https://docs.browserless.io/browserql/bot-detection/solving-captchas)
- [Connecting Libraries](https://docs.browserless.io/browserql/connecting-libraries/puppeteer)

![Browsers as a Service](https://docs.browserless.io/img/homepage/card-browser-as-a-service-browserless.svg)

### Browsers as a Service

Scale your Puppeteer/Playwright scripts on our infrastructure with a simple one-line code replacement:

- [Connecting Libraries](https://docs.browserless.io/baas/start#connecting-libraries)
- [Hybrid Automation](https://docs.browserless.io/baas/hybrid-automation)
- [Session Management](https://docs.browserless.io/baas/session-management/reconnect)

![REST APIs](https://docs.browserless.io/img/homepage/card-rest-apis-browserless.svg)

### REST APIs

Simple HTTP requests for browser operations without complex automation code:

- [Scraping Data](https://docs.browserless.io/rest-apis/scrape)
- [Generating PDFs](https://docs.browserless.io/rest-apis/pdf)
- [Taking Screenshots](https://docs.browserless.io/rest-apis/screenshot)

![AI Integrations](https://docs.browserless.io/img/homepage/card-ai-integrations-browserless.svg)

### AI Integrations

Add powerful browser automation to your AI applications:

- [Browser Use](https://docs.browserless.io/ai-integrations/browser-use/python)
- [Vercel AI SDK](https://docs.browserless.io/ai-integrations/vercel-ai-sdk)
- [Langchain](https://docs.browserless.io/ai-integrations/langchain)

![API Reference](https://docs.browserless.io/img/homepage/card-api-reference-browserless.svg)

### API Reference

Detailed documentation of endpoints and parameters for integrating Browserless.

- [BrowserQL Schema](https://docs.browserless.io/bql-schema/schema)
- [OpenAPI Reference](https://docs.browserless.io/open-api)

---

### Untitled
Original URL: https://docs.browserless.io/assets/files/ips-8e7fda4a41344669859fb22b4df54d56.json

```json
[
  "146.190.53.75",
  "146.190.53.72",
  "146.190.175.184",
  "147.182.250.161",
  "164.92.125.142",
  "164.92.125.134",
  "146.190.143.216",
  "146.190.127.114",
  "146.190.143.212",
  "24.199.123.163",
  "24.199.111.199",
  "146.190.159.230",
  "146.190.159.176",
  "24.199.103.126",
  "159.223.205.248",
  "137.184.226.226",
  "146.190.159.171",
  "24.144.81.223",
  "137.184.235.213",
  "146.190.139.82",
  "164.92.125.23",
  "159.223.205.48",
  "146.190.159.67",
  "164.92.125.19",
  "146.190.130.128",
  "137.184.179.6",
  "137.184.178.146",
  "164.92.109.217",
  "164.92.109.12",
  "143.198.129.119",
  "165.232.140.251",
  "24.199.105.203",
  "143.198.111.152",
  "143.198.99.228",
  "24.144.94.186",
  "146.190.53.55",
  "164.90.145.42",
  "143.198.99.72",
  "146.190.53.52",
  "144.126.211.154",
  "143.244.181.136",
  "146.190.57.39",
  "144.126.220.231",
  "143.198.131.227",
  "143.244.188.238",
  "147.182.203.53",
  "146.190.143.211",
  "146.190.131.136",
  "24.199.115.166",
  "137.184.12.124",
  "209.38.79.187",
  "209.38.68.13",
  "209.38.74.36",
  "164.92.95.6",
  "209.38.75.204",
  "209.38.67.232",
  "209.38.70.84",
  "209.38.73.120",
  "143.198.129.120",
  "143.198.136.242",
  "146.190.114.39",
  "146.190.118.62",
  "146.190.59.199",
  "146.190.116.90",
  "146.190.34.116",
  "64.23.239.117",
  "64.23.238.239",
  "64.23.235.163",
  "64.23.238.31",
  "64.23.238.124",
  "64.23.232.196",
  "64.23.234.46",
  "164.90.159.169",
  "164.90.155.253",
  "64.23.235.171",
  "64.23.215.208",
  "64.23.167.192",
  "64.23.215.190",
  "137.184.3.181",
  "143.198.109.32",
  "146.190.44.51",
  "161.35.229.21",
  "161.35.229.77",
  "161.35.237.149",
  "161.35.233.103",
  "134.209.180.180",
  "134.209.189.197",
  "134.209.188.237",
  "134.209.186.0",
  "134.209.187.201",
  "134.209.186.65",
  "209.97.186.36",
  "167.172.61.214",
  "46.101.92.250",
  "46.101.87.212",
  "134.209.25.165",
  "134.209.25.209",
  "134.209.25.215",
  "134.209.17.68",
  "134.209.17.100",
  "134.209.25.201",
  "134.209.17.116",
  "134.209.25.53",
  "144.126.204.196",
  "134.209.25.97",
  "152.42.138.139",
  "157.245.73.238",
  "167.71.77.118",
  "167.71.74.138",
  "157.245.70.98"
]

```

---

### Untitled
Original URL: https://docs.browserless.io/assets/files/ips-a37a4fd5146bde60402d7c270401ce97.txt

```
146.190.53.75
146.190.53.72
146.190.175.184
147.182.250.161
164.92.125.142
164.92.125.134
146.190.143.216
146.190.127.114
146.190.143.212
24.199.123.163
24.199.111.199
146.190.159.230
146.190.159.176
24.199.103.126
159.223.205.248
137.184.226.226
146.190.159.171
24.144.81.223
137.184.235.213
146.190.139.82
164.92.125.23
159.223.205.48
146.190.159.67
164.92.125.19
146.190.130.128
137.184.179.6
137.184.178.146
164.92.109.217
164.92.109.12
143.198.129.119
165.232.140.251
24.199.105.203
143.198.111.152
143.198.99.228
24.144.94.186
146.190.53.55
164.90.145.42
143.198.99.72
146.190.53.52
144.126.211.154
143.244.181.136
146.190.57.39
144.126.220.231
143.198.131.227
143.244.188.238
147.182.203.53
146.190.143.211
146.190.131.136
24.199.115.166
137.184.12.124
209.38.79.187
209.38.68.13
209.38.74.36
164.92.95.6
209.38.75.204
209.38.67.232
209.38.70.84
209.38.73.120
143.198.129.120
143.198.136.242
146.190.114.39
146.190.118.62
146.190.59.199
146.190.116.90
146.190.34.116
64.23.239.117
64.23.238.239
64.23.235.163
64.23.238.31
64.23.238.124
64.23.232.196
64.23.234.46
164.90.159.169
164.90.155.253
64.23.235.171
64.23.215.208
64.23.167.192
64.23.215.190
137.184.3.181
143.198.109.32
146.190.44.51
161.35.229.21
161.35.229.77
161.35.237.149
161.35.233.103
134.209.180.180
134.209.189.197
134.209.188.237
134.209.186.0
134.209.187.201
134.209.186.65
209.97.186.36
167.172.61.214
46.101.92.250
46.101.87.212
134.209.25.165
134.209.25.209
134.209.25.215
134.209.17.68
134.209.17.100
134.209.25.201
134.209.17.116
134.209.25.53
144.126.204.196
134.209.25.97
152.42.138.139
157.245.73.238
167.71.77.118
167.71.74.138
157.245.70.98

```

---

### Solving Captchas | Browserless.io
Original URL: https://docs.browserless.io/baas/avoid-bot-detection/captchas

[Skip to main content](https://docs.browserless.io/baas/avoid-bot-detection/captchas#__docusaurus_skipToContent_fallback)



info

Looking for full developer docs? [See them here](https://docs.browserless.io/open-api#section/The-Browserless-CDP-API/Browserless.solveCaptcha).
This feature is only available on the Scale plan and Enterprise plans.

Some sites won't allow you to bypass their captchas or strictly enforce them to be solved on some sites. You can solve these captchas with Browserless without much effort. You can have a listener waiting to see if a captcha is found and you can also solve them programmatically.

Every captcha you solve costs 10 units from your plan.

note

Many passive captchas can be prevented from showing with our [**BrowserQL**](https://docs.browserless.io/browserql/start), that hides signs of browser automation.

## Find a captcha programmatically [â€‹](https://docs.browserless.io/baas/avoid-bot-detection/captchas\#find-a-captcha-programmatically "Direct link to Find a captcha programmatically")

You can listen for captchas on the site, in puppeteer it would be like this:

- Puppeteer
- Playwright

```codeBlockLines_p187
const cdp = await page.createCDPSession();
await new Promise((resolve) =>
  cdp.on("Browserless.captchaFound", () => {
    console.log("Found a captcha!");
    return resolve();
  })
);

```

- Javascript
- Python
- Java
- C#

```codeBlockLines_p187
const cdp = await page.context().newCDPSession(page);

await new Promise((resolve) =>
  cdp.on("Browserless.captchaFound", () => {
    console.log("Found a captcha!");
    return resolve();
  })
);

```

```codeBlockLines_p187
cdp = await page.context.new_cdp_session(page)

async def handle_captcha_found(event):
    print("Found a captcha!")
    return

cdp.on("Browserless.captchaFound", handle_captcha_found)

# Wait for the event to resolve
await asyncio.Future()

```

```codeBlockLines_p187
CDPSession cdp = page.context().newCDPSession(page);

cdp.addListener("Browserless.captchaFound", event -> {
    System.out.println("Found a captcha!");
    // You can add additional handling logic here
});

```

```codeBlockLines_p187
var cdp = await page.Context.NewCDPSessionAsync(page);

cdp.On("Browserless.captchaFound", e =>
{
    Console.WriteLine("Found a captcha!");
    // Additional logic can be added here
});

```

## Solve a captcha programmatically [â€‹](https://docs.browserless.io/baas/avoid-bot-detection/captchas\#solve-a-captcha-programmatically "Direct link to Solve a captcha programmatically")

You can solve the captcha from code, in puppeteer it would be like this:

- Puppeteer
- Playwright

```codeBlockLines_p187
const cdp = await page.createCDPSession();
const { solved, error } = await cdp.send("Browserless.solveCaptcha");
console.log({
  solved,
  error,
});

```

- Javascript
- Python
- Java
- C#

```codeBlockLines_p187
const cdp = await page.context().newCDPSession(page);

const { solved, error } = await cdp.send("Browserless.solveCaptcha");
console.log({
  solved,
  error,
});

```

```codeBlockLines_p187
cdp = await page.context.new_cdp_session(page)

result = await cdp.send("Browserless.solveCaptcha")
solved = result.get("solved")
error = result.get("error")

print({
    "solved": solved,
    "error": error,
})

```

```codeBlockLines_p187
CDPSession cdp = page.context().newCDPSession(page);

Map<String, Object> result = cdp.send("Browserless.solveCaptcha");
Boolean solved = (Boolean) result.get("solved");
String error = (String) result.get("error");

System.out.println(Map.of(
    "solved", solved,
    "error", error
));

```

```codeBlockLines_p187
var cdp = await page.Context.NewCDPSessionAsync(page);

var result = await cdp.SendAsync<Dictionary<string, object>>("Browserless.solveCaptcha");
var solved = result.ContainsKey("solved") ? result["solved"] : null;
var error = result.ContainsKey("error") ? result["error"] : null;

Console.WriteLine(new {
    solved,
    error
});

```

## Script Examples [â€‹](https://docs.browserless.io/baas/avoid-bot-detection/captchas\#script-examples "Direct link to Script Examples")

### Puppeteer [â€‹](https://docs.browserless.io/baas/avoid-bot-detection/captchas\#puppeteer "Direct link to Puppeteer")

Here's a sample snippet you can run to demonstrate this works.

```codeBlockLines_p187
import puppeteer from "puppeteer-core";

const waitForCaptcha = (cdpSession) => {
  return new Promise((resolve) =>
    cdpSession.on("Browserless.captchaFound", resolve)
  );
};

const browserWSEndpoint =
  "wss://production-sfo.browserless.io/chromium?token=YOUR_API_TOKEN_HERE&timeout=300000";

try {
  const browser = await puppeteer.connect({ browserWSEndpoint });

  const page = await browser.newPage();
  const cdp = await page.createCDPSession();

  await page.goto("https://www.google.com/recaptcha/api2/demo", {
    waitUntil: "networkidle0",
  });

  await waitForCaptcha(cdp);
  console.log("Captcha found!");

  const { solved, error } = await cdp.send("Browserless.solveCaptcha");
  console.log({ solved, error });

  // Continue...
  await page.click("#recaptcha-demo-submit");
  await browser.close();
} catch (e) {
  console.error("There was a big error :(", e);
  process.exit(1);
}

```

### Playwright [â€‹](https://docs.browserless.io/baas/avoid-bot-detection/captchas\#playwright "Direct link to Playwright")

Playwright works a bit different than Puppeteer in regards to its pages, as it uses it own browser protocols to communicate. For that reason, **you'll need to connect over CDP**. And while most of the steps are the same as in Puppeteer, **you should use the default existing context and page instead of creating a new one**.

- Javascript
- Python
- Java
- C#

```codeBlockLines_p187
import playwright from "playwright-core";

const waitForCaptcha = (cdpSession) => {
  return new Promise((resolve) =>
    cdpSession.on("Browserless.captchaFound", resolve)
  );
};
const pwEndpoint = `wss://production-sfo.browserless.io/chromium?token=YOUR_API_TOKEN_HERE`;

try {
  const browser = await playwright.chromium.connectOverCDP(pwEndpoint);
  // ðŸ‘‡ Queue we're re-using the existing context and page
  const context = browser.contexts()[0];
  const page = context.pages()[0];

  await page.goto("https://www.google.com/recaptcha/api2/demo", {
    waitUntil: "networkidle0",
  });

  const cdp = await page.context().newCDPSession(page);
  await waitForCaptcha(cdp);
  console.log("Captcha found!");

  const { solved, error } = await cdp.send("Browserless.solveCaptcha");

  console.log({ solved, error });

  // Continue...
  await page.click("#recaptcha-demo-submit");
  await browser.close();
} catch (e) {
  console.error("There was a big error :(", e);
  process.exit(1);
}

```

```codeBlockLines_p187
import asyncio
from playwright.async_api import async_playwright

async def wait_for_captcha(cdp_session):
    # Wait for the "Browserless.captchaFound" event
    future = asyncio.Future()

    def handle_captcha_found(event):
        print("Captcha found!")
        future.set_result(event)

    cdp_session.on("Browserless.captchaFound", handle_captcha_found)
    return await future

async def main():
    pw_endpoint = "wss://production-sfo.browserless.io/chromium?token=YOUR_API_TOKEN_HERE"
    async with async_playwright() as p:
        try:
            # Connect to the browser
            browser = await p.chromium.connect_over_cdp(pw_endpoint)

            # Use the first context and page
            context = browser.contexts[0]
            page = context.pages[0]

            # Navigate to the captcha demo page
            await page.goto("https://www.google.com/recaptcha/api2/demo", wait_until="networkidle")

            # Create a CDP session
            cdp = await page.context.new_cdp_session(page)

            # Wait for captcha to be found
            await wait_for_captcha(cdp)

            # Solve the captcha
            result = await cdp.send("Browserless.solveCaptcha")
            solved, error = result.get("solved"), result.get("error")
            print({"solved": solved, "error": error})

            # Continue after solving captcha
            await page.click("#recaptcha-demo-submit")
            await browser.close()
        except Exception as e:
            print("There was a big error :(", e)

asyncio.run(main())

```

```codeBlockLines_p187
import com.microsoft.playwright.*;
import com.microsoft.playwright.options.*;

import java.util.*;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutionException;

public class PlaywrightCaptchaExample {
    public static void main(String[] args) {
        String pwEndpoint = "wss://production-sfo.browserless.io/chromium?token=YOUR_API_TOKEN_HERE";

        try (Playwright playwright = Playwright.create()) {
            Browser browser = playwright.chromium().connectOverCDP(pwEndpoint);

            // Reuse the existing context and page
            BrowserContext context = browser.contexts().get(0);
            Page page = context.pages().get(0);

            // Navigate to the captcha demo page
            page.navigate("https://www.google.com/recaptcha/api2/demo", new Page.NavigateOptions()
                .setWaitUntil(LoadState.NETWORKIDLE));

            // Create a CDP session
            CDPSession cdp = page.context().newCDPSession(page);

            // Wait for captcha to be found
            CompletableFuture<Void> captchaFound = new CompletableFuture<>();
            cdp.on("Browserless.captchaFound", event -> {
                System.out.println("Captcha found!");
                captchaFound.complete(null);
            });

            captchaFound.get(); // Wait for the event

            // Solve the captcha
            Map<String, Object> result = cdp.send("Browserless.solveCaptcha");
            System.out.println("Result: " + result);

            // Continue after solving captcha
            page.click("#recaptcha-demo-submit");
            browser.close();
        } catch (ExecutionException | InterruptedException e) {
            System.err.println("There was a big error :(" + e.getMessage());
            e.printStackTrace();
        }
    }
}

```

```codeBlockLines_p187
using System;
using System.Collections.Generic;
using System.Threading.Tasks;
using Microsoft.Playwright;

class Program
{
    static async Task Main(string[] args)
    {
        var pwEndpoint = "wss://production-sfo.browserless.io/chromium?token=YOUR_API_TOKEN_HERE";

        try
        {
            var playwright = await Playwright.CreateAsync();
            var browser = await playwright.Chromium.ConnectOverCDPAsync(pwEndpoint);

            // Use the first context and page
            var context = browser.Contexts[0];
            var page = context.Pages[0];

            // Navigate to the captcha demo page
            await page.GotoAsync("https://www.google.com/recaptcha/api2/demo", new PageGotoOptions
            {
                WaitUntil = WaitUntilState.NetworkIdle
            });

            // Create a CDP session
            var cdp = await page.Context.NewCDPSessionAsync(page);

            // Wait for captcha to be found
            var captchaFound = new TaskCompletionSource<bool>();
            cdp.On("Browserless.captchaFound", _ =>
            {
                Console.WriteLine("Captcha found!");
                captchaFound.TrySetResult(true);
            });

            await captchaFound.Task;

            // Solve the captcha
            var result = await cdp.SendAsync<Dictionary<string, object>>("Browserless.solveCaptcha");
            Console.WriteLine($"Solved: {result["solved"]}, Error: {result["error"]}");

            // Continue after solving captcha
            await page.ClickAsync("#recaptcha-demo-submit");
            await browser.CloseAsync();
        }
        catch (Exception e)
        {
            Console.WriteLine("There was a big error :(");
            Console.WriteLine(e.Message);
        }
    }
}

```

- [Find a captcha programmatically](https://docs.browserless.io/baas/avoid-bot-detection/captchas#find-a-captcha-programmatically)
- [Solve a captcha programmatically](https://docs.browserless.io/baas/avoid-bot-detection/captchas#solve-a-captcha-programmatically)
- [Script Examples](https://docs.browserless.io/baas/avoid-bot-detection/captchas#script-examples)
  - [Puppeteer](https://docs.browserless.io/baas/avoid-bot-detection/captchas#puppeteer)
  - [Playwright](https://docs.browserless.io/baas/avoid-bot-detection/captchas#playwright)

---

### How to bypass bot detection | Browserless.io
Original URL: https://docs.browserless.io/baas/avoid-bot-detection/stealth

[Skip to main content](https://docs.browserless.io/baas/avoid-bot-detection/stealth#__docusaurus_skipToContent_fallback)



Websites can have a different level of anti-bot mechanisms depending on the sensitivity of their data and budget. If your automation is being blocked, take action with the steps below.

## BrowserQL [â€‹](https://docs.browserless.io/baas/avoid-bot-detection/stealth\#browserql "Direct link to BrowserQL")

You can use our query-language, BQL, which is designed to bypass sophisticated bot detection mechanisms effectively. This API allows you to specify a target URL and return data you care about: the HTML content, a `.png` screenshot or an unblocked browser session to use with Playwright or Puppeteer.

A simple cURL request to the API specifying your target website will return all the data needed to scrape it after it is done bypassing the bot detection:

```codeBlockLines_p187
curl --request POST \
  --url 'https://production-sfo.browserless.io/chrome/bql?token=YOUR-TOKEN-HERE' \
  --header 'Content-Type: application/json' \
  --data '{
  "query": "mutation Reconnect($url: String!) { goto(url: $url, waitUntil: networkIdle) { status } reconnect(timeout: 30000) { browserWSEndpoint } }",
  "variables": { "url": "https://example.com/" }
}'

```

You can use the content, or screenshot directly, or use the endpoint to run further actions with a library:

- Puppeteer
- Playwright

```codeBlockLines_p187
import puppeteer from "puppeteer-core";

const TOKEN = 'YOUR_API_TOKEN_HERE';
const url = "https://www.browserless.io/"

const unblock = async (url) => {
  const opts = {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
    },
    body: JSON.stringify({
      "query": "mutation Reconnect($url: String!) { goto(url: $url, waitUntil: networkIdle) { status } reconnect(timeout: 30000) { browserWSEndpoint } }",
      "variables": { url }
    }),
  };

  const response = await fetch(
    `https://production-sfo.browserless.io/chromium/bql?token=${TOKEN}`,
    opts,
  );

  return await response.json();
};

// Reconnect
const { data } = await unblock(url);
const browser = await puppeteer.connect({
  browserWSEndpoint: data.reconnect.browserWSEndpoint + `?token=${TOKEN}`,
});
const pages = await browser.pages();

const page = pages.find((p) => p.url() === url);
await page.screenshot({ path: `screenshot-${Date.now()}.png` });
await browser.close();

```

- Javascript
- Python
- Java
- C#

```codeBlockLines_p187
import { chromium } from "playwright-core";

const TOKEN = 'YOUR_API_TOKEN_HERE';
const url = "https://www.browserless.io/";

const unblock = async (url) => {
  const opts = {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
    },
    body: JSON.stringify({
      "query": "mutation Reconnect($url: String!) { goto(url: $url, waitUntil: networkIdle) { status } reconnect(timeout: 30000) { browserWSEndpoint } }",
      "variables": { url }
    }),
  };

  const response = await fetch(
    `https://production-sfo.browserless.io/chromium/bql?token=${TOKEN}`,
    opts,
  );

  return await response.json();
};

const { data } = await unblock(url);

const browser = await chromium.connectOverCDP(data.reconnect.browserWSEndpoint + `?token=${TOKEN}`);
const pages = browser.contexts()[0].pages();

const page = pages.find((p) => p.url() === url);
await page.screenshot({ path: `screenshot-${Date.now()}.png` });
await browser.close();

```

```codeBlockLines_p187
import asyncio
import requests
from playwright.async_api import async_playwright

TOKEN = "YOUR_API_TOKEN_HERE"
url = "https://www.browserless.io/"

def unblock(url):
    opts = {
        "query": """mutation Reconnect($url: String!) {
            goto(url: $url, waitUntil: networkIdle) { status }
            reconnect(timeout: 30000) { browserWSEndpoint }
        }""",
        "variables": {"url": url},
    }

    response = requests.post(
        f"https://production-sfo.browserless.io/chromium/bql?token={TOKEN}",
        json=opts,
        headers={"Content-Type": "application/json"},
    )

    response.raise_for_status()
    return response.json()

async def main():
    data = unblock(url)["data"]

    async with async_playwright() as p:
        browser = await p.chromium.connect_over_cdp(
            data["reconnect"]["browserWSEndpoint"] + f"?token={TOKEN}"
        )
        context = browser.contexts[0]
        page = next((p for p in context.pages if p.url == url), None)
        await page.screenshot(path="screenshot.png")
        await browser.close()

asyncio.run(main())

```

```codeBlockLines_p187
import com.microsoft.playwright.*;
import java.net.http.*;
import java.net.URI;
import java.net.http.HttpClient;
import java.util.Map;
import com.google.gson.Gson;

public class PlaywrightExample {
    private static final String TOKEN = "YOUR_API_TOKEN_HERE";
    private static final String URL = "https://www.browserless.io/";

    public static void main(String[] args) throws Exception {
        HttpClient client = HttpClient.newHttpClient();

        Map<String, Object> payload = Map.of(
            "query", """
                mutation Reconnect($url: String!) {
                    goto(url: $url, waitUntil: networkIdle) { status }
                    reconnect(timeout: 30000) { browserWSEndpoint }
                }
            """,
            "variables", Map.of("url", URL)
        );

        HttpRequest request = HttpRequest.newBuilder()
            .uri(URI.create("https://production-sfo.browserless.io/chromium/bql?token=" + TOKEN))
            .header("Content-Type", "application/json")
            .POST(HttpRequest.BodyPublishers.ofString(new Gson().toJson(payload)))
            .build();

        System.out.println("Unblocking " + URL);
        HttpResponse<String> response = client.send(request, HttpResponse.BodyHandlers.ofString());

        if (response.statusCode() != 200) {
            throw new Exception("Error: " + response.body());
        }

        String browserWSEndpoint = new Gson().fromJson(response.body(), Map.class)
            .get("data").get("reconnect").get("browserWSEndpoint").toString();

        System.out.println("Connecting to Playwright...");
        try (Playwright playwright = Playwright.create()) {
            Browser browser = playwright.chromium().connectOverCDP(browserWSEndpoint);
            Page page = browser.contexts().get(0).pages().stream()
                .filter(p -> p.url().equals(URL))
                .findFirst()
                .orElseThrow(() -> new Exception("Page not found"));

            page.screenshot(new Page.ScreenshotOptions().setPath("screenshot.png"));
        }

        System.out.println("Done!");
    }
}

```

```codeBlockLines_p187
using System;
using System.Net.Http;
using System.Text.Json;
using System.Text.Json.Serialization;
using System.Threading.Tasks;
using Microsoft.Playwright;

class Program
{
    private const string TOKEN = "YOUR_API_TOKEN_HERE";
    private const string URL = "https://www.browserless.io/";

    static async Task Main(string[] args)
    {
        var httpClient = new HttpClient();
        var payload = new
        {
            query = @"
                mutation Reconnect($url: String!) {
                    goto(url: $url, waitUntil: networkIdle) { status }
                    reconnect(timeout: 30000) { browserWSEndpoint }
                }",
            variables = new { url = URL }
        };

        var requestContent = new StringContent(JsonSerializer.Serialize(payload), System.Text.Encoding.UTF8, "application/json");
        var response = await httpClient.PostAsync($"https://production-sfo.browserless.io/chromium/bql?token={TOKEN}", requestContent);

        if (!response.IsSuccessStatusCode)
        {
            Console.WriteLine($"Error: {await response.Content.ReadAsStringAsync()}");
            return;
        }

        var jsonResponse = JsonSerializer.Deserialize<JsonElement>(await response.Content.ReadAsStringAsync());
        var browserWSEndpoint = jsonResponse.GetProperty("data").GetProperty("reconnect").GetProperty("browserWSEndpoint").GetString();

        var playwright = await Playwright.CreateAsync();
        var browser = await playwright.Chromium.ConnectOverCDPAsync(browserWSEndpoint + $"?token={TOKEN}");
        var context = browser.Contexts[0];
        var page = context.Pages[0];

        Console.WriteLine("Taking screenshot...");
        await page.ScreenshotAsync(new PageScreenshotOptions { Path = "screenshot.png" });

        await browser.CloseAsync();
        Console.WriteLine("Done!");
    }
}

```

## Additional strategies [â€‹](https://docs.browserless.io/baas/avoid-bot-detection/stealth\#additional-strategies "Direct link to Additional strategies")

If none of these do the trick, get in touch with us at [support@browserless.io](mailto:support@browserless.io) >.

We have more trick up our sleeves we can show you, such as captcha solving, [BQL methods](https://docs.browserless.io/browserql/avoid-bot-detection/bypass-tough-bot-detection), and special infrastructure on our enterprise plans.

## Try out the Stealth routes [â€‹](https://docs.browserless.io/baas/avoid-bot-detection/stealth\#try-out-the-stealth-routes "Direct link to Try out the Stealth routes")

info

The stealth routes below are for only for paid cloud-unit or Enterprise plans.

We have native support for things like puppeteer-stealth, but also offer our own stealth routes that encompass more stealthy behaviors. We use a route path semantic for this, and today this only supports libraries that work over the Chrome Devtools Protocol.

- Puppeteer
- Playwright

```codeBlockLines_p187
// Chromium:
await puppeteer.connect({
  browserWSEndpoint:
    "wss://production-sfo.browserless.io/chromium/stealth?token=YOUR_API_TOKEN_HERE",
});

// Chrome:
await puppeteer.connect({
  browserWSEndpoint:
    "wss://production-sfo.browserless.io/chrome/stealth?token=YOUR_API_TOKEN_HERE",
});

```

- Javascript
- Python
- Java
- C#

```codeBlockLines_p187
// Chromium
const chromiumBrowser = await playwright.chromium.connectOverCDP(
  "wss://production-sfo.browserless.io/chromium/stealth?token=YOUR_API_TOKEN_HERE"
);

// Chrome
const chromeBrowser = await playwright.chromium.connectOverCDP(
  "wss://production-sfo.browserless.io/chrome/stealth?token=YOUR_API_TOKEN_HERE"
);

```

```codeBlockLines_p187
import asyncio
from playwright.async_api import async_playwright

CHROMIUM_URL = "wss://production-sfo.browserless.io/chromium/stealth?token=YOUR_API_TOKEN_HERE"
CHROME_URL = "wss://production-sfo.browserless.io/chrome/stealth?token=YOUR_API_TOKEN_HERE"

async def main():
    async with async_playwright() as p:
        # Chromium
        chromium_browser = await p.chromium.connect_over_cdp(CHROMIUM_URL)

        # Chrome
        chrome_browser = await p.chromium.connect_over_cdp(CHROME_URL)

asyncio.run(main())

```

```codeBlockLines_p187
import com.microsoft.playwright.*;

public class PlaywrightConnectExample {
    public static void main(String[] args) {
        String CHROMIUM_URL = "wss://production-sfo.browserless.io/chromium/stealth?token=YOUR_API_TOKEN_HERE";
        String CHROME_URL = "wss://production-sfo.browserless.io/chrome/stealth?token=YOUR_API_TOKEN_HERE";

        try (Playwright playwright = Playwright.create()) {
            // Chromium
            Browser chromiumBrowser = playwright.chromium().connectOverCDP(CHROMIUM_URL);

            // Chrome
            Browser chromeBrowser = playwright.chromium().connectOverCDP(CHROME_URL);
        }
    }
}

```

```codeBlockLines_p187
using System;
using System.Threading.Tasks;
using Microsoft.Playwright;

class Program
{
    static async Task Main(string[] args)
    {
        string chromiumUrl = "wss://production-sfo.browserless.io/chromium/stealth?token=YOUR_API_TOKEN_HERE";
        string chromeUrl = "wss://production-sfo.browserless.io/chrome/stealth?token=YOUR_API_TOKEN_HERE";

        var playwright = await Playwright.CreateAsync();

        // Chromium
        var chromiumBrowser = await playwright.Chromium.ConnectOverCDPAsync(chromiumUrl);

        // Chrome
        var chromeBrowser = await playwright.Chromium.ConnectOverCDPAsync(chromeUrl);
    }
}

```

These routes incorporate many of the anti-detection mechanisms below, which you're free to try as well.

## Launch args to bypass bot detection [â€‹](https://docs.browserless.io/baas/avoid-bot-detection/stealth\#launch-args-to-bypass-bot-detection "Direct link to Launch args to bypass bot detection")

### Use the `headless` arg [â€‹](https://docs.browserless.io/baas/avoid-bot-detection/stealth\#use-the-headless-arg "Direct link to use-the-headless-arg")

Most bot detectors will check your user-agent, which by default explicitly claims you're running headless chrome. This is a dead giveaway. It can be changed by setting a specific user-agent but we highly recommend you use the &headless=false flag instead, which changes your user-agent to a more credible one.

- Puppeteer
- Playwright

```codeBlockLines_p187
import puppeteer from "puppeteer-core";

const launchArgs = JSON.stringify({ headless: false });
const browser = await puppeteer.connect({
  browserWSEndpoint: `wss://production-sfo.browserless.io/?token=YOUR_API_TOKEN_HERE&launch=${launchArgs}`,
});

//...

```

- Javascript
- Python
- Java
- C#

```codeBlockLines_p187
import { chromium } from "playwright-core";

const launchArgs = JSON.stringify({ headless: false });
const browser = await chromium.connectOverCDP(
  `wss://production-sfo.browserless.io/?token=YOUR_API_TOKEN_HERE&launch=${launchArgs}`
);

// ...

```

```codeBlockLines_p187
import asyncio
from playwright.async_api import async_playwright

LAUNCH_ARGS = '{"headless": false}'
WS_ENDPOINT = f"wss://production-sfo.browserless.io/?token=YOUR_API_TOKEN_HERE&launch={LAUNCH_ARGS}"

async def main():
    async with async_playwright() as p:
        browser = await p.chromium.connect_over_cdp(WS_ENDPOINT)

        # ...

asyncio.run(main())

```

```codeBlockLines_p187
import com.microsoft.playwright.*;

public class PlaywrightConnectExample {
    public static void main(String[] args) {
        String launchArgs = "{\"headless\": false}";
        String WS_ENDPOINT = "wss://production-sfo.browserless.io/?token=YOUR_API_TOKEN_HERE&launch=" + launchArgs;

        try (Playwright playwright = Playwright.create()) {
            Browser browser = playwright.chromium().connectOverCDP(WS_ENDPOINT);

            // ...

        }
    }
}

```

```codeBlockLines_p187
using System;
using System.Threading.Tasks;
using Microsoft.Playwright;

class Program
{
    static async Task Main(string[] args)
    {
        string launchArgs = "{\"headless\": false}";
        string wsEndpoint = $"wss://production-sfo.browserless.io/?token=YOUR_API_TOKEN_HERE&launch={launchArgs}";

        var playwright = await Playwright.CreateAsync();
        var browser = await playwright.Chromium.ConnectOverCDPAsync(wsEndpoint);

        // ...
    }
}

```

### Use the `stealth` arg [â€‹](https://docs.browserless.io/baas/avoid-bot-detection/stealth\#use-the-stealth-arg "Direct link to use-the-stealth-arg")

The stealth flag implements Puppeteer's puppeteer-extra-plugin-stealth plugin which applies various techniques to make detection of headless puppeteer harder. This flag may backfire and be easily detected by some sites, so consider avoiding it as well.

- Puppeteer
- Playwright

```codeBlockLines_p187
import puppeteer from "puppeteer-core";

const launchArgs = JSON.stringify({ stealth: true });
const browser = await puppeteer.connect({
  browserWSEndpoint: `wss://production-sfo.browserless.io/?token=YOUR_API_TOKEN_HERE&launch=${launchArgs}`,
});

//...

```

- Javascript
- Python
- Java
- C#

```codeBlockLines_p187
import { chromium } from "playwright-core";

const launchArgs = JSON.stringify({ stealth: true });
const browser = await chromium.connectOverCDP(
  `wss://production-sfo.browserless.io/?token=YOUR_API_TOKEN_HERE&launch=${launchArgs}`
);

// ...

```

```codeBlockLines_p187
import asyncio
from playwright.async_api import async_playwright

LAUNCH_ARGS = '{"stealth": true}'
WS_ENDPOINT = f"wss://production-sfo.browserless.io/?token=YOUR_API_TOKEN_HERE&launch={LAUNCH_ARGS}"

async def main():
    async with async_playwright() as p:
        browser = await p.chromium.connect_over_cdp(WS_ENDPOINT)

        # ...

asyncio.run(main())

```

```codeBlockLines_p187
import com.microsoft.playwright.*;

public class PlaywrightConnectExample {
    public static void main(String[] args) {
        String launchArgs = "{\"stealth\": true}";
        String WS_ENDPOINT = "wss://production-sfo.browserless.io/?token=YOUR_API_TOKEN_HERE&launch=" + launchArgs;

        try (Playwright playwright = Playwright.create()) {
            Browser browser = playwright.chromium().connectOverCDP(WS_ENDPOINT);

            // ...

        }
    }
}

```

```codeBlockLines_p187
using System;
using System.Threading.Tasks;
using Microsoft.Playwright;

class Program
{
    static async Task Main(string[] args)
    {
        string launchArgs = "{\"stealth\": true}";
        string wsEndpoint = $"wss://production-sfo.browserless.io/?token=YOUR_API_TOKEN_HERE&launch={launchArgs}";

        var playwright = await Playwright.CreateAsync();
        var browser = await playwright.Chromium.ConnectOverCDPAsync(wsEndpoint);

        // ...
    }
}

```

### Use a proxy [â€‹](https://docs.browserless.io/baas/avoid-bot-detection/stealth\#use-a-proxy "Direct link to Use a proxy")

Finally, the hardest sites to crack down check your IP address; there are two type of bocks that can occur, those based on type of IP, and those based on frequency of requests (rate-limits).

- Sites checking the type of IP address will detect your data-center IP addresses when using Browserless. To overcome this, using a proxy with residential IP addresses will be the best option.
- Sites that work the first few times and then stop working, are probably rate-limiting and it's not the residential part of it that blocks us. For these cases, you don't necessarily need a residential proxy and data-center IP addresses that rotate should be enough.

Browserless offers a residential proxy API that you can easily incorporate into your scripts.

- Puppeteer
- Playwright

```codeBlockLines_p187
import puppeteer from "puppeteer-core";

const browserWSEndpoint = "wss://production-sfo.browserless.io/content?token=YOUR_API_TOKEN_HERE&proxy=residential&proxyCountry=us&proxySticky";
const browser = await puppeteer.connect({ browserWSEndpoint });

//...

```

- Javascript
- Python
- Java
- C#

```codeBlockLines_p187
import { chromium } from "playwright-core";

const browserWSEndpoint = "wss://production-sfo.browserless.io/content?token=YOUR_API_TOKEN_HERE&proxy=residential&proxyCountry=us&proxySticky";
const browser = await chromium.connectOverCDP(browserWSEndpoint);

// ...

```

```codeBlockLines_p187
import asyncio
from playwright.async_api import async_playwright

WS_ENDPOINT = "wss://production-sfo.browserless.io/content?token=YOUR_API_TOKEN_HERE&proxy=residential&proxyCountry=us&proxySticky"

async def main():
    async with async_playwright() as p:
        browser = await p.chromium.connect_over_cdp(WS_ENDPOINT)

        # ...

asyncio.run(main())

```

```codeBlockLines_p187
import com.microsoft.playwright.*;

public class PlaywrightConnectExample {
    public static void main(String[] args) {
        String WS_ENDPOINT = "wss://production-sfo.browserless.io/content?token=YOUR_API_TOKEN_HERE&proxy=residential&proxyCountry=us&proxySticky";

        try (Playwright playwright = Playwright.create()) {
            Browser browser = playwright.chromium().connectOverCDP(WS_ENDPOINT);

            // ...

        }
    }
}

```

```codeBlockLines_p187
using System;
using System.Threading.Tasks;
using Microsoft.Playwright;

class Program
{
    static async Task Main(string[] args)
    {
        string wsEndpoint = "wss://production-sfo.browserless.io/content?token=YOUR_API_TOKEN_HERE&proxy=residential&proxyCountry=us&proxySticky";

        var playwright = await Playwright.CreateAsync();
        var browser = await playwright.Chromium.ConnectOverCDPAsync(wsEndpoint);

        // ...
    }
}

```

Utilizing proxies remains a crucial strategy in bypassing bot detection. Depending on the site's mechanism, you might need a proxy with residential IP addresses or a data-center IP that rotates. For more information about these topics, please check our documentation on [our built-in proxy](https://www.browserless.io/docs/proxying) and [third-party proxy](https://www.browserless.io/docs/using-a-proxy).

- [BrowserQL](https://docs.browserless.io/baas/avoid-bot-detection/stealth#browserql)
- [Additional strategies](https://docs.browserless.io/baas/avoid-bot-detection/stealth#additional-strategies)
- [Try out the Stealth routes](https://docs.browserless.io/baas/avoid-bot-detection/stealth#try-out-the-stealth-routes)
- [Launch args to bypass bot detection](https://docs.browserless.io/baas/avoid-bot-detection/stealth#launch-args-to-bypass-bot-detection)
  - [Use the `headless` arg](https://docs.browserless.io/baas/avoid-bot-detection/stealth#use-the-headless-arg)
  - [Use the `stealth` arg](https://docs.browserless.io/baas/avoid-bot-detection/stealth#use-the-stealth-arg)
  - [Use a proxy](https://docs.browserless.io/baas/avoid-bot-detection/stealth#use-a-proxy)

---

### How to use the Unblock API | Browserless.io
Original URL: https://docs.browserless.io/baas/avoid-bot-detection/unblocking

[Skip to main content](https://docs.browserless.io/baas/avoid-bot-detection/unblocking#__docusaurus_skipToContent_fallback)



note

Looking for full developer docs? [See them here](https://docs.browserless.io/open-api#tag/Browser-REST-APIs/paths/~1unblock%20~1chromium~1unblock/post).

When using a library like puppeteer or playwright, there's a lot of sites out there that can detect this library usage. These libraries leave traces of their existence behind in many ways (web workers, background pages, etc). With the `/unblock` API, Browserless takes a minimalistic approach into getting past bot blocks. It uses a variety of tools and strategies that we've seen work well in the past, and includes many adapters to get past more notorious mechanisms:

- We don't use any library for this API, and work directly with the browser's native remote interfaces.
- We launch and run the browser just like end-users.
- Detection of common bot blockers are listened for and corrected.
- Returns the underlying `browserWSEndpoint` to connect to, or just content and cookies.

This JSON API is flexible in how it operates. By setting all certain values to `false`, Browserless will optimize the execution of this request to only return fields you asked for, and not spend time producing the other fields.

Here's a list of common examples:

### Returning cookies only [â€‹](https://docs.browserless.io/baas/avoid-bot-detection/unblocking\#returning-cookies-only "Direct link to Returning cookies only")

```codeBlockLines_p187
{
    "url": "https://www.example.com/",
    "cookies": true,
    "content": false,
    "browserWSEndpoint": false,
    "screenshot": false,
    "ttl": 0
}

```

### Returning content only [â€‹](https://docs.browserless.io/baas/avoid-bot-detection/unblocking\#returning-content-only "Direct link to Returning content only")

```codeBlockLines_p187
{
    "url": "https://www.example.com/",
    "cookies": false,
    "content": true,
    "browserWSEndpoint": false,
    "screenshot": false,
    "ttl": 0
}

```

### Returning screenshots only [â€‹](https://docs.browserless.io/baas/avoid-bot-detection/unblocking\#returning-screenshots-only "Direct link to Returning screenshots only")

```codeBlockLines_p187
{
    "url": "https://www.example.com/",
    "cookies": false,
    "content": false,
    "browserWSEndpoint": false,
    "screenshot": true,
    "ttl": 0
}

```

### Full example with a library [â€‹](https://docs.browserless.io/baas/avoid-bot-detection/unblocking\#full-example-with-a-library "Direct link to Full example with a library")

This API is also intended to work with libraries that run on Chrome's Devtools Protocol (like puppeteer and certain APIs in playwright). What this means is you can unblock a site, then connect your library of choice to the browser and kick off your automation. It's a powerful way to work and keeps your code more focused on your needs, rather than trying to solve management-related tasks.

- Puppeteer
- Playwright

```codeBlockLines_p187
import puppeteer from 'puppeteer-core';

// The underlying site you wish automate
const url = 'https://www.example.com/';

// Your API token retrievable from the dashboard.
const token = 'YOUR_API_TOKEN_HERE';

// Set a threshold, in milliseconds, to unblock
const timeout = 5 * 60 * 1000;

// What proxy type (residential), or remove for none.
const proxy = 'residential';

// Where you want to proxy from (GB === Great Britain), or remove for none.
const proxyCountry = 'gb';

// If you want to use the same proxy IP for every network request
const proxySticky = true;

const queryParams = new URLSearchParams({
  timeout,
  proxy,
  proxyCountry,
  proxySticky,
  token,
}).toString();

const unblockURL =
  `https://production-sfo.browserless.io/chromium/unblock?${queryParams}`;

const options = {
  method: 'POST',
  headers: {
    'content-type': 'application/json'
  },
  body: JSON.stringify({
    url: url,
    browserWSEndpoint: true,
    cookies: true,
    content: true,
    screenshot: true,
    ttl: 5000,
  }),
};

try {
  console.log(`Unblocking ${url}`);

  const response = await fetch(unblockURL, options);

  if (!response.ok) {
    throw new Error(`Got non-ok response:\n` + (await response.text()));
  }

  const { browserWSEndpoint } = await response.json();

  console.log(`Got OK response! Connecting puppeteer to "${browserWSEndpoint}"...`);
  const browser = await puppeteer.connect({
    browserWSEndpoint: `${browserWSEndpoint}?${queryParams}`
  });
  // Find the page by inspecting the URL and matching it
  const pages = await browser.pages();
  const page = pages.find((p) => p.url().includes(url));
  page.on('response', (res) => {
    if (!res.ok) {
      console.log(`${res.status()}: ${res.url()}`);
    }
  });
  console.log('Reloading page with networkidle0...');
  await page.reload({
    waitUntil: 'networkidle0',
    timeout,
  });
  console.log('Taking page screenshot...');
  await page.screenshot({
    path: 'temp.png',
    fullPage: true,
  });
  console.log('Done!');
  await browser.close();
} catch (error) {
  console.error(error);
}

```

- Javascript
- Python
- Java
- C#

```codeBlockLines_p187
import playwright from 'playwright-core';

// The underlying site you wish automate
const url = 'https://www.example.com/';

// Your API token retrievable from the dashboard.
const token = 'YOUR_API_TOKEN_HERE';

// Set a threshold, in milliseconds, to unblock
const timeout = 5 * 60 * 1000;

// What proxy type (residential), or remove for none.
const proxy = 'residential';

// Where you want to proxy from (GB === Great Britain), or remove for none.
const proxyCountry = 'gb';

// If you want to use the same proxy IP for every network request
const proxySticky = true;

const queryParams = new URLSearchParams({
  timeout,
  proxy,
  proxyCountry,
  proxySticky,
  token,
}).toString();

const unblockURL =
  `https://production-sfo.browserless.io/chromium/unblock?${queryParams}`;

const options = {
  method: 'POST',
  headers: {
    'content-type': 'application/json'
  },
  body: JSON.stringify({
    url: url,
    browserWSEndpoint: true,
    cookies: true,
    content: true,
    screenshot: true,
    ttl: 5000,
  }),
};

try {
  console.log(`Unblocking ${url}`);

  const response = await fetch(unblockURL, options);

  if (!response.ok) {
    throw new Error(`Got non-ok response:\n` + (await response.text()));
  }

  const { browserWSEndpoint } = await response.json();

  console.log(`Got OK response! Connecting Playwright to "${browserWSEndpoint}"...`);
  const browser = await playwright.chromium.connectOverCDP({
    wsEndpoint: `${browserWSEndpoint}?${queryParams}`,
  });

  // Find the page by inspecting the URL and matching it
  const contexts = browser.contexts();
  const pages = contexts.flatMap((context) => context.pages());
  const page = pages.find((p) => p.url().includes(url));

  if (!page) {
    throw new Error(`Page with URL "${url}" not found.`);
  }

  page.on('response', (res) => {
    if (!res.ok()) {
      console.log(`${res.status()}: ${res.url()}`);
    }
  });

  console.log('Reloading page with networkidle...');
  await page.reload({
    waitUntil: 'networkidle',
    timeout,
  });

  console.log('Taking page screenshot...');
  await page.screenshot({
    path: 'temp.png',
    fullPage: true,
  });

  console.log('Done!');
  await browser.close();
} catch (error) {
  console.error(error);
}

```

```codeBlockLines_p187
import asyncio
from playwright.async_api import async_playwright
import requests

# The underlying site you wish automate
url = "https://www.example.com/"

# Your API token retrievable from the dashboard.
token = "YOUR_API_TOKEN_HERE"

# Set a threshold, in milliseconds, to unblock
timeout = 5 * 60 * 1000

# What proxy type (residential), or remove for none.
proxy = "residential"

# Where you want to proxy from (GB === Great Britain), or remove for none.
proxy_country = "gb"

# If you want to use the same proxy IP for every network request
proxy_sticky = True

# Build query parameters
query_params = {
    "timeout": timeout,
    "proxy": proxy,
    "proxyCountry": proxy_country,
    "proxySticky": proxy_sticky,
    "token": token,
}

unblock_url = "https://production-sfo.browserless.io/chromium/unblock"
options = {
    "url": url,
    "browserWSEndpoint": True,
    "cookies": True,
    "content": True,
    "screenshot": True,
    "ttl": 5000,
}

try:
    print(f"Unblocking {url}...")

    # Make the POST request
    response = requests.post(unblock_url, json=options, params=query_params)

    if response.status_code != 200:
        raise Exception(f"Non-OK response:\n{response.text}")

    response_data = response.json()
    browser_ws_endpoint = response_data.get("browserWSEndpoint")

    print(f'Got OK response! Connecting Playwright to "{browser_ws_endpoint}"...')

    async def main():
        async with async_playwright() as p:
            browser = await p.chromium.connect_over_cdp(browser_ws_endpoint)

            # Find the page by inspecting the URL and matching it
            contexts = browser.contexts
            pages = [page for context in contexts for page in context.pages]
            page = next((p for p in pages if url in p.url), None)

            if not page:
                raise Exception(f"Page with URL '{url}' not found.")

            page.on(
                "response",
                lambda res: print(f"{res.status}: {res.url}") if not res.ok else None,
            )

            print("Reloading page with networkidle...")
            await page.reload(wait_until="networkidle", timeout=timeout)

            print("Taking page screenshot...")
            await page.screenshot(path="temp.png", full_page=True)

            print("Done!")
            await browser.close()

    asyncio.run(main())

except Exception as e:
    print(e)

```

```codeBlockLines_p187
import com.microsoft.playwright.*;
import java.net.http.*;
import java.net.URI;
import java.net.http.HttpClient;
import java.util.Map;
import com.google.gson.Gson;

public class PlaywrightExample {
    private static final String TOKEN = "YOUR_BROWSERLESS_API_TOKEN";
    private static final String URL = "https://www.example.com/";
    private static final int TIMEOUT = 5 * 60 * 1000;
    private static final String PROXY = "residential";
    private static final String PROXY_COUNTRY = "gb";
    private static final boolean PROXY_STICKY = true;

    public static void main(String[] args) throws Exception {
        String unblockURL = "https://production-sfo.browserless.io/chromium/unblock";
        HttpClient client = HttpClient.newHttpClient();

        // Prepare query params
        String queryParams = String.format(
            "?timeout=%d&proxy=%s&proxyCountry=%s&proxySticky=%b&token=%s",
            TIMEOUT, PROXY, PROXY_COUNTRY, PROXY_STICKY, TOKEN
        );

        // Request payload
        Map<String, Object> payload = Map.of(
            "url", URL,
            "browserWSEndpoint", true,
            "cookies", true,
            "content", true,
            "screenshot", true,
            "ttl", 5000
        );

        HttpRequest request = HttpRequest.newBuilder()
            .uri(URI.create(unblockURL + queryParams))
            .header("Content-Type", "application/json")
            .POST(HttpRequest.BodyPublishers.ofString(new Gson().toJson(payload)))
            .build();

        System.out.println("Unblocking " + URL);
        HttpResponse<String> response = client.send(request, HttpResponse.BodyHandlers.ofString());

        if (response.statusCode() != 200) {
            throw new Exception("Error: " + response.body());
        }

        String browserWSEndpoint = new Gson().fromJson(response.body(), Map.class).get("browserWSEndpoint").toString();
        System.out.println("Connecting to Playwright...");

        try (Playwright playwright = Playwright.create()) {
            Browser browser = playwright.chromium().connectOverCDP(browserWSEndpoint);

            Page page = browser.contexts().get(0).pages().get(0);
            System.out.println("Reloading page...");
            page.reload(new Page.ReloadOptions().setWaitUntil(Page.LoadState.NETWORKIDLE).setTimeout(TIMEOUT));
            System.out.println("Taking screenshot...");
            page.screenshot(new Page.ScreenshotOptions().setPath("screenshot.png"));
        }

        System.out.println("Done!");
    }
}

```

```codeBlockLines_p187
using System;
using System.Net.Http;
using System.Text;
using System.Text.Json;
using System.Threading.Tasks;
using Microsoft.Playwright;

class Program
{
    static async Task Main(string[] args)
    {
        const string TOKEN = "YOUR_BROWSERLESS_API_TOKEN";
        const string URL = "https://www.example.com/";
        const int TIMEOUT = 5 * 60 * 1000;
        const string PROXY = "residential";
        const string PROXY_COUNTRY = "gb";
        const bool PROXY_STICKY = true;

        var unblockUrl = "https://production-sfo.browserless.io/chromium/unblock";
        using var httpClient = new HttpClient();

        var queryParams = $"?timeout={TIMEOUT}&proxy={PROXY}&proxyCountry={PROXY_COUNTRY}&proxySticky={PROXY_STICKY}&token={TOKEN}";
        var payload = new
        {
            url = URL,
            browserWSEndpoint = true,
            cookies = true,
            content = true,
            screenshot = true,
            ttl = 5000
        };

        var requestContent = new StringContent(JsonSerializer.Serialize(payload), Encoding.UTF8, "application/json");
        var response = await httpClient.PostAsync(unblockUrl + queryParams, requestContent);

        if (!response.IsSuccessStatusCode)
        {
            throw new Exception($"Error: {await response.Content.ReadAsStringAsync()}");
        }

        var responseData = JsonSerializer.Deserialize<Dictionary<string, object>>(await response.Content.ReadAsStringAsync());
        var browserWSEndpoint = responseData["browserWSEndpoint"].ToString();

        Console.WriteLine("Connecting to Playwright...");
        using var playwright = await Playwright.CreateAsync();
        var browser = await playwright.Chromium.ConnectOverCDPAsync(browserWSEndpoint);

        var context = browser.Contexts[0];
        var page = context.Pages[0];

        Console.WriteLine("Reloading page...");
        await page.ReloadAsync(new PageReloadOptions { WaitUntil = WaitUntilState.NetworkIdle, Timeout = TIMEOUT });

        Console.WriteLine("Taking screenshot...");
        await page.ScreenshotAsync(new PageScreenshotOptions { Path = "screenshot.png", FullPage = true });

        Console.WriteLine("Done!");
    }
}

```

With this powerful API you can get past a lot of common bot detection mechanisms and worry less about your automation.

- [Returning cookies only](https://docs.browserless.io/baas/avoid-bot-detection/unblocking#returning-cookies-only)
- [Returning content only](https://docs.browserless.io/baas/avoid-bot-detection/unblocking#returning-content-only)
- [Returning screenshots only](https://docs.browserless.io/baas/avoid-bot-detection/unblocking#returning-screenshots-only)
- [Full example with a library](https://docs.browserless.io/baas/avoid-bot-detection/unblocking#full-example-with-a-library)

---

### Setting a user agent | Browserless.io
Original URL: https://docs.browserless.io/baas/avoid-bot-detection/user-agent

[Skip to main content](https://docs.browserless.io/baas/avoid-bot-detection/user-agent#__docusaurus_skipToContent_fallback)



TheÂ User-AgentÂ request headerÂ is a characteristic string that lets servers and network peers identify the application, operating system, vendor, and/or version of the requesting user agent.

Many sites use this information to render the site differently for each user, and sometimes even for rudimentary bot detection. If you run chrome headless and want to take a screenshot of a page, it's a good idea to set a user agent so that web fonts load properly.

note

If you are having trouble getting past bot detectors, we would recommend trying [**BrowserQL**](https://docs.browserless.io/browserql/start).

## Using a Library [â€‹](https://docs.browserless.io/baas/avoid-bot-detection/user-agent\#using-a-library "Direct link to Using a Library")

You can set the user agent from code, in puppeteer and playwright it would be like this:

- Puppeteer
- Playwright

```codeBlockLines_p187
import puppeteer from "puppeteer";

const browser = await puppeteer.connect({
  browserWSEndpoint: `wss://production-sfo.browserless.io?token=YOUR_API_TOKEN_HERE`,
});
const page = await browser.newPage();
await page.setUserAgent(
  "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/84.0.4147.125 Safari/537.36"
);

```

- Javascript
- Python
- Java
- C#

```codeBlockLines_p187
import { chromium } from "playwright-core";

(async () => {
  const browser = await chromium.connectOverCDP(
    `wss://production-sfo.browserless.io?token=YOUR_API_TOKEN_HERE`
  );

  const context = browser.contexts()[0] || (await browser.newContext());
  const page = await context.newPage();

  // Set User-Agent
  await context.setDefaultUserAgent(
    "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/84.0.4147.125 Safari/537.36"
  );
})();

```

```codeBlockLines_p187
import asyncio
from playwright.async_api import async_playwright

async def main():
    async with async_playwright() as p:
        browser = await p.chromium.connect_over_cdp(
            "wss://production-sfo.browserless.io?token=YOUR_API_TOKEN_HERE"
        )

        context = browser.contexts[0] if browser.contexts else await browser.new_context()
        page = await context.new_page()

        # Set User-Agent
        await context.set_default_user_agent(
            "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/84.0.4147.125 Safari/537.36"
        )

asyncio.run(main())

```

```codeBlockLines_p187
import com.microsoft.playwright.*;

public class PlaywrightExample {
    public static void main(String[] args) {
        try (Playwright playwright = Playwright.create()) {
            Browser browser = playwright.chromium().connectOverCDP(
                "wss://production-sfo.browserless.io?token=YOUR_API_TOKEN_HERE"
            );

            BrowserContext context = browser.contexts().isEmpty()
                ? browser.newContext()
                : browser.contexts().get(0);

            // Set User-Agent
            context.setDefaultUserAgent(
                "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/84.0.4147.125 Safari/537.36"
            );
        }
    }
}

```

```codeBlockLines_p187
using System;
using System.Threading.Tasks;
using Microsoft.Playwright;

class Program
{
    static async Task Main(string[] args)
    {
        var playwright = await Playwright.CreateAsync();
        var browser = await playwright.Chromium.ConnectOverCDPAsync(
            "wss://production-sfo.browserless.io?token=YOUR_API_TOKEN_HERE"
        );

        var context = browser.Contexts.Count > 0
            ? browser.Contexts[0]
            : await browser.NewContextAsync();

        // Set User-Agent
        await context.SetDefaultUserAgentAsync(
            "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/84.0.4147.125 Safari/537.36"
        );
    }
}

```

## REST API [â€‹](https://docs.browserless.io/baas/avoid-bot-detection/user-agent\#rest-api "Direct link to REST API")

If you're using our APIs like /screenshot, /content, /pdf, or /scrape, you can also set the user agent in the body of your request.

```codeBlockLines_p187
// /content API
{
  "url": "https://example.com/",
  "userAgent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 14_3_1) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.3.1 Safari/605.1.15"
}

```

## As Launch Args [â€‹](https://docs.browserless.io/baas/avoid-bot-detection/user-agent\#as-launch-args "Direct link to As Launch Args")

If you're on a usage-based, cloud unit-based or capacity-based account, you can change the user agent as so:

- Puppeteer
- Playwright

```codeBlockLines_p187
import puppeteer from "puppeteer-core";

const launchArgs = JSON.stringify({
  args: [\
    `--user-agent=Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/100.0.4896.127 Safari/537.36`,\
  ],
});

const browser = await puppeteer.connect({
  browserWSEndpoint: `wss://production-sfo.browserless.io/?token=YOUR_API_TOKEN_HERE&launch=${launchArgs}`,
});

```

- Javascript
- Python
- Java
- C#

```codeBlockLines_p187
import { chromium } from "playwright-core";

(async () => {
  const launchArgs = JSON.stringify({
    args: [\
      `--user-agent=Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/100.0.4896.127 Safari/537.36`,\
    ],
  });

  const browser = await chromium.connectOverCDP(
    `wss://production-sfo.browserless.io/?token=YOUR_API_TOKEN_HERE&launch=${launchArgs}`
  );
})();

```

```codeBlockLines_p187
import asyncio
from playwright.async_api import async_playwright

async def main():
    launch_args = {
        "args": [\
            "--user-agent=Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/100.0.4896.127 Safari/537.36"\
        ]
    }

    async with async_playwright() as p:
        browser = await p.chromium.connect_over_cdp(
            f"wss://production-sfo.browserless.io/?token=YOUR_API_TOKEN_HERE&launch={launch_args}"
        )

asyncio.run(main())

```

```codeBlockLines_p187
import com.microsoft.playwright.*;

public class PlaywrightExample {
    public static void main(String[] args) {
        String launchArgs = "{\"args\": [\"--user-agent=Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/100.0.4896.127 Safari/537.36\"]}";

        try (Playwright playwright = Playwright.create()) {
            Browser browser = playwright.chromium().connectOverCDP(
                "wss://production-sfo.browserless.io/?token=YOUR_API_TOKEN_HERE&launch=" + launchArgs
            );
        }
    }
}

```

```codeBlockLines_p187
using System;
using System.Threading.Tasks;
using Microsoft.Playwright;

class Program
{
    static async Task Main(string[] args)
    {
        var launchArgs = new
        {
            args = new[]
            {
                "--user-agent=Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/100.0.4896.127 Safari/537.36"
            }
        };

        string wsEndpoint = $"wss://production-sfo.browserless.io/?token=YOUR_API_TOKEN_HERE&launch={System.Text.Json.JsonSerializer.Serialize(launchArgs)}";

        var playwright = await Playwright.CreateAsync();
        var browser = await playwright.Chromium.ConnectOverCDPAsync(wsEndpoint);
    }
}

```

- [Using a Library](https://docs.browserless.io/baas/avoid-bot-detection/user-agent#using-a-library)
- [REST API](https://docs.browserless.io/baas/avoid-bot-detection/user-agent#rest-api)
- [As Launch Args](https://docs.browserless.io/baas/avoid-bot-detection/user-agent#as-launch-args)

---

### Launch Options | Browserless.io
Original URL: https://docs.browserless.io/baas/chrome-flags

[Skip to main content](https://docs.browserless.io/baas/chrome-flags#__docusaurus_skipToContent_fallback)



## Using Launch Options [â€‹](https://docs.browserless.io/baas/chrome-flags\#using-launch-options "Direct link to Using Launch Options")

Browserless provides two main ways to configure launch options:

1. Through the `launch` parameter in the query string, which accepts a JSON object containing both Chrome flags and Browserless-specific options
2. Through individual query parameters for commonly used options

### Using the `launch` Parameter [â€‹](https://docs.browserless.io/baas/chrome-flags\#using-the-launch-parameter "Direct link to using-the-launch-parameter")

The `launch` parameter allows you to specify both Chrome flags and Browserless-specific options in a structured way. Here's how to use it:

- Puppeteer
- Playwright CDP
- Playwright Connect

```codeBlockLines_p187
import puppeteer from "puppeteer-core";

// Define launch options
const launchArgs = {
  headless: false,
  stealth: true,
  args: ['--window-size=1920,1080', '--force-color-profile=srgb']
};

// Create query parameters
const queryParams = new URLSearchParams({
  token: 'YOUR_API_TOKEN_HERE',
  proxy: 'residential',
  proxyCountry: 'us',
  timeout: '180000',
  launch: JSON.stringify(launchArgs)
});

const browser = await puppeteer.connect({
  browserWSEndpoint: `wss://production-sfo.browserless.io?${queryParams.toString()}`,
});

```

```codeBlockLines_p187
import playwright from "playwright";

// Define launch options
const launchArgs = {
  headless: false,
  stealth: true,
  args: ['--window-size=1920,1080', '--force-color-profile=srgb']
};

// Create query parameters
const queryParams = new URLSearchParams({
  token: 'YOUR_API_TOKEN_HERE',
  proxy: 'residential',
  proxyCountry: 'us',
  timeout: '180000',
  launch: JSON.stringify(launchArgs)
});

const browser = await playwright.chromium.connectOverCDP(
  `wss://production-sfo.browserless.io?${queryParams.toString()}`
);

```

```codeBlockLines_p187
import playwright from "playwright";

// Define launch options
const launchArgs = {
  headless: false,
  stealth: true,
  args: ['--window-size=1920,1080', '--force-color-profile=srgb']
};

// Create query parameters
const queryParams = new URLSearchParams({
  token: 'YOUR_API_TOKEN_HERE',
  proxy: 'residential',
  proxyCountry: 'us',
  timeout: '180000',
  launch: JSON.stringify(launchArgs)
});

const browser = await playwright.chromium.connect(
  `wss://production-sfo.browserless.io/chrome/playwright?${queryParams.toString()}`
);

```

### Available Chrome Args [â€‹](https://docs.browserless.io/baas/chrome-flags\#available-chrome-args "Direct link to Available Chrome Args")

All chrome flags are supported on Enterprise plans. The following chrome flags are available to all accounts:

- --disable-features,
- --disable-setuid-sandbox,
- --disable-site-isolation-trials,
- --disable-web-security,
- --enable-features,
- --font-render-hinting,
- --force-color-profile,
- --lang,
- --proxy-bypass-list,
- --proxy-server,
- --window-size,
- blockAds,
- humanlike,
- blockConsentModals,
- headless,
- ignoreDefaultArgs,
- ignoreHTTPSErrors,
- launch,
- record,
- slowMo,
- stealth,
- timeout,
- token,
- proxy,
- proxyCountry,
- proxySticky,

Browserless allows you to control how Chrome is launched through query-string parameters in your `puppeteer.connect`'s `browserWSEndpoint` URL or in your REST API calls. We allow you to set a `launch` query parameter as a way to specify Chrome launch options using a JSON object. This provides a clean, structured approach to setting up your browser environment, and it allows features like stealth mode, setting headful mode, and custom Chrome arguments.

## Launch Options (Query Parameters) [â€‹](https://docs.browserless.io/baas/chrome-flags\#launch-options-query-parameters "Direct link to Launch Options (Query Parameters)")

Below is a list of available launch options you can use in query strings for BaaS.

| Parameter | Description | Default |
| --- | --- | --- |
| headless | Runs the browser in headless mode. Set to false to enable headful mode (with a GUI). While the GUI isn't visible in cloud environments, headful mode may help bypass bot detection. Note: it uses more resources. | `true` |
| stealth | Enables stealth mode to reduce automation signals (similar to puppeteer-extraâ€™s stealth plugin). In BQL, stealth is always on by design and controlled via the humanlike option. In BaaS/REST, set to true to enable stealth techniques. | - `false` (for BaaS/REST)<br>- `true` (for BQL) |
| blockAds | Enables the built-in ad blocker (powered by uBlock Origin). Helps speed up scripts and reduce noise by blocking ads and trackers. Especially useful for scraping to avoid popups and clutter. | `false` |
| proxy | Routes browser traffic through a proxy. Options: proxy=residential for Browserlessâ€™s residential proxy pool; proxy=\`<your proxy URL>\` for your own proxy. Omit to use a direct connection. | none |
| proxyCountry | Used with proxy=residential to specify the exit nodeâ€™s country. Accepts ISO 3166 country codes (e.g., us, gb, de). If omitted, a random location is chosen. | none |
| proxySticky | Used with proxy=residential to maintain the same proxy IP across a session (when possible). Useful for sites that expect consistent IP usage. | `false` |
| timeout | Maximum session duration in milliseconds. The session will automatically close after this time to prevent overuse. | 60000 |

### Launching with Proxies [â€‹](https://docs.browserless.io/baas/chrome-flags\#launching-with-proxies "Direct link to Launching with Proxies")

While you can always use your own proxy service, we highly recommend using our built-in and first-party residential proxies. See our [Proxies documentation](https://docs.browserless.io/baas/proxies) for detailed information on both our built-in residential proxy and how to use third-party proxies.

- Puppeteer
- Playwright

```codeBlockLines_p187
import puppeteer from "puppeteer-core";

const browser = await puppeteer.connect({
  browserWSEndpoint: `wss://production-sfo.browserless.io/chromium?token=YOUR_API_TOKEN_HERE&proxy=residential&proxyCountry=us`,
});
// ...

```

```codeBlockLines_p187
import playwright from "playwright";

const browser = await playwright.chromium.connectOverCDP(
  `wss://production-sfo.browserless.io/chromium?token=YOUR_API_TOKEN_HERE&proxy=residential&proxyCountry=us`
);

```

### Blocking ads [â€‹](https://docs.browserless.io/baas/chrome-flags\#blocking-ads "Direct link to Blocking ads")

You can use our built-in ad-blocker for both `puppeteer.connect()` and REST API calls. You'll simply need to add a query-string parameter of `blockAds=true` to your URL when connecting:

- Puppeteer
- Playwright

```codeBlockLines_p187
import puppeteer from "puppeteer-core";

const browser = await puppeteer.connect({
  browserWSEndpoint: `wss://production-sfo.browserless.io/chromium?token=YOUR_API_TOKEN_HERE&blockAds=true`,
});
// ...

```

```codeBlockLines_p187
import playwright from "playwright";

const browser = await playwright.chromium.connectOverCDP(
  `wss://production-sfo.browserless.io/chromium?token=YOUR_API_TOKEN_HERE&blockAds=true`
);

```

Under the hood, Browserless uses UBlock Origin to block ads and filter content.

## Time to Live (TTL) [â€‹](https://docs.browserless.io/baas/chrome-flags\#time-to-live-ttl "Direct link to Time to Live (TTL)")

Use the `ttl` key in your `launch` parameter to keep the browser instance alive for a specified duration, which allows for reconnections during this period.

- Puppeteer
- Playwright

```codeBlockLines_p187
import puppeteer from "puppeteer-core";

const browser = await puppeteer.connect({
  browserWSEndpoint: `wss://production-sfo.browserless.io/?token=YOUR_API_KEY&ttl=30000`,
});
// ...

```

```codeBlockLines_p187
import playwright from "playwright";

const browser = await playwright.chromium.connectOverCDP(
  `wss://production-sfo.browserless.io/?token=YOUR_API_KEY&ttl=30000`
);

```

## Dynamic Launch Arguments [â€‹](https://docs.browserless.io/baas/chrome-flags\#dynamic-launch-arguments "Direct link to Dynamic Launch Arguments")

You can pass dynamic launch arguments to Chrome by sending a JSON object and including it in the `launch` query parameter. This object can contain any Chrome launch arguments supported by Puppeteer and Browserless' launch options.

### Overriding the session timer [â€‹](https://docs.browserless.io/baas/chrome-flags\#overriding-the-session-timer "Direct link to Overriding the session timer")

By default, your sessions are governed by a timeout. This is set via your account page for the hosted service. You can override this behavior.

- If you are running `BaaS` in Docker, you can specify a `TIMEOUT` environment variable in the `docker run` command to override the default timeout of 30 seconds.

- If you need to override the timeout on a per-job basis, simply specify a `timeout` parameter in your connect calls query-parameters, with the value being the time in milliseconds for the session to execute:



- Puppeteer
- Playwright

```codeBlockLines_p187
import puppeteer from "puppeteer-core";

const browser = await puppeteer.connect({
  browserWSEndpoint: `wss://production-sfo.browserless.io/?token=YOUR_API_TOKEN_HERE&timeout=10000`,
});
// ...

```

```codeBlockLines_p187
import playwright from "playwright";

const browser = await playwright.chromium.connectOverCDP(
  `wss://production-sfo.browserless.io/?token=YOUR_API_TOKEN_HERE&timeout=10000`
);

```

note

For other runtimes and selenium libraries be sure to consult your libraries documentation, or [contact us](https://www.browserless.io/contact)

### Stealth Mode [â€‹](https://docs.browserless.io/baas/chrome-flags\#stealth-mode "Direct link to Stealth Mode")

You can use stealth mode to reduce bot-detection from blocking your scripts.

- Puppeteer
- Playwright

```codeBlockLines_p187
import puppeteer from "puppeteer-core";

const launchArgs = JSON.stringify({ stealth: true });
const browser = await puppeteer.connect({
  browserWSEndpoint: `wss://production-sfo.browserless.io/?token=YOUR_API_TOKEN_HERE&launch=${launchArgs}`,
});
// ...

```

```codeBlockLines_p187
import playwright from "playwright";

const launchArgs = JSON.stringify({ stealth: true });
const browser = await playwright.chromium.connectOverCDP(
  `wss://production-sfo.browserless.io/?token=YOUR_API_TOKEN_HERE&launch=${launchArgs}`
);

```

Bot Detection

If stealth mode flags aren't enough to avoid bot detection, we recommend using [**BrowserQL**](https://docs.browserless.io/browserql/start).

### Headful mode [â€‹](https://docs.browserless.io/baas/chrome-flags\#headful-mode "Direct link to Headful mode")

You can set the browser's headless mode using the `headless` query parameter. Running the browser in headful mode will launch the browser using the OS' GUI, in contrast to headless mode. This can be helphul to avoid more sophisticated bot-detection methods that rely on screen or rendering pattern detection.

- Puppeteer
- Playwright

```codeBlockLines_p187
import puppeteer from "puppeteer-core";

const launchArgs = JSON.stringify({ headless: false });
const browser = await puppeteer.connect({
  browserWSEndpoint: `wss://production-sfo.browserless.io/?token=YOUR_API_TOKEN_HERE&launch=${launchArgs}`,
});
// ...

```

```codeBlockLines_p187
import playwright from "playwright";

const launchArgs = JSON.stringify({ headless: false });
const browser = await playwright.chromium.connectOverCDP(
  `wss://production-sfo.browserless.io/?token=YOUR_API_TOKEN_HERE&launch=${launchArgs}`
);

```

### Chrome launch arguments [â€‹](https://docs.browserless.io/baas/chrome-flags\#chrome-launch-arguments "Direct link to Chrome launch arguments")

In adition to the launch options Browserless offers, you can also use some of the [Chrome launch flags](https://peter.sh/experiments/chromium-command-line-switches/) inside the `args` array of the `launch` object.

- Puppeteer
- Playwright

```codeBlockLines_p187
import puppeteer from "puppeteer-core";

const launchArgs = JSON.stringify({
  args: ["--window-size=1920,1080", "--lang=en-US"],
});
const browser = await puppeteer.connect({
  browserWSEndpoint: `wss://production-sfo.browserless.io/?token=YOUR_API_TOKEN_HERE&launch=${launchArgs}`,
});
// ...

```

```codeBlockLines_p187
import playwright from "playwright";

const launchArgs = JSON.stringify({
  args: ["--window-size=1920,1080", "--lang=en-US"],
});
const browser = await playwright.chromium.connectOverCDP(
  `wss://production-sfo.browserless.io/?token=YOUR_API_TOKEN_HERE&launch=${launchArgs}`
);

```

### Caching with `user-data-dir` [â€‹](https://docs.browserless.io/baas/chrome-flags\#caching-with-user-data-dir "Direct link to caching-with-user-data-dir")

warning

Setting a `user-data-dir` is only available for Dedicated and self-hosted accounts (not on usage-based or cloud unit-based)

You can launch Chrome and specify a "user-data-dir" on each request to cache and make future sessions faster:

- Puppeteer
- Playwright

```codeBlockLines_p187
import puppeteer from "puppeteer-core";

const launchArgs = JSON.stringify({
  args: ["--user-data-dir=~/browserless-cache-123"],
});
const browser = await puppeteer.connect({
  browserWSEndpoint: `wss://production-sfo.browserless.io/?token=YOUR_API_TOKEN_HERE&launch=${launchArgs}`,
});
// ...

```

```codeBlockLines_p187
import playwright from "playwright";

const launchArgs = JSON.stringify({
  args: ["--user-data-dir=~/browserless-cache-123"],
});
const browser = await playwright.chromium.connectOverCDP(
  `wss://production-sfo.browserless.io/?token=YOUR_API_TOKEN_HERE&launch=${launchArgs}`
);

```

This can be used in conjuction with all our API's and integrations.

### Ignoring default flags [â€‹](https://docs.browserless.io/baas/chrome-flags\#ignoring-default-flags "Direct link to Ignoring default flags")

By default Puppeteer specifies a certain number of launch flags in order to provide the best experience. In order to turn these off you'll want to tell Browserless to ignore them.

danger

Be careful ignoring these args as it might cause chromium to become unstable or refuse to launch.

- Puppeteer
- Playwright

```codeBlockLines_p187
import puppeteer from "puppeteer-core";

const launchArgs = JSON.stringify({
  args: ["--hide-scrollbars", "--disable-default-apps"],
});
const browser = await puppeteer.connect({
  browserWSEndpoint: `wss://production-sfo.browserless.io/?token=YOUR_API_TOKEN_HERE&launch=${launchArgs}`,
});
// ...

```

```codeBlockLines_p187
import playwright from "playwright";

const launchArgs = JSON.stringify({
  args: ["--hide-scrollbars", "--disable-default-apps"],
});
const browser = await playwright.chromium.connectOverCDP(
  `wss://production-sfo.browserless.io/?token=YOUR_API_TOKEN_HERE&launch=${launchArgs}`
);

```

### Overriding Puppeteer's launch args [â€‹](https://docs.browserless.io/baas/chrome-flags\#overriding-puppeteers-launch-args "Direct link to Overriding Puppeteer's launch args")

Since `puppeteer.connect` differs greatly from `puppeteer.launch`, Browserless allows to override Puppeteer's default launch arguments. These are specified through query-string parameters, and can be applied like so:

### Ignore HTTPS Errors [â€‹](https://docs.browserless.io/baas/chrome-flags\#ignore-https-errors "Direct link to Ignore HTTPS Errors")

```codeBlockLines_p187
// Via puppeteer.launch()
puppeteer.launch({
  ignoreHTTPSErrors: true,
});

// Via puppeteer.connect()
puppeteer.connect({
  browserWSEndpoint: "wss://production-sfo.browserless.io?token=YOUR_API_TOKEN_HERE",
  ignoreHTTPSErrors: true,
});

```

### Slow Mo [â€‹](https://docs.browserless.io/baas/chrome-flags\#slow-mo "Direct link to Slow Mo")

```codeBlockLines_p187
// Via puppeteer.launch()
puppeteer.launch({
  slowMo: 1000,
});

// Via puppeteer.connect()
puppeteer.connect({
  browserWSEndpoint: "wss://production-sfo.browserless.io?token=YOUR_API_TOKEN_HERE",
  slowMo: 1000,
});

```

### Ignore default args [â€‹](https://docs.browserless.io/baas/chrome-flags\#ignore-default-args "Direct link to Ignore default args")

```codeBlockLines_p187
// Via puppeteer.launch()
puppeteer.launch({
  ignoreDefaultArgs: true,
});

// Via puppeteer.connect()
puppeteer.connect({
  browserWSEndpoint:
    "wss://production-sfo.browserless.io?token=YOUR_API_TOKEN_HERE&ignoreDefaultArgs=true",
});

```

- [Using Launch Options](https://docs.browserless.io/baas/chrome-flags#using-launch-options)
  - [Using the `launch` Parameter](https://docs.browserless.io/baas/chrome-flags#using-the-launch-parameter)
  - [Available Chrome Args](https://docs.browserless.io/baas/chrome-flags#available-chrome-args)
- [Launch Options (Query Parameters)](https://docs.browserless.io/baas/chrome-flags#launch-options-query-parameters)
  - [Launching with Proxies](https://docs.browserless.io/baas/chrome-flags#launching-with-proxies)
  - [Blocking ads](https://docs.browserless.io/baas/chrome-flags#blocking-ads)
- [Time to Live (TTL)](https://docs.browserless.io/baas/chrome-flags#time-to-live-ttl)
- [Dynamic Launch Arguments](https://docs.browserless.io/baas/chrome-flags#dynamic-launch-arguments)
  - [Overriding the session timer](https://docs.browserless.io/baas/chrome-flags#overriding-the-session-timer)
  - [Stealth Mode](https://docs.browserless.io/baas/chrome-flags#stealth-mode)
  - [Headful mode](https://docs.browserless.io/baas/chrome-flags#headful-mode)
  - [Chrome launch arguments](https://docs.browserless.io/baas/chrome-flags#chrome-launch-arguments)
  - [Caching with `user-data-dir`](https://docs.browserless.io/baas/chrome-flags#caching-with-user-data-dir)
  - [Ignoring default flags](https://docs.browserless.io/baas/chrome-flags#ignoring-default-flags)
  - [Overriding Puppeteer's launch args](https://docs.browserless.io/baas/chrome-flags#overriding-puppeteers-launch-args)
  - [Ignore HTTPS Errors](https://docs.browserless.io/baas/chrome-flags#ignore-https-errors)
  - [Slow Mo](https://docs.browserless.io/baas/chrome-flags#slow-mo)
  - [Ignore default args](https://docs.browserless.io/baas/chrome-flags#ignore-default-args)

---

### Connection URLs and Endpoints | Browserless.io
Original URL: https://docs.browserless.io/baas/connection-urls

[Skip to main content](https://docs.browserless.io/baas/connection-urls#__docusaurus_skipToContent_fallback)



This page explains all the connection URLs and endpoints available for **BaaS**, including how to authenticate with your API token, choose the optimal regional base URL, and connect using WebSocket or HTTP. Whether you're using Puppeteer or Playwright, this guide provides everything you need to connect and automate effectively.

## Base URL and Regions [â€‹](https://docs.browserless.io/baas/connection-urls\#base-url-and-regions "Direct link to Base URL and Regions")

Browserless has multiple regional base URLs:

- `https://production-sfo.browserless.io` (US West)
- `https://production-lon.browserless.io` (Europe UK)
- `https://production-ams.browserless.io` (Europe Amsterdam)

For WebSocket connections, simply replace `https://` with `wss://` for the same host. For
example:

- WebSocket (Puppeteer/Playwright): `wss://production-sfo.browserless.io/...`
- HTTP REST API call: `https://production-sfo.browserless.io/...`

Choose the region closest to you to reduce latency (see [Load Balancers](https://docs.browserless.io/baas/load-balancers)). All require the token query parameter.

## Using Your API Token in URLs [â€‹](https://docs.browserless.io/baas/connection-urls\#using-your-api-token-in-urls "Direct link to Using Your API Token in URLs")

Add your API token to the URL query string as `?token=YOUR_TOKEN`. Required for authentication (see [BaaS Connection URL Builder](https://docs.browserless.io/baas/connection-urls)). Invalid tokens result in HTTP 401/403 errors. Keep this URL secure and never expose it in client-side code or logs.

Example:
`wss://production-sfo.browserless.io/chrome?token=094632bb-e326-4c63-b953-82b55700b14c` is a basic connection string for a new Chrome session on the SFO cluster using the given token.

Below you can select your preferences of region, library, stealth mode and browser to define your URL:

### BaaS Connection URL Builder

Service Type:

BaaS v2

Library:

PuppeteerPlaywright

Browser:

ChromiumChrome

Stealth Mode:

DisabledEnabled

Region:

US WestEurope UKEurope Amsterdam

API Token:

#### Connection URL:

Copy

```
wss://production-sfo.browserless.io/?token=YOUR_TOKEN
```

#### Code Snippet:

Copy

```
const browser = await puppeteer.connect({
  browserWSEndpoint: 'wss://production-sfo.browserless.io/?token=YOUR_TOKEN',
});
```

## BaaS v2 (Puppeteer/Playwright) Connection URLs [â€‹](https://docs.browserless.io/baas/connection-urls\#baas-v2-puppeteerplaywright-connection-urls "Direct link to BaaS v2 (Puppeteer/Playwright) Connection URLs")

To connect an automation library to Browserless, use a WebSocket URL ( `wss://`). The
WebSocket endpoint tells Browserless to launch a browser for you and gives you control over it.
The format can vary slightly depending on the browser and library:

- **Puppeteer (Chrome/Chromium)**: Use the base WebSocket URL with your token.
Example: `wss://production-sfo.browserless.io?token=YOUR_TOKEN`. This
will launch a Chromium instance on Browserless. Puppeteer's browserWSEndpoint
should be set to this URL (see [How it Works](https://docs.browserless.io/baas/start)).



note





By default, this gives you a Chromium browser. Browserless treats Chrome/Chromium essentially the same; you can explicitly request Chrome by using `/chrome` in the path, but on the cloud service the default is a headless Chromium build with necessary features.

- **Playwright (Chromium via CDP)**: Playwright can connect over Chrome DevTools
Protocol (CDP) similarly to Puppeteer. You would use
`playwright.chromium.connect_over_cdp("wss://production-sfo.browserless.io?token=YOUR_TOKEN")`. This is effectively the same as Puppeteer's
approach and will give you a Chromium browser (see [Launch Options](https://docs.browserless.io/baas/chrome-flags)).

- **Playwright (Firefox)**: To use Firefox (since Playwright supports Firefox via its own
protocol), you must include the browser in the path and specify that you want the
Playwright protocol. Browserless uses a convention: `/<browser>/playwright` in the
URL for Playwright connections. So for Firefox:
`wss://production-sfo.browserless.io/firefox/playwright?token=YOUR_TOKEN` (see [How it Works](https://docs.browserless.io/baas/start)).

- **Playwright (WebKit)**:
`wss://production-sfo.browserless.io/webkit/playwright?token=YOUR_TOKEN` â€“ spawns a WebKit browser (usually for Safari automation needs). WebKit
support is available in Browserless v2 for Playwright connections.

- **Selecting Chrome vs Chromium**: If you specifically need Chrome (the branded Google
Chrome, which might have minor differences or supports Widevine, etc.), you can use
the path `/chrome` in the URL. For example:
`wss://production-sfo.browserless.io/chrome?token=YOUR_TOKEN`. By
default, `/` or `/chromium` point to the latest Chromium. In practice, most use cases don't
require distinguishing, but the option exists.


### Summary of WebSocket URL formats [â€‹](https://docs.browserless.io/baas/connection-urls\#summary-of-websocket-url-formats "Direct link to Summary of WebSocket URL formats")

The following are URL formats for each browser available:

- **Chromium (Puppeteer or CDP)**:
`wss://production-<region>.browserless.io/?token=YOUR_TOKEN`
- **Chromium (Playwright server mode)**:
`wss://production-<region>.browserless.io/chromium/playwright?token=YOUR_TOKEN`
- **Chrome (explicit)**:
`wss://production-<region>.browserless.io/chrome?token=YOUR_TOKEN`
- **Firefox (Playwright)**:
`wss://production-<region>.browserless.io/firefox/playwright?token=YOUR_TOKEN`
- **WebKit (Playwright)**:
`wss://production-<region>.browserless.io/webkit/playwright?token=YOUR_TOKEN`

- [Base URL and Regions](https://docs.browserless.io/baas/connection-urls#base-url-and-regions)
- [Using Your API Token in URLs](https://docs.browserless.io/baas/connection-urls#using-your-api-token-in-urls)
- [BaaS v2 (Puppeteer/Playwright) Connection URLs](https://docs.browserless.io/baas/connection-urls#baas-v2-puppeteerplaywright-connection-urls)
  - [Summary of WebSocket URL formats](https://docs.browserless.io/baas/connection-urls#summary-of-websocket-url-formats)

---

### Connecting Playwright | Browserless.io
Original URL: https://docs.browserless.io/baas/connect-playwright

[Skip to main content](https://docs.browserless.io/baas/connect-playwright#__docusaurus_skipToContent_fallback)



We support all Playwright protocols, and, just like with Puppeteer, you can easily switch to Browserless. The standard connect method uses playwright's built-in browser-server to handle the connection. This, generally, is a faster and more fully-featured method since it supports most of the playwright parameters (such as using a proxy and more).

- Javascript
- Python
- Java
- C#

```codeBlockLines_p187
import playwright from "playwright";

// Connecting to Firefox locally
const browser = await playwright.firefox.launch();

// Connecting to Firefox via Browserless and using a proxy
const browser = await playwright.firefox.connect(`wss://production-sfo.browserless.io/firefox/playwright?token=${TOKEN}&proxy=residential`);

```

```codeBlockLines_p187
from playwright.sync_api import sync_playwright

# Connecting to Firefox locally
with sync_playwright() as p:
    browser = p.firefox.launch()

# Connecting to Firefox via Browserless with a proxy
with sync_playwright() as p:
    browser = p.firefox.connect_over_cdp(f"wss://production-sfo.browserless.io/firefox/playwright?token={TOKEN}&proxy=residential")

```

```codeBlockLines_p187
package org.example;

import com.microsoft.playwright.*;
import java.nio.file.Paths;

public class Main {
  public static void main(String[] args) {
    // Connecting to Firefox locally
    Browser browserLocal = playwright.firefox().launch();

    // Connecting to Firefox via Browserless and using a proxy
    String wsEndpoint = String.format(
      "wss://production-sfo.browserless.io/firefox/playwright?token=%s&proxy=residential",
      TOKEN
    );
    BrowserType.ConnectOptions connectOptions = new BrowserType.ConnectOptions();
    connectOptions.setWsEndpoint(wsEndpoint);
  }
}

```

```codeBlockLines_p187
using System;
using System.Threading.Tasks;
using Microsoft.Playwright;

namespace PlaywrightExample
{
    class Program
    {
        public static async Task Main(string[] args)
        {
            // Connecting to Firefox locally
            using var playwright = await Playwright.CreateAsync();
            var browserLocal = await playwright.Firefox.LaunchAsync();

            // Connecting to Firefox via Browserless and using a proxy
            using var playwright = await Playwright.CreateAsync();
            string wsEndpoint = $"wss://production-sfo.browserless.io/firefox/playwright?token={TOKEN}&proxy=residential";
            var browserRemote = await playwright.Firefox.ConnectAsync(wsEndpoint);
        }
    }
}

```

## More Playwright Details [â€‹](https://docs.browserless.io/baas/connect-playwright\#more-playwright-details "Direct link to More Playwright Details")

Playwright is a cross-browser library written by Microsoft to aide in cross-browser testing and development.

**Warning**: To avoid errors with no apparent reason, please make sure your playwright version is compatible with one of these [versions.](https://docs.browserless.io/baas/versions)

### Using the Playwright Protocol [â€‹](https://docs.browserless.io/baas/connect-playwright\#using-the-playwright-protocol "Direct link to Using the Playwright Protocol")

The standard `connect` method uses Playwright's built-in browser-server protocol to handle the connection. This, generally, is a faster and more fully-featured method since it supports most of the Playwright parameters (such as using a proxy and more). However, since this requires the usage of Playwright in our servers, **your client's Playwright version should match ours**.

#### Take a screenshot in Playwright with Firefox [â€‹](https://docs.browserless.io/baas/connect-playwright\#take-a-screenshot-in-playwright-with-firefox "Direct link to Take a screenshot in Playwright with Firefox")

```codeBlockLines_p187
import playwright from "playwright-core";

const pwEndpoint = `wss://production-sfo.browserless.io/firefox/playwright?token=YOUR_API_TOKEN_HERE`;
const browser = await playwright.firefox.connect(pwEndpoint);
const context = await browser.newContext();
const page = await context.newPage();

await page.goto("https://www.whatsmybrowser.org/", { waitUntil: "domcontentloaded" });
await page.screenshot({
  path: `firefox.png`,
});

await browser.close();

```

Similarly, if you need to use another browser, just make sure the Playwright Browser object matches the endpoint.

### Using the Chrome DevTools Protocol [â€‹](https://docs.browserless.io/baas/connect-playwright\#using-the-chrome-devtools-protocol "Direct link to Using the Chrome DevTools Protocol")

The `connectOverCDP` method allows Playwright to connect through Chrome's DevTools Protocol. While this is more functionally similar to how `puppeteer` operates, it does come with a slight performance hit since sessions are more "chatty" over the network versus Playwright's `connect`. Furthermore, **you can only use the Chrome for these connections**.

#### Take a screenshot in Playwright [â€‹](https://docs.browserless.io/baas/connect-playwright\#take-a-screenshot-in-playwright "Direct link to Take a screenshot in Playwright")

```codeBlockLines_p187
import playwright from "playwright";

const browser = await playwright.chromium.connectOverCDP(
  "wss://production-sfo.browserless.io?token=YOUR_API_TOKEN_HERE"
);
const context = await browser.newContext();
const page = await context.newPage();

await page.goto("https://www.example.com/");
await page.screenshot({ path: "cdp.png" });

await browser.close();

```

### Using 3rd Party Proxies with Playwright [â€‹](https://docs.browserless.io/baas/connect-playwright\#using-3rd-party-proxies-with-playwright "Direct link to Using 3rd Party Proxies with Playwright")

When using Playwright with browserless, you can set up a 3rd party proxy by providing proxy configuration to the `newContext()` method. This is different from how proxies are handled in Puppeteer, as Playwright allows you to specify proxy settings directly at the context level:

```codeBlockLines_p187
import playwright from "playwright-core";

const browser = await playwright.chromium.connectOverCDP(
  "wss://production-sfo.browserless.io?token=YOUR_API_TOKEN_HERE"
);
const context = await browser.newContext({
  proxy: {
    server: "http://domain:port",
    username: "username",
    password: "password",
  },
});
const page = await context.newPage();

await page.goto("https://icanhazip.com/");
console.log(await page.content());

await browser.close();

```

This approach applies the proxy configuration at the context level, which means all pages created from that context will use the specified proxy. For more detailed information about using proxies with Playwright, see our [Proxies](https://docs.browserless.io/baas/proxies) documentation.

- [More Playwright Details](https://docs.browserless.io/baas/connect-playwright#more-playwright-details)
  - [Using the Playwright Protocol](https://docs.browserless.io/baas/connect-playwright#using-the-playwright-protocol)
  - [Using the Chrome DevTools Protocol](https://docs.browserless.io/baas/connect-playwright#using-the-chrome-devtools-protocol)
  - [Using 3rd Party Proxies with Playwright](https://docs.browserless.io/baas/connect-playwright#using-3rd-party-proxies-with-playwright)

---

### Connecting Puppeteer | Browserless.io
Original URL: https://docs.browserless.io/baas/connect-puppeteer

[Skip to main content](https://docs.browserless.io/baas/connect-puppeteer#__docusaurus_skipToContent_fallback)



Libraries like puppeteer and chrome-remote-interface can hook into an existing Chrome instance by websocket. The hosted Browserless service only supports this type of interface since you can pass in tokens and other query-params. Typically you only need to replace how you start Chrome with a connect-like statement:

```codeBlockLines_p187
import puppeteer from "puppeteer-core";

// Connecting to Chrome locally
const browser = await puppeteer.launch();

// Connecting to Browserless and using a proxy
const browser = await puppeteer.connect({
  browserWSEndpoint: `wss://production-sfo.browserless.io/?token=${TOKEN}&proxy=residential`,
});

```

## More Puppeteer Details [â€‹](https://docs.browserless.io/baas/connect-puppeteer\#more-puppeteer-details "Direct link to More Puppeteer Details")

Puppeteer is well-supported by Browserless, and is easy to upgrade an existing service or app to use it.

### Basic Usage [â€‹](https://docs.browserless.io/baas/connect-puppeteer\#basic-usage "Direct link to Basic Usage")

In order to use the Browserless service, simply change the following:

#### Before browserless [â€‹](https://docs.browserless.io/baas/connect-puppeteer\#before-browserless "Direct link to Before browserless")

```codeBlockLines_p187
import puppeteer from "puppeteer";

const browser = await puppeteer.launch();
const page = await browser.newPage();
// ...

```

#### After browserless [â€‹](https://docs.browserless.io/baas/connect-puppeteer\#after-browserless "Direct link to After browserless")

```codeBlockLines_p187
import puppeteer from "puppeteer";

const browser = await puppeteer.connect({
  browserWSEndpoint: `wss://production-sfo.browserless.io?token=YOUR_API_TOKEN_HERE`,
});
const page = await browser.newPage();

```

If you're running the docker container to replace the location of `wss://production-sfo.browserless.io/` to wherever your container is running.

### Code Snippet [â€‹](https://docs.browserless.io/baas/connect-puppeteer\#code-snippet "Direct link to Code Snippet")

Below is a copy-paste example (remember to replace the API key for yours!) that should be a great starting point since it shows how to use puppeteer's methods with basic exception handling and file saving:

```codeBlockLines_p187
import puppeteer from "puppeteer-core";
import fs from "fs";

async function main() {
  let browser = null;

  try {
    const url = "https://www.example.com";
    const token = "YOUR_API_TOKEN_HERE";
    const launchArgs = JSON.stringify({
      args: [`--window-size=1920,1080`],
      headless: false,
      stealth: true,
      timeout: 30000
    });

    console.log("Connecting to browser...");
    browser = await puppeteer.connect({
      browserWSEndpoint: `wss://production-sfo.browserless.io/?token=${token}&launch=${launchArgs}`,
    });

    console.log("Creating new page...");
    const page = await browser.newPage();

    page.setViewport({ width: 1920, height: 1080 }) //it's best to use this in addition to --window-size
    await page.setUserAgent('My Custom User Agent/1.0');
    console.log(`User agent: ${await page.evaluate(() => navigator.userAgent)}`);
    console.log(`Viewport size: ${JSON.stringify(await page.viewport())}`);
    console.log("Navigating to example.com...");
    await page.goto(url);

    const title = await page.title();
    console.log(`The page's title is: ${title}`);
    const html = await page.content();
    fs.writeFileSync("example.html", html);
    console.log(`HTML file saved.`);
    await page.screenshot({ path: "example.png" });
    console.log(`Screenshot saved.`);
    const pdfBuffer = await page.pdf({ format: "A4" });
    fs.writeFileSync("example.pdf", pdfBuffer);
    console.log(`PDF file saved.`);

  } catch (error) {
    console.error("An error occurred:", error.message);
  } finally {
    if (browser) {
      try {
        console.log("Closing browser...");
        await browser.close();
      } catch (closeError) {
        console.error("Error while closing browser:", closeError.message);
      }
    }
  }
}
// Run the main function
main().catch(error => {
  console.error("Unhandled error in main function:", error);
});

```

Connecting to unlocked browser sessions

If your Puppeteer scripts are getting blocked by bot detectors, you can use [**BrowserQL**](https://docs.browserless.io/browserql/start) to generate a browser instance with advanced stealth features, that you can then connect to with the provided `browserWSEndpoint` and cookies.

## Reduce `await`'s as much as possible [â€‹](https://docs.browserless.io/baas/connect-puppeteer\#reduce-awaits-as-much-as-possible "Direct link to reduce-awaits-as-much-as-possible")

Most of the puppeteer is async, meaning any command with `await` in front of it (or `.then`'s) is going to make a round-trip from your application to browserless and back. While you can only do so much to limit this you should definitely try and do as much as possible. For instance, use `page.evaluate` over `page.$selector` as you can accomplish a lot in one `evaluate` versus multiple `$selector` calls.

**DON'T DO**

```codeBlockLines_p187
const $button = await page.$(".buy-now");
const buttonText = await $button.getProperty("innerText");
const clicked = await $button.click();

```

**DO**

```codeBlockLines_p187
const buttonText = await page.evaluate(() => {
  const $button = document.querySelector(".buy-now");
  const clicked = $button.click();

  return $button.innerText;
});

```

- [More Puppeteer Details](https://docs.browserless.io/baas/connect-puppeteer#more-puppeteer-details)
  - [Basic Usage](https://docs.browserless.io/baas/connect-puppeteer#basic-usage)
  - [Code Snippet](https://docs.browserless.io/baas/connect-puppeteer#code-snippet)
- [Reduce `await`'s as much as possible](https://docs.browserless.io/baas/connect-puppeteer#reduce-awaits-as-much-as-possible)

---

### Hybrid automation - human in the loop | Browserless.io
Original URL: https://docs.browserless.io/baas/hybrid-automation

[Skip to main content](https://docs.browserless.io/baas/hybrid-automation#__docusaurus_skipToContent_fallback)



info

Hybrid Automation is only available on paid plans.

Hybrid automation allows you to have humans intervene in an automation workflow, or even take complete control. This is useful in case a user needs to input their credentials, handle 2FA or simply perform some actions on a website before resuming automation. This can be done with Puppeteer, Playwright and virtually any library that supports CDP connections.

![hybrid automation preview](https://docs.browserless.io/img/hybrid_automation.gif)

## Default behavior [â€‹](https://docs.browserless.io/baas/hybrid-automation\#default-behavior "Direct link to Default behavior")

When creating a `liveURL` in our Chrome Devtools API, Browserless will return a one-time link to a webpage which you can share with your end-users. No API tokens or other secretive information is shared in this link, and no additional software or third-party packages are required. By default, this feature intends to mimic the underlying browser's screen to your end users, and will adjust the underlying browser to "fit" your end-users screen. As an example: If your user has a screen of 1920x1080, then we'll resize the underlying browser to match. This is configurable by specifying a value of `resizable: false` when creating this URL, which will preserve whatever viewport the browser currently is.

Interactions with the page are also turned on by default. This means your end user can click, type, scroll, touch, or tap on the page and interact with the page. We use a compressed video stream to preserve as much bandwidth as possible, and you can also configure a `quality` option, with values of 1 - 100 to lessen the amount of network consumption. This is ideal for streaming to mobile devices.

Below is a full example, with all options set, feel free to adjust this as your use-case demands:

```codeBlockLines_p187
import puppeteer from 'puppeteer-core';

const login = async () => {
  const browser = await puppeteer.connect({
    browserWSEndpoint: 'wss://production-sfo.browserless.io?token=YOUR_API_TOKEN_HERE',
  });
  const page = await browser.newPage();

  await page.goto('https://www.gmail.com/');
  const cdp = await page.createCDPSession();

  const { liveURL } = await cdp.send('Browserless.liveURL', {
    // Maintain the underlying browser viewport and don't resize to match the end users display.
    // End users will get a stream that maintains the aspect ratio.
    resizable: false,

    // Disable interactivity: useful for viewing the page as your code runs.
    interactable: false,

    // Set quality to "50" to help with bandwidth consumption.
    quality: 50

    // Finally, only allow this to run for 5 minutes (300000ms)
    timeout: 300_000,
  });

  console.log(liveURL);

  // More code or scripts...
  await browser.close();
};

login();

```

## How to stream a remote headless browsers [â€‹](https://docs.browserless.io/baas/hybrid-automation\#how-to-stream-a-remote-headless-browsers "Direct link to How to stream a remote headless browsers")

Browserless communicates with the browser at a CDP layer to return the `Browserless.liveURL`, which is a fully-qualified URL that doesn't require a token, which means you can share this with the end users. The URL can be opened in a new tab or displayed as an iFrame on your website where they will be able to click, type and interact with the browser.

You can also listen for the `Browserless.captchaFound` and `Browserless.liveComplete` events to identify when there's a captcha on the screen and also when a customers has completed their automation and closed the interactive tab.

Here's a sample snippet where you want end users to log in to Gmail with their credentials/2FA.

```codeBlockLines_p187
import puppeteer from 'puppeteer-core';

const login = async () => {
  const browser = await puppeteer.connect({
    browserWSEndpoint: 'wss://production-sfo.browserless.io?token=YOUR_API_TOKEN_HERE',
  });
  const page = await browser.newPage();

  await page.goto('https://www.gmail.com/');
  const cdp = await page.createCDPSession();
  const { liveURL } = await cdp.send('Browserless.liveURL');

  // Send this one-time link to your end-users.
  // This URL doesn't contain an API-token so there's no
  // secrets being leaked by doing so
  console.log(`Shareable Public URL:`, liveURL);

  //This event is fired when a captcha is found on the page.
  await new Promise((resolve) =>
    cdp.on('Browserless.captchaFound', () => {
      console.log('Found a captcha!');
      return resolve();
    }),
  );

  // This event is fired after a user closes the page.
  // Assuming the page is where it's supposed to be, we can
  // proceed with doing further automations
  await new Promise((r) => cdp.on('Browserless.liveComplete', r));

  // Implement your scraping, data collections or further automations here.

  // Don't forget to close!
  browser.close();
};

login().catch((e) => console.log(e));

```

## Reusing the session after login [â€‹](https://docs.browserless.io/baas/hybrid-automation\#reusing-the-session-after-login "Direct link to Reusing the session after login")

If you're using the hybrid automation for logging into a platform, you can reutilize the cookies, session and cache on subsequent browser sessions by using the `&--user-data-dir` flag.

```codeBlockLines_p187
puppeteer.connect({
  browserWSEndpoint: 'wss://production-sfo.browserless.io/?token=YOUR_API_KEY&--user-data-dir=~/browserless-cache-123',
});

```

## Multiple LiveURL sessions, captcha solving and more advanced use [â€‹](https://docs.browserless.io/baas/hybrid-automation\#multiple-liveurl-sessions-captcha-solving-and-more-advanced-use "Direct link to Multiple LiveURL sessions, captcha solving and more advanced use")

The hybrid automation features can be combined to create more sophisticated workflows. You can use this example as a starting point to create even more sophisticated workflows. Here's an example that demonstrates:

1. Generating a LiveURL for user interaction
2. Adding a countdown timer to show session limits
3. Detecting and handling captchas
4. Creating multiple LiveURL sessions in sequence
5. Adding UI overlays to guide user behavior

````codeBlockLines_p187
import puppeteer from 'puppeteer-core';
const sleep = (ms) => new Promise((res) => setTimeout(res, ms));

// Configuration for timeouts
// BROWSER_TIMEOUT: Total time the browser session can run (6 minutes)
// LIVE_URL_TIMEOUT: Time each LiveURL session can run (2 minutes)
const BROWSER_TIMEOUT = 6*60*1000; // 6 minutes in milliseconds
const LIVE_URL_TIMEOUT = 2*60*1000; // 2 minutes in milliseconds

const queryParams = new URLSearchParams({
  token: "YOUR_API_TOKEN_HERE",
  timeout: BROWSER_TIMEOUT,
  headless: true,
}).toString();

// Main automation function
(async() => {
  let browser = null;
  let sessionStartTime = null; // Tracks when each LiveURL session starts
  let browserStartTime = null; // Tracks when the browser session starts

  try {
    browser = await puppeteer.connect({
      browserWSEndpoint: `wss://production-sfo.browserless.io?${queryParams}`,
    });
    console.log('Connected to browserless.io!');

    const page = await browser.newPage();

    // Reinject banner after page navigation to maintain countdown
    page.on('load', async () => {
      if (sessionStartTime) {
        await injectTimeoutBanner(page, sessionStartTime, browserStartTime);
      }
    });

    // Initial page navigation and banner setup
    await page.goto('https://www.google.com', {
      waitUntil: 'networkidle2'
    });
    console.log('Navigated');

    // Record start times and inject initial banner with the timer countdown so users know how much time they have left
    browserStartTime = Date.now();
    sessionStartTime = Date.now();
    await injectTimeoutBanner(page, sessionStartTime, browserStartTime);

    // Create first LiveURL session
    const cdp = await page.createCDPSession();
    const { liveURL } = await cdp.send('Browserless.liveURL', {
      timeout: LIVE_URL_TIMEOUT
    });
    //You can embed this liveURL in your website or send it to the user via email or text message
    console.log('Click for live experience:', liveURL);

    // Wait for CAPTCHA detection
    let captchaFound = false;
    await new Promise((resolve) =>
      cdp.on('Browserless.captchaFound', () => {
        console.log('Found a captcha!');
        captchaFound = true;
        return resolve();
      }),
    );

    // Only handle CAPTCHA if one was found
    if (captchaFound) {
      // Add full-screen overlay and notification when CAPTCHA is detected so the user can't interact with the page while it's being solved
      await addCaptchaOverlay(page);

      // Wait for user to close the live URL
      await new Promise((r) => cdp.on('Browserless.liveComplete', r));
      console.log(`Live URL closed on page: ${page.url()}`);

      // Solve the CAPTCHA
      const { solved, error } = await cdp.send('Browserless.solveCaptcha', {
        appearTimeout: 20000
      });

      await page.waitForNavigation({ waitUntil: 'networkidle2' });
      console.log({
        solved,
        error,
      });
    }

    // Create second LiveURL session
    const { liveURL: newLiveURL } = await cdp.send('Browserless.liveURL', {
      timeout: LIVE_URL_TIMEOUT
    });
    console.log('Click for live experience:', newLiveURL);

    // Reset session timer for new LiveURL session
    sessionStartTime = Date.now();
    await injectTimeoutBanner(page, sessionStartTime, browserStartTime);

    // Wait for user to close the new live URL
    await new Promise((r) => cdp.on('Browserless.liveComplete', r));
    console.log(`Live URL closed on page: ${page.url()}`);

  } catch (error) {
    console.error('An error occurred:', error);
  } finally {
    // Ensure browser is always closed
    if (browser) {
      try {
        await browser.close();
        console.log('Browser closed successfully');
      } catch (closeError) {
        console.error('Error closing browser:', closeError);
      }
    }
  }
})().catch((e) => {
  console.error('Fatal error:', e);
  process.exit(1);
});

// Function to create and update the timeout banner
async function injectTimeoutBanner(page, startTime, browserStartTime) {
  // Wait 1 second to ensure page is fully loaded
  await sleep(1000);

  await page.evaluate((liveTimeoutMs, browserTimeoutMs, startTime, browserStartTime) => {
    // Remove existing banner if it exists
    const existingBanner = document.getElementById('timeout-banner');
    if (existingBanner) {
      existingBanner.remove();
    }

    // Create timeout banner with styling
    const banner = document.createElement('div');
    banner.id = 'timeout-banner';
    banner.style.cssText = `
      position: fixed;
      bottom: 20px;
      right: 20px;
      background-color: #333;
      color: white;
      padding: 10px 15px;
      border-radius: 5px;
      z-index: 9999;
      font-family: Arial, sans-serif;
      box-shadow: 0 2px 5px rgba(0,0,0,0.2);
      font-size: 14px;
    `;

    // Function to update the countdown display
    const updateCountdown = () => {
      const elapsed = Date.now() - startTime;
      const browserElapsed = Date.now() - browserStartTime;
      const liveRemaining = Math.max(0, liveTimeoutMs - elapsed);
      const browserRemaining = Math.max(0, browserTimeoutMs - browserElapsed);
      const remaining = Math.min(liveRemaining, browserRemaining);

      const minutes = Math.floor(remaining / 60000);
      const seconds = Math.floor((remaining % 60000) / 1000);

      banner.textContent = `Session timeout in: ${minutes}:${seconds.toString().padStart(2, '0')}`;

      if (remaining <= 0) {
        banner.style.backgroundColor = '#ff0000';
        banner.textContent = 'Session expired!';
      } else if (remaining <= 30000) { // Last 30 seconds
        banner.style.backgroundColor = '#ff9900';
      }
    };

    // Initial update and set up interval for countdown
    updateCountdown();
    const intervalId = setInterval(updateCountdown, 1000);
    window.timeoutBannerInterval = intervalId;

    document.body.appendChild(banner);
  }, LIVE_URL_TIMEOUT, BROWSER_TIMEOUT, startTime, browserStartTime);
}

// Function to add overlay and notification when CAPTCHA is detected
async function addCaptchaOverlay(page) {
  await page.evaluate(() => {
    // Create full-screen overlay to block interaction
    const overlay = document.createElement('div');
    overlay.style.cssText = `
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.5);
      z-index: 9998;
      cursor: not-allowed;
    `;
    document.body.appendChild(overlay);

    // Create notification message
    const notification = document.createElement('div');
    notification.style.cssText = `
      position: fixed;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      background-color: #ff4444;
      color: white;
      padding: 15px 30px;
      border-radius: 5px;
      z-index: 9999;
      font-family: Arial, sans-serif;
      box-shadow: 0 2px 5px rgba(0,0,0,0.2);
    `;

    notification.textContent = 'Please close this tab so that we can perform some tasks (solve captcha in this case)';
    document.body.appendChild(notification);
  });
}

## Using Hybrid Automation with Python and Playwright

The hybrid automation features can also be used with Python and Playwright. The main difference is in how we handle event listeners and async operations. Here's a complete example:

```python
import asyncio
import logging
from playwright.async_api import async_playwright
from urllib.parse import urlencode

logging.basicConfig(level=logging.DEBUG)

# Configuring query parameters
params = {
    "token": "YOUR_API_TOKEN_HERE",
    "timeout": 60000,
    "proxy": "residential",
    "proxyCountry": "US"
}
query_params = urlencode(params)

async def main():
    async with async_playwright() as p:
        browser = await p.chromium.connect_over_cdp(f"wss://production-sfo.browserless.io/chromium?{query_params}")
        print('Connected')
        context = browser.contexts[0]
        page = await context.new_page()
        await page.goto('https://www.example.com', wait_until='networkidle')
        print('Navigated')

        cdp_session = await context.new_cdp_session(page)
        print('printing liveURL')
        response = await cdp_session.send('Browserless.liveURL', {
            'timeout': 600000
        })
        print(response)

        live_complete = asyncio.Future()

        def handle_event(params):
            print("Browserless.liveComplete:", params)
            live_complete.set_result(None)

        # Register the event handler
        cdp_session.on('Browserless.liveComplete', handle_event)

        # Wait for the future to complete
        await live_complete

        print("Page closed, current URL:", page.url)

        # Screenshot
        await page.screenshot(path='temp.png', full_page=True)

        await browser.close()

# Run the main function
asyncio.run(main())

````

## Additional LiveURL Options [â€‹](https://docs.browserless.io/baas/hybrid-automation\#additional-liveurl-options "Direct link to Additional LiveURL Options")

The LiveURL feature supports several additional options for customizing behavior:

- **Quality and Type**: Control the streamed quality and format (jpeg/png)
- **Wait for Close**: Listen for events when the live page is closed
- **Programmatic Control**: Manage LiveURL sessions programmatically
- **Interactive:false**: Create read-only streaming sessions

For full developer documentation on these options, [see the CDP API documentation](https://docs.browserless.io/open-api#section/The-Browserless-CDP-API/Browserless.liveURL).

- [Default behavior](https://docs.browserless.io/baas/hybrid-automation#default-behavior)
- [How to stream a remote headless browsers](https://docs.browserless.io/baas/hybrid-automation#how-to-stream-a-remote-headless-browsers)
- [Reusing the session after login](https://docs.browserless.io/baas/hybrid-automation#reusing-the-session-after-login)
- [Multiple LiveURL sessions, captcha solving and more advanced use](https://docs.browserless.io/baas/hybrid-automation#multiple-liveurl-sessions-captcha-solving-and-more-advanced-use)
- [Additional LiveURL Options](https://docs.browserless.io/baas/hybrid-automation#additional-liveurl-options)

---

### Beautiful Soup (Python) | Browserless.io
Original URL: https://docs.browserless.io/baas/libraries/beautifulsoup

[Skip to main content](https://docs.browserless.io/baas/libraries/beautifulsoup#__docusaurus_skipToContent_fallback)



Beautiful Soup is one the most popular scrapping libraries. It allows you to use Python to easily parse an existing HTML string to scrape its data in an easy and fast manner. You can use Beautiful Soup alongside our [/content](https://docs.browserless.io/rest-apis/content) or [BrowserQL](https://docs.browserless.io/browserql/start) to scrape any website.

Both of these APIs will render the content in a browser before HTML, with the difference that BrowserQL uses advanced stealth techniques to first bypass bot detectors.

## Basic Usage [â€‹](https://docs.browserless.io/baas/libraries/beautifulsoup\#basic-usage "Direct link to Basic Usage")

Just like [Cheerio](https://www.npmjs.com/package/cheerio), Beautiful Soup is _only_ a parser, it does not provide any API to _get_ the HTML string in the first place. Usually, to get the HTML string from a website, you would use the `requests` library to download the page, like this:

```codeBlockLines_p187
import requests
from bs4 import BeautifulSoup

url = 'https://browserless.io/'
response = requests.get(url)
soup = BeautifulSoup(response.text, 'html.parser')
entries = soup.find_all('a')

for entry in entries:
    print(entry.text.strip())

```

Here's the main problem: since `requests` just downloads the HTML, **it can only return the _source code_ of a page without interacting with it**. Which means that any page that relies on JavaScript and user interactions to render content, will not be downloaded properly.

On the other hand, the `/content` API ensures that the HTML content is not just downloaded, but rendered and evaluated inside a browser. You can use the `requests` library to make an HTTP request to our api, this way:

```codeBlockLines_p187
import requests
from bs4 import BeautifulSoup

response = requests.post("https://production-sfo.browserless.io/content",
    params={ "token": "YOUR_API_TOKEN_HERE"},
    json={
        "waitForTimeout": 5000,
        "url": "https://puppeteer.github.io/pptr.dev/"
    }
)

soup = BeautifulSoup(response.text, 'html.parser')
entries = soup.find_all("a", class_="pptr-sidebar-item")

for entry in entries:
    print(entry.text.strip())

```

In the example, we are using the [old Puppeteer doc site](https://puppeteer.github.io/pptr.dev/), which relies heavily on JS to render its content. With a usual `requests` or `cURL` request, it would only download the page's source code, the JavaScript wouldn't be interpreted and the content wouldn't be rendered.

Using our API, you can use [all the options available in the `/content` API](https://docs.browserless.io/rest-apis/content), use stealth mode, our residential proxies and more! For more reference, please check our [OpenAPI](https://docs.browserless.io/open-api/#tag/Browser-REST-APIs/paths/~1chrome~1content/post).

## Bypass bot-blockers using `/unblock` [â€‹](https://docs.browserless.io/baas/libraries/beautifulsoup\#bypass-bot-blockers-using-unblock "Direct link to bypass-bot-blockers-using-unblock")

In cases where websites implement aggressive bot-detection mechanisms, you can use the `/unblock` API to bypass these. The `/unblock` API uses a variety of tools and strategies to override and hide the footprints that headless browsers leave behind, allowing you to access bot-protected websites from a remote interface.

Similar to the `/content` API, the `/unblock` API renders and evaluates the page in a browser, but with extra stealth features. This makes it ideal for scraping highly protected websites.

```codeBlockLines_p187
import json
import requests
from bs4 import BeautifulSoup

response = requests.post("https://production-sfo.browserless.io/unblock",
    params={ "token": "YOUR_API_TOKEN_HERE"},
    json={
        "waitForTimeout": 5000,
        "url": "https://puppeteer.github.io/pptr.dev/"
    }
)

html_content = json.loads(response.text)['content']
soup = BeautifulSoup(html_content, 'html.parser')

entries = soup.find_all("a", class_="pptr-sidebar-item")
for entry in entries:
    print(entry.text.strip())

```

- [Basic Usage](https://docs.browserless.io/baas/libraries/beautifulsoup#basic-usage)
- [Bypass bot-blockers using `/unblock`](https://docs.browserless.io/baas/libraries/beautifulsoup#bypass-bot-blockers-using-unblock)

---

### Go (chromedp) | Browserless.io
Original URL: https://docs.browserless.io/baas/libraries/chromedp

[Skip to main content](https://docs.browserless.io/baas/libraries/chromedp#__docusaurus_skipToContent_fallback)


We offer beta support for the [`chromedp`](https://pptr.dev/api/puppeteer.cdpsession) Go library.

Usage of the library remains similar to how you'd run your application locally, simply use the `RemoteAllocator` to connect to browserless API.

An example of navigating to the Example.com site, and getting the title, is listed below as a jumping off point:

```codeBlockLines_p187
package main

import (
    "context"
    "flag"
    "log"

    "github.com/chromedp/chromedp"
)

func main() {
    devtoolsWsURL := flag.String("devtools-ws-url", "wss://production-sfo.browserless.io?token=YOUR_API_TOKEN_HERE", "DevTools WebSsocket URL")
    flag.Parse()

    allocatorContext, cancel := chromedp.NewRemoteAllocator(context.Background(), *devtoolsWsURL,chromedp.NoModifyURL)
    defer cancel()

    ctx, cancel := chromedp.NewContext(allocatorContext)
    defer cancel()

    var title string
    if err := chromedp.Run(ctx,
        chromedp.Navigate("https://example.com"),
        chromedp.Title(&title),
    ); err != nil {
        log.Fatalf("Failed getting title of example.com: %v", err)
    }

    log.Println("Got title of:", title)
}

```

Be sure to [let us know if you have questions or issues](https://www.browserless.io/contact).

---

### PHP (cURL) | Browserless.io
Original URL: https://docs.browserless.io/baas/libraries/php

[Skip to main content](https://docs.browserless.io/baas/libraries/php#__docusaurus_skipToContent_fallback)


Browserless can run in PHP by using cURL.
Here's a small example:

```codeBlockLines_p187
<?php

$curl = curl_init();

curl_setopt_array($curl, [\
  CURLOPT_URL => "https://production-sfo.browserless.io/screenshot?token=YOUR_API_TOKEN_HERE",\
  CURLOPT_RETURNTRANSFER => true,\
  CURLOPT_ENCODING => "",\
  CURLOPT_MAXREDIRS => 10,\
  CURLOPT_TIMEOUT => 30,\
  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\
  CURLOPT_CUSTOMREQUEST => "POST",\
  CURLOPT_POSTFIELDS => "{\n  \"url\": \"https://example.com/\",\n\t\"options\": {\n\t\t\"fullPage\": true,\n\t\t\"encoding\": \"base64\"\n\t}\n}",\
  CURLOPT_HTTPHEADER => [\
    "Content-Type: application/json"\
  ],\
]);

$response = curl_exec($curl);
$err = curl_error($curl);

curl_close($curl);

if ($err) {
  echo "cURL Error #:" . $err;
} else {
  echo $response;
}

```

This will simply take a screenshot of the Example website and return it encoded in base64 format, however it'll give you a great starting place for using our APIs through cURL in PHP.

Be sure to [let us know if you have questions or issues](https://www.browserless.io/contact).

---

### Pyppeteer (Python) - UNMAINTAINED | Browserless.io
Original URL: https://docs.browserless.io/baas/libraries/pyppeteer

[Skip to main content](https://docs.browserless.io/baas/libraries/pyppeteer#__docusaurus_skipToContent_fallback)


warning

We suggest not using this library anymore as it is now unmaintained, please consider [playwright-python](https://www.browserless.io/docs/playwright#python-playwright) as an alternative

You can use your existing python infrastructure today with browserless by using [Pyppeteer](https://github.com/pyppeteer/pyppeteer), an unofficial python port of puppeteer.

Below is a small example of getting started:

```codeBlockLines_p187
import asyncio
import pyppeteer

async def main():
  browser = await pyppeteer.launcher.connect(
    browserWSEndpoint='wss://production-sfo.browserless.io?token=YOUR_API_TOKEN_HERE'
    )
  page = await browser.newPage()
  url = "https://www.example.com"
  await page.goto(url)
  values = await page.evaluate('''() => document.querySelector('h1').innerHTML
    ''')
  print(values)
  await browser.close()

asyncio.get_event_loop().run_until_complete(main())

```

This will simply navigate to the example website and return the title, however it'll give you a great starting place for using Pyppeteer alongside browserless.

Be sure to [let us know if you have questions or issues](https://www.browserless.io/contact).

---

### Scrapy (Python) | Browserless.io
Original URL: https://docs.browserless.io/baas/libraries/scrapy

[Skip to main content](https://docs.browserless.io/baas/libraries/scrapy#__docusaurus_skipToContent_fallback)



You can use Scrapy alongside our [/content API](https://docs.browserless.io/rest-apis/content) or [BrowserQL](https://docs.browserless.io/browserql/start) to scrape data. All you need to do is use the `start_requests()` method to make a query to the `/content` or BrowserQL, while keeping your scraping code the same.

## Basic Usage [â€‹](https://docs.browserless.io/baas/libraries/scrapy\#basic-usage "Direct link to Basic Usage")

Since Scrapy uses HTTP requests to just download the HTML page and build a DOM-like abstraction to be scrapped, **it can only return the initial render of a page without interacting with it**. On the other hand, the `/content` API asure the HTML content is not just downloaded, but rendered and evaluated inside a browser, while BrowserQL uses advanced stealth techniques to bypass bot detectors before rendering a page.

All you need to do is implement the `start_requests()` method to make a query to the `/content` API, while keeping your scraping code the same.

```codeBlockLines_p187
import json
import scrapy

class PptrDocsSpider(scrapy.Spider):
    name = "pptr-docs"

    def start_requests (self):
        options = {
            "url": "https://puppeteer.github.io/pptr.dev/",
            "waitForTimeout": 5000
        }

        yield scrapy.Request(
            url="https://production-sfo.browserless.io/content?token=YOUR_API_TOKEN_HERE",
            method='POST',
            dont_filter=True,
            headers={"Content-Type": "application/json"},
            body=json.dumps(options)
        )

    def parse(self, response):
        entries = response.css('sidebar-component a.pptr-sidebar-item')
        for entry in entries:
            yield{
                'title' : entry.css('::text').get(),
                'url' : entry.css('::attr(href)').get(),
            }

```

You can use [all the options available in the `/content` API](https://docs.browserless.io/rest-apis/content), use stealth mode, our residential proxies and more! For more reference, please see this [blogpost](https://www.browserless.io/blog/2024/02/15/scrapy-headless/).

## Bypass bot-blockers using `/unblock` [â€‹](https://docs.browserless.io/baas/libraries/scrapy\#bypass-bot-blockers-using-unblock "Direct link to bypass-bot-blockers-using-unblock")

In cases where websites implement aggressive bot-detection mechanisms, you can use the `/unblock` API to bypass these. The `/unblock` API uses a variety of tools and strategies to override and hide the footprints that headless browsers leave behind, allowing you to access bot-protected websites from a remote interface.

Similar to the `/content` API, the `/unblock` API renders and evaluates the page in a browser, but with extra stealth features. This makes it ideal for scraping highly protected websites.

You want to make the `/unblock` request yeilding the `scrapy.Request()` method, and **extracting the html content from the JSON in the `parse()` method**. Here's an example:

```codeBlockLines_p187
import json
import scrapy

class PptrDocsSpider(scrapy.Spider):
    name = "pptr-docs"

    def start_requests (self):
        options = {
            "url": "https://puppeteer.github.io/pptr.dev/",
            "waitForTimeout": 5000
        }

        yield scrapy.Request(
            url="https://production-sfo.browserless.io/unblock?token=YOUR_API_TOKEN_HERE",
            method='POST',
            dont_filter=True,
            headers={"Content-Type": "application/json"},
            body=json.dumps(options)
        )

    def parse(self, response):
        # Extracts the content from the response
        html_content = json.loads(response.text)['content']
        dom = scrapy.Selector(text=html_content)

        # Continue as normal
        entries = dom.css('sidebar-component a.pptr-sidebar-item')
        for entry in entries:
            yield{
                'title' : entry.css('::text').get(),
                'url' : entry.css('::attr(href)').get(),
            }

```

- [Basic Usage](https://docs.browserless.io/baas/libraries/scrapy#basic-usage)
- [Bypass bot-blockers using `/unblock`](https://docs.browserless.io/baas/libraries/scrapy#bypass-bot-blockers-using-unblock)

---

### Load Balancers | Browserless.io
Original URL: https://docs.browserless.io/baas/load-balancers

[Skip to main content](https://docs.browserless.io/baas/load-balancers#__docusaurus_skipToContent_fallback)



The Cloud Subscription plans and Dedicated plans have load balancing mechanisms built-in. This documentation will provide further information on how they work on each plan.

## Cloud subscriptions' load balancing [â€‹](https://docs.browserless.io/baas/load-balancers\#cloud-subscriptions-load-balancing "Direct link to Cloud subscriptions' load balancing")

When you fire a request to our endpoints, it will go through our load balancers and will be sent to one of our instances to be handled. These are the cloud subscription endpoints available:

1. SFO endpoint: `https://production-sfo.browserless.io`
2. LON endpoint: `https://production-lon.browserless.io`
3. AMS endpoint: `https://production-ams.browserless.io`

We list our shared fleet's [IP addresses for whitelisting](https://docs.browserless.io/baas/troubleshooting/whitelisting-ips) purposes.

Our cloud-unit fleet is comprised of many machines running browserless, and our load-balancer will automatically determine which machine to handle the request. If, say, a machine is too overloaded to handle the inbound connection then our load-balancer routes the request to another. In very plain terms we use a modified least-connected algorithm to ensure your request is handled appropriately.

## Enterprise - Dedicated workers' load balancing [â€‹](https://docs.browserless.io/baas/load-balancers\#enterprise---dedicated-workers-load-balancing "Direct link to Enterprise - Dedicated workers' load balancing")

Your worker can be located in 4 different sites: San Francisco, New York, Amsterdam, or London. If you request to `https://chrome.browserless.io`, it will redirect to one of the 4 regions.

In order to improve the latency by having a worker located closer to your client, you'll want to use the load balancer closest to your machine to reduce the distance data from requests must travel. These are the load balancers available for you to point your traffic to:

1. West load balancer (SFO): `https://chrome-us-west.browserless.io`
2. East load balancer (NYC): `https://chrome-us-east.browserless.io`
3. UK load balancer (LON): `https://chrome-eu-uk.browserless.io`
4. AMS load balancer (AMS): `https://chrome-eu-ams.browserless.io`

### Multiple worker load balancing [â€‹](https://docs.browserless.io/baas/load-balancers\#multiple-worker-load-balancing "Direct link to Multiple worker load balancing")

When you have multiple instances, it'll automatically load-balance amongst them by least connections. If you want to handle load-balancing on your end, you can get the endpoint for every individual worker by clicking on the URL in the "Address" Column in the Production Workers table available in your [account dashboard](https://account.browserless.io/).

- [Cloud subscriptions' load balancing](https://docs.browserless.io/baas/load-balancers#cloud-subscriptions-load-balancing)
- [Enterprise - Dedicated workers' load balancing](https://docs.browserless.io/baas/load-balancers#enterprise---dedicated-workers-load-balancing)
  - [Multiple worker load balancing](https://docs.browserless.io/baas/load-balancers#multiple-worker-load-balancing)

---

### Migration Guide | Browserless.io
Original URL: https://docs.browserless.io/baas/migrate

[Skip to main content](https://docs.browserless.io/baas/migrate#__docusaurus_skipToContent_fallback)



Important Note for Shared Fleet Users

**For users on the Shared Fleet**: Migration from v1 to v2 is primarily a connection URL change. Most of the changes described in this guide are relevant for self-hosted deployments. If you're using the shared fleet, you'll mainly need to:

1. Update your connection URLs as explained in our [Quick Start page](https://docs.browserless.io/baas/start)
2. Ensure you're using a compatible Puppeteer/Playwright version (see our [versions page](https://docs.browserless.io/baas/troubleshooting/versions))

Browserless 2.0 is finally here! It's a complete rewrite of the core of browserless, and many things have changed. To keep things short, this rewrite allows us to support many new things which you can read about [in our blog](https://www.browserless.io/blog/2023/12/06/browserless-2-0/).

This document serves as a guide to migrate existing systems from browserless 1.x to 2.x. New features are not covered in this guide, but we do recommend checking the new things outBelow is a table of contents from which you can pick to better aide in migrating your existing codebase or REST calls.

For the most comprehensive API documentation, feel free to visit the built-in Swagger doc-site located at your Browserless instance `/docs` route, or [our hosted Swagger docs](http://chrome-dev.browserless.io/docs). Browserless also logs this on startup for help.

## List of Major and Potentially Breaking Changes [â€‹](https://docs.browserless.io/baas/migrate\#list-of-major-and-potentially-breaking-changes "Direct link to List of Major and Potentially Breaking Changes")

- **Drop support for Selenium and Webdriver**
- Many docker environment variable changes (see below).
- Drop support for `DEFAULT_*` arguments.
- Drop support for pre-booting and keep-alive.
- `TOKEN` is now randomly generated when none is present to enforce some authentication.
- When using custom launch flags for APIs and Libraries: please update to the new format which is a consolidated `&launch` parameter.
- Playwright's Chromium path is now `/chromium/playwright` in order to reflect other browsers in different paths.
- Unknown query parameters or JSON POST parameters will now respond with a 4xx error.
- New `/function` API environment and uses Ecmascript modules. We no longer run /function calls in the NodeJS environment, and instead run inside the browser's JavaScript runtime. `import` does work and loads modules over HTTP instead of locally.
- `blockAds` now uses Ublock Origin to facilitate ad-blocking. No more request interception.
- The prior `/stats` API is now located at `/performance`.

## Design Changes and overall goals [â€‹](https://docs.browserless.io/baas/migrate\#design-changes-and-overall-goals "Direct link to Design Changes and overall goals")

browserless 2.xx was designed and developed for the sole purpose of making browser behavior more deterministic. We want to make the process of operating a headless browser stack more developer-friendly since these workflows can often be frustrating to work with. What do we mean by this? Here's a few points

- Unknown parameters will fail with 4xx errors since they're unrecognized.
- No more pre-booting or keep-alive as they can cause so many problems.
- A typescript-first workflow. All routes are strongly typed with a prescriptive approach so you can add your own.
- Forcing of best practices: we generate a unique TOKEN when none is present, meaning you _must_ have a token at all times.
- Better logging and built-in doc-site with all parameters and definitions.
- Enhanced and comprehensive security.

This, in combination with the past 5+ years experience in headless, means there's several things that are different in browserless 2.xx. Please refer to the above Table of Contents to find the most relevant information for your API, library or use-case.

Finally, browserless does its best to be friendly and helpful by logging things like out-of-date parameters and configuration. Please be sure to read through logs when migrating existing workflows over and we'll continue to improve these messages as time goes on.

## Docker [â€‹](https://docs.browserless.io/baas/migrate\#docker "Direct link to Docker")

Multiple environment variables have changed for simplicity and clarity in 2.0, but act similar in functionality to prior environment variables. We did remove a few due to their ability to cause issues, bad performance, and non-deterministic behavior.

browserless does it's best to log these old or deprecated environment variables, so be sure to read those out when using the new 2.0 builds.

### Removed parameters (no replacements): [â€‹](https://docs.browserless.io/baas/migrate\#removed-parameters-no-replacements "Direct link to Removed parameters (no replacements):")

- `CHROME_REFRESH_TIME`: No longer support pre-booted chrome.
- `DEFAULT_BLOCK_ADS`: Use `blockAds` in your API or library connect calls.
- `DEFAULT_DUMPIO`: Use `dumpio` in the launch arguments in your API or library connect calls.
- `DEFAULT_HEADLESS`: Use `headless: false` in your API or library connect calls.
- `DEFAULT_IGNORE_DEFAULT_ARGS`: Use `ignoreDefaultArgs` in your API or library connect calls.
- `DEFAULT_IGNORE_HTTPS_ERRORS`: Use `ignoreHTTPSErrors` your API or library connect calls.
- `DEFAULT_LAUNCH_ARGS`: Use the `args` option in your API or library connect calls. For this, please refer to our launch options.
- `DEFAULT_STEALTH`: Use the `stealth` option in your API or library connect calls.
- `DISABLED_FEATURES`: Fully ignored and deprecated.
- `ENABLE_HEAP_DUMP`: No longer supported.
- `FUNCTION_BUILT_INS`: No longer supported with the new function implementation.
- `FUNCTION_ENABLE_INCOGNITO_MODE`: No longer supported.
- `FUNCTION_ENV_VARS`: No longer supported.
- `FUNCTION_EXTERNALS`: No longer supported with the new function implementation.
- `KEEP_ALIVE`: No more pre-booting or keep-alive allowed.
- `PREBOOT_CHROME`: No more pre-booting or keep-alive allowed.
- `PRINT_GET_STARTED_LINKS`: Ignored
- `WORKSPACE_DELETE_EXPIRED`: No more workspace since most libraries do this now.
- `WORKSPACE_DIR`: No more workspace since most libraries do this now.
- `WORKSPACE_EXPIRE_DAYS`: No more workspace since most libraries do this now.

### Changed Parameters [â€‹](https://docs.browserless.io/baas/migrate\#changed-parameters "Direct link to Changed Parameters")

Browserless will log these and replace them for you internally, but feel free to update these in order to prevent further logged messages:

- `CONNECTION_TIMEOUT`: Is now: `TIMEOUT`
- `DEFAULT_USER_DATA_DIR`: Is now: `DATA_DIR`
- `ENABLE_API_GET`: Is now: `ALLOW_GET`
- `ENABLE_CORS`: Is now: `CORS`
- `MAX_CONCURRENT_SESSIONS`: Is now: `CONCURRENT`
- `PRE_REQUEST_HEALTH_CHECK`: Is now: `HEALTH`
- `PROXY_URL`: Is now: `EXTERNAL`
- `QUEUE_LENGTH`: Is now: `QUEUED`
- `TOKEN`: Remains `TOKEN` but is randomly generated when none is present.

### Other Changes [â€‹](https://docs.browserless.io/baas/migrate\#other-changes "Direct link to Other Changes")

We have changed where we serve our Docker images from docker hub to Github's container registry. Please use the `ghcr.io/browserless` or look at our open our [Packages page](https://github.com/orgs/browserless/packages).

## Cloud Service [â€‹](https://docs.browserless.io/baas/migrate\#cloud-service "Direct link to Cloud Service")

Browserless v2 is available as a cloud service and offers several advanced features, including:

- [**BQL**](https://docs.browserless.io/browserql/start "BrowserQL Quick Start | Browserless.io")
- [**Unblock API**](https://docs.browserless.io/rest-apis/unblock "/unblock API | Browserless.io")
- [**Captcha Solving**](https://docs.browserless.io/baas/avoid-bot-detection/captchas "Solving Captchas | Browserless.io")
- [**Live Url**](https://docs.browserless.io/baas/session-management/hybrid#how-to-stream-a-remote-headless-browsers "Hybrid automation - human in the loop | Browserless.io")
- [and more](https://docs.browserless.io/ "Quick Start | Browserless.io")

To ensure optimal performance, we provide three fleets that you can choose from, based on your geographic location:

- [`https://production-sfo.browserless.io/`](https://production-sfo.browserless.io/) (Based in San Francisco, USA).
- [`https://production-lon.browserless.io/`](https://production-lon.browserless.io/) (Based in London, England).
- [`https://production-ams.browserless.io/`](https://production-ams.browserless.io/) (Based in Amsterdam, Netherlands).

All paid cloud unit accounts have access to Browserless v2. However, feature availability depends on the plan you are subscribed to. The table below provides detailed information about the permissions for each plan.

|  | Usage plans (Deprecated) | Cloud Unit Free (Deprecated) | Cloud Unit 15k to 100k (Deprecated) | Starter 180k units | Scale 500k units and above |
| --- | --- | --- | --- | --- | --- |
| Web Socket Connection | âŒ | âŒ | âœ… | âœ… | âœ… |
| BQL (bypass, query, extract) | âŒ | âŒ | âœ… | âœ… | âœ… |
| Multi browser (chrome, chromium, firefox, webkit) | âŒ | âŒ | âœ… | âœ… | âœ… |
| APIs (unblock, screenshot, pdf, etc..) | âŒ | âŒ | âœ… | âœ… | âœ… |
| Residential Proxy | âŒ | âŒ | âœ… | âœ… | âœ… |
| Screen Recording | âŒ | âŒ | âŒ | âœ… | âœ… |
| State Proxying | âŒ | âŒ | âŒ | âŒ | âœ… |
| City Proxying | âŒ | âŒ | âŒ | âŒ | âœ… |
| Captcha Solving | âŒ | âŒ | âŒ | âŒ | âœ… |
| LiveUrl | âŒ | âŒ | âŒ | âŒ | âœ… |

## Libraries [â€‹](https://docs.browserless.io/baas/migrate\#libraries "Direct link to Libraries")

We tried to keep library changes as little as possible since the compromise the core of the platform. However, one change is the consolidation of _all_ launch options into a single query string parameter of a JSON-stringified "launch". Connect calls are now more strict with query parameters. Any unknown parameter will cause connect calls to fail since they aren't supported by browserless. In version 1.xx unknown parameters were simply ignored.

browserless 2.xx shims old launch options query parameters internally, so it'll fix 1.xx requests for you. Here's a few examples of this so you can make any changes in code.

You may also optionally base64 encode these JSON stringified `launch` parameter as well.

### Launch flags: [â€‹](https://docs.browserless.io/baas/migrate\#launch-flags "Direct link to Launch flags:")

**Before** `ws://localhost:3000?token=ABCD&--window-size=1920,1080`

**After** `ws://localhost:3000?token=ABCD&launch={"args":["--window-size=1920,108"]}`

### Headless flags: [â€‹](https://docs.browserless.io/baas/migrate\#headless-flags "Direct link to Headless flags:")

**Before** `ws://localhost:3000?token=ABCD&headless=shell`

**After** `ws://localhost:3000?token=ABCD&launch={"headless":"shell"}`

## /function API [â€‹](https://docs.browserless.io/baas/migrate\#function-api "Direct link to /function API")

The biggest difference in the function API is that it no longer operates inside of the NodeJS runtime, but in the browser. It also supports ECMAScript modules, so you'll have to tweak existing code to work inside 2.xx. This is a fairly large change, and any /function calls should be well tested prior to deploying them into production.

The function API is still hybrid in that it can accept a JavaScript file (with content-type application/javascript) OR a JSON file with `code` and `context` properties. Be sure to read more about it on the built-in doc-site.

Browserless also now infers the appropriate response type so you no longer need to specify it. Simply return whatever data you wish and it'll write the request appropriately.

browserless 2.xx shims old launch options query parameters internally, so it'll fix 1.xx-style requests for you.

### Basic Request [â€‹](https://docs.browserless.io/baas/migrate\#basic-request "Direct link to Basic Request")

**Before**

```codeBlockLines_p187
// CommonJS no longer supported
module.exports = async({ page }) => {
  await page.goto('https://example.com');

  // No longer need to response with this object schematic
  return {
    data: await page.screenshot(),
    type: 'image/png',
  };
}

```

**After**

```codeBlockLines_p187
// Use the "export default" keywords
export default async({ page }) => {
  await page.goto('https://example.com');
  // No longer need to tell what type
  return await page.screenshot();
}

```

### Request with requires [â€‹](https://docs.browserless.io/baas/migrate\#request-with-requires "Direct link to Request with requires")

**Before**

```codeBlockLines_p187
// npm packages are no longer supported
const url = require('url');

module.exports = async({ page }) => {
  await page.goto('https://example.com');
  const links = await page.evaluate(() => [...document.querySelectorAll('a')].map(l => l.href));
  const parsed = links.map((link) => url.parse(link));

  return {
    data: parsed,
    type: 'application/json',
  };
}

```

**After**

```codeBlockLines_p187
export default async({ page }) => {
  await page.goto('https://example.com');
  const links = await page.evaluate(() => [...document.querySelectorAll('a')].map(l => l.href));

  // Can use URL and other browser-based APIs as well as load them
  // with `import` syntax from hosts like unpkg
  const parsed = links.map((link) => new URL(link));

  return parsed;
}

```

## /pdf API [â€‹](https://docs.browserless.io/baas/migrate\#pdf-api "Direct link to /pdf API")

The PDF API operates in a similar fashion as the in browserless 1.xx. The biggest difference is how launch flags are handled, which now use a consolidated `launch` object to hold all CLI arguments and flags.

`waitFor` has now been removed and deprecated in favor of puppeteer's discrete API methods: `waitForEvent`, `waitForFunction`, `waitForSelector` and `waitForTimeout`.

`rotate` has been removed due to lack of usage and included 3rd party dependencies. `safeMode` has also been removed in favor of using puppeteer's streaming capabilities that are much less error-prone.

## /screenshot API [â€‹](https://docs.browserless.io/baas/migrate\#screenshot-api "Direct link to /screenshot API")

The /screenshot API operates very similarly to how it did in browserless 1.xx. A few properties and options have been removed due to their infrequent usage and 3rd party dependencies.

`waitFor` has now been removed and deprecated in favor of puppeteer's discrete API methods: `waitForEvent`, `waitForFunction`, `waitForSelector` and `waitForTimeout`.

`manipulate` has also been removed since it was infrequently used and required numerous other dependencies in order to run properly.

## /scrape API [â€‹](https://docs.browserless.io/baas/migrate\#scrape-api "Direct link to /scrape API")

The /scrape API operates similarly to how it did in browserless 1.xx. A few properties and options have been removed due to their infrequent usage and 3rd party dependencies.

`waitFor` has now been removed and deprecated in favor of puppeteer's discrete API methods: `waitForEvent`, `waitForFunction`, `waitForSelector` and `waitForTimeout`.

## /stats API [â€‹](https://docs.browserless.io/baas/migrate\#stats-api "Direct link to /stats API")

The /stats API has been moved to /performance now to better reflect the action its doing since the word "stats" in this context can be ambiguous. Internally, it still runs lighthouse reports and you can provide various configurations to it.

## /screencast API [â€‹](https://docs.browserless.io/baas/migrate\#screencast-api "Direct link to /screencast API")

The /screencast API has been removed in favor of a library-based approach. browserless 2.xx now ships with what we call an "embedded" API which you can use to initiate a recording of a page and get the response back (with audio!).

Please refer to the built-in doc-site for how to do screencasting or consult your library of choice for how to screencast.

## /config API [â€‹](https://docs.browserless.io/baas/migrate\#config-api "Direct link to /config API")

The /config API now returns more meta-data about the instance including more parameters. Please visit the internal doc-site page to see the JSON response and all the properties.

- [List of Major and Potentially Breaking Changes](https://docs.browserless.io/baas/migrate#list-of-major-and-potentially-breaking-changes)
- [Design Changes and overall goals](https://docs.browserless.io/baas/migrate#design-changes-and-overall-goals)
- [Docker](https://docs.browserless.io/baas/migrate#docker)
  - [Removed parameters (no replacements):](https://docs.browserless.io/baas/migrate#removed-parameters-no-replacements)
  - [Changed Parameters](https://docs.browserless.io/baas/migrate#changed-parameters)
  - [Other Changes](https://docs.browserless.io/baas/migrate#other-changes)
- [Cloud Service](https://docs.browserless.io/baas/migrate#cloud-service)
- [Libraries](https://docs.browserless.io/baas/migrate#libraries)
  - [Launch flags:](https://docs.browserless.io/baas/migrate#launch-flags)
  - [Headless flags:](https://docs.browserless.io/baas/migrate#headless-flags)
- [/function API](https://docs.browserless.io/baas/migrate#function-api)
  - [Basic Request](https://docs.browserless.io/baas/migrate#basic-request)
  - [Request with requires](https://docs.browserless.io/baas/migrate#request-with-requires)
- [/pdf API](https://docs.browserless.io/baas/migrate#pdf-api)
- [/screenshot API](https://docs.browserless.io/baas/migrate#screenshot-api)
- [/scrape API](https://docs.browserless.io/baas/migrate#scrape-api)
- [/stats API](https://docs.browserless.io/baas/migrate#stats-api)
- [/screencast API](https://docs.browserless.io/baas/migrate#screencast-api)
- [/config API](https://docs.browserless.io/baas/migrate#config-api)

---

### Proxies | Browserless.io
Original URL: https://docs.browserless.io/baas/proxies

[Skip to main content](https://docs.browserless.io/baas/proxies#__docusaurus_skipToContent_fallback)



Browserless offers two approaches to using proxies with your browser automation:

1. [**Built-in Residential Proxy**](https://docs.browserless.io/baas/proxies#built-in-residential-proxy) \- Our first-party residential proxy service available for paid cloud-unit accounts
2. [**Third Party Proxies**](https://docs.browserless.io/baas/proxies#third-party-proxies) \- Support for using your own external proxies with browserless

## Built-in Residential Proxy [â€‹](https://docs.browserless.io/baas/proxies\#built-in-residential-proxy "Direct link to Built-in Residential Proxy")

Browserless offers a built-in residential proxy for paid cloud-unit accounts. [You can sign-up for one here](https://www.browserless.io/sign-up/).

In order to effectively use this proxy, you'll need to adjust your code or API calls to let browserless proxy the request for you. For both library connect and REST API calls, the process is the same!

Bot Detection

For strict bot detectors where browsers and a proxy aren't enough to get past, we would recommend using [**BrowserQL**](https://docs.browserless.io/browserql/start).

### Puppeteer [â€‹](https://docs.browserless.io/baas/proxies\#puppeteer "Direct link to Puppeteer")

The following uses our built-in residential proxy, targeting a node in the US:

```codeBlockLines_p187
import puppeteer from "puppeteer-core";

const TOKEN = "YOUR_API_TOKEN_HERE";

// Simply add proxy=residential and (optionally) a country
const browserWSEndpoint =
  `wss://production-sfo.browserless.io?token=${TOKEN}&proxy=residential&proxyCountry=us`;
const url = "https://ipinfo.io/";
let browser;

try {
  browser = await puppeteer.connect({ browserWSEndpoint });
  const page = await browser.newPage();
  await page.setViewport({ width: 1920, height: 1080 });
  await page.goto(url);
  await page.screenshot({ path: "ip.png" });
} catch (e) {
  console.log("Error during script:", e.message);
} finally {
  browser && browser.close();
}

```

Sticky Sessions

By default, all requests will go through a random node in the proxy pool. This may not be desireable and can cause other issues. In order to keep your session "sticky" (use the same IP node), add a `proxySticky` parameter:

```codeBlockLines_p187
"http://production-sfo.browserless.io/content?token=YOUR_API_TOKEN_HERE&proxy=residential&proxyCountry=us&proxySticky";

```

### Playwright [â€‹](https://docs.browserless.io/baas/proxies\#playwright "Direct link to Playwright")

Our proxy service is also available for Playwright browsers. You only need to set the same parameters as for Puppeteer.

- Javascript
- Python
- Java
- C#

```codeBlockLines_p187
import playwright from "playwright-core";

const TOKEN = "YOUR_API_TOKEN_HERE"

// Simply add proxy=residential and (optionally) a country
const pwEndpoint = `wss://production-sfo.browserless.io/firefox/playwright?token=${TOKEN}&proxy=residential&proxyCountry=us`;
const browser = await playwright.firefox.connect(pwEndpoint);

const context = await browser.newContext();
const page = await context.newPage();

await page.goto("https://ipinfo.io/");
await page.screenshot({
  path: `firefox.png`,
});
await browser.close();

```

```codeBlockLines_p187
from playwright.sync_api import sync_playwright

TOKEN = "YOUR_API_TOKEN_HERE"
pw_endpoint = f"wss://production-sfo.browserless.io/firefox/playwright?token={TOKEN}&proxy=residential&proxyCountry=us"

with sync_playwright() as p:
    # Connect to the Browserless endpoint
    browser = p.firefox.connect_over_cdp(pw_endpoint)
    context = browser.new_context()
    page = context.new_page()

    # Navigate to the URL and take a screenshot
    page.goto("https://ipinfo.io/")
    page.screenshot(path="firefox.png")

    # Close the browser connection
    browser.close()

print("Screenshot saved as firefox.png")

```

```codeBlockLines_p187
import com.microsoft.playwright.*;

public class PlaywrightRemoteProxy {
    public static void main(String[] args) {
        String TOKEN = "YOUR_API_TOKEN_HERE";
        String PW_ENDPOINT = "wss://production-sfo.browserless.io/firefox/playwright?token="
            + TOKEN + "&proxy=residential&proxyCountry=us";

        try (Playwright playwright = Playwright.create()) {
            Browser browser = playwright.firefox().connect(PW_ENDPOINT);
            System.out.println("Connected to remote Firefox browser");

            BrowserContext context = browser.newContext();
            Page page = context.newPage();

            page.navigate("https://ipinfo.io/");
            page.screenshot(new Page.ScreenshotOptions().setPath("firefox.png"));
            System.out.println("Screenshot saved as firefox.png");

            browser.close();
        }
    }
}

```

```codeBlockLines_p187
using System;
using System.Threading.Tasks;
using Microsoft.Playwright;

class Program {
    static async Task Main(string[] args) {
        string TOKEN = "YOUR_API_TOKEN_HERE";
        string PW_ENDPOINT = $"wss://production-sfo.browserless.io/firefox/playwright?token={TOKEN}&proxy=residential&proxyCountry=us";

        var playwright = await Playwright.CreateAsync();
        var browser = await playwright.Firefox.ConnectAsync(PW_ENDPOINT);
        Console.WriteLine("Connected to remote Firefox browser");

        var context = await browser.NewContextAsync();
        var page = await context.NewPageAsync();

        await page.GotoAsync("https://ipinfo.io/");
        await page.ScreenshotAsync(new PageScreenshotOptions { Path = "firefox.png" });
        Console.WriteLine("Screenshot saved as firefox.png");

        await browser.CloseAsync();
    }
}

```

Sticky Sessions

By default, all requests will go through a random node in the proxy pool. This may not be desireable and can cause other issues. In order to keep your session "sticky" (use the same IP node), add a `proxySticky` parameter:

```codeBlockLines_p187
"http://production-sfo.browserless.io/content?token=YOUR_API_TOKEN_HERE&proxy=residential&proxyCountry=us&proxySticky";

```

### REST APIs [â€‹](https://docs.browserless.io/baas/proxies\#rest-apis "Direct link to REST APIs")

All of our REST-APIs function the same for proxying: simply add the proxy parameters you care about to the requests' query-string parameters, and you're all done. No need for credentials or otherwise.

Here's an examples of collecting [content](https://docs.browserless.io/baas/proxies#content), [pdf](https://docs.browserless.io/baas/proxies#pdf) and [screenshot](https://docs.browserless.io/baas/proxies#screenshot) from a United States Proxy:

#### Content [â€‹](https://docs.browserless.io/baas/proxies\#content "Direct link to Content")

- cURL
- Javascript
- Python
- Java
- C#

```codeBlockLines_p187
curl --request POST \
  --url "https://production-sfo.browserless.io/content?token=YOUR_API_TOKEN_HERE&proxyCountry=us&proxy=residential" \
  --header "Content-Type: application/json" \
  --data "{
    \"url\": \"https://ipinfo.io/\"
  }" \
  --output "ipinfo.html"

```

```codeBlockLines_p187
import fetch from 'node-fetch';
import { writeFile } from 'fs/promises';

const TOKEN = "YOUR_API_TOKEN_HERE";

const url = `https://production-sfo.browserless.io/content?token=${TOKEN}&proxyCountry=us&proxy=residential`;
const headers = {
    "Content-Type": "application/json"
};
const data = {
    url: "https://ipinfo.io/"
};

const fetchContent = async () => {
    const response = await fetch(url, {
        method: 'POST',
        headers: headers,
        body: JSON.stringify(data)
    });

    const html = await response.text();
    await writeFile("ipinfo.html", html);
    console.log("HTML content saved as ipinfo.html");
};

fetchContent();

```

```codeBlockLines_p187
import requests

TOKEN = "YOUR_API_TOKEN_HERE"
url = f"https://production-sfo.browserless.io/content?token={TOKEN}&proxyCountry=us&proxy=residential"
headers = {
    "Content-Type": "application/json"
}
data = {
    "url": "https://ipinfo.io/"
}

response = requests.post(url, headers=headers, json=data)

with open("ipinfo.html", "wb") as f:
    f.write(response.content)

print("HTML content saved as ipinfo.html")

```

```codeBlockLines_p187
import java.io.*;
import java.net.http.*;
import java.net.URI;

public class FetchHTML {
    public static void main(String[] args) {
        String TOKEN = "YOUR_API_TOKEN_HERE";
        String url = "https://production-sfo.browserless.io/content?token=" + TOKEN + "&proxyCountry=us&proxy=residential";

        HttpClient client = HttpClient.newHttpClient();

        String jsonData = """
            {
                "url": "https://ipinfo.io/"
            }
        """;

        HttpRequest request = HttpRequest.newBuilder()
            .uri(URI.create(url))
            .header("Content-Type", "application/json")
            .POST(HttpRequest.BodyPublishers.ofString(jsonData))
            .build();

        try {
            HttpResponse<InputStream> response = client.send(request, HttpResponse.BodyHandlers.ofInputStream());
            try (FileOutputStream fos = new FileOutputStream("ipinfo.html")) {
                response.body().transferTo(fos);
                System.out.println("HTML content saved to ipinfo.html");
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

```

```codeBlockLines_p187
using System;
using System.IO;
using System.Net.Http;
using System.Text;
using System.Text.Json;
using System.Threading.Tasks;

class Program {
    static async Task Main(string[] args) {
        string TOKEN = "YOUR_API_TOKEN_HERE";
        string url = $"https://production-sfo.browserless.io/content?token={TOKEN}&proxyCountry=us&proxy=residential";

        var payload = new {
            url = "https://ipinfo.io/"
        };

        var jsonContent = new StringContent(JsonSerializer.Serialize(payload), Encoding.UTF8, "application/json");

        using var httpClient = new HttpClient();
        try {
            var response = await httpClient.PostAsync(url, jsonContent);
            response.EnsureSuccessStatusCode();

            var contentStream = await response.Content.ReadAsStreamAsync();
            using (var fileStream = new FileStream("ipinfo.html", FileMode.Create, FileAccess.Write, FileShare.None)) {
                await contentStream.CopyToAsync(fileStream);
                Console.WriteLine("HTML content saved to ipinfo.html");
            }
        } catch (Exception e) {
            Console.WriteLine("Error: " + e.Message);
        }
    }
}

```

#### PDF [â€‹](https://docs.browserless.io/baas/proxies\#pdf "Direct link to PDF")

- cURL
- Javascript
- Python
- Java
- C#

```codeBlockLines_p187
curl --request POST \
  --url "https://production-sfo.browserless.io/pdf?token=YOUR_API_TOKEN_HERE&proxyCountry=us&proxy=residential" \
  --header "Content-Type: application/json" \
  --data "{
    \"url\": \"https://ipinfo.io/\"
  }" \
  --output "ipinfo.pdf"

```

```codeBlockLines_p187
import fetch from 'node-fetch';
import { writeFile } from 'fs/promises';

const TOKEN = "YOUR_API_TOKEN_HERE";
const url = `https://production-sfo.browserless.io/pdf?token=${TOKEN}&proxyCountry=us&proxy=residential`;
const headers = {
  "Content-Type": "application/json"
};
const data = {
  url: "https://ipinfo.io/"
};

const fetchPDF = async () => {
  const response = await fetch(url, {
    method: 'POST',
    headers: headers,
    body: JSON.stringify(data)
  });

  const pdfBuffer = await response.arrayBuffer();
  await writeFile("ipinfo.pdf", Buffer.from(pdfBuffer));
  console.log("PDF content saved as ipinfo.pdf");
};

fetchPDF();

```

```codeBlockLines_p187
import requests

TOKEN = "YOUR_API_TOKEN_HERE"
url = f"https://production-sfo.browserless.io/pdf?token={TOKEN}&proxyCountry=us&proxy=residential"
headers = {
    "Content-Type": "application/json"
}
data = {
    "url": "https://ipinfo.io/"
}

response = requests.post(url, headers=headers, json=data)

with open("ipinfo.pdf", "wb") as f:
    f.write(response.content)

print("PDF content saved as ipinfo.pdf")

```

```codeBlockLines_p187
import java.io.*;
import java.net.http.*;
import java.net.URI;

public class FetchPDF {
    public static void main(String[] args) {
        String TOKEN = "YOUR_API_TOKEN_HERE";
        String url = "https://production-sfo.browserless.io/pdf?token=" + TOKEN + "&proxyCountry=us&proxy=residential";

        HttpClient client = HttpClient.newHttpClient();

        String jsonData = """
            {
                "url": "https://ipinfo.io/"
            }
        """;

        HttpRequest request = HttpRequest.newBuilder()
            .uri(URI.create(url))
            .header("Content-Type", "application/json")
            .POST(HttpRequest.BodyPublishers.ofString(jsonData))
            .build();

        try {
            HttpResponse<InputStream> response = client.send(request, HttpResponse.BodyHandlers.ofInputStream());
            try (FileOutputStream fos = new FileOutputStream("ipinfo.pdf")) {
                response.body().transferTo(fos);
                System.out.println("PDF saved as ipinfo.pdf");
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

```

```codeBlockLines_p187
using System;
using System.IO;
using System.Net.Http;
using System.Text;
using System.Text.Json;
using System.Threading.Tasks;

class Program {
    static async Task Main(string[] args) {
        string TOKEN = "YOUR_API_TOKEN_HERE";
        string url = $"https://production-sfo.browserless.io/pdf?token={TOKEN}&proxyCountry=us&proxy=residential";

        var payload = new {
            url = "https://ipinfo.io/"
        };

        var jsonContent = new StringContent(JsonSerializer.Serialize(payload), Encoding.UTF8, "application/json");

        using var httpClient = new HttpClient();
        try {
            var response = await httpClient.PostAsync(url, jsonContent);
            response.EnsureSuccessStatusCode();

            var contentStream = await response.Content.ReadAsStreamAsync();
            using (var fileStream = new FileStream("ipinfo.pdf", FileMode.Create, FileAccess.Write, FileShare.None)) {
                await contentStream.CopyToAsync(fileStream);
                Console.WriteLine("PDF saved as ipinfo.pdf");
            }
        } catch (Exception e) {
            Console.WriteLine("Error: " + e.Message);
        }
    }
}

```

#### Screenshot [â€‹](https://docs.browserless.io/baas/proxies\#screenshot "Direct link to Screenshot")

- cURL
- Javascript
- Python
- Java
- C#

```codeBlockLines_p187
curl --request POST \
  --url "https://production-sfo.browserless.io/screenshot?token=YOUR_API_TOKEN_HERE&proxyCountry=us&proxy=residential" \
  --header "Content-Type: application/json" \
  --data "{
    \"url\": \"https://ipinfo.io/\"
  }" \
  --output "ipinfo.png"

```

```codeBlockLines_p187
import fetch from 'node-fetch';
import { writeFile } from 'fs/promises';

const TOKEN = "YOUR_API_TOKEN_HERE";
const url = `https://production-sfo.browserless.io/screenshot?token=${TOKEN}&proxyCountry=us&proxy=residential`;
const headers = {
  "Content-Type": "application/json"
};
const data = {
  url: "https://ipinfo.io/"
};

const fetchScreenshot = async () => {
  const response = await fetch(url, {
    method: 'POST',
    headers: headers,
    body: JSON.stringify(data)
  });

  const imageBuffer = await response.arrayBuffer();
  await writeFile("ipinfo.png", Buffer.from(imageBuffer));
  console.log("Screenshot saved as ipinfo.png");
};

fetchScreenshot();

```

```codeBlockLines_p187
import requests

TOKEN = "YOUR_API_TOKEN_HERE"
url = f"https://production-sfo.browserless.io/screenshot?token={TOKEN}&proxyCountry=us&proxy=residential"
headers = {
    "Content-Type": "application/json"
}
data = {
    "url": "https://ipinfo.io/"
}

response = requests.post(url, headers=headers, json=data)

with open("ipinfo.png", "wb") as f:
    f.write(response.content)

print("Screenshot saved as ipinfo.png")

```

```codeBlockLines_p187
import java.io.*;
import java.net.http.*;
import java.net.URI;

public class FetchScreenshot {
    public static void main(String[] args) {
        String TOKEN = "YOUR_API_TOKEN_HERE";
        String url = "https://production-sfo.browserless.io/screenshot?token=" + TOKEN + "&proxyCountry=us&proxy=residential";

        HttpClient client = HttpClient.newHttpClient();

        String jsonData = """
            {
                "url": "https://ipinfo.io/"
            }
        """;

        HttpRequest request = HttpRequest.newBuilder()
            .uri(URI.create(url))
            .header("Content-Type", "application/json")
            .POST(HttpRequest.BodyPublishers.ofString(jsonData))
            .build();

        try {
            HttpResponse<InputStream> response = client.send(request, HttpResponse.BodyHandlers.ofInputStream());
            try (FileOutputStream fos = new FileOutputStream("ipinfo.png")) {
                response.body().transferTo(fos);
                System.out.println("Screenshot saved as ipinfo.png");
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

```

```codeBlockLines_p187
using System;
using System.IO;
using System.Net.Http;
using System.Text;
using System.Text.Json;
using System.Threading.Tasks;

class Program {
    static async Task Main(string[] args) {
        string TOKEN = "YOUR_API_TOKEN_HERE";
        string url = $"https://production-sfo.browserless.io/screenshot?token={TOKEN}&proxyCountry=us&proxy=residential";

        var payload = new {
            url = "https://ipinfo.io/"
        };

        var jsonContent = new StringContent(JsonSerializer.Serialize(payload), Encoding.UTF8, "application/json");

        using var httpClient = new HttpClient();
        try {
            var response = await httpClient.PostAsync(url, jsonContent);
            response.EnsureSuccessStatusCode();

            var contentStream = await response.Content.ReadAsStreamAsync();
            using (var fileStream = new FileStream("ipinfo.png", FileMode.Create, FileAccess.Write, FileShare.None)) {
                await contentStream.CopyToAsync(fileStream);
                Console.WriteLine("Screenshot saved as ipinfo.png");
            }
        } catch (Exception e) {
            Console.WriteLine("Error: " + e.Message);
        }
    }
}

```

## Third Party Proxies [â€‹](https://docs.browserless.io/baas/proxies\#third-party-proxies "Direct link to Third Party Proxies")

Both browserless, and Chrome itself, support the usage of external proxies. If you want to use an external, or 3rd party proxy, please continue to read below. In general there's two things you'll have to do:

- Specify the address of where the proxy is with the `--proxy-server` switch.
- Optionally, you'll also need to send in your username and password if the proxy is authenticated.

### Specifying the proxy [â€‹](https://docs.browserless.io/baas/proxies\#specifying-the-proxy "Direct link to Specifying the proxy")

Regardless of whether or not you're using our REST API's or the puppeteer integration, you'll need to specify _where_ the proxy is. Chrome has a command-line flag to do this, and we support this in browserless via the following query-string parameter:

```codeBlockLines_p187
?--proxy-server=https://YOUR-PROXY-SERVER-DOMAIN:PORT

```

You can set this parameter in our [live debugger](https://chrome.browserless.io/debugger) by clicking on the gear icon on the left panel and modifying the Browser URL field.

If you're using a proxy that doesn't require a password (maybe just an IP address filter), then that's it! You're free to now use this proxy going forward! Otherwise read on.

### Using username and password [â€‹](https://docs.browserless.io/baas/proxies\#using-username-and-password "Direct link to Using username and password")

#### Method 1: page.authenticate (Puppeteer) [â€‹](https://docs.browserless.io/baas/proxies\#method-1-pageauthenticate-puppeteer "Direct link to Method 1: page.authenticate (Puppeteer)")

Most proxies will require some means of authentication. There's generally two ways you can do this in Puppeteer, and also in browserless. The first more common method is the `page.authenticate`:

```codeBlockLines_p187
await page.authenticate({
  username: 'joel',
  password: 'browserless-rocks',
});

```

Doing this will apply these parameters to your network requests going forward.

In our REST API's you can specify these fields with the following in your POST JSON body. These parameters work for the `pdf`, `content` and `screenshot` APIs:

```codeBlockLines_p187
{
  "authenticate": {
    "username": "joel",
    "password": "browserless-rocks"
  }
}

```

#### Method 2: page.setExtraHTTPHeaders (Puppeteer) [â€‹](https://docs.browserless.io/baas/proxies\#method-2-pagesetextrahttpheaders-puppeteer "Direct link to Method 2: page.setExtraHTTPHeaders (Puppeteer)")

The other mechanism is to use HTTP headers to send in extra authorization information. Puppeteer makes this pretty easy by allowing us to send in new HTTP headers via `page.setExtraHTTPHeaders`:

> NOTE: This is deprecated in most libraries now, so it's worth keeping in mind that using authentication methods in each library is now the standard.

```codeBlockLines_p187
// Remember to base64 encode your username:password!
await page.setExtraHTTPHeaders({
  'Proxy-Authorization': 'Basic username:password',
  // OR
  Authorization: 'Basic username:password',
});

```

Refer to your libraries documentation on what the name of the headers is, and how to properly encode it.

We also allow this in our REST APIs as well, via the `setExtraHTTPHeaders` property:

```codeBlockLines_p187
{
  "setExtraHTTPHeaders": {
    "Proxy-Authorization": "Basic username:password",
    // OR
    "Authorization": "Basic username:password"
  }
}

```

This will allow your REST APIs to utilize the prior provided proxy!

### Using Proxies with Playwright [â€‹](https://docs.browserless.io/baas/proxies\#using-proxies-with-playwright "Direct link to Using Proxies with Playwright")

Playwright handles proxies differently than Puppeteer. Instead of using `page.authenticate()` or `setExtraHTTPHeaders()`, Playwright allows you to specify proxy settings directly at the context level, which means all pages created from that context will use the specified proxy.

#### Method: browser.newContext() with proxy option (Playwright) [â€‹](https://docs.browserless.io/baas/proxies\#method-browsernewcontext-with-proxy-option-playwright "Direct link to Method: browser.newContext() with proxy option (Playwright)")

When using Playwright with browserless, you can set up a proxy by providing proxy configuration to the `newContext()` method:

```codeBlockLines_p187
import playwright from "playwright-core";

const browser = await playwright.chromium.connectOverCDP(
  "wss://production-sfo.browserless.io?token=YOUR_API_TOKEN_HERE"
);
const context = await browser.newContext({
  proxy: {
    server: "http://domain:port",
    username: "username",
    password: "password",
  },
});
const page = await context.newPage();

await page.goto("https://icanhazip.com/");
console.log(await page.content());

await browser.close();

```

- [Built-in Residential Proxy](https://docs.browserless.io/baas/proxies#built-in-residential-proxy)
  - [Puppeteer](https://docs.browserless.io/baas/proxies#puppeteer)
  - [Playwright](https://docs.browserless.io/baas/proxies#playwright)
  - [REST APIs](https://docs.browserless.io/baas/proxies#rest-apis)
- [Third Party Proxies](https://docs.browserless.io/baas/proxies#third-party-proxies)
  - [Specifying the proxy](https://docs.browserless.io/baas/proxies#specifying-the-proxy)
  - [Using username and password](https://docs.browserless.io/baas/proxies#using-username-and-password)
  - [Using Proxies with Playwright](https://docs.browserless.io/baas/proxies#using-proxies-with-playwright)

---

### Uploading files to sites | Browserless.io
Original URL: https://docs.browserless.io/baas/recipes/uploading-files

[Skip to main content](https://docs.browserless.io/baas/recipes/uploading-files#__docusaurus_skipToContent_fallback)



When automating browser tasks, you may need to upload files to websites. This guide demonstrates how to upload files to sites using Puppeteer with Browserless.

## Example: Uploading an image to a compression site [â€‹](https://docs.browserless.io/baas/recipes/uploading-files\#example-uploading-an-image-to-a-compression-site "Direct link to Example: Uploading an image to a compression site")

The following example shows how to upload an image file to imagecompressor.com, a site that optimizes images:

```codeBlockLines_p187
import puppeteer from "puppeteer-core";
import path from 'path';

const sleep = (ms) => new Promise((res) => setTimeout(res, ms));

const API_TOKEN = "YOUR_API_TOKEN_HERE";
const BROWSER_WS_ENDPOINT = `wss://production-sfo.browserless.io?token=${API_TOKEN}`;

(async() => {
    const browser = await puppeteer.connect({ browserWSEndpoint: BROWSER_WS_ENDPOINT });
    const page = await browser.newPage();

    // Navigate to the image compressor website
    console.log('Navigating to imagecompressor.com...');
    await page.goto('https://imagecompressor.com/');

    // Wait for the file input to be available
    console.log('Waiting for file input...');
    await page.waitForSelector('#fileSelector');

    // Get the file input element
    const fileInput = await page.$('#fileSelector');

    // Upload the image
    console.log('Uploading image...');
    await fileInput.uploadFile(path.join(process.cwd(), 'screenshot.png'));

    // Wait 5 seconds to allow upload to process
    console.log('Waiting 5 seconds to allow upload...');
    await sleep(5000);

    // Take a screenshot to verify upload
    await page.screenshot({ path: 'imagecompressor_upload_result.png' });
    console.log('Screenshot taken: imagecompressor_upload_result.png');

    // Always close your sessions
    await browser.close();
})().catch((e) => {
    console.error('Error:', e);
});

```

## How it works [â€‹](https://docs.browserless.io/baas/recipes/uploading-files\#how-it-works "Direct link to How it works")

1. **Connect to Browserless**: The script connects to Browserless using the WebSocket endpoint.
2. **Navigate to the target site**: Opens the image compression website.
3. **Locate the file input**: Waits for the file input element to be available.
4. **Upload the file**: Uses Puppeteer's `uploadFile` method to upload a local file.
5. **Wait for processing**: Allows time for the upload to complete.
6. **Verify the result**: Takes a screenshot to confirm the upload was successful.
7. **Clean up**: Closes the browser session.

## Tips for file uploads [â€‹](https://docs.browserless.io/baas/recipes/uploading-files\#tips-for-file-uploads "Direct link to Tips for file uploads")

- Make sure the file exists at the specified path.
- Some sites may require clicking a button after selecting the file.
- For more complex upload forms, you might need to fill out additional fields.
- Always wait for the upload to complete before proceeding with further actions.

- [Example: Uploading an image to a compression site](https://docs.browserless.io/baas/recipes/uploading-files#example-uploading-an-image-to-a-compression-site)
- [How it works](https://docs.browserless.io/baas/recipes/uploading-files#how-it-works)
- [Tips for file uploads](https://docs.browserless.io/baas/recipes/uploading-files#tips-for-file-uploads)

---

### Close Browser Sessions | Browserless.io
Original URL: https://docs.browserless.io/baas/session-management/close-session

[Skip to main content](https://docs.browserless.io/baas/session-management/close-session#__docusaurus_skipToContent_fallback)


When finished with work, or on errors, make sure you run `browser.close` so that other sessions may start. browserless _will_ terminate long-running sessions via the timeout setting, but it's always a good idea to close tidly whenever you're finished.

- Puppeteer
- Playwright

```codeBlockLines_p187
import puppeteer from "puppeteer-core";

const TOKEN = "YOUR_API_TOKEN_HERE";

const browser = await puppeteer.connect({
  browserWSEndpoint: `wss://production-sfo.browserless.io?token=${TOKEN}`,
});

const page = await browser.newPage();

try {
  await page.goto("https://www.browserless.io/");
  await page.screenshot({ path: "./browserless.png" });
  browser.close();
} catch (error) {
  console.error({ error }, "Something happened!");
  browser.close();
}

```

```codeBlockLines_p187
import playwright from "playwright";

const TOKEN = "YOUR_API_TOKEN_HERE";

const browser = await playwright.chromium.connectOverCDP(
  `wss://production-sfo.browserless.io?token=${TOKEN}`
);

const page = await browser.newPage();

try {
  await page.goto("https://www.browserless.io/");
  await page.screenshot({ path: "./browserless.png" });
  browser.close();
} catch (error) {
  console.error({ error }, "Something happened!");
  browser.close();
}

```

---

### Reconnect to an existing Browser | Browserless.io
Original URL: https://docs.browserless.io/baas/session-management/reconnect

[Skip to main content](https://docs.browserless.io/baas/session-management/reconnect#__docusaurus_skipToContent_fallback)



note

Looking for full developer docs? [See them here](https://docs.browserless.io/open-api#section/The-Browserless-CDP-API/Browserless.reconnect).
This feature is only available on the Enterprise plans.

Reconnecting to an existing browser is useful if you want to avoid logging in multiple times, or if you leave a process pending and want to open a websocket connection again once you're ready to resume automation, amongst other use cases.

If you want to reconnect to a browser, all you have to do is fetch the browser's websocket endpoint which you can reconnect with later. You do so by using a CDP connection to the browser and triggering the `Browserless.reconnect` CDP command, which will keep that browser alive and allow you to reconnect to it within the specified timeout. This virtually replaces the `keepalive` flag that was previously used in V1.

## Sample snippet [â€‹](https://docs.browserless.io/baas/session-management/reconnect\#sample-snippet "Direct link to Sample snippet")

You can use the returned `browserWSEndpoint` to reconnect to a browser and continue working. The example below takes a screenshot after reconnecting:

- Puppeteer
- Playwright
- Python
- Java
- C#

```codeBlockLines_p187
import puppeteer from 'puppeteer-core';

const url = 'https://www.example.com';
const sleep = (ms) => new Promise((res) => setTimeout(res, ms));

const queryParams = new URLSearchParams({
  token: 'YOUR_API_TOKEN_HERE',
  timeout: 60000,
}).toString();

(async () => {
  const browser = await puppeteer.connect({
    browserWSEndpoint: `wss://production-sfo.browserless.io/chromium?${queryParams}`,
  });
  const page = await browser.newPage();
  const cdp = await page.createCDPSession();
  await page.goto(url);

  // Allow this browser to run for 1 minute, then shut down if nothing connects to it.
  // Defaults to the overall timeout set on the instance, which is 5 minutes if not specified.
  const { error, browserWSEndpoint } = await cdp.send('Browserless.reconnect', {
    timeout: 60000,
  });

  if (error) throw error;
  console.log(`${browserWSEndpoint}?${queryParams}`);

  await browser.close();
  //Reconnect using the browserWSEndpoint that was returned from the CDP command.
  const browserReconnect = await puppeteer.connect({
    browserWSEndpoint: `${browserWSEndpoint}?${queryParams}`,
  });
  const [pageReconnect] = await browserReconnect.pages();
  await pageReconnect.goto(url);
  await sleep(2000);
  await pageReconnect.screenshot({
    path: 'reconnected.png',
    fullPage: true,
  });
  await browserReconnect.close();

})().catch((e) => {
  console.error(e);
  process.exit(1);
});

```

```codeBlockLines_p187
import playwright from 'playwright-core';

const url = 'https://www.example.com';
const sleep = (ms) => new Promise((res) => setTimeout(res, ms));

const queryParams = new URLSearchParams({
  token: 'YOUR_API_TOKEN_HERE',
  timeout: 60000,
}).toString();

(async () => {
  const browser = await playwright.chromium.connectOverCDP(
    `wss://production-sfo.browserless.io/chromium?${queryParams}`
  );
  const page = await browser.newPage();
  const cdpSession = await page.context().newCDPSession(page);
  await page.goto(url);

  // Allow this browser to run for 1 minute, then shut down if nothing connects to it.
  // Defaults to the overall timeout set on the instance, which is 5 minutes if not specified.
  const { error, browserWSEndpoint } = await cdpSession.send('Browserless.reconnect', {
    timeout: 60000,
  });

  if (error) throw new Error(error);
  console.log(`${browserWSEndpoint}?${queryParams}`);

  await browser.close();

  // Reconnect using the browserWSEndpoint that was returned from the CDP command.
  const browserReconnect = await playwright.chromium.connectOverCDP(
    `${browserWSEndpoint}?${queryParams}`
  );
  const pageReconnect = await browserReconnect.newPage();
  await pageReconnect.goto(url);
  await sleep(2000);
  await pageReconnect.screenshot({
    path: 'reconnected.png',
    fullPage: true,
  });
  await browserReconnect.close();
})().catch((e) => {
  console.error(e);
  process.exit(1);
});

```

```codeBlockLines_p187
from playwright.sync_api import sync_playwright
from time import sleep

url = "https://www.example.com"
query_params = "token=YOUR_API_TOKEN_HERE&timeout=60000"
ws_endpoint = f"wss://production-sfo.browserless.io/chromium?{query_params}"

with sync_playwright() as playwright:
    # Connect to the remote Chromium browser
    browser = playwright.chromium.connect_over_cdp(ws_endpoint)
    context = browser.new_context()
    page = context.new_page()
    cdp_session = context.new_cdp_session(page)

    # Navigate to the URL
    page.goto(url)

    # Send the `Browserless.reconnect` command
    response = cdp_session.send("Browserless.reconnect", {"timeout": 60000})
    browser_ws_endpoint = response.get("browserWSEndpoint")
    if response.get("error") is not None:
        raise Exception(response["error"])

    print(f"{browser_ws_endpoint}?{query_params}")

    # Close the current browser connection
    browser.close()

    # Reconnect using the returned WebSocket endpoint
    browser_reconnect = playwright.chromium.connect_over_cdp(browser_ws_endpoint + "?" + query_params)
    context_reconnect = browser_reconnect.new_context()
    page_reconnect = context_reconnect.new_page()
    page_reconnect.goto(url)

    sleep(2)

    # Take a screenshot
    page_reconnect.screenshot(path="reconnected.png", full_page=True)

    browser_reconnect.close()

```

```codeBlockLines_p187
import com.microsoft.playwright.*;
import com.google.gson.JsonObject;
import java.nio.file.Paths;

public class App {
  public static void main(String[] args) {
    String url = "https://www.example.com";
    String token = "YOUR_API_TOKEN_HERE";
    String queryParams = String.format("token=%s&timeout=60000", token);
    String wsEndpoint = String.format("wss://production-sfo.browserless.io/chromium?%s", queryParams);

    try (Playwright playwright = Playwright.create()) {
      // Connect to the remote Chromium browser
      Browser browser = playwright.chromium().connectOverCDP(wsEndpoint);
      BrowserContext context = browser.newContext();
      Page page = context.newPage();
      CDPSession cdpSession = page.context().newCDPSession(page);

      // Navigate to the URL
      page.navigate(url);

      // Send the `Browserless.reconnect` command using a JsonObject
      JsonObject reconnectParams = new JsonObject();
      reconnectParams.addProperty("timeout", 60000);
      JsonObject response = cdpSession.send("Browserless.reconnect", reconnectParams);

      // Extract the `browserWSEndpoint` from the response
      String browserWSEndpoint = response.get("browserWSEndpoint").getAsString();
      if (response.has("error") && !response.get("error").isJsonNull()) {
        throw new RuntimeException("Error: " + response.get("error").getAsString());
      }

      System.out.println(browserWSEndpoint + "?" + queryParams);

      // Close the current browser connection
      browser.close();

      // Reconnect using the returned WebSocket endpoint
      Browser browserReconnect = playwright.chromium().connectOverCDP(browserWSEndpoint + "?" + queryParams);
      BrowserContext contextReconnect = browserReconnect.newContext();
      Page pageReconnect = contextReconnect.newPage();
      pageReconnect.navigate(url);
      Thread.sleep(2000);

      // Take a screenshot
      pageReconnect.screenshot(new Page.ScreenshotOptions()
          .setPath(Paths.get("reconnected.png"))
          .setFullPage(true));

      browserReconnect.close();
    } catch (Exception ex) {
      System.out.println("Exception: " + ex.Message);
    }
  }
}

```

```codeBlockLines_p187
using Microsoft.Playwright;
using System;
using System.Collections.Generic;
using System.Threading.Tasks;

class BrowserlessReconnect
{
    public static async Task Main(string[] args)
    {
        string url = "https://www.example.com";
        string queryParams = "token=YOUR_API_TOKEN_HERE&timeout=60000";
        string wsEndpoint = $"wss://production-sfo.browserless.io/chromium?{queryParams}";

        using var playwright = await Playwright.CreateAsync();

        try
        {
            // Connect to the remote Chromium browser
            var browser = await playwright.Chromium.ConnectOverCDPAsync(wsEndpoint);
            var context = await browser.NewContextAsync();
            var page = await context.NewPageAsync();
            var cdpSession = await context.NewCDPSessionAsync(page);

            // Navigate to the URL
            await page.GotoAsync(url);

            // Send the `Browserless.reconnect` command
            var response = await cdpSession.SendAsync("Browserless.reconnect", new { timeout = 60000 });

            if (response.TryGetValue("error", out var error) && error != null)
            {
                throw new Exception($"Error: {error}");
            }

            string browserWSEndpoint = response["browserWSEndpoint"].ToString();
            System.Console.WriteLine(browserWSEndpoint + "?" + queryParams);

            // Close the current browser connection
            await browser.CloseAsync();

            // Reconnect using the returned WebSocket endpoint
            var browserReconnect = await playwright.Chromium.ConnectOverCDPAsync(browserWSEndpoint + "?" + queryParams);
            var contextReconnect = await browserReconnect.NewContextAsync();
            var pageReconnect = await contextReconnect.NewPageAsync();
            await pageReconnect.GotoAsync(url);
            await Task.Delay(2000);

            // Take a screenshot
            await pageReconnect.ScreenshotAsync(new PageScreenshotOptions
            {
                Path = "reconnected.png",
                FullPage = true
            });

            await browserReconnect.CloseAsync();
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Exception: {ex.Message}");
        }
    }
}

```

## Session Timeout [â€‹](https://docs.browserless.io/baas/session-management/reconnect\#session-timeout "Direct link to Session Timeout")

By default, your sessions are governed by a timeout. This is set via your account page for the hosted service. You can override this behavior.

- If you are running `BaaS` in Docker, you can specify a `TIMEOUT` environment variable in the `docker run` command to override the default timeout of 30 seconds.

- If you need to override the timeout on a per-job basis, simply specify a `timeout` parameter in your connect calls query-parameters, with the value being the time in milliseconds for the session to execute:



- Puppeteer
- Playwright

```codeBlockLines_p187
import puppeteer from "puppeteer-core";

const browser = await puppeteer.connect({
  browserWSEndpoint: `wss://production-sfo.browserless.io/?token=YOUR_API_TOKEN_HERE&timeout=10000`,
});
// ...

```

```codeBlockLines_p187
import playwright from "playwright";

const browser = await playwright.chromium.connectOverCDP(
  `wss://production-sfo.browserless.io/?token=YOUR_API_TOKEN_HERE&timeout=10000`
);

```

note

For other runtimes and selenium libraries be sure to consult your libraries documentation, or [contact us](https://www.browserless.io/contact)

- [Sample snippet](https://docs.browserless.io/baas/session-management/reconnect#sample-snippet)
- [Session Timeout](https://docs.browserless.io/baas/session-management/reconnect#session-timeout)

---

### Recording Sessions with LiveURL Integration | Browserless.io
Original URL: https://docs.browserless.io/baas/session-management/recording-liveurl

[Skip to main content](https://docs.browserless.io/baas/session-management/recording-liveurl#__docusaurus_skipToContent_fallback)



This guide demonstrates how to use Browserless's recording capabilities alongside LiveURL for interactive sessions. This combination is particularly useful when you need to:

- Record user interactions for training or debugging
- Provide a live interactive experience while capturing the session
- Monitor login processes with visual feedback
- Create documentation with recorded sessions
- Debug complex user flows with visual playback

## Prerequisites [â€‹](https://docs.browserless.io/baas/session-management/recording-liveurl\#prerequisites "Direct link to Prerequisites")

Before running this script, make sure you have:

1. Node.js installed on your system
2. A browserless API key
3. The required npm packages:







```codeBlockLines_p187
npm install puppeteer-core

```


## Complete Example [â€‹](https://docs.browserless.io/baas/session-management/recording-liveurl\#complete-example "Direct link to Complete Example")

Here's a complete example that shows how to:

1. Connect to Browserless with recording enabled
2. Generate a LiveURL for user interaction
3. Monitor for successful login with visual feedback
4. Save the recording for later playback

```codeBlockLines_p187
import puppeteer from 'puppeteer-core';
import fs from "fs";

// Utility function to create a delay
const sleep = (ms) => new Promise((res) => setTimeout(res, ms));

// Configure browserless.io connection parameters
const queryParams = new URLSearchParams({
  token: "YOUR-API-KEY",
  timeout: 180000,
  headless: true,
}).toString();

// Main automation function
(async() => {
  let browser = null;

  try {
    // Connect to browserless.io with recording enabled
    browser = await puppeteer.connect({
      browserWSEndpoint: `wss://production-sfo.browserless.io?record=true&${queryParams}`,
    });
    console.log('Connected to browserless.io');

    // Create a new page and navigate to the login form
    const page = await browser.newPage();
    await page.goto('https://practicetestautomation.com/practice-test-login/', {
      waitUntil: 'networkidle2'
    });
    console.log('Navigated to login page');

    // Set up CDP session for browserless features
    const cdp = await page.createCDPSession();

    // Start recording the session
    await cdp.send("Browserless.startRecording");

    // Generate live URL for user interaction
    const { liveURL } = await cdp.send('Browserless.liveURL', {
      timeout: 600_000
    });
    console.log('Click for live experience:', liveURL);

    // Monitor for successful login
    await page.waitForFunction(() => {
      // Check for success indicators in URL or page content
      const currentUrl = window.location.href;
      const isSuccess = currentUrl.includes('logged-in') ||
                       currentUrl.includes('dashboard') ||
                       document.querySelector('.post-login') !== null;

      if (isSuccess) {
        // Show success notification
        const notification = document.createElement('div');
        notification.style.cssText = `
          position: fixed;
          top: 20px;
          left: 50%;
          transform: translateX(-50%);
          background-color: #4CAF50;
          color: white;
          padding: 15px 30px;
          border-radius: 5px;
          z-index: 9999;
          font-family: Arial, sans-serif;
          box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        `;
        notification.textContent = 'You can safely close the tab, login was successful.';
        document.body.appendChild(notification);
        return true;
      }
      return false;
    }, { timeout: 60000 }); // Wait up to 60 seconds for successful login

    // Wait for user to close the live URL
    await new Promise((r) => cdp.on('Browserless.liveComplete', r));
    console.log(`Live URL closed on page: ${page.url()}`);
    console.log('You can now continue automation on this site.');

    // Stop recording and save the recording
    const response = await cdp.send("Browserless.stopRecording");
    const file = Buffer.from(response.value, "binary");
    await fs.promises.writeFile("./record.webm", file);
    console.log('Recording saved as record.webm');

  } catch (error) {
    // Log any errors that occur during execution
    console.error('An error occurred:', error);
  } finally {
    // Ensure browser is always closed, even if an error occurs
    if (browser) {
      try {
        await browser.close();
        console.log('Browser closed successfully');
      } catch (closeError) {
        console.error('Error closing browser:', closeError);
      }
    }
  }
})().catch((e) => {
  console.error('Fatal error:', e);
  process.exit(1);
});

```

## Understanding the Code [â€‹](https://docs.browserless.io/baas/session-management/recording-liveurl\#understanding-the-code "Direct link to Understanding the Code")

### 1\. Initial Setup [â€‹](https://docs.browserless.io/baas/session-management/recording-liveurl\#1-initial-setup "Direct link to 1. Initial Setup")

- The script uses environment variables for secure API key storage
- It configures a 3-minute timeout for the browser session
- The `queryParams` object contains all necessary parameters for the Browserless connection

### 2\. Browser Connection [â€‹](https://docs.browserless.io/baas/session-management/recording-liveurl\#2-browser-connection "Direct link to 2. Browser Connection")

- Connects to Browserless with recording enabled via the `record=true` parameter
- Creates a new page and navigates to the target login form
- Sets up a CDP session for advanced browser control

### 3\. Recording and LiveURL Integration [â€‹](https://docs.browserless.io/baas/session-management/recording-liveurl\#3-recording-and-liveurl-integration "Direct link to 3. Recording and LiveURL Integration")

- Starts the recording session using `Browserless.startRecording`
- Generates a LiveURL with a 10-minute timeout
- This URL allows users to interact with the page while being recorded

### 4\. Login Monitoring [â€‹](https://docs.browserless.io/baas/session-management/recording-liveurl\#4-login-monitoring "Direct link to 4. Login Monitoring")

- Uses `waitForFunction` to monitor for successful login indicators
- Adds a visual notification when login is successful
- Waits for the user to close the LiveURL before proceeding

### 5\. Recording Management [â€‹](https://docs.browserless.io/baas/session-management/recording-liveurl\#5-recording-management "Direct link to 5. Recording Management")

- Stops the recording when the session is complete
- Saves the recording as a WebM file for later playback
- Ensures proper cleanup of browser resources

note

All recordings are saved in WebM format, which provides efficient compression while maintaining quality. This format is compatible with most modern browsers and video players.

## Best Practices [â€‹](https://docs.browserless.io/baas/session-management/recording-liveurl\#best-practices "Direct link to Best Practices")

### 1\. Error Handling [â€‹](https://docs.browserless.io/baas/session-management/recording-liveurl\#1-error-handling "Direct link to 1. Error Handling")

- Always wrap the main execution in a try-catch block
- Use a finally block to ensure browser cleanup
- Log errors with meaningful messages

### 2\. Session Management [â€‹](https://docs.browserless.io/baas/session-management/recording-liveurl\#2-session-management "Direct link to 2. Session Management")

- Set appropriate timeouts for your use case
- Store your API key securely
- Monitor the LiveURL for debugging

### 3\. Recording Optimization [â€‹](https://docs.browserless.io/baas/session-management/recording-liveurl\#3-recording-optimization "Direct link to 3. Recording Optimization")

- Start recording only when needed to reduce file size
- Consider recording quality settings for different use cases
- Save recordings with meaningful names and timestamps

## Common Use Cases [â€‹](https://docs.browserless.io/baas/session-management/recording-liveurl\#common-use-cases "Direct link to Common Use Cases")

### 1\. User Training [â€‹](https://docs.browserless.io/baas/session-management/recording-liveurl\#1-user-training "Direct link to 1. User Training")

- Record user interactions for training materials
- Create step-by-step guides with visual demonstrations
- Document complex workflows for team reference

### 2\. Debugging and Support [â€‹](https://docs.browserless.io/baas/session-management/recording-liveurl\#2-debugging-and-support "Direct link to 2. Debugging and Support")

- Capture user-reported issues for troubleshooting
- Record session replays for bug reports
- Provide visual context for support tickets

### 3\. Quality Assurance [â€‹](https://docs.browserless.io/baas/session-management/recording-liveurl\#3-quality-assurance "Direct link to 3. Quality Assurance")

- Record test sessions for regression testing
- Document expected behavior for new features
- Create visual test cases for team review

## Advanced Techniques [â€‹](https://docs.browserless.io/baas/session-management/recording-liveurl\#advanced-techniques "Direct link to Advanced Techniques")

### 1\. Custom Recording Triggers [â€‹](https://docs.browserless.io/baas/session-management/recording-liveurl\#1-custom-recording-triggers "Direct link to 1. Custom Recording Triggers")

```codeBlockLines_p187
// Start recording only after specific conditions are met
await page.waitForSelector('.login-form');
await cdp.send("Browserless.startRecording");

```

### 2\. Audio Recording [â€‹](https://docs.browserless.io/baas/session-management/recording-liveurl\#2-audio-recording "Direct link to 2. Audio Recording")

```codeBlockLines_p187
// Audio is automatically captured with the recording
// No additional configuration is needed
await cdp.send("Browserless.startRecording");

```

### 3\. Conditional Recording [â€‹](https://docs.browserless.io/baas/session-management/recording-liveurl\#3-conditional-recording "Direct link to 3. Conditional Recording")

```codeBlockLines_p187
// Only record if a specific element is present
const hasLoginForm = await page.$('.login-form');
if (hasLoginForm) {
  await cdp.send("Browserless.startRecording");
}

```

- [Prerequisites](https://docs.browserless.io/baas/session-management/recording-liveurl#prerequisites)
- [Complete Example](https://docs.browserless.io/baas/session-management/recording-liveurl#complete-example)
- [Understanding the Code](https://docs.browserless.io/baas/session-management/recording-liveurl#understanding-the-code)
  - [1\. Initial Setup](https://docs.browserless.io/baas/session-management/recording-liveurl#1-initial-setup)
  - [2\. Browser Connection](https://docs.browserless.io/baas/session-management/recording-liveurl#2-browser-connection)
  - [3\. Recording and LiveURL Integration](https://docs.browserless.io/baas/session-management/recording-liveurl#3-recording-and-liveurl-integration)
  - [4\. Login Monitoring](https://docs.browserless.io/baas/session-management/recording-liveurl#4-login-monitoring)
  - [5\. Recording Management](https://docs.browserless.io/baas/session-management/recording-liveurl#5-recording-management)
- [Best Practices](https://docs.browserless.io/baas/session-management/recording-liveurl#best-practices)
  - [1\. Error Handling](https://docs.browserless.io/baas/session-management/recording-liveurl#1-error-handling)
  - [2\. Session Management](https://docs.browserless.io/baas/session-management/recording-liveurl#2-session-management)
  - [3\. Recording Optimization](https://docs.browserless.io/baas/session-management/recording-liveurl#3-recording-optimization)
- [Common Use Cases](https://docs.browserless.io/baas/session-management/recording-liveurl#common-use-cases)
  - [1\. User Training](https://docs.browserless.io/baas/session-management/recording-liveurl#1-user-training)
  - [2\. Debugging and Support](https://docs.browserless.io/baas/session-management/recording-liveurl#2-debugging-and-support)
  - [3\. Quality Assurance](https://docs.browserless.io/baas/session-management/recording-liveurl#3-quality-assurance)
- [Advanced Techniques](https://docs.browserless.io/baas/session-management/recording-liveurl#advanced-techniques)
  - [1\. Custom Recording Triggers](https://docs.browserless.io/baas/session-management/recording-liveurl#1-custom-recording-triggers)
  - [2\. Audio Recording](https://docs.browserless.io/baas/session-management/recording-liveurl#2-audio-recording)
  - [3\. Conditional Recording](https://docs.browserless.io/baas/session-management/recording-liveurl#3-conditional-recording)

---

### Screencast API | Browserless.io
Original URL: https://docs.browserless.io/baas/session-management/screencasting

[Skip to main content](https://docs.browserless.io/baas/session-management/screencasting#__docusaurus_skipToContent_fallback)



The screencast API allows for generating `webm` video files on demand of your Puppeteer or Playwright scripts. The API supports recording audio.

The resulting video's dimensions are inherited by the width and height of the browser. You can change this very easily by calling `page.setViewport` with your dimensions in your scripts as well as setting `--window-size` in the URL.

## Usage [â€‹](https://docs.browserless.io/baas/session-management/screencasting\#usage "Direct link to Usage")

This API works over CDP, thus you can use with with Puppeteer, Playwright, ChromeCDP or any other library that support CDP connections. **You must add `record=true` to your connection string in order to use this API**.

- Puppeteer
- Playwright

```codeBlockLines_p187
import fs from "fs";
import puppeteer from "puppeteer-core";

const sleep = (ms) => new Promise((res) => setTimeout(res, ms));
const token = "YOUR_API_TOKEN_HERE"

const wsEndpoint = `wss://production-sfo.browserless.io?token=${token}&headless=false&stealth&record=true`;
const browser = await puppeteer.connect({ browserWSEndpoint: wsEndpoint });
const page = await browser.newPage();
await page.goto("https://browserless.io");

// The magic happens here
const cdp = await page.createCDPSession();
await cdp.send("Browserless.startRecording");
await sleep(15000);
const response = await cdp.send("Browserless.stopRecording");
// â˜ï¸ The response is a string containing a valid webm file

const file = Buffer.from(response.value, "binary");
await fs.promises.writeFile("./recording.webm", file);

await browser.close();

```

- Javascript
- Python
- Java
- C#

warning

On Playwright, you **must** use the already existing context and page and avoid creating new ones.

```codeBlockLines_p187
import playwright from "playwright";
import fs from "fs/promises";

const sleep = (ms) => new Promise((res) => setTimeout(res, ms));
const token = "YOUR_API_TOKEN_HERE";

const wsEndpoint = `wss://production-sfo.browserless.io?token=${token}&headless=false&stealth&record=true`;

(async () => {
  // Connect to the remote browser
  const browser = await playwright.chromium.connectOverCDP(wsEndpoint);

  // Reuse the context and page
  const context = browser.contexts()[0];
  const page = context.pages()[0];
  await page.goto("https://browserless.io");

  // The magic happens here
  const cdpSession = await page.context().newCDPSession(page);
  await cdpSession.send("Browserless.startRecording");
  // Wait for some time while recording
  await sleep(15000);

  // Stop recording and get the response
  const response = await cdpSession.send("Browserless.stopRecording");
  const file = Buffer.from(response.value, "binary");

  // Save the recording as a webm file
  await fs.writeFile("./recording.webm", file);

  await browser.close();
})();

```

warning

On Playwright, you **must** use the already existing context and page and avoid creating new ones.

```codeBlockLines_p187
from playwright.sync_api import sync_playwright
import time

TOKEN = "YOUR_API_TOKEN_HERE"
WS_ENDPOINT = (
    f"wss://production-sfo.browserless.io?token={TOKEN}&headless=false&stealth&record=true"
)

with sync_playwright() as playwright:
    # Connect to the remote browser
    browser = playwright.chromium.connect_over_cdp(WS_ENDPOINT)

    # Reuse the context and page
    context = browser.contexts[0]
    page = context.pages[0]
    page.goto("https://browserless.io")

    # The magic happens here
    cdp_session = context.new_cdp_session(page)
    cdp_session.send("Browserless.startRecording")

    # Wait for some time while recording
    time.sleep(15)

    # Stop recording and get the response
    response = cdp_session.send("Browserless.stopRecording")
    recording_data = response["value"]

    # Directly write the binary data to a file
    with open("recording.webm", "wb") as file:
        file.write(recording_data.encode("latin1"))

    browser.close()

```

warning

On Playwright, you **must** use the already existing context and page and avoid creating new ones.

```codeBlockLines_p187
import com.microsoft.playwright.*;
import java.nio.file.*;

public class App {
  public static void main(String[] args) {
    String TOKEN = "YOUR_API_TOKEN_HERE";
    String WS_ENDPOINT = String.format("wss://production-sfo.browserless.io?token=%s&headless=false&stealth&record=true",
        TOKEN);

    try (Playwright playwright = Playwright.create()) {
      // Connect to the remote browser
      Browser browser = playwright.chromium().connectOverCDP(WS_ENDPOINT);

      // Reuse the context and page
      Page page = browser.contexts().get(0).pages().get(0);
      page.navigate("https://browserless.io");

      // Start recording
      CDPSession cdpSession = browser.contexts().get(0).newCDPSession(page);
      cdpSession.send("Browserless.startRecording", null);

      // Wait for 15 seconds
      Thread.sleep(15000);

      // Stop recording
      var response = cdpSession.send("Browserless.stopRecording", null);
      String recordingData = response.get("value").getAsString();

      // Write binary data to a file
      byte[] fileData = recordingData.getBytes("ISO-8859-1");
      Files.write(Paths.get("recording.webm"), fileData);

      System.out.println("Recording saved as 'recording.webm'");
      browser.close();
    } catch (Exception e) {
      e.printStackTrace();
    }
  }
}

```

warning

On Playwright, you **must** use the already existing context and page and avoid creating new ones.

```codeBlockLines_p187
using Microsoft.Playwright;
using System;
using System.IO;
using System.Text;

class BrowserlessRecording
{
    public static async Task Main(string[] args)
    {
        string TOKEN = "YOUR_API_TOKEN_HERE";
        string WS_ENDPOINT = $"wss://production-sfo.browserless.io?token={TOKEN}&headless=false&stealth&record=true";

        using var playwright = await Playwright.CreateAsync();
        var browser = await playwright.Chromium.ConnectOverCDPAsync(WS_ENDPOINT);

        // Reuse the context and page
        var context = browser.Contexts[0];
        var page = context.Pages[0];

        await page.GotoAsync("https://browserless.io");

        // Start recording
        var cdpSession = await context.NewCDPSessionAsync(page);
        await cdpSession.SendAsync("Browserless.startRecording");

        // Wait for 15 seconds
        await Task.Delay(15000);

        // Stop recording
        var response = await cdpSession.SendAsync("Browserless.stopRecording");
        string recordingData = response.Value<string>("value");

        // Write binary data to a file
        byte[] fileData = Encoding.GetEncoding("ISO-8859-1").GetBytes(recordingData);
        await File.WriteAllBytesAsync("recording.webm", fileData);

        Console.WriteLine("Recording saved as 'recording.webm'");
        await browser.CloseAsync();
    }
}

```

- [Usage](https://docs.browserless.io/baas/session-management/screencasting#usage)

---

### Browsers as a Service | Browserless.io
Original URL: https://docs.browserless.io/baas/start

[Skip to main content](https://docs.browserless.io/baas/start#__docusaurus_skipToContent_fallback)



Browserless is a cloud-based service for running headless browsers at scale. **Browsers as a Service (BaaS) v2** is a direct browser-as-a-service API that you can connect to using standard libraries like Puppeteer or Playwright. BaaS v2 closely mimics running a browser locally, allowing you to use familiar code by simply changing the connection URL to point at Browserless.

Ideal use case

BaaS features are best suited for sites where bot detection isn't an issue, especially your own site. For getting past detectors, we'd recommend checking out [**BrowserQL**](https://docs.browserless.io/browserql/start).

## How Browserless Works [â€‹](https://docs.browserless.io/baas/start\#how-browserless-works "Direct link to How Browserless Works")

Browserless works almost identically to how most libraries and web-drivers work when ran locally. There's no additional software you need to install on your production machines or complicated setup steps. As a matter of fact, the only thing you really need to when using the Browserless' service is merely change where your code references the browser.

Browserless runs browsers in a cloud environment, and exposes most of the Chrome DevTools protocol and the Playwright Protocols to you. On top of exposing these commands, it also:

- Isolates your session from all others.
- Can run concurrent requests without interfering with others.
- Cleans up sessions after 30 seconds.
- Starts a clean copy of a browser for each session.
- Restarts automatically if anything crashes.
- Queues requests if thresholds are met.
- Helps bypass bot detectors.

You can use the hosted service either by connecting an automation library as described below, or by using one of our HTTP APIs.

## Getting Started [â€‹](https://docs.browserless.io/baas/start\#getting-started "Direct link to Getting Started")

To use BaaS, you need a unique token, created when you sign-up for a Browserless account:

1. [Sign up for a Browserless account](https://account.browserless.io/signup/email?plan=free) (free plan available).
2. Get your **API Key**.

Once your worker(s) are ready you should use this token anytime you interact with the service.

You can use this token with most of our integrations by simply appending a `?token=YOUR_API_TOKEN_HERE` as a query-string parameter.

## Global Endpoints [â€‹](https://docs.browserless.io/baas/start\#global-endpoints "Direct link to Global Endpoints")

Browserless operates multiple regional endpoints for low-latency access. The primary shared clusters are in US West (SFO), EU West (London), and EU Central (Amsterdam) ( [Load Balancers](https://docs.browserless.io/baas/load-balancers)). For example:

- `https://production-sfo.browserless.io` â€“ San Francisco, USA (default US endpoint)
- `https://production-lon.browserless.io` â€“ London, UK (European endpoint)
- `https://production-ams.browserless.io` â€“ Amsterdam, NL (another EU endpoint)

You can use the endpoint closest to your servers or users. All endpoints offer the same API and require your token.

## Connecting Libraries [â€‹](https://docs.browserless.io/baas/start\#connecting-libraries "Direct link to Connecting Libraries")

BaaS can be connected to standard libraries like Puppeteer or Playwright. The pages below guide you through an example on how to connect to your preffered choice:

- [Connecting Puppeteer](https://docs.browserless.io/baas/connect-puppeteer)
- [Connecting Playwright](https://docs.browserless.io/baas/connect-playwright)

## Next Steps [â€‹](https://docs.browserless.io/baas/start\#next-steps "Direct link to Next Steps")

Before exploring all BaaS has to offer, learn more about connecting and building an URL for your needs, and all launch parameters available:

- [Connection URLs and Endpoints](https://docs.browserless.io/baas/connection-urls)
- [Launch Parameters and Options](https://docs.browserless.io/baas/chrome-flags)

Want to explore more?

BaaS provides a wide range of functionalities that help your web scraping process. To discover all the capabilities Browserless has to offer, start with the following guides:

- [Cloud Services](https://docs.browserless.io/baas/session-management/reconnect)
- [REST APIs](https://docs.browserless.io/rest-apis/intro)
- [Utility Functions](https://docs.browserless.io/enterprise/utility-functions/intro)

**Advanced Features**

Learn about more advanced features that you can take advantage when using BaaS:

- [Human-in-the-Loop Automations](https://docs.browserless.io/baas/hybrid-automation)
- [Screencasting](https://docs.browserless.io/baas/session-management/screencasting)
- [Live debugger](https://docs.browserless.io/enterprise/live-debugger)

- [How Browserless Works](https://docs.browserless.io/baas/start#how-browserless-works)
- [Getting Started](https://docs.browserless.io/baas/start#getting-started)
- [Global Endpoints](https://docs.browserless.io/baas/start#global-endpoints)
- [Connecting Libraries](https://docs.browserless.io/baas/start#connecting-libraries)
- [Next Steps](https://docs.browserless.io/baas/start#next-steps)

---

### Long queues | Browserless.io
Original URL: https://docs.browserless.io/baas/troubleshooting

[Skip to main content](https://docs.browserless.io/baas/troubleshooting#__docusaurus_skipToContent_fallback)



This doc is intended to help you understand potential causes for excessive queues. They are most often from issues with managing sessions where they are left to idle for too long.

## Closing and disconnecting browsers [â€‹](https://docs.browserless.io/baas/troubleshooting\#closing-and-disconnecting-browsers "Direct link to Closing and disconnecting browsers")

With Browserless, you should call the `close` or `disconnect` method when a task is complete or there is an error. That will shutdown the process and let the next connection in, else it will continue until it hits the default 30s timeout.

This is different from how Puppeteer and Playwright handle idle and new browsers, so letâ€™s look at the differences in more detail.

### Whatâ€™s the default, and why we donâ€™t do it [â€‹](https://docs.browserless.io/baas/troubleshooting\#whats-the-default-and-why-we-dont-do-it "Direct link to Whatâ€™s the default, and why we donâ€™t do it")

Puppeteer and Playwright use a fairly blunt approach to starting up browsers.

They donâ€™t care if you already have a browser running in a function/worker, theyâ€™ll listen to any command to start a browser and shove it in there. About the only thing that these libraries will check is that the browser-binary itself is present and is executable.

While this type of process can work decently in development, a more nuanced approach is needed for production. Things like machine health, implied dependencies, and more start to come into play.

### Managing browsers with Browserless [â€‹](https://docs.browserless.io/baas/troubleshooting\#managing-browsers-with-browserless "Direct link to Managing browsers with Browserless")

Browserless takes the opposite approach. If a browser is running, it is protected from being pushed aside by a new script.

If a new connection is started, and thereâ€™s already browsers running, we â€œholdâ€ onto that connection until a spot becomes available. Thatâ€™s why we have things like concurrency, queue, and timeout limits. These are all there to help things flow through Browserless in a streamlined way.

But what about health? If things are in a place where a Browser can start, Browserless does one last check on CPU and Memory to ensure that the browser can be started and run properly. Without it youâ€™re likely to run into other timeouts (like navigation) due to lack of proper resources.

We feel that this has many advantages:

- You can limit via concurrent access.

- You can begin to queue additional access once concurrent slots are full.

- After that we do a quick â€œpulse checkâ€ to see if access is viable.


Of course all of this is optional, but comes at our recommendation of a best practice.

### Deciding when to close browsers [â€‹](https://docs.browserless.io/baas/troubleshooting\#deciding-when-to-close-browsers "Direct link to Deciding when to close browsers")

Switching this priority around means youâ€™ll need to decide when to close a browser, otherwise theyâ€™ll stay open until they hit the default timeout of 30s.

Whilst our timeouts are there to help a browser from hogging execution time, the best thing you can do is to quickly (and in the case of errors) call the `close` or `disconnect` method. Browserless will see this, shutdown the process, and let the next connection in.

_Note: Itâ€™s hard for us to set a blanket rule of â€œclose them when theyâ€™re idleâ€ as idle means different things to different people, so we have to leave it up to each user._

Some options we would suggest are:

- Closing the browser when youâ€™ve got what you came for.

- If an unrecoverable error happens, then shutdown and retry.

- Set a `TIMEOUT` parameter thatâ€™s reasonable and within an acceptable range of time.


- [Closing and disconnecting browsers](https://docs.browserless.io/baas/troubleshooting#closing-and-disconnecting-browsers)
  - [Whatâ€™s the default, and why we donâ€™t do it](https://docs.browserless.io/baas/troubleshooting#whats-the-default-and-why-we-dont-do-it)
  - [Managing browsers with Browserless](https://docs.browserless.io/baas/troubleshooting#managing-browsers-with-browserless)
  - [Deciding when to close browsers](https://docs.browserless.io/baas/troubleshooting#deciding-when-to-close-browsers)

---

### HTTP Error Codes | Browserless.io
Original URL: https://docs.browserless.io/baas/troubleshooting/http-error-codes

[Skip to main content](https://docs.browserless.io/baas/troubleshooting/http-error-codes#__docusaurus_skipToContent_fallback)



This document explains the common HTTP error codes you may encounter when using Browserless and how to resolve them. If you're interested in knowing the status code of the site being navigated to by one of our REST APIs, you can find the status code and status in the headers named `x-response-code` and `x-response-status`.

## HTTP response codes [â€‹](https://docs.browserless.io/baas/troubleshooting/http-error-codes\#http-response-codes "Direct link to HTTP response codes")

- [400 Bad Request](https://docs.browserless.io/baas/troubleshooting/http-error-codes#400-bad-request)
- [401 Unauthorized](https://docs.browserless.io/baas/troubleshooting/http-error-codes#401-unauthorized)
- [404 Not Found](https://docs.browserless.io/baas/troubleshooting/http-error-codes#404-not-found)
- [408 Request Timeout](https://docs.browserless.io/baas/troubleshooting/http-error-codes#408-request-timeout)
- [429 Too Many Requests](https://docs.browserless.io/baas/troubleshooting/http-error-codes#429-too-many-requests)

## 400 Bad Request [â€‹](https://docs.browserless.io/baas/troubleshooting/http-error-codes\#400-bad-request "Direct link to 400 Bad Request")

This error indicates that the request is badly formed and could not be processed.

Troubleshoot:

- You might bee sending a malformed JSON payload.
- You might be sending invalid fields for an specific API.
- You might be setting the timeout to a negative number or over 1800000 ms.
- Your request arguments might be colliding (for instance, using our internal proxy while connecting to a `--proxy-server` in your args).

## 401 Unauthorized [â€‹](https://docs.browserless.io/baas/troubleshooting/http-error-codes\#401-unauthorized "Direct link to 401 Unauthorized")

This error indicates that the request has not been applied because it lacks valid authentication credentials for the resource.

Troubleshoot:

- You might not be sending the API key in the WebSocket Endpoint properly.
- Your HTTP Client may be caching an old API key that's no longer valid.
- You might be using an endpoint not supported by your plan, e.g. trying to use the v2 endpoints, when being on a dedicated or legacy plan.

## 404 Not Found [â€‹](https://docs.browserless.io/baas/troubleshooting/http-error-codes\#404-not-found "Direct link to 404 Not Found")

This error indicates that the request's endpoint has not been found.

Troubleshoot:

- You might be trying to request a non-existent endpoint.

## 408 Request Timeout [â€‹](https://docs.browserless.io/baas/troubleshooting/http-error-codes\#408-request-timeout "Direct link to 408 Request Timeout")

This error indicates that the request has taken too long to process.

Troubleshoot:

- You might have set the timeout too low.
- You might be trying to wait for a selector or event the doesn't exist.
- Your dedicated workers might be unhealthy and unresponsive.

## 429 Too Many Requests [â€‹](https://docs.browserless.io/baas/troubleshooting/http-error-codes\#429-too-many-requests "Direct link to 429 Too Many Requests")

This error indicates that too many requests are currently being processed.

### Exceeding Concurrency Limits [â€‹](https://docs.browserless.io/baas/troubleshooting/http-error-codes\#exceeding-concurrency-limits "Direct link to Exceeding Concurrency Limits")

The most common cause of 429 errors is exceeding your plan's concurrency limit. Each Browserless plan has a maximum number of concurrent browser sessions that can run simultaneously:

| Plan | Concurrent Browsers |
| --- | --- |
| Free | 1 |
| Prototyping | 3 |
| Starter | 15 |
| Scale | 50 |
| Enterprise | Custom |

When you attempt to start more browser sessions than your plan allows, Browserless will return a 429 error to indicate that you've reached your concurrency limit.

You can view the current pricing and concurrency limits on the [Browserless pricing page](https://www.browserless.io/pricing).

#### How to resolve concurrency limit issues [â€‹](https://docs.browserless.io/baas/troubleshooting/http-error-codes\#how-to-resolve-concurrency-limit-issues "Direct link to How to resolve concurrency limit issues")

1. **Upgrade your plan**: If you consistently need more concurrent sessions, consider upgrading to a plan with higher concurrency limits.

2. **Implement request queuing**: Add a retry mechanism with exponential backoff to your code to handle 429 responses.

3. **Optimize your automation**: Review your code to ensure you're closing browser sessions properly and not keeping unnecessary sessions open.


### Improper Browser Closure [â€‹](https://docs.browserless.io/baas/troubleshooting/http-error-codes\#improper-browser-closure "Direct link to Improper Browser Closure")

Another common cause of 429 errors is improper browser closure. If your code doesn't properly close browser instances after use, especially during errors or exceptions, you may accumulate "zombie" sessions that count against your concurrency limit.

#### Proper browser closure with Puppeteer [â€‹](https://docs.browserless.io/baas/troubleshooting/http-error-codes\#proper-browser-closure-with-puppeteer "Direct link to Proper browser closure with Puppeteer")

Here's an example of how to properly close a browser with Puppeteer, even when errors occur:

```codeBlockLines_p187
const puppeteer = require('puppeteer-core');

async function runAutomation() {
  let browser = null;

  try {
    // Connect to browserless
    browser = await puppeteer.connect({
      browserWSEndpoint: 'wss://production-sfo.browserless.io?token=YOUR_API_KEY&timeout=300000',
    });

    const page = await browser.newPage();
    await page.goto('https://example.com');

    // Your automation code here
    const title = await page.title();
    console.log(`Page title: ${title}`);

    // More operations...

    return { success: true, data: title };
  } catch (error) {
    console.error('Automation error:', error);
    return { success: false, error: error.message };
  } finally {
    // Always close the browser, even if an error occurred
    if (browser) {
      await browser.close();
    }
  }
}

// Usage
runAutomation()
  .then(result => console.log('Finished:', result))
  .catch(err => console.error('Fatal error:', err));

```

#### Proper browser closure with Playwright [â€‹](https://docs.browserless.io/baas/troubleshooting/http-error-codes\#proper-browser-closure-with-playwright "Direct link to Proper browser closure with Playwright")

Here's a similar example using Playwright:

```codeBlockLines_p187
const { chromium } = require('playwright-core');

async function runAutomation() {
  let browser = null;

  try {
    // Connect to browserless
    browser = await chromium.connect({
      wsEndpoint: 'wss://production-sfo.browserless.io/chromium/playwright?token=YOUR_API_KEY&timeout=300000',
    });

    const context = await browser.newContext();
    const page = await context.newPage();
    await page.goto('https://example.com');

    // Your automation code here
    const title = await page.title();
    console.log(`Page title: ${title}`);

    // More operations...

    return { success: true, data: title };
  } catch (error) {
    console.error('Automation error:', error);
    return { success: false, error: error.message };
  } finally {
    // Always close the browser, even if an error occurred
    if (browser) {
      await browser.close();
    }
  }
}

// Usage
runAutomation()
  .then(result => console.log('Finished:', result))
  .catch(err => console.error('Fatal error:', err));

```

### Using Timeout Flag as a Quick Fix [â€‹](https://docs.browserless.io/baas/troubleshooting/http-error-codes\#using-timeout-flag-as-a-quick-fix "Direct link to Using Timeout Flag as a Quick Fix")

While implementing proper browser closure is the best long-term solution, you can use the `timeout` query parameter as a quick fix to ensure browsers don't live past a certain time limit. By default, Browserless has a global timeout of 15 minutes, but you can override this with the `timeout` parameter:

```codeBlockLines_p187
wss://production-sfo.browserless.io?token=YOUR_API_KEY&timeout=300000

```

The timeout value is specified in milliseconds (300000ms = 5 minutes). This ensures that even if your code fails to properly close the browser, Browserless will automatically terminate the session after the specified timeout.

This approach is particularly useful when:

- You're debugging 429 errors and need a quick solution
- You have legacy code that's difficult to update with proper error handling
- You want an additional safety mechanism alongside proper browser closure

### Best Practices to Avoid 429 Errors [â€‹](https://docs.browserless.io/baas/troubleshooting/http-error-codes\#best-practices-to-avoid-429-errors "Direct link to Best Practices to Avoid 429 Errors")

1. **Always use try/catch/finally blocks**: Ensure browser instances are closed in a `finally` block to guarantee cleanup even when errors occur.

2. **Implement connection pooling**: For high-volume applications, consider implementing a connection pool to reuse browser instances instead of creating new ones for each operation.

3. **Monitor your usage**: Keep track of your concurrent session usage to avoid hitting limits unexpectedly.

4. **Set explicit timeouts**: Configure reasonable timeouts using the `timeout` parameter to prevent browser sessions from hanging indefinitely.

5. **Implement graceful shutdown**: Ensure your application properly closes all browser instances when shutting down.


If you continue to experience 429 errors despite following these best practices, please contact [Browserless support](https://www.browserless.io/contact) for assistance.

### Other Troubleshooting for 429 Errors [â€‹](https://docs.browserless.io/baas/troubleshooting/http-error-codes\#other-troubleshooting-for-429-errors "Direct link to Other Troubleshooting for 429 Errors")

- You might be running more concurrent sessions than expected.
- Your dedicated workers might be unhealthy and unresponsive, thus rejecting any incomming traffic.

- [HTTP response codes](https://docs.browserless.io/baas/troubleshooting/http-error-codes#http-response-codes)
- [400 Bad Request](https://docs.browserless.io/baas/troubleshooting/http-error-codes#400-bad-request)
- [401 Unauthorized](https://docs.browserless.io/baas/troubleshooting/http-error-codes#401-unauthorized)
- [404 Not Found](https://docs.browserless.io/baas/troubleshooting/http-error-codes#404-not-found)
- [408 Request Timeout](https://docs.browserless.io/baas/troubleshooting/http-error-codes#408-request-timeout)
- [429 Too Many Requests](https://docs.browserless.io/baas/troubleshooting/http-error-codes#429-too-many-requests)
  - [Exceeding Concurrency Limits](https://docs.browserless.io/baas/troubleshooting/http-error-codes#exceeding-concurrency-limits)
  - [Improper Browser Closure](https://docs.browserless.io/baas/troubleshooting/http-error-codes#improper-browser-closure)
  - [Using Timeout Flag as a Quick Fix](https://docs.browserless.io/baas/troubleshooting/http-error-codes#using-timeout-flag-as-a-quick-fix)
  - [Best Practices to Avoid 429 Errors](https://docs.browserless.io/baas/troubleshooting/http-error-codes#best-practices-to-avoid-429-errors)
  - [Other Troubleshooting for 429 Errors](https://docs.browserless.io/baas/troubleshooting/http-error-codes#other-troubleshooting-for-429-errors)

---

### Browserless.io
Original URL: https://docs.browserless.io/baas/troubleshooting/versions

[Skip to main content](https://docs.browserless.io/baas/troubleshooting/versions#__docusaurus_skipToContent_fallback)

# Page Not Found

We could not find what you were looking for.

Please contact the owner of the site that linked you to the original URL and let them know their link is broken.

---

### Whitelisting IP Addresses | Browserless.io
Original URL: https://docs.browserless.io/baas/troubleshooting/whitelisting-ips

[Skip to main content](https://docs.browserless.io/baas/troubleshooting/whitelisting-ips#__docusaurus_skipToContent_fallback)



If you restrict access to your infrastructure, you can whitelist our service through IP address to allow communicating to your systems.

## Dedicated plans [â€‹](https://docs.browserless.io/baas/troubleshooting/whitelisting-ips\#dedicated-plans "Direct link to Dedicated plans")

Your worker's IP addresses are listed under the Production Worker's section in the Public IP column.

## Cloud-subscription plans (Shared fleet) [â€‹](https://docs.browserless.io/baas/troubleshooting/whitelisting-ips\#cloud-subscription-plans-shared-fleet "Direct link to Cloud-subscription plans (Shared fleet)")

The table below lists the most recent IP addresses from our shared fleet for you to whitelist.

The workers that service the cloud-subscription plans may change every few months, since we add more workers according to the demand increase, and also when there are maintenance tasks that require relaunching.

## Current IP Address lists [â€‹](https://docs.browserless.io/baas/troubleshooting/whitelisting-ips\#current-ip-address-lists "Direct link to Current IP Address lists")

Below is the most recent list of IP addresses on our shared-fleet.

Date of last update: March/28/2025.

| IP address |  |  |  |
| --- | --- | --- | --- |
| 146.190.53.75 | 146.190.53.72 | 146.190.175.184 | 147.182.250.161 |
| 164.92.125.142 | 164.92.125.134 | 146.190.143.216 | 146.190.127.114 |
| 146.190.143.212 | 24.199.123.163 | 24.199.111.199 | 146.190.159.230 |
| 146.190.159.176 | 24.199.103.126 | 159.223.205.248 | 137.184.226.226 |
| 146.190.159.171 | 24.144.81.223 | 137.184.235.213 | 146.190.139.82 |
| 164.92.125.23 | 159.223.205.48 | 146.190.159.67 | 164.92.125.19 |
| 146.190.130.128 | 137.184.179.6 | 137.184.178.146 | 164.92.109.217 |
| 164.92.109.12 | 143.198.129.119 | 165.232.140.251 | 24.199.105.203 |
| 143.198.111.152 | 143.198.99.228 | 24.144.94.186 | 146.190.53.55 |
| 164.90.145.42 | 143.198.99.72 | 146.190.53.52 | 144.126.211.154 |
| 143.244.181.136 | 146.190.57.39 | 144.126.220.231 | 143.198.131.227 |
| 143.244.188.238 | 147.182.203.53 | 146.190.143.211 | 146.190.131.136 |
| 24.199.115.166 | 137.184.12.124 | 209.38.79.187 | 209.38.68.13 |
| 209.38.74.36 | 164.92.95.6 | 209.38.75.204 | 209.38.67.232 |
| 209.38.70.84 | 209.38.73.120 | 143.198.129.120 | 143.198.136.242 |
| 146.190.114.39 | 146.190.118.62 | 146.190.59.199 | 146.190.116.90 |
| 146.190.34.116 | 64.23.239.117 | 64.23.238.239 | 64.23.235.163 |
| 64.23.238.31 | 64.23.238.124 | 64.23.232.196 | 64.23.234.46 |
| 164.90.159.169 | 164.90.155.253 | 64.23.235.171 | 64.23.215.208 |
| 64.23.167.192 | 64.23.215.190 | 137.184.3.181 | 143.198.109.32 |
| 146.190.44.51 | 161.35.229.21 | 161.35.229.77 | 161.35.237.149 |
| 161.35.233.103 | 134.209.180.180 | 134.209.189.197 | 134.209.188.237 |
| 134.209.186.0 | 134.209.187.201 | 134.209.186.65 | 209.97.186.36 |
| 167.172.61.214 | 46.101.92.250 | 46.101.87.212 | 134.209.25.165 |
| 134.209.25.209 | 134.209.25.215 | 134.209.17.68 | 134.209.17.100 |
| 134.209.25.201 | 134.209.17.116 | 134.209.25.53 | 144.126.204.196 |
| 134.209.25.97 | 152.42.138.139 | 157.245.73.238 | 167.71.77.118 |
| 167.71.74.138 | 157.245.70.98 |  |  |

Or you can download it [as a txt file](https://docs.browserless.io/assets/files/ips-a37a4fd5146bde60402d7c270401ce97.txt) or [a json file](https://docs.browserless.io/assets/files/ips-8e7fda4a41344669859fb22b4df54d56.json).

- [Dedicated plans](https://docs.browserless.io/baas/troubleshooting/whitelisting-ips#dedicated-plans)
- [Cloud-subscription plans (Shared fleet)](https://docs.browserless.io/baas/troubleshooting/whitelisting-ips#cloud-subscription-plans-shared-fleet)
- [Current IP Address lists](https://docs.browserless.io/baas/troubleshooting/whitelisting-ips#current-ip-address-lists)

---

### /config API | Browserless.io
Original URL: https://docs.browserless.io/baas/v1/apis/config

[Skip to main content](https://docs.browserless.io/baas/v1/apis/config#__docusaurus_skipToContent_fallback)



DEPRECATION WARNING

This documentation is for BaaS v1, which is no longer actively supported. If you are a new user, please refer to the updated documentation for [BaaS v2](https://docs.browserless.io/enterprise/utility-functions/config) or [BrowserQL](https://docs.browserless.io/browserql/start).

The config API allows you to retrieve the current configuration of your container **and is only available for dedicated and self-hosted accounts.**

Check out the [config API schema](https://chrome.browserless.io/docs/#/Management%20API/get_config) defined in our Swagger page.

## Gathering your container configuration [â€‹](https://docs.browserless.io/baas/v1/apis/config\#gathering-your-container-configuration "Direct link to Gathering your container configuration")

To see the configuration of your container, simply issue a `GET` request to `/config`:

```codeBlockLines_p187
curl -X GET \
  https://chrome.browserless.io/config?token=MY_API_TOKEN

```

warning

Remember that running this in the browser will expose your API key!

Running this cURL request will result in an output like:

```codeBlockLines_p187
{
  "allowFileProtocol": true,
  "chromeRefreshTime": 0,
  "connectionTimeout": 0,
  "disabledFeatures": ["string"],
  "enableAPIGet": true,
  "enableCors": true,
  "errorAlertURL": "string",
  "exitOnHealthFailure": true,
  "functionBuiltIns": ["string"],
  "functionEnableIncognitoMode": true,
  "functionExternals": ["string"],
  "healthFailureURL": "string",
  "sessionCheckFailURL": "string",
  "keepAlive": true,
  "maxCPU": 0,
  "maxConcurrentSessions": 0,
  "maxMemory": 0,
  "maxQueueLength": 0,
  "metricsJSONPath": "string",
  "port": 0,
  "prebootChrome": true,
  "queuedAlertURL": "string",
  "rejectAlertURL": "string",
  "singleRun": true,
  "timeoutAlertURL": "string",
  "token": "string",
  "workspaceDir": "string",
  "socketBehavior": "string"
}

```

- [Gathering your container configuration](https://docs.browserless.io/baas/v1/apis/config#gathering-your-container-configuration)

---

### /content API | Browserless.io
Original URL: https://docs.browserless.io/baas/v1/apis/content

[Skip to main content](https://docs.browserless.io/baas/v1/apis/content#__docusaurus_skipToContent_fallback)



DEPRECATION WARNING

This documentation is for BaaS v1, which is no longer actively supported. If you are a new user, please refer to the updated documentation for [BaaS v2](https://docs.browserless.io/rest-apis/content) or [BrowserQL](https://docs.browserless.io/browserql/start).

The content API allows for simple navigation to a site and capturing the page's content (including the `<head>` section). browserless will respond with a `Content-Type` of `text/html`, and string of the site's HTML. This is useful for capturing the content of a page that has a lot of JavaScript or other interactivity.

If you want to see all the options check out the [schema for it here on GitHub](https://github.com/browserless/browserless/blob/v1/src/schemas.ts#L177-L192) or check out this API schema defined in [Swagger](https://chrome.browserless.io/docs/#/Browser%20API/post_content).

## Capture the content of example.com [â€‹](https://docs.browserless.io/baas/v1/apis/content\#capture-the-content-of-examplecom "Direct link to Capture the content of example.com")

**JSON payload**

```codeBlockLines_p187
{
  "url": "https://example.com/"
}

```

**cURL request**

```codeBlockLines_p187
curl -X POST \
  https://chrome.browserless.io/content?token=MY_API_TOKEN \
  -H 'Cache-Control: no-cache' \
  -H 'Content-Type: application/json' \
  -d '
{
  "url": "https://example.com/"
}'

```

- [Capture the content of example.com](https://docs.browserless.io/baas/v1/apis/content#capture-the-content-of-examplecom)

---

### /download API | Browserless.io
Original URL: https://docs.browserless.io/baas/v1/apis/download

[Skip to main content](https://docs.browserless.io/baas/v1/apis/download#__docusaurus_skipToContent_fallback)



DEPRECATION WARNING

This documentation is for BaaS v1, which is no longer actively supported. If you are a new user, please refer to the updated documentation for [BaaS v2](https://docs.browserless.io/rest-apis/download) or [BrowserQL](https://docs.browserless.io/browserql/start).

Much like the `/function` API, the `/download` API allows you to `POST` code for browserless to execute. The only difference with /download is that, instead of returning the result of your function, we instead return a file that the browser downloads.

Check out this API schema defined in [Swagger](https://chrome.browserless.io/docs/#/Browser%20API/post_download).

> If your download request doesn't result in a file being downloaded, browserless will likely time out the function.

## Basic Usage [â€‹](https://docs.browserless.io/baas/v1/apis/download\#basic-usage "Direct link to Basic Usage")

Here's an example of downloading a file created in the browser (a CSV file):

```codeBlockLines_p187
const puppeteer = require('puppeteer');

async function run() {
  const browser = await puppeteer.launch();
  const page = await browser.newPage();

  // Here we generate a CSV file and have the browser download it
  await page.evaluate(() => {
    const rows = [\
      ['name1', 'city1', 'some other info'],\
      ['name2', 'city2', 'more info'],\
    ];
    let csvContent = 'data:text/csv;charset=utf-8,';
    rows.forEach(function (rowArray) {
      let row = rowArray.join(',');
      csvContent += row + '\r\n';
    });
    const encodedUri = encodeURI(csvContent);
    const link = document.createElement('a');
    link.setAttribute('href', encodedUri);
    link.setAttribute('download', 'data.csv');
    document.body.appendChild(link);

    return link.click();
  });
}

run();

```

This might come as a surprise, but unfortunately in puppeteer there's no way to know if the file was downloaded, or an API to even get it. You'll have to _know_ ahead of time where files are kept, and watch the file system for it to complete. Instead of wiring up all that code you can send browserless an HTTP request and it takes care of all the underlying file-system calls:

```codeBlockLines_p187
curl -X POST \
  https://chrome.browserless.io/download?token=YOUR-API-TOKEN \
  -H 'Content-Type: application/javascript' \
  -d 'module.exports = async ({ page }) => {
    await page.evaluate(() => {
        const rows = [\
            ["name1", "city1", "some other info"],\
            ["name2", "city2", "more info"]\
        ];
        let csvContent = "data:text/csv;charset=utf-8,";
        rows.forEach(function(rowArray){
            let row = rowArray.join(",");
            csvContent += row + "\r\n";
        });
        const encodedUri = encodeURI(csvContent);
        const link = document.createElement("a");
        link.setAttribute("href", encodedUri);
        link.setAttribute("download", "data.csv");
        document.body.appendChild(link);

        return link.click();
    });
};'

```

This API is sensitive to the downloaded file and will return an appropriate `Content-Type` with the response.

## Parameterizing your /download call [â€‹](https://docs.browserless.io/baas/v1/apis/download\#parameterizing-your-download-call "Direct link to Parameterizing your /download call")

You can also post an `application/json` body, as opposed to an `application/javascript` one, if you'd like to re-use your function with new parameters. In this case, let's change our CSV file to be dynamic (note that our script is now minified for portability):

```codeBlockLines_p187
curl -X POST \
  https://chrome.browserless.io/download?token=YOUR-API-TOKEN \
  -H 'Content-Type: application/json' \
  -d '{
  "code": "module.exports=async({page:a,context:b})=>{const{rows:c}=b;await a.evaluate(()=>{let d='\''data:text/csv;charset=utf-8,'\'';c.forEach(function(g){let h=g.join('\'','\'');d+=h+'\''\r\n'\''});const e=encodeURI(d),f=document.createElement('\''a'\'');return f.setAttribute('\''href'\'',e),f.setAttribute('\''download'\'','\''data.csv'\''),document.body.appendChild(f),f.click()})};",
  "context": {
    "rows": [\
      ["Some", "Cool", "CSV"],\
            ["With", "Rows", "And Stuff"]\
        ]
  }
}'

```

This lets you define re-usable functions and invoke them over HTTP in a more flexible way.

- [Basic Usage](https://docs.browserless.io/baas/v1/apis/download#basic-usage)
- [Parameterizing your /download call](https://docs.browserless.io/baas/v1/apis/download#parameterizing-your-download-call)

---

### /function API | Browserless.io
Original URL: https://docs.browserless.io/baas/v1/apis/function

[Skip to main content](https://docs.browserless.io/baas/v1/apis/function#__docusaurus_skipToContent_fallback)



DEPRECATION WARNING

This documentation is for BaaS v1, which is no longer actively supported. If you are a new user, please refer to the updated documentation for [BaaS v2](https://docs.browserless.io/rest-apis/function) or [BrowserQL](https://docs.browserless.io/browserql/start).

A quick way to run commands with Browserless is via our `/function` API. You can use Python, NodeJS or any other language that supports making HTTP requests, so you don't need to install any libraries on your end.

The `/function` endpoint allows for `POST` ing of custom `code` and `context` to run them with. The `code` function, which only supports puppeteer code, gets called with an object containing several properties: a `page` property, [which is a puppeteer page object](https://pptr.dev/api/puppeteer.page), and `context` which is the context you provide in the JSON body.

Functions should return an object with two properties: `data` and `type`. `data` can be whatever you'd like ( `Buffer`, `JSON`, or plain `text`) and `type` is a string describing the content-type of `data`. Browserless reads both of these from your functions return value and resolves the request appropriately.

Check out this API schema defined in [Swagger](https://chrome.browserless.io/docs/#/Browser%20API/post_function).

> If you want to see more examples, checkout how other [REST API's are handled in our GitHub project](https://github.com/browserless/browserless/tree/v1/functions).

## Basic Usage [â€‹](https://docs.browserless.io/baas/v1/apis/function\#basic-usage "Direct link to Basic Usage")

**JS code**

```codeBlockLines_p187
// Read the `url` from context, goto the page and return the results
module.exports = async ({ page, context }) => {
  const { url } = context;
  await page.goto(url);

  const data = await page.content();

  return {
    data,
    // Make sure to match the appropriate content here
    // You'll likely want 'application/json'
    type: 'application/html',
  };
};

```

**context**

```codeBlockLines_p187
{
  "url": "https://example.com"
}

```

Since you can't have multi-line strings in JSON we've minified our above code with the [online babel repl](https://babeljs.io/repl) and use it in the below `curl` call.

**cURL request**

```codeBlockLines_p187
curl -X POST \
  'https://chrome.browserless.io/function?TOKEN=YOUR-API-TOKEN' \
  -H 'Content-Type: application/json' \
  -d '{
  "code": "module.exports=async({page:a,context:b})=>{const{url:c}=b;await a.goto(c);const d=await a.content();return{data:d,type:\"application/html\"}};",
  "context": {
    "url": "https://example.com/"
  }
}'

```

## Detached functions [â€‹](https://docs.browserless.io/baas/v1/apis/function\#detached-functions "Direct link to Detached functions")

Functions that are "detached" resolve _immediately_ with a JSON payload exposing the job's ID. These are useful if you don't want to hold onto the connection with browserless while it's running, but are relying on the side-effects of having a browserless run the function. You can also call external services with any results (like webhooks or your own API's). Since it's harder to track detached functions, browserless will call them with another parameter if `id` which is the same `id` that they immediately resolve with.

In order to detach a function you'll need to pass in a third parameter of `detached: true` in the JSON POST body.

> You can currently require 'url', 'util', 'path', 'querystring', 'lodash', 'node-fetch', and 'request' in your functions. Please contact us for adding a module

**code**

```codeBlockLines_p187
const fetch = require('node-fetch');

// ID here is dynamic, and matches up with the immediate response from
// browserless but allows you to track it in third-party systems
module.exports = async ({ page, context, id }) => {
  const { url } = context;
  await page.goto(url);

  const data = await page.content();

  // POST the content to a third-party service
  return fetch('https://my-third-party-service.com/content', {
    headers: {
      'Content-Type': 'application/json',
    },
    body: JSON.stringify({
      pageContent: data,
      sessionId: id,
    }),
    method: 'POST',
  });
};

```

**context**

```codeBlockLines_p187
{
  "url": "https://example.com"
}

```

To force functions to operate in a detached way, simply add a `detached: true` to the POSTed body.

**cURL request**

```codeBlockLines_p187
curl -X POST \
  https://chrome.browserless.io/function?token=MY_API_TOKEN \
  -H 'Cache-Control: no-cache' \
  -H 'Content-Type: application/json' \
  -d '{
    "code": "const fetch=require('\''node-fetch'\'');module.exports=async({page:a,context:b,id:c})=>{const{url:d}=b;await a.goto(d);const e=await a.content();return fetch('\''https://my-third-party-service.com/content'\'',{headers:{'\''Content-Type'\'':'\''application/json'\''},body:JSON.stringify({pageContent:e,sessionId:c}),method:'\''POST'\''})};",
    "context": {
        "url": "https://example.com/"
    },
    "detached": true
}'

```

- [Basic Usage](https://docs.browserless.io/baas/v1/apis/function#basic-usage)
- [Detached functions](https://docs.browserless.io/baas/v1/apis/function#detached-functions)

---

### /kill API | Browserless.io
Original URL: https://docs.browserless.io/baas/v1/apis/kill

[Skip to main content](https://docs.browserless.io/baas/v1/apis/kill#__docusaurus_skipToContent_fallback)



DEPRECATION WARNING

This documentation is for BaaS v1, which is no longer actively supported. If you are a new user, please refer to the updated documentation for [BaaS v2](https://docs.browserless.io/rest-apis/intro) or [BrowserQL](https://docs.browserless.io/browserql/start).

The kill API allows you to kill a specific session or all the open sessions **and is only available for dedicated and self-hosted accounts.**

Check out the [kill API schema](https://chrome.browserless.io/docs/#/Management%20API/get_kill__id_) defined in our Swagger page.

danger

These actions **cannot** be undone

### Examples [â€‹](https://docs.browserless.io/baas/v1/apis/kill\#examples "Direct link to Examples")

1. [Killing a specific session](https://docs.browserless.io/baas/v1/apis/kill#killing-a-specific-session)
2. [Killing all the sessions](https://docs.browserless.io/baas/v1/apis/kill#killing-all-the-sessions)

## Killing a specific session [â€‹](https://docs.browserless.io/baas/v1/apis/kill\#killing-a-specific-session "Direct link to Killing a specific session")

To kill a specific session, simply issue a `GET` request to `/kill/{id}`, you can set the id with the browser ID or tracking-ID, you can find this with the help of the [sessions API](https://chrome.browserless.io/docs/#/Management%20API/get_sessions)

You can run this with a cURL request as so:

```codeBlockLines_p187
curl -X GET \
  https://chrome.browserless.io/kill/{id}?token=MY_API_TOKEN

```

## Killing all the sessions [â€‹](https://docs.browserless.io/baas/v1/apis/kill\#killing-all-the-sessions "Direct link to Killing all the sessions")

To kill all the open sessions, simply issue a `GET` request to `/kill/all`

You can run this with a cURL request as so:

```codeBlockLines_p187
curl -X GET \
  https://chrome.browserless.io/kill/all?token=MY_API_TOKEN

```

warning

Remember that running this in the browser will expose your API key!

- [Examples](https://docs.browserless.io/baas/v1/apis/kill#examples)
- [Killing a specific session](https://docs.browserless.io/baas/v1/apis/kill#killing-a-specific-session)
- [Killing all the sessions](https://docs.browserless.io/baas/v1/apis/kill#killing-all-the-sessions)

---

### /metrics API | Browserless.io
Original URL: https://docs.browserless.io/baas/v1/apis/metrics

[Skip to main content](https://docs.browserless.io/baas/v1/apis/metrics#__docusaurus_skipToContent_fallback)



DEPRECATION WARNING

This documentation is for BaaS v1, which is no longer actively supported. If you are a new user, please refer to the updated documentation for [BaaS v2](https://docs.browserless.io/enterprise/utility-functions/metrics) or [BrowserQL](https://docs.browserless.io/browserql/start).

The metrics API allows you to retrieve an array of session statistics **and is only available for dedicated and self-hosted accounts.** This API is different to the [pressure API](https://chrome.browserless.io/docs/#/Management%20API/get_pressure) since the metrics API returns a collection of all the metrics data with one week of history whereas the pressure API only returns one object (the current metrics).

Check out the [metrics API schema](https://chrome.browserless.io/docs/#/Management%20API/get_metrics) defined in our Swagger page.

## Gathering metrics array from your workers [â€‹](https://docs.browserless.io/baas/v1/apis/metrics\#gathering-metrics-array-from-your-workers "Direct link to Gathering metrics array from your workers")

To see statistics regarding your workers, simply issue a `GET` request to `/metrics`:

```codeBlockLines_p187
curl -X GET \
  https://chrome.browserless.io/metrics?token=MY_API_TOKEN

```

warning

Remember that running this in the browser will expose your API key!

Running this cURL request will result in an output like:

```codeBlockLines_p187
[\
  {\
    "date": 0,\
    "successful": 0,\
    "queued": 0,\
    "rejected": 0,\
    "unhealthy": 0,\
    "memory": 0,\
    "cpu": 0,\
    "timedout": 0,\
    "totalTime": 0,\
    "meanTime": 0,\
    "maxTime": 0,\
    "minTime": 0,\
    "maxConcurrent": 0,\
    "sessionTimes": [0]\
  }\
]

```

### /metrics/all [â€‹](https://docs.browserless.io/baas/v1/apis/metrics\#metricsall "Direct link to /metrics/all")

This route will output a similar payload, but with the total stats of all sessions.

- [Gathering metrics array from your workers](https://docs.browserless.io/baas/v1/apis/metrics#gathering-metrics-array-from-your-workers)
  - [/metrics/all](https://docs.browserless.io/baas/v1/apis/metrics#metricsall)

---

### Browserless API Index | Browserless.io
Original URL: https://docs.browserless.io/baas/v1/apis/overview

[Skip to main content](https://docs.browserless.io/baas/v1/apis/overview#__docusaurus_skipToContent_fallback)



DEPRECATION WARNING

This documentation is for BaaS v1, which is no longer actively supported. If you are a new user, please refer to the updated documentation for [BaaS v2](https://docs.browserless.io/rest-apis/intro) or [BrowserQL](https://docs.browserless.io/browserql/start).

Browserless has production ready APIs that you can use depending on your use-case. Each API accepts different parameters and options; their schemas are displayed in the [Swagger UI page](https://chrome.browserless.io/docs/).

There are [Browser](https://chrome.browserless.io/docs/#/Browser%20API) and [Management](https://chrome.browserless.io/docs/#/Management%20API) APIs. The browser APIs help you execute specific tasks for your use-case. The management APIs allow you to access things like open sessions, metrics, and kill sessions among many more functions to monitor the health of your worker.

> The management APIs are not available for usage-based or cloud unit-based accounts.

### Browser APIs [â€‹](https://docs.browserless.io/baas/v1/apis/overview\#browser-apis "Direct link to Browser APIs")

- [/content](https://docs.browserless.io/baas/v1/apis/content)
- [/download](https://docs.browserless.io/baas/v1/apis/download)
- [/function](https://docs.browserless.io/baas/v1/apis/function)
- [/pdf](https://docs.browserless.io/baas/v1/apis/pdf)
- [/screencast](https://docs.browserless.io/baas/v1/apis/screencast)
- [/screenshot](https://docs.browserless.io/baas/v1/apis/screenshot)
- [/scrape](https://docs.browserless.io/baas/v1/apis/scrape)
- [/stats](https://docs.browserless.io/baas/v1/apis/stats)

### Management APIs [â€‹](https://docs.browserless.io/baas/v1/apis/overview\#management-apis "Direct link to Management APIs")

- [/workspace](https://docs.browserless.io/baas/v1/apis/workspace)
- [/sessions](https://docs.browserless.io/baas/v1/apis/sessions)
- [/metrics](https://docs.browserless.io/baas/v1/apis/metrics)
- [/pressure](https://docs.browserless.io/baas/v1/apis/pressure)
- [/kill](https://docs.browserless.io/baas/v1/apis/kill)
- [/config](https://docs.browserless.io/baas/v1/apis/config)

Remember to check out all the APIs available from the [Swagger UI page](https://chrome.browserless.io/docs/)

- [Browser APIs](https://docs.browserless.io/baas/v1/apis/overview#browser-apis)
- [Management APIs](https://docs.browserless.io/baas/v1/apis/overview#management-apis)

---

### /pdf API | Browserless.io
Original URL: https://docs.browserless.io/baas/v1/apis/pdf

[Skip to main content](https://docs.browserless.io/baas/v1/apis/pdf#__docusaurus_skipToContent_fallback)



DEPRECATION WARNING

This documentation is for BaaS v1, which is no longer actively supported. If you are a new user, please refer to the updated documentation for [BaaS v2](https://docs.browserless.io/rest-apis/pdf) or [BrowserQL](https://docs.browserless.io/browserql/start).

The pdf API allows for simple navigation to a site and capturing a pdf. browserless will respond with a `Content-Type` of `application/pdf`, and a Buffer of the pdf file. Similar to screenshots, this also exposes puppeteer's `pdf` options via an `options` property in the JSON body for granular control.

If you want to see all the options check out this API schema defined in [Swagger](https://chrome.browserless.io/docs/#/Browser%20API/post_pdf).

> This route requires either a `url` or `html` property in the JSON body. When `html` is present browserless will render the HTML for you and capture the PDF

## Basic Usage [â€‹](https://docs.browserless.io/baas/v1/apis/pdf\#basic-usage "Direct link to Basic Usage")

```codeBlockLines_p187
// JSON body
// `options` are the options available via puppeteer's Page.pdf() method
// (see https://pptr.dev/api/puppeteer.pdfoptions)
{
  "url": "https://example.com/",
  "options": {
    "displayHeaderFooter": true,
    "printBackground": false,
    "format": "A0"
  }
}

```

**cURL request**

```codeBlockLines_p187
curl -X POST \
  https://chrome.browserless.io/pdf?token=MY_API_TOKEN \
  -H 'Cache-Control: no-cache' \
  -H 'Content-Type: application/json' \
  -d '{
  "url": "https://example.com/",
  "options": {
    "displayHeaderFooter": true,
    "printBackground": false,
    "format": "A0"
  }
}'

```

> We do not allow to set a `options.path`

## Custom options [â€‹](https://docs.browserless.io/baas/v1/apis/pdf\#custom-options "Direct link to Custom options")

The `/pdf` route has a few special custom options that make it more usable and configurable. We've added these options based on feedback from you in hope that it will help gather best-practices in a single place.

### `gotoOptions` [â€‹](https://docs.browserless.io/baas/v1/apis/pdf\#gotooptions "Direct link to gotooptions")

The `gotoOptions` is an object that's passed directly into puppeteer's `page.goto()` call so that you can specify things like alternative loaded events. See [puppeteer's goto options](https://pptr.dev/api/puppeteer.page.goto#remarks) for more information.

**Example cURL request**

```codeBlockLines_p187
curl -X POST \
  https://chrome.browserless.io/pdf?token=MY_API_TOKEN \
  -H 'Cache-Control: no-cache' \
  -H 'Content-Type: application/json' \
  -d '{
  "url": "https://example.com/",
  "gotoOptions": {
    "waitUntil": "networkidle2",
  },
  "options": {
    "displayHeaderFooter": true,
    "printBackground": false,
    "format": "A0"
  }
}'

```

## Custom styling [â€‹](https://docs.browserless.io/baas/v1/apis/pdf\#custom-styling "Direct link to Custom styling")

If you need to inject custom CSS code to the page, you can use the `addStyleTag` property.

This property takes an array of objects, each with either a `content` property with valid CSS code, or a `url` property that loads the stylesheet from the web.

**Example**

```codeBlockLines_p187
{
  "url": "https://example.com/",
  "gotoOptions": {
    "waitUntil": "networkidle2"
  },
  "addStyleTag": [\
    {\
      "content": "body { height: 100vh;  background: linear-gradient(45deg, #da5a44, #a32784);}"\
    },\
    {\
      "url": "https://interactive-examples.mdn.mozilla.net/live-examples/css-examples/text-decoration/text-decoration-color.css"\
    }\
  ]
}

```

## safeMode [â€‹](https://docs.browserless.io/baas/v1/apis/pdf\#safemode "Direct link to safeMode")

Because longer pages can crash trigger a "Page Crashed!" error when doing a `page.pdf` invocation, we've implemented a "safe" way to generate PDF's of bigger websites. When set to `true`, `safeMode` will:

- Capture PDF's _one_ page at a time in-memory.
- Once all pages are in memory we connect them together.
- Compress the PDF so it's more efficiently transported over the network.
- Return the resulting PDF as a binary via `application/pdf`.

> Please note that when using `safeMode` that it will likely take a while longer to process the request, and the resulting PDF file may be larger.

**Example cURL request**

```codeBlockLines_p187
curl -X POST \
  https://chrome.browserless.io/pdf?token=MY_API_TOKEN \
  -H 'Cache-Control: no-cache' \
  -H 'Content-Type: application/json' \
  -d '{
  "url": "https://example.com/",
  "safeMode": true,
  "options": {
    "displayHeaderFooter": true,
    "printBackground": false,
    "format": "A0"
  }
}'

```

- [Basic Usage](https://docs.browserless.io/baas/v1/apis/pdf#basic-usage)
- [Custom options](https://docs.browserless.io/baas/v1/apis/pdf#custom-options)
  - [`gotoOptions`](https://docs.browserless.io/baas/v1/apis/pdf#gotooptions)
- [Custom styling](https://docs.browserless.io/baas/v1/apis/pdf#custom-styling)
- [safeMode](https://docs.browserless.io/baas/v1/apis/pdf#safemode)

---

### /pressure API | Browserless.io
Original URL: https://docs.browserless.io/baas/v1/apis/pressure

[Skip to main content](https://docs.browserless.io/baas/v1/apis/pressure#__docusaurus_skipToContent_fallback)



DEPRECATION WARNING

This documentation is for BaaS v1, which is no longer actively supported. If you are a new user, please refer to the updated documentation for [BaaS v2](https://docs.browserless.io/rest-apis/intro) or [BrowserQL](https://docs.browserless.io/browserql/start).

The pressure API allows you to retrieve the current metrics of your worker(s) **and is only available for dedicated and self-hosted accounts.** This API is different to the [metrics API](https://chrome.browserless.io/docs/#/Management%20API/get_metrics) since the pressure API only returns one object (the current metrics) whereas the metrics API returns a collection of all the metrics data with one week of history.

Check out the [pressure API schema](https://chrome.browserless.io/docs/#/Management%20API/get_pressure) defined in our Swagger page.

## Gathering metrics from your workers [â€‹](https://docs.browserless.io/baas/v1/apis/pressure\#gathering-metrics-from-your-workers "Direct link to Gathering metrics from your workers")

To see statistics regarding your workers, simply issue a `GET` request to `/pressure`:

```codeBlockLines_p187
curl -X GET \
  https://chrome.browserless.io/pressure?token=MY_API_TOKEN

```

warning

Remember that running this in the browser will expose your API key!

Running this cURL request will result in an output like:

```codeBlockLines_p187
{
  "date": 0,
  "successful": 0,
  "queued": 0,
  "rejected": 0,
  "unhealthy": 0,
  "memory": 0,
  "cpu": 0,
  "timedout": 0,
  "totalTime": 0,
  "meanTime": 0,
  "maxTime": 0,
  "minTime": 0,
  "maxConcurrent": 0,
  "sessionTimes": [0]
}

```

- [Gathering metrics from your workers](https://docs.browserless.io/baas/v1/apis/pressure#gathering-metrics-from-your-workers)

---

### /scrape API | Browserless.io
Original URL: https://docs.browserless.io/baas/v1/apis/scrape

[Skip to main content](https://docs.browserless.io/baas/v1/apis/scrape#__docusaurus_skipToContent_fallback)



DEPRECATION WARNING

This documentation is for BaaS v1, which is no longer actively supported. If you are a new user, please refer to the updated documentation for [BaaS v2](https://docs.browserless.io/rest-apis/scrape) or [BrowserQL](https://docs.browserless.io/browserql/start).

The scrape API allows for getting the contents a page, by specifying selectors you are interested in, and returning a structured JSON response. We also allow for setting a timeout option for asynchronously added elements.

The default behavior is to navigate to the URL specified, wait for the page to load (including parsing and executing of JavaScript), then waiting for the elements for a maximum of 30 seconds. All of these are configurable, and documented in detail below.

At a minimum you'll need to specify at least a `url` and an `elements` array.

Check out this API schema defined in [Swagger](https://chrome.browserless.io/docs/#/Browser%20API/post_scrape).

## Basic Usage [â€‹](https://docs.browserless.io/baas/v1/apis/scrape\#basic-usage "Direct link to Basic Usage")

Below is the most basic usage, where we'll navigate to the example.com website (waiting for page-load) and parse out all `a` elements.

Internally we use `document.querySelectorAll` to retrieve all matches on a page. Using a more specific selector can narrow down the returned results.

**Get the a elements on example.com**

```codeBlockLines_p187
{
  "url": "https://example.com/",
  "elements": [\
    {\
      "selector": "a"\
    }\
  ]
}

```

**cURL request**

```codeBlockLines_p187
curl -X POST \
  https://chrome.browserless.io/scrape?token=MY_API_TOKEN \
  -H 'Cache-Control: no-cache' \
  -H 'Content-Type: application/json' \
  -d '{
  "url": "https://example.com/",
  "elements": [{\
      "selector": "a"\
  }]
}'

```

Once ran, this will return a JSON payload of the following. We return the `innerHTML` and `innerText` of all matched selectors, as well as all their `attributes`. In the case of the above call, this will return:

```codeBlockLines_p187
{
  "data": [\
    {\
      "selector": "a",\
      "results": [\
        {\
          "html": "More information...",\
          "text": "More information...",\
          "attributes": [\
            {\
              "name": "href",\
              "value": "https://www.iana.org/domains/example"\
            }\
          ]\
        }\
      ]\
    }\
  ]
}

```

## Specifying page-load behavior [â€‹](https://docs.browserless.io/baas/v1/apis/scrape\#specifying-page-load-behavior "Direct link to Specifying page-load behavior")

The scrape API allows for setting specific page-load behaviors by setting a `gotoOptions` in the JSON body. This is passed directly into [puppeteer's `goto()` method](https://pptr.dev/api/puppeteer.page.goto).

In the example below, we'll set a `waitUntil` property and a `timeout`

**Get the H1 elements on example.com with custom goto options**

```codeBlockLines_p187
{
  "url": "https://example.com/",
  "elements": [\
    {\
      "selector": "h1"\
    }\
  ],
  "gotoOptions": {
    "timeout": 10000,
    "waitUntil": "networkidle2"
  }
}

```

This will now force selectors to be collected _after_ the network has been idle for 2 seconds, and we'll timeout the request after 10 seconds.

## Custom behavior with `waitFor` [â€‹](https://docs.browserless.io/baas/v1/apis/scrape\#custom-behavior-with-waitfor "Direct link to custom-behavior-with-waitfor")

Sometimes it's helpful to do further actions, or wait for custom events on the page before getting data. We allow this behavior with the `waitFor` property. We closely follow [puppeteer's `waitFor()` method](https://github.com/puppeteer/puppeteer/blob/7b768838023bcb79051f5d34c96949ef253ad9a2/docs/api.md#pagewaitforselectororfunctionortimeout-options-args).

This property can accept one of three options:

- A function to be ran within the page's context, inside of the browser.
- A `number` indicating the time in milliseconds to wait.
- A valid selector to wait for.

**Waiting for a selector**

```codeBlockLines_p187
{
  "url": "https://example.com/",
  "elements": [\
    {\
      "selector": "h1"\
    }\
  ],
  "waitFor": "h1"
}

```

**Waiting for 10 seconds**

```codeBlockLines_p187
{
  "url": "https://example.com/",
  "elements": [\
    {\
      "selector": "h1"\
    }\
  ],
  "waitFor": 10000
}

```

**Waiting for a function**

```codeBlockLines_p187
{
  "url": "https://example.com/",
  "elements": [\
    {\
      "selector": "h1"\
    }\
  ],
  "waitFor": "() => document.querySelector('h1')"
}

```

**Error handling**

We do catch and return errors for invalid functions inside of `waitFor`. For instance: `() => document.querySelector('h1'))` as a `waitFor` will return an HTTP code of `400` and the following text:

```codeBlockLines_p187
Evaluation failed: SyntaxError: Unexpected token ')'
at new Function (<anonymous>)
  at waitForPredicatePageFunction (__puppeteer_evaluation_script__:2:21)

```

## Cookies, headers and other options [â€‹](https://docs.browserless.io/baas/v1/apis/scrape\#cookies-headers-and-other-options "Direct link to Cookies, headers and other options")

As with our other APIs, you can inject things like `cookies`, `headers` and other options, including intercepting requests and responses. These follow the pattern set by [puppeteer's `setCokkie()`](https://pptr.dev/15.3.0/api/puppeteer.page.setcookie) and [`setExtraHTTPHeaders()` methods](https://pptr.dev/15.3.0/api/puppeteer.page.setextrahttpheaders).

**Setting a special cookie**

```codeBlockLines_p187
{
  "url": "https://example.com/",
  "elements": [\
    {\
      "selector": "h1"\
    }\
  ],
  "cookies": [\
    {\
      "name": "my-special-cookie",\
      "value": "foo-bar",\
      "url": "https://www.example.com",\
      "path": "/",\
      "sameSite": "Strict"\
    }\
  ]
}

```

**Adding an authentication header**

```codeBlockLines_p187
{
  "url": "https://example.com/",
  "elements": [\
    {\
      "selector": "h1"\
    }\
  ],
  "setExtraHTTPHeaders": {
    "Authentication": "Basic foo-bar"
  }
}

```

**Intercepting requests**

```codeBlockLines_p187
{
  "url": "https://example.com/",
  "elements": [\
    {\
      "selector": "h1"\
    }\
  ],
  "rejectRequestPattern": ["png", "jpg"]
}

```

## Element timeouts [â€‹](https://docs.browserless.io/baas/v1/apis/scrape\#element-timeouts "Direct link to Element timeouts")

browserless will wait for the elements specified for up to 30 seconds to be inserted in the page. This is useful for single-page applications that can load data on the fly. You can conditionally change this timer by specifying a `timeout` property per-element.

**Using a custom timeout of 10 seconds**

```codeBlockLines_p187
{
  "url": "https://example.com/",
  "elements": [\
    {\
      "selector": "h1",\
      "timeout": 10000\
    },\
    {\
      "selector": "a",\
      "timeout": 5000\
    }\
  ]
}

```

## Debugging [â€‹](https://docs.browserless.io/baas/v1/apis/scrape\#debugging "Direct link to Debugging")

Without a doubt, one of the most frustrating aspects of scraping is debugging broken scripts. This is nothing new for browserless, and though we offer [excellent debugging tools](https://www.browserless.io/blog/2019/04/18/live-debugger/), we thought it'd be appropriate to add some extra information in the JSON response to help make debugging even easier.

As of today, we offer five payloads to help debug the page: `html`, `screenshot`, `console`, `cookies` and `network`. Each is listed below.

**HTML**: This is the raw HTML of the webpage, after all page-load and `waitFor` functions have ran.

**Screenshot**: A full-page JPEG of the page encoded in `base64`.

**Console**: An array of all the various `console` messages the page has written out.

**Cookies**: An array of objects specifying all the cookies currently set on the page.

**Network**: An object with two properties: `inbound` and `outbound`, representing the outgoing requests as well as their inbound responses.

In order to get this debugging information, you'll need to specify that you want it in your JSON POST payload. This is made optional due to the fact that generating these properties can take additional resources away from other concurrent work. You'll need to specify what fields you want, by adding a `debug` object and declaring what fields you want returned. Here's an example of getting all the fields back:

**Requesting all debug fields**

```codeBlockLines_p187
{
  "url": "https://example.com/",
  "elements": [\
    {\
      "selector": "h1",\
      "timeout": 10000\
    },\
    {\
      "selector": "a",\
      "timeout": 5000\
    }\
  ],
  "debug": {
    "screenshot": true,
    "console": true,
    "network": true,
    "cookies": true,
    "html": true
  }
}

```

- [Basic Usage](https://docs.browserless.io/baas/v1/apis/scrape#basic-usage)
- [Specifying page-load behavior](https://docs.browserless.io/baas/v1/apis/scrape#specifying-page-load-behavior)
- [Custom behavior with `waitFor`](https://docs.browserless.io/baas/v1/apis/scrape#custom-behavior-with-waitfor)
- [Cookies, headers and other options](https://docs.browserless.io/baas/v1/apis/scrape#cookies-headers-and-other-options)
- [Element timeouts](https://docs.browserless.io/baas/v1/apis/scrape#element-timeouts)
- [Debugging](https://docs.browserless.io/baas/v1/apis/scrape#debugging)

---

### /screencast API | Browserless.io
Original URL: https://docs.browserless.io/baas/v1/apis/screencast

[Skip to main content](https://docs.browserless.io/baas/v1/apis/screencast#__docusaurus_skipToContent_fallback)



DEPRECATION WARNING

This documentation is for BaaS v1, which is no longer actively supported. If you are a new user, please refer to the updated documentation for [BaaS v2](https://docs.browserless.io/rest-apis/intro) or [BrowserQL](https://docs.browserless.io/browserql/start).

> The screencast API is still under beta, and isn't recommended yet for production usage.

The screencast API allows for generating video files, on demand, of your puppeteer scripts. This simple REST API allows for POSTing of an `application/json` _or_ `application/javascript` body of your code you'd like to record. The resulting response is a `webm` file with the video attached. Audio is now supported in our screencast API as of docker version `1.8.0`.

The resulting video's dimensions are _inherited_ by the width and height of the browser. You can change this very easily by calling `page.setViewport` with your dimensions in your scripts as well as setting `--window-size` in the URL.

Check out this API schema defined in [Swagger](https://chrome.browserless.io/docs/#/Browser%20API/post_screencast).

## Basic Usage [â€‹](https://docs.browserless.io/baas/v1/apis/screencast\#basic-usage "Direct link to Basic Usage")

**Example body**

```codeBlockLines_p187
module.exports = async ({ page }) => {
  const sleep = (ms) => new Promise((res) => setTimeout(res, ms));

  await page.setViewport({ width: 1920, height: 1080 });
  await page.goto('https://www.youtube.com/watch?v=GnEmD17kYsE');
  await sleep(10000);
};

```

And the resulting `cURL` call:

**Full cURL request**

```codeBlockLines_p187
curl -X POST \
  https://chrome.browserless.io/screencast?token=MY-API-TOKEN&--window-size=1920,1080 \
  -o video.webm \
  -H 'Content-Type: application/javascript' \
  -d '
    module.exports = async ({ page }) => {
      const sleep = (ms) => new Promise((res) => setTimeout(res, ms));

      await page.setViewport({ width: 1920, height: 1080 });
      await page.goto(`https://www.youtube.com/watch?v=GnEmD17kYsE`);
      await sleep(10000);
    };
  '

```

## Using `application/javascript` content-type [â€‹](https://docs.browserless.io/baas/v1/apis/screencast\#using-applicationjavascript-content-type "Direct link to using-applicationjavascript-content-type")

The `application/javascript` content-type is great for testing quick scripts and seeing their output and works with many tools like postman for faster feedback. When using this API you'll need to specify an appropriate content-type for the body of the request. When the type is `application/json` the /screencast API follows a similar semantic of the `/function` API, where you'll apply both a `code` property and a `context` property.

This makes your request more reusable as you can specify arguments in the `context` property that your code can reference. The only limitation is that all parameters will need to be hard-coded.

**Example code body**

```codeBlockLines_p187
module.exports = async ({ page, context }) => {
  const sleep = (ms) => new Promise((res) => setTimeout(res, ms));

  const { url, wait, width, height } = context;
  await page.setViewport({ width, height });
  await page.goto(url);
  await sleep(wait);
};

```

**context object example**

```codeBlockLines_p187
// JSON body
// Code is minified here!
{
  "code": "module.exports = async ({ page, context }) => { const sleep = (ms) => new Promise((res) => setTimeout(res, ms)); const { url, wait, width, height } = context; await page.setViewport({ width, height }); await page.goto(url); await sleep(wait); };",
  "context": {
    "url": "https://www.youtube.com/watch?v=GnEmD17kYsE",
    "wait": 1000,
    "width": 1920,
    "height": 1080
  }
}

```

**Full cURL request**

```codeBlockLines_p187
curl -X POST \
  https://chrome.browserless.io/screencast?token=YOUR-API-TOKEN&--window-size=1920,1080 \
  -o video.webm \
  -H 'Content-Type: application/json' \
  -d '{
  "code": "module.exports = async ({ page, context }) => { const sleep = (ms) => new Promise((res) => setTimeout(res, ms)); const { url, wait, width, height } = context; await page.setViewport({ width, height }); await page.goto(url); await sleep(wait); };",
  "context": {
    "url": "https://www.youtube.com/watch?v=GnEmD17kYsE",
    "wait": 5000,
    "width": 1920,
    "height": 1080
  }
}'

```

## Programmatic control [â€‹](https://docs.browserless.io/baas/v1/apis/screencast\#programmatic-control "Direct link to Programmatic control")

By default, browserless will start recording the session immediately and will stop once your function completes execution. You can change this behavior by using two functions in your code: `startScreencast` and `stopScreencast`:

**Starting the screencast after load**

```codeBlockLines_p187
module.exports = async ({ page, startScreencast, stopScreencast }) => {
  const sleep = (ms) => new Promise((res) => setTimeout(res, ms));

  await page.goto('https://vclock.com/stopwatch');
  await page.click('#btn-resume');
  startScreencast();
  await sleep(5000);
  stopScreencast();
};

```

**Full cURL request**

```codeBlockLines_p187
curl -X POST \
  https://chrome.browserless.io/screencast?token=YOUR-API-TOKEN \
  -H 'Content-Type: application/javascript' \
  -d 'module.exports = async ({ page, startScreencast, stopScreencast }) => {
    const sleep = (ms) => new Promise((res) => setTimeout(res, ms));

    await page.goto("https://vclock.com/stopwatch");
    await page.click("#btn-resume");
    startScreencast();
    await sleep(5000);
    stopScreencast();
}'

```

- [Basic Usage](https://docs.browserless.io/baas/v1/apis/screencast#basic-usage)
- [Using `application/javascript` content-type](https://docs.browserless.io/baas/v1/apis/screencast#using-applicationjavascript-content-type)
- [Programmatic control](https://docs.browserless.io/baas/v1/apis/screencast#programmatic-control)

---

### /screenshot API | Browserless.io
Original URL: https://docs.browserless.io/baas/v1/apis/screenshot

[Skip to main content](https://docs.browserless.io/baas/v1/apis/screenshot#__docusaurus_skipToContent_fallback)



DEPRECATION WARNING

This documentation is for BaaS v1, which is no longer actively supported. If you are a new user, please refer to the updated documentation for [BaaS v2](https://docs.browserless.io/rest-apis/screenshot) or [BrowserQL](https://docs.browserless.io/browserql/start).

The screenshot API allows for simple navigation to a site and capturing a screenshot. browserless will respond with either a binary or base64 encode of a `png` or `jpg` (depending on parameters). This API exposes most of puppeteer's screenshot API through the posted JSON payload.

If you want to see all the options check out this API schema defined in [Swagger](https://chrome.browserless.io/docs/#/Browser%20API/post_screenshot).

## Basic Usage [â€‹](https://docs.browserless.io/baas/v1/apis/screenshot\#basic-usage "Direct link to Basic Usage")

```codeBlockLines_p187
// JSON body
// `options` are the options available via puppeteer's Page.screenshot() method
// (see https://pptr.dev/api/puppeteer.screenshotoptions)
{
  "url": "https://example.com/",
  "options": {
    "fullPage": true,
    "type": "jpeg",
    "quality": 75
  }
}

```

**cURL request**

```codeBlockLines_p187
curl -X POST \
  https://chrome.browserless.io/screenshot?token=MY_API_TOKEN \
  -H 'Cache-Control: no-cache' \
  -H 'Content-Type: application/json' \
  -d '{
  "url": "https://example.com/",
  "options": {
    "fullPage": true,
    "type": "jpeg",
    "quality": 75
  }
}'

```

## Screenshot options [â€‹](https://docs.browserless.io/baas/v1/apis/screenshot\#screenshot-options "Direct link to Screenshot options")

We support Puppeteer's [screenshot options](https://pptr.dev/api/puppeteer.screenshotoptions/#properties) almost in its entirety, and you can easily pass options to the JSON payload using the `options` property.

**Example**

```codeBlockLines_p187
{
  "url": "https://example.com/",
  "options": {
    "type": "jpeg",
    "clip": {
      "height": 200,
      "width": 600,
      "x": 90,
      "y": 100
    },
    "fullPage": false,
    "encoding": "binary"
  }
}

```

> We do not allow to set a `options.path` nor to return a `webp`

## Custom options [â€‹](https://docs.browserless.io/baas/v1/apis/screenshot\#custom-options "Direct link to Custom options")

The `/screenshot` route has a few special custom options that make it more usable and configurable. We've added these options based on feedback from you in hope that it will help gather best-practices in a single place.

### `gotoOptions` [â€‹](https://docs.browserless.io/baas/v1/apis/screenshot\#gotooptions "Direct link to gotooptions")

The `gotoOptions` is an object that's passed directly into puppeteer's `page.goto()` call so that you can specify things like alternative loaded events. See [puppeteer's goto options](https://pptr.dev/api/puppeteer.page.goto#remarks) for more information.

**cURL request**

```codeBlockLines_p187
curl -X POST \
  https://chrome.browserless.io/screenshot?token=MY_API_TOKEN \
  -H 'Cache-Control: no-cache' \
  -H 'Content-Type: application/json' \
  -d '{
  "url": "https://example.com/",
  "gotoOptions": {
    "waitUntil": "networkidle2",
  }
}'

```

## Custom styling [â€‹](https://docs.browserless.io/baas/v1/apis/screenshot\#custom-styling "Direct link to Custom styling")

If you need to inject custom CSS code to the page, you can use the `addStyleTag` property.

This property takes an array of objects, each with either a `content` property with valid CSS code, or a `url` property that loads the stylesheet from the web.

**Example**

```codeBlockLines_p187
{
  "url": "https://example.com/",
  "gotoOptions": {
    "waitUntil": "networkidle2"
  },
  "addStyleTag": [\
    {\
      "content": "body { height: 100vh;  background: linear-gradient(45deg, #da5a44, #a32784);}"\
    },\
    {\
      "url": "https://interactive-examples.mdn.mozilla.net/live-examples/css-examples/text-decoration/text-decoration-color.css"\
    }\
  ]
}

```

## Custom behavior with `waitFor` [â€‹](https://docs.browserless.io/baas/v1/apis/screenshot\#custom-behavior-with-waitfor "Direct link to custom-behavior-with-waitfor")

If you need to wait for a selector to appear in the DOM, to wait for a timeout to happen, or to execute a custom function before screenshotting, you can use the `waitFor` property in your JSON payload.

We closely follow [puppeteer's `waitFor()` method](https://github.com/puppeteer/puppeteer/blob/7b768838023bcb79051f5d34c96949ef253ad9a2/docs/api.md#pagewaitforselectororfunctionortimeout-options-args).

This property can accept one of three options:

- A valid CSS selector to wait for.
- A `number` indicating the time in milliseconds to wait.
- A function to be ran within the page's context.

**Waiting for a selector**

```codeBlockLines_p187
{
  "url": "https://example.com/",
  "waitFor": "h1"
}

```

**Waiting for a timeout**

```codeBlockLines_p187
{
  "url": "https://example.com/",
  "waitFor": 5000
}

```

**Waiting for a function**

```codeBlockLines_p187
{
  "url": "https://example.com/",
  "waitFor": "() => document.querySelector(`h1`).innerText = `Hello World!`"
}

```

- [Basic Usage](https://docs.browserless.io/baas/v1/apis/screenshot#basic-usage)
- [Screenshot options](https://docs.browserless.io/baas/v1/apis/screenshot#screenshot-options)
- [Custom options](https://docs.browserless.io/baas/v1/apis/screenshot#custom-options)
  - [`gotoOptions`](https://docs.browserless.io/baas/v1/apis/screenshot#gotooptions)
- [Custom styling](https://docs.browserless.io/baas/v1/apis/screenshot#custom-styling)
- [Custom behavior with `waitFor`](https://docs.browserless.io/baas/v1/apis/screenshot#custom-behavior-with-waitfor)

---

### /sessions API | Browserless.io
Original URL: https://docs.browserless.io/baas/v1/apis/sessions

[Skip to main content](https://docs.browserless.io/baas/v1/apis/sessions#__docusaurus_skipToContent_fallback)



DEPRECATION WARNING

This documentation is for BaaS v1, which is no longer actively supported. If you are a new user, please refer to the updated documentation for [BaaS v2](https://docs.browserless.io/enterprise/utility-functions/sessions) or [BrowserQL](https://docs.browserless.io/browserql/start).

The sessions API allows you to gather information about the currently running sessions **and is only available for dedicated and self-hosted accounts**

Check out this API schema defined in [Swagger](https://chrome.browserless.io/docs/#/Management%20API/get_sessions).

## Gathering information from your running sessions [â€‹](https://docs.browserless.io/baas/v1/apis/sessions\#gathering-information-from-your-running-sessions "Direct link to Gathering information from your running sessions")

To see information regarding the running sessions, simply issue a `GET` request to `/sessions`:

```codeBlockLines_p187
curl -X GET \
  https://chrome.browserless.io/sessions?token=MY_API_TOKEN

```

warning

Remember that running this in the browser will expose your API key!

Running this cURL request will result in an output like:

```codeBlockLines_p187
[\
  {\
    "description": "",\
    "devtoolsFrontendUrl": "/devtools/inspector.html?ws=0.0.0.0:3000/devtools/page/7B491986CD0B6408DF15A339A7621226",\
    "id": "7B491986CD0B6408DF15A339A7621226",\
    "title": "Example Domain",\
    "type": "page",\
    "url": "https://www.example.com",\
    "webSocketDebuggerUrl": "ws://0.0.0.0:3000/devtools/page/7B491986CD0B6408DF15A339A7621226",\
    "port": "41685",\
    "browserId": "b95cd82a-76b1-495e-8092-b040de780d0f",\
    "trackingId": null,\
    "browserWSEndpoint": "ws://0.0.0.0:3000/devtools/browser/b95cd82a-76b1-495e-8092-b040de780d0f"\
  }\
]

```

- [Gathering information from your running sessions](https://docs.browserless.io/baas/v1/apis/sessions#gathering-information-from-your-running-sessions)

---

### /stats API | Browserless.io
Original URL: https://docs.browserless.io/baas/v1/apis/stats

[Skip to main content](https://docs.browserless.io/baas/v1/apis/stats#__docusaurus_skipToContent_fallback)



DEPRECATION WARNING

This documentation is for BaaS v1, which is no longer actively supported. If you are a new user, please refer to the updated documentation for [BaaS v2](https://docs.browserless.io/rest-apis/intro) or [BrowserQL](https://docs.browserless.io/browserql/start).

The stats API reveals key metrics about a site's accessibility, best practices, performance, PWA information, and SEO, from a performance standpoint. It includes useful metrics like latency, time-to-interaction, design contrast other recommendations. This API is powered by [Google's Lighthouse](https://github.com/GoogleChrome/lighthouse) project, and it's compatible with its CLI options.

In order to gather this data, send a `POST` request to `https://chrome.browserless.io/stats` if on a hosted plan, with a simple JSON payload containing a valid URL.

warning

Due to the number of checks gathered it can take anywhere from several seconds to minutes depending on the site and size of the worker.

If you want to see all the options check out this API schema defined in [Swagger](https://chrome.browserless.io/docs/#/Browser%20API/post_stats).

### Examples [â€‹](https://docs.browserless.io/baas/v1/apis/stats\#examples "Direct link to Examples")

1. [Basic Usage](https://docs.browserless.io/baas/v1/apis/stats#basic-usage)
2. [Gathering metrics for a category](https://docs.browserless.io/baas/v1/apis/stats#gathering-metrics-for-a-category)
3. [Gathering metrics from a single audit](https://docs.browserless.io/baas/v1/apis/stats#gathering-metrics-from-a-single-audit)

## Basic Usage [â€‹](https://docs.browserless.io/baas/v1/apis/stats\#basic-usage "Direct link to Basic Usage")

**JSON**

```codeBlockLines_p187
{
  "url": "https://example.com/"
}

```

**cURL request**

```codeBlockLines_p187
curl -X POST \
  https://chrome.browserless.io/stats?token=MY_API_TOKEN \
  -H 'Cache-Control: no-cache' \
  -H 'Content-Type: application/json' \
  -d '
{
  "url": "https://example.com/"
}'

```

By default, the `/stats` API will gather **all** the metrics. This will not only result in a **really** big JSON response (350kb to 800kb on average) and it **will** take some seconds (to minutes) to complete.

Each test has a score that indicates how well it performed, where 1 is the maximum and 0 is the lowest, generating a response like this:

```codeBlockLines_p187
  // ...
  "audits": {
    "is-on-https": {
      "title": "Uses HTTPS",
      "score": 1
      // ...
    },
    "viewport": {
      "title": "Has a `<meta name=\"viewport\">` tag with `width` or `initial-scale`",
      "score": 1
      // ...
    },
    "first-contentful-paint": {
      "score": 1,
      "displayValue": "0.8Â s"
      // ...
    }
    // ...
  }

```

## Gathering metrics for a category [â€‹](https://docs.browserless.io/baas/v1/apis/stats\#gathering-metrics-for-a-category "Direct link to Gathering metrics for a category")

You can get metrics from specific categories, using the `config` property. [Just like Lighthouse](https://github.com/GoogleChrome/lighthouse/blob/master/readme.md#cli-options), available categories are `accessibility`, `best practices`, `performance`, `pwa`, and `seo`

**JSON**

```codeBlockLines_p187
{
  "url": "https://example.com",
  "config": {
    "extends": "lighthouse:default",
    "settings": {
      "onlyCategories": ["accessibility"]
    }
  }
}

```

**cURL request**

```codeBlockLines_p187
curl --request POST \
  --url 'https://chrome.browserless.io/stats?token=MY_API_TOKEN' \
  --header 'Cache-Control: no-cache' \
  --header 'Content-Type: application/json' \
  --data '{
  "url": "https://browserless.io",
  "config": {
    "extends": "lighthouse:default",
    "settings": {
      "onlyCategories": ["accessibility"]
    }
  }
}'

```

This will gather the predefined metrics defined by Lighthouse for that category:

```codeBlockLines_p187
  // ...
  "audits": {
    "aria-command-name": {
      "title": "`button`, `link`, and `menuitem` elements have accessible names",
      "score": 1
      // ...
    },
    "aria-hidden-body": {
      "title": "`[aria-hidden=\"true\"]` is not present on the document `<body>`",
      "score": 1
      // ...
    },
    "aria-hidden-focus": {
      "title": "`[aria-hidden=\"true\"]` elements do not contain focusable descendents",
      "score": 1
      // ...
    },
    // ...
  }

```

## Gathering metrics from a single audit [â€‹](https://docs.browserless.io/baas/v1/apis/stats\#gathering-metrics-from-a-single-audit "Direct link to Gathering metrics from a single audit")

You can get any specific metrics [valid in Lighthouse](https://github.com/GoogleChrome/lighthouse/tree/master/core/audits)

```codeBlockLines_p187
{
  "url": "https://browserless.io",
  "config": {
    "extends": "lighthouse:default",
    "settings": {
      "onlyAudits": ["unminified-css"]
    }
  }
}

```

**cURL request**

```codeBlockLines_p187
curl --request POST \
  --url 'https://chrome.browserless.io/stats?token=MY_API_TOKEN' \
  --header 'Cache-Control: no-cache' \
  --header 'Content-Type: application/json' \
  --data '{
  "url": "https://browserless.io",
  "config": {
    "extends": "lighthouse:default",
    "settings": {
      "onlyCategories": ["accessibility"]
    }
  }
}'

```

**Response example**

```codeBlockLines_p187
  // ...
  "audits": {
    "unminified-css": {
      "title": "Minify CSS",
      "score": 1
      // ...
    },
    // ...
  }

```

- [Examples](https://docs.browserless.io/baas/v1/apis/stats#examples)
- [Basic Usage](https://docs.browserless.io/baas/v1/apis/stats#basic-usage)
- [Gathering metrics for a category](https://docs.browserless.io/baas/v1/apis/stats#gathering-metrics-for-a-category)
- [Gathering metrics from a single audit](https://docs.browserless.io/baas/v1/apis/stats#gathering-metrics-from-a-single-audit)

---

### /workspace API | Browserless.io
Original URL: https://docs.browserless.io/baas/v1/apis/workspace

[Skip to main content](https://docs.browserless.io/baas/v1/apis/workspace#__docusaurus_skipToContent_fallback)



DEPRECATION WARNING

This documentation is for BaaS v1, which is no longer actively supported. If you are a new user, please refer to the updated documentation for [BaaS v2](https://docs.browserless.io/rest-apis/intro) or [BrowserQL](https://docs.browserless.io/browserql/start).

info

If you're using the hosted service, please refer to our GraphQL "workspace" query for better documentation. We also collect workspace results across your entire fleet in GraphQL. See [https://api.browserless.io/graphql](https://api.browserless.io/graphql)

When dealing with both file downloads and uploads, Chrome needs access to the local file-system. In most docker-based environments this can be challenging since each container runs with its own file-system, unless you attach a network-mounted file system (and subsequently grant it access in your `docker run` command). Because of these challenges we've implemented a series of API's that make it easier to work with files on disk, under the `/workspace` route.

Check out this API schema defined in [Swagger](https://chrome.browserless.io/docs/#/Management%20API/post_workspace).

info

The workspace API is only available for dedicated and self-hosted accounts

## Listing your files [â€‹](https://docs.browserless.io/baas/v1/apis/workspace\#listing-your-files "Direct link to Listing your files")

To get files on your running container, simply issue a `GET` request to `/workspace`:

```codeBlockLines_p187
curl -X GET \
  https://chrome.browserless.io/workspace?token=MY_API_TOKEN

```

The following cURL will result in an output like:

```codeBlockLines_p187
[\
  {\
    "created": "2019-07-15T22:11:40.157Z",\
    "isDirectory": false,\
    "name": "data.csv",\
    "path": "/workspace/data.csv",\
    "size": 52,\
    "workspaceId": null\
  }\
]

```

Please note that this _will_ print any files in the current directory, but won't recursively look into them. It will also show files that browserless itself hasn't had any interaction with (in cases where assign `WORKSPACE_DIR` to a non-empty directory in docker). Consequently, **browserless won't delete or remove any files automatically**, so take care that files are removed swiftly when no-longer needed.

With this information returned, we can now download a file from the system.

## Downloading files [â€‹](https://docs.browserless.io/baas/v1/apis/workspace\#downloading-files "Direct link to Downloading files")

Once you know the name of the file, you can simply issue a `GET` request for that particular file. We currently don't support downloading of all files in an archived format, so you'll need to issue a download request for every file you want.

```codeBlockLines_p187
curl -X GET \
  https://chrome.browserless.io/workspace/file-one.csv?token=MY_API_TOKEN

```

Depending on the file, and its extension, browserless will stream the file back. In this case since the file is a CSV file, it'll return a `text/csv; charset=UTF-8` Content-Type.

```codeBlockLines_p187
"Wednesday, October 10, 2018"
"Thursday, October 4, 2018"
"Monday, October 1, 2018"
"Wednesday, September 26, 2018"
"Monday, September 24, 2018"
"Wednesday, September 19, 2018"
"Monday, September 17, 2018"
"Wednesday, September 12, 2018"

```

## Saving files [â€‹](https://docs.browserless.io/baas/v1/apis/workspace\#saving-files "Direct link to Saving files")

If you need to have a file locally for Chrome to reference, then you'll need to upload it into browserless for consumption. This is done by `POST` ing a requests to the `/workspace` API with a `multipart/form-data` Content-Type. This allows for uploading of _multiple_ files, and is more flexible to meet a variety of use-cases. Once uploaded, browserless will return an array of file information based upon the content.

Please refer to your language or libraries documentation on how to handle `multipart/form-data` uploads. cURL, for instance, adds these headers automatically, as does many other libraries.

```codeBlockLines_p187
curl -X POST \
  https://chrome.browserless.io/workspace?token=MY_API_TOKEN \
  -F 'file=@/Users/browserless/Documents/file-one.csv'

```

Responses have the following output, and are always returned in an array:

```codeBlockLines_p187
[\
  {\
    "fieldname": "file",\
    "originalname": "file-one.csv",\
    "encoding": "7bit",\
    "mimetype": "text/csv",\
    "destination": "/Users/jgriffith/Downloads",\
    "filename": "file-one.csv",\
    "path": "/Users/jgriffith/Downloads/file-one.csv",\
    "size": 2649\
  }\
]

```

## Deleting files [â€‹](https://docs.browserless.io/baas/v1/apis/workspace\#deleting-files "Direct link to Deleting files")

> Be careful when deleting files as the operation cannot be undone

When work is complete, or you simply want to cleanup the workspace, you can issue a `DELETE` request for the file(s) you want to remove. Following upon our previous examples, you'll need to tell browserless which file to delete:

```codeBlockLines_p187
curl -X DELETE \
  https://chrome.browserless.io/workspace/file-one.csv?token=MY_API_TOKEN

```

Once this is complete, browserless will either respond with a `404` if the file isn't available, or a `204` if the operation was successful.

By default our dedicated plans automatically get their workspace contents deleted seven (7) days after creation.

## Scoping downloads [â€‹](https://docs.browserless.io/baas/v1/apis/workspace\#scoping-downloads "Direct link to Scoping downloads")

> Scoping downloads is available in version 1.11.0 of our docker images.

Often times workloads involve downloading the same files as previous sessions did, which can result in a filename conflict. You might also want to just extract _all_ the files that Chrome downloads in a particular session instead of a single file at a time. For instances such as these we recommend using a `trackingId` in your connect request.

`trackingID` treats the behavior of file downloads slightly differently. Instead of saving files in the default workspace directory, browserless will instead create a sub-directory with the name of the `trackingId` you provide. For instance, if you connect with the following, and run some work, the result of the /workspace GET call will include files in a sub-directory.

```codeBlockLines_p187
// Connect with a "trackingId" in the browserWSEndpoint:
puppeteer.connect({
  browserWSEndpoint:
    'wss://chrome.browserless.io?token=YOUR-API-TOKEN&trackingId=AwENCwMHDQoHBgwKBAUODQ',
});

// Do some work, download files, catch errors!
browser.close();

```

Now, with that session complete, a `GET /workspace` will reveal these contents:

```codeBlockLines_p187
[\
  {\
    // Date of file creation\
    created: "2019-07-15T22:11:40.157Z",\
\
    // If the download is a directory\
    isDirectory: false,\
\
    // The resulting files name\
    name: "data.csv",\
\
    // The path to retrieve the file\
    path: "/workspace/AwENCwMHDQoHBgwKBAUODQ/data.csv",\
\
    // The size of the file in bytes\
    size: 52,\
\
    // The tracking-id that this file belongs to\
    workspaceId: "AwENCwMHDQoHBgwKBAUODQ",\
  },\
];

```

Also, if you wish to get _all_ the files of a particular session, simply do a GET call with the sessions tracking ID in place. Following our previous example, that will look like:

```codeBlockLines_p187
curl -X GET \
  https://chrome.browserless.io/workspace/AwENCwMHDQoHBgwKBAUODQ?token=MY_API_TOKEN

```

This will return a ZIP archive of all the files downloaded from that particular session. Finally, you can do a DELETE call on that tracking-id to remove all files:

```codeBlockLines_p187
curl -X DELETE \
  https://chrome.browserless.io/workspace/AwENCwMHDQoHBgwKBAUODQ?token=MY_API_TOKEN

```

We strongly recommend using a `tracingId` that has a low chance of collision with another (like GUID or UUID). This prevents one session from overwriting another's request.

- [Listing your files](https://docs.browserless.io/baas/v1/apis/workspace#listing-your-files)
- [Downloading files](https://docs.browserless.io/baas/v1/apis/workspace#downloading-files)
- [Saving files](https://docs.browserless.io/baas/v1/apis/workspace#saving-files)
- [Deleting files](https://docs.browserless.io/baas/v1/apis/workspace#deleting-files)
- [Scoping downloads](https://docs.browserless.io/baas/v1/apis/workspace#scoping-downloads)

---

### Docker Configuration | Browserless.io
Original URL: https://docs.browserless.io/baas/v1/docker/config

[Skip to main content](https://docs.browserless.io/baas/v1/docker/config#__docusaurus_skipToContent_fallback)



DEPRECATION WARNING

This documentation is for BaaS v1, which is no longer actively supported. If you are a new user, please refer to the updated documentation for [BaaS v2](https://docs.browserless.io/enterprise/docker/configuration) or [BrowserQL](https://docs.browserless.io/browserql/start).

### All Options [â€‹](https://docs.browserless.io/baas/v1/docker/config\#all-options "Direct link to All Options")

- [Chrome information](https://docs.browserless.io/baas/v1/docker/config#chrome-information)
- [Port](https://docs.browserless.io/baas/v1/docker/config#port)
- [Max Concurrent Sessions](https://docs.browserless.io/baas/v1/docker/config#max-concurrent-sessions)
- [Connection Timeout](https://docs.browserless.io/baas/v1/docker/config#connection-timeout)
- [Max Queue Length](https://docs.browserless.io/baas/v1/docker/config#max-queue-length)
- [Pre-booting Chrome](https://docs.browserless.io/baas/v1/docker/config#pre-booting-chrome)
- [Pre-boot quantity](https://docs.browserless.io/baas/v1/docker/config#pre-boot-quantity)
- [Demo Mode](https://docs.browserless.io/baas/v1/docker/config#demo-mode)
- [Defining a host bind](https://docs.browserless.io/baas/v1/docker/config#defining-a-host-bind)
- [Defining a workspace location](https://docs.browserless.io/baas/v1/docker/config#defining-a-workspace-location)
- [Deleting workspace files automatically](https://docs.browserless.io/baas/v1/docker/config#deleting-workspace-files-automatically)
- [Defining a time to delete workspace files](https://docs.browserless.io/baas/v1/docker/config#defining-a-time-to-delete-workspace-files)
- [Disable the Debugger](https://docs.browserless.io/baas/v1/docker/config#disabling-the-debugger)
- [Disable download behavior](https://docs.browserless.io/baas/v1/docker/config#disable-download-behavior)
- [Securing your Instance](https://docs.browserless.io/baas/v1/docker/config#securing-your-instance)
- [Logging](https://docs.browserless.io/baas/v1/docker/config#logging)
- [Enable CORS](https://docs.browserless.io/baas/v1/docker/config#enable-cors)
- [Enable XVFB](https://docs.browserless.io/baas/v1/docker/config#enable-xvfb)
- [Exit on health failure](https://docs.browserless.io/baas/v1/docker/config#exit-on-health-failure)
- [Persisting Metrics](https://docs.browserless.io/baas/v1/docker/config#persisting-metrics)
- [Exposing Built-in Modules for `/function`](https://docs.browserless.io/baas/v1/docker/config#exposing-built-in-modules-to-function)
- [Exposing External Modules for `/function`](https://docs.browserless.io/baas/v1/docker/config#exposing-external-modules-to-function)
- [Keeping Chrome Alive](https://docs.browserless.io/baas/v1/docker/config#keeping-chrome-alive)
- [Chrome Refresh Time](https://docs.browserless.io/baas/v1/docker/config#chrome-refresh-time)
- [Single Run mode](https://docs.browserless.io/baas/v1/docker/config#single-run-mode)
- [Default Block Ads](https://docs.browserless.io/baas/v1/docker/config#default-block-ads)
- [Default Headless](https://docs.browserless.io/baas/v1/docker/config#default-headless)
- [Default Launch Args](https://docs.browserless.io/baas/v1/docker/config#default-launch-args)
- [Default Ignore Default Args](https://docs.browserless.io/baas/v1/docker/config#default-ignore-default-args)
- [Default Ignore HTTPS](https://docs.browserless.io/baas/v1/docker/config#default-ignore-https)
- [Default User Data Dir](https://docs.browserless.io/baas/v1/docker/config#default-user-data-dir)
- [Disabling Routes](https://docs.browserless.io/baas/v1/docker/config#disable-routes)
- [Enable API GET Calls](https://docs.browserless.io/baas/v1/docker/config#enable-api-get)
- [Function Incognito Mode](https://docs.browserless.io/baas/v1/docker/config#function-incognito-mode)
- [Pre-boot Chrome](https://docs.browserless.io/baas/v1/docker/config#pre-booting-chrome)
- [Using a proxy](https://docs.browserless.io/baas/v1/docker/config#using-a-proxy)

The browserless docker container is highly-configurable, and accepts parameters through environment variables when starting. You can set parameters such as port, connection-timeout, queueing and more. Below is a description of each parameter, what they mean, and what they default to.

## Chrome information [â€‹](https://docs.browserless.io/baas/v1/docker/config\#chrome-information "Direct link to Chrome information")

Browserless automatically builds labels with each release regarding important information like the current browser version, the version of puppeteer that's supported, and even the debugger version protocol. You can access this information by running the command below:

```codeBlockLines_p187
$ docker inspect browserless/chrome

```

## Port [â€‹](https://docs.browserless.io/baas/v1/docker/config\#port "Direct link to Port")

By default browserless listens on port `3000`. You can configure this in docker by using it's port mapping functionality. As an example, let's say you want to have it listen port `8080`, you would run it like so:

```codeBlockLines_p187
$ docker run -p 8080:3000 --restart always -d --name browserless browserless/chrome

```

This should allow you some flexibility in how to run the image.

## Max Concurrent Sessions [â€‹](https://docs.browserless.io/baas/v1/docker/config\#max-concurrent-sessions "Direct link to Max Concurrent Sessions")

Since running Chrome can be rather resource intensive you'll probably want to limit the number of concurrent sessions. This is, by default, set to 5 when not specified. Once the limit is reached then queueing begins to take place and requests will wait until more workers are ready.

To set this to a different number, say 10, issue your run like so:

```codeBlockLines_p187
$ docker run -e "MAX_CONCURRENT_SESSIONS=10" -p 3000:3000 --restart always -d --name browserless browserless/chrome

```

It's best to keep this limit small and grow it over time as it's easy to starve resources when running on restricted hardware.

## Connection Timeout [â€‹](https://docs.browserless.io/baas/v1/docker/config\#connection-timeout "Direct link to Connection Timeout")

Connection timeout is a parameter that sets how long any session can run for. This is in place to prevent scripts that don't cleanup properly, or run into errors tha cause them to hang. The value of which can be set in milliseconds, and defaults to `30000`, or 30 seconds.

To allow more time for sessions, simply change it by setting `CONNECTION_TIMEOUT` when running.

> You can opt-out of timers by setting this value to `-1` for _no_ session timer. Be sure to close connections when not in use!

```codeBlockLines_p187
$ docker run -e "CONNECTION_TIMEOUT=60000" -p 3000:3000 --restart always -d --name browserless browserless/chrome

```

## Max Queue Length [â€‹](https://docs.browserless.io/baas/v1/docker/config\#max-queue-length "Direct link to Max Queue Length")

This value determines how many items in the queue are allowed before requests are issued a `429` response code and closed. This mechanism is in place to prevent consumers from accidentally (or purposefully) triggering a denial-of-service. By default the image only allows a queue of 5 requests before beginning to fail more. As an example, if you have a `MAX_CONCURRENT_SESSIONS` of 5 and a `MAX_QUEUE_LENGTH` of 5, then 10 concurrent connections are allowed (5 running then 5 pending).

To adjust this value, simply set it via `MAX_QUEUE_LENGTH`.

```codeBlockLines_p187
$ docker run -e "MAX_QUEUE_LENGTH=10" -p 3000:3000 --restart always -d --name browserless browserless/chrome

```

## Pre-booting Chrome [â€‹](https://docs.browserless.io/baas/v1/docker/config\#pre-booting-chrome "Direct link to Pre-booting Chrome")

> Prebooting is an experimental feature, and its usage is generally discouraged if your workers don't have a lot of resources or if you are going to perform resource-intensive tasks (PDF rendering, scrapping JS-heavy webpages, screenshotting).

You can, optionally, pre-boot Chrome and keep it in a pool of instances in order to cut-down on the boot time. To enable this, run your docker command as you normally would plus the `PREBOOT_CHROME=true` flag. Unless specified otherwise using `PREBOOT_QUANTITY`, `PREBOOT_CHROME` will create a swarm of browsers of lenght `MAX_CONCURRENT_SESSIONS`.

```codeBlockLines_p187
$ docker run -e "PREBOOT_CHROME=true" -p 3000:3000 --restart always -d --name browserless browserless/chrome

```

## Pre-boot quantity [â€‹](https://docs.browserless.io/baas/v1/docker/config\#pre-boot-quantity "Direct link to Pre-boot quantity")

> Prebooting is an experimental feature, and its usage is generally discouraged if your workers don't have a lot of resources or if you are going to perform resource-intensive tasks (PDF rendering, scrapping JS-heavy webpages, screenshotting).

By default, prebooting will create a swarm of browsers of lenght `MAX_CONCURRENT_SESSIONS`. `PREBOOT_QUANTITY` allows better resource management by setting the number of pre-booted and always-open browser instances. This can be useful if your browserless instance has a large ceiling for concurrent connections but doesn't need as many always-open browsers.

If `PREBOOT_QUANTITY` gets evaluated as `0`, browserless is going to use `MAX_CONCURRENT_SESSIONS` instead.

```codeBlockLines_p187
$ docker run -e "PREBOOT_CHROME=true" -e "PREBOOT_QUANTITY=5" -p 3000:3000 --restart always -d --name browserless browserless/chrome

```

## Demo Mode [â€‹](https://docs.browserless.io/baas/v1/docker/config\#demo-mode "Direct link to Demo Mode")

If you want to serve the interactive debugger, but not allow it to handle `puppeteer.connect` calls, you can do so via the `DEMO_MODE` flag.

```codeBlockLines_p187
$ docker run -e "DEMO_MODE=true" -p 3000:3000 --restart always -d --name browserless browserless/chrome

```

## Defining a host bind [â€‹](https://docs.browserless.io/baas/v1/docker/config\#defining-a-host-bind "Direct link to Defining a host bind")

browserless will, by default, bind to localhost when no host is provided. If you want to bind to another IP, or domain, then pass in a `HOST` variable to do so.

```codeBlockLines_p187
$ docker run -e "HOST=192.168.1.1" -p 3000:3000 --restart always -d --name browserless browserless/chrome

```

## Defining a workspace location [â€‹](https://docs.browserless.io/baas/v1/docker/config\#defining-a-workspace-location "Direct link to Defining a workspace location")

Browserless automatically has downloads from Chromium set to the `/tmp` directory inside the docker image. To change this, simply set the `WORKSPACE_DIR`:

```codeBlockLines_p187
$ docker run -e "WORKSPACE_DIR=~/downloads" -p 3000:3000 --restart always -d --name browserless browserless/chrome

```

## Deleting workspace files automatically [â€‹](https://docs.browserless.io/baas/v1/docker/config\#deleting-workspace-files-automatically "Direct link to Deleting workspace files automatically")

When downloads from Chrome are larger, it's easy for the docker image to fill it's disk-space if you forget to periodically delete files. browserless has a mechanism to do so with `WORKSPACE_DELETE_EXPIRED`:

```codeBlockLines_p187
$ docker run -e "WORKSPACE_DELETE_EXPIRED=true" -p 3000:3000 --restart always -d --name browserless browserless/chrome

```

This will have browserless delete files older than 30 days in the workspace, checking once a day. To change the length, simply set `WORKSPACE_EXPIRE_DAYS`.

## Defining a time to delete workspace files [â€‹](https://docs.browserless.io/baas/v1/docker/config\#defining-a-time-to-delete-workspace-files "Direct link to Defining a time to delete workspace files")

When `WORKSPACE_DELETE_EXPIRED` is `true`, browserless attempts to delete files older than 30 days in the workspace directory. To change this to something else, set a `WORKSPACE_EXPIRE_DAYS`:

```codeBlockLines_p187
$ docker run -e "WORKSPACE_DELETE_EXPIRED=true" -e "WORKSPACE_EXPIRE_DAYS=7" -p 3000:3000 --restart always -d --name browserless browserless/chrome

```

The example above will delete files older than 7 days.

## Disabling the debugger [â€‹](https://docs.browserless.io/baas/v1/docker/config\#disabling-the-debugger "Direct link to Disabling the debugger")

If you want to disable the debugger (and all accompnaying HTML) you can set the `ENABLE_DEBUGGER` to `false` to only allow `puppeteer.connect` calls to succeed.

```codeBlockLines_p187
$ docker run -e "ENABLE_DEBUGGER=false" -p 3000:3000 --restart always -d --name browserless browserless/chrome

```

## Disable download behavior [â€‹](https://docs.browserless.io/baas/v1/docker/config\#disable-download-behavior "Direct link to Disable download behavior")

By default, browserless tells chromium to use a special directory in `/tmp` for storing files. If you want opt-out of this behavior, start the docker image with this flag:

```codeBlockLines_p187
$ docker run -e "DISABLE_AUTO_SET_DOWNLOAD_BEHAVIOR=true" -p 3000:3000 --restart always -d --name browserless browserless/chrome

```

## Securing your instance [â€‹](https://docs.browserless.io/baas/v1/docker/config\#securing-your-instance "Direct link to Securing your instance")

If you're exposing your instance to the world, but don't want anyone to use it, you can optionally apply a `TOKEN` param that will restrict calls without a `token` query-string parameter. When present, browserless will reject any calls that don't have a matching token.

```codeBlockLines_p187
$ docker run -e "TOKEN=2cbc5771-38f2-4dcf-8774-50ad51a971b8" -p 3000:3000 --restart always -d --name browserless browserless/chrome

```

Then, in your application use a query-parameter to pass that token in.

```codeBlockLines_p187
const browser = await puppeteer.connect({
  browserWSEndpoint: 'ws://localhost:3000?token=2cbc5771-38f2-4dcf-8774-50ad51a971b8',
});

```

## Logging [â€‹](https://docs.browserless.io/baas/v1/docker/config\#logging "Direct link to Logging")

Browserless uses the `debug` npm package to log output. By default, browserless prints a minimal set of logs regarding sessions and other performance characteristics. To turn it off, simply set the DEBUG value to nothing:

```codeBlockLines_p187
$ docker run -e "DEBUG=-*" -p 3000:3000 --restart always -d --name browserless browserless/chrome

```

Since most other npm packages use this same module, you can set this flag to a wildcard `*` to see nearly everything that's happening internally:

NOTE: Be careful running with this command as you'll generate a lot of log output.

```codeBlockLines_p187
$ docker run -e "DEBUG=*" -p 3000:3000 --restart always -d --name browserless browserless/chrome

```

## Enable CORS [â€‹](https://docs.browserless.io/baas/v1/docker/config\#enable-cors "Direct link to Enable CORS")

You can enable cross-origin-resource-sharing with browserless by setting the `ENABLE_CORS=true` variable. This defaults to `false`:

```codeBlockLines_p187
$ docker run -e "ENABLE_CORS=true" -p 3000:3000 --restart always -d --name browserless browserless/chrome

```

## Enable XVFB [â€‹](https://docs.browserless.io/baas/v1/docker/config\#enable-xvfb "Direct link to Enable XVFB")

By default browserless will take care of XVFB running automatically, which essentially means this is defaulted to `true`. However, in some hosting environments it's not possible to write to the appropriate folders to support XVFB and you should set this parameter to `false`.

> The screencast API depends on this setting to be `true` and will fail when turned off.

```codeBlockLines_p187
$ docker run -e "ENABLE_XVBF=false" -p 3000:3000 --restart always -d --name browserless browserless/chrome

```

## Exit on health failure [â€‹](https://docs.browserless.io/baas/v1/docker/config\#exit-on-health-failure "Direct link to Exit on health failure")

browserless routinely checks on the health of the image as it's running. Sometimes it's helpful to have it restart automatically when CPU or Memory usage are above 100% for a period of time (by default 5 minutes). In order for browserless to restart on health-failure checks, you'll have to set a parameter of `EXIT_ON_HEALTH_FAILURE=true`.

```codeBlockLines_p187
$ docker run -e "EXIT_ON_HEALTH_FAILURE=true" -p 3000:3000 --restart always -d --name browserless browserless/chrome

```

## Persisting Metrics [â€‹](https://docs.browserless.io/baas/v1/docker/config\#persisting-metrics "Direct link to Persisting Metrics")

browserless captures metrics while it's running, and exposes them via the `/metrics` endpoint. These, by default, don't persist anywhere _unless_ you tell browserless where to persist them. When provided, the docker image will also attempt to read the metrics on startup and write to it periodically during execution.

> In this run command we're mounting the machines `/root` path so that the docker can access it at `/root`, be sure to change this to fit your use-case.

```codeBlockLines_p187
$ docker run -e "METRICS_JSON_PATH=/root/metrics.json" -v /root:/root -p 3000:3000 --restart always -d --name browserless browserless/chrome

```

## Exposing built-in modules to `/function` [â€‹](https://docs.browserless.io/baas/v1/docker/config\#exposing-built-in-modules-to-function "Direct link to exposing-built-in-modules-to-function")

The `/function` endpoint allows for user-submitted code to be ran inside the docker-image without the need for another compilation step. By default functions are _not_ allowed to require modules (both built-in's or externally). To enable Node's built-in modules you'll need to supply an array of modules available.

Here we're allowing both the `url` and `util` modules.

```codeBlockLines_p187
$ docker run -e "FUNCTION_BUILT_INS=[\"url\", \"util\"]" -p 3000:3000 --restart always -d --name browserless browserless/chrome

```

## Exposing external modules to `/function` [â€‹](https://docs.browserless.io/baas/v1/docker/config\#exposing-external-modules-to-function "Direct link to exposing-external-modules-to-function")

The `/function` endpoint allows for user-submitted code to be ran inside the docker-image without the need for another compilation step. By default functions are _not_ allowed to require modules (both built-in's or externally). To enable external modules you'll need to supply an array of modules available.

Here we're allowing both the `request` and `fetch` modules to be required in the `/function` endpoint.

```codeBlockLines_p187
$ docker run -e "FUNCTION_EXTERNALS=[\"request\", \"fetch\"]" -p 3000:3000 --restart always -d --name browserless browserless/chrome

```

## Keeping Chrome Alive [â€‹](https://docs.browserless.io/baas/v1/docker/config\#keeping-chrome-alive "Direct link to Keeping Chrome Alive")

When the `PREBOOT_CHROME` flag is set, you can optionally keep Chrome "alive" after sessions are complete. This allows you to re-use Chrome instances without having to start and stop them (making for much faster execution). To enable this behavior, set the `PREBOOT_CHROME=true` and `KEEP_ALIVE=true`.

Browserless will close Chrome after 30 minutes to try and mitigate issues with Chrome consuming too many resources. This is configurable as well with the `CHROME_REFRESH_TIME` flag.

> When using KEEP\_ALIVE Chrome will retain information about prior-sessions such as cookies and login contexts. **You'll also need to replace `browser.close()` with `browser.disconnect()` in your puppeteer code.**

```codeBlockLines_p187
$ docker run -e "PREBOOT_CHROME=true" -e "KEEP_ALIVE=true" -p 3000:3000 --restart always -d --name browserless browserless/chrome

```

## Chrome Refresh Time [â€‹](https://docs.browserless.io/baas/v1/docker/config\#chrome-refresh-time "Direct link to Chrome Refresh Time")

When both `PREBOOT_CHROME` and `KEEP_ALIVE` are `true` browserless keeps track of how long Chrome has been running, and will attempt to close it after a certain period. By default it will try and restart Chrome after 30 minutes. You can configure this behavior with the `CHROME_REFRESH_TIME` flag.

The `CHROME_REFRESH_TIME` flag accepts a value in milliseconds to keep Chrome running before it attempts to close it. Below we set this threshold to one hour.

```codeBlockLines_p187
$ docker run -e "PREBOOT_CHROME=true" -e "KEEP_ALIVE=true" -e "CHROME_REFRESH_TIME=3600000" -p 3000:3000 --restart always -d --name browserless browserless/chrome

```

## Single Run Mode [â€‹](https://docs.browserless.io/baas/v1/docker/config\#single-run-mode "Direct link to Single Run Mode")

Some cloud providers offer a way to run a docker images as a "function", wherein the container is shutdown after all open connections are terminated. In order to make this as seamless as an experience as possible, there's an option call `SINGLE_RUN` which will shutdown the container after a single session completes.

> It's recommended to set MAX\_CONCURRENT\_SESSIONS to 1 and QUEUE\_LENGTH to 0 if you want to run just a single session

```codeBlockLines_p187
$ docker run -e "SINGLE_RUN=true" -p 3000:3000 --restart always -d --name browserless browserless/chrome

```

## Default Block Ads [â€‹](https://docs.browserless.io/baas/v1/docker/config\#default-block-ads "Direct link to Default Block Ads")

Starts all sessions with the ad-blocker already running (no need to use `?blockAds=true` in your API or puppeteer connect calls). If a session with `?blockAds=false` is started, that preference will take precedence, and the ad-blocker will be turned off.

```codeBlockLines_p187
$ docker run -e "DEFAULT_BLOCK_ADS=true" -p 3000:3000 --restart always -d --name browserless browserless/chrome

```

## Default Headless [â€‹](https://docs.browserless.io/baas/v1/docker/config\#default-headless "Direct link to Default Headless")

Starts all sessions, that don't include a `?headless` flag in their API or connect call, with a pre-set headless behavior. When not set, browserless sets all sessions to be headless by default.

If a session starts with a different `?headless` flag, that flag will take precedence over the pre-configured behavior.

```codeBlockLines_p187
$ docker run -e "DEFAULT_HEADLESS=false" -p 3000:3000 --restart always -d --name browserless browserless/chrome

```

## Default Launch Args [â€‹](https://docs.browserless.io/baas/v1/docker/config\#default-launch-args "Direct link to Default Launch Args")

Allows for setting default launch args when none are present in an API or puppeteer.connect call. When a call is started with launch-arguments set, they take precedence over this default behavior.

```codeBlockLines_p187
$ docker run -e "DEFAULT_LAUNCH_ARGS=[\"--window-size=1920,1080\"]" -p 3000:3000 --restart always -d --name browserless browserless/chrome

```

## Default Ignore HTTPS [â€‹](https://docs.browserless.io/baas/v1/docker/config\#default-ignore-https "Direct link to Default Ignore HTTPS")

Tells browserless to, by default, ignore or not ignore HTTPS errors on sites. If a sesions or API call comes starts with a different preference set, then it will override this default behavior.

```codeBlockLines_p187
$ docker run -e "DEFAULT_IGNORE_HTTPS_ERRORS=true" -p 3000:3000 --restart always -d --name browserless browserless/chrome

```

## Default Ignore Default Args [â€‹](https://docs.browserless.io/baas/v1/docker/config\#default-ignore-default-args "Direct link to Default Ignore Default Args")

When set this will override any default arguments set by browserless to Chrome's launch arguments. This can be a list of flags to ignore, or `true`/ `false` to ignore all arguments. When a session is started with this flag set, it takes precedence over this default behavior.

```codeBlockLines_p187
$ docker run -e "DEFAULT_IGNORE_DEFAULT_ARGS=true" -p 3000:3000 --restart always -d --name browserless browserless/chrome

```

## Default User Data Dir [â€‹](https://docs.browserless.io/baas/v1/docker/config\#default-user-data-dir "Direct link to Default User Data Dir")

Sets a default directory to cache user data to (cookies, local-storage and more). This will force all sessions to use the same cache unless sessions themselves specify another path, which will override this behavior.

```codeBlockLines_p187
$ docker run -e "DEFAULT_USER_DATA_DIR=/tmp/my-profile" -p 3000:3000 --restart always -d --name browserless browserless/chrome

```

## Disable Routes [â€‹](https://docs.browserless.io/baas/v1/docker/config\#disable-routes "Direct link to Disable Routes")

Allows for disabling routes by supplying a list of routes to disable:

```codeBlockLines_p187
$ docker run -e 'DISABLED_FEATURES=["pdfEndpoint", "contentEndpoint"]' -p 3000:3000 --restart always -d --name browserless browserless/chrome

```

## Enable API GET [â€‹](https://docs.browserless.io/baas/v1/docker/config\#enable-api-get "Direct link to Enable API GET")

Allows for enabling an expiremental GET-style operation, as opposed to POSTing bodies of code to run on our APIs. When enabled, you'll simply need to set a `body` query-string parameter, with a URL-encoded JSON string of the normal API body.

```codeBlockLines_p187
$ docker run -e 'ENABLE_API_GET=true' -p 3000:3000 --restart always -d --name browserless browserless/chrome

```

## Function Incognito Mode [â€‹](https://docs.browserless.io/baas/v1/docker/config\#function-incognito-mode "Direct link to Function Incognito Mode")

When set, and `PREBOOT_CHROME` and `KEEP_ALIVE` are set, allows for generating a fresh page (incognito page) from a re-used browser. This is useful if you want to reuse a Chrome instance, but don't want to retain the cookies and other browser caches.

```codeBlockLines_p187
$ docker run -e FUNCTION_ENABLE_INCOGNITO_MODE=true -e KEEP_ALIVE=true -e PREBOOT_CHROME=true -p 3000:3000 --restart always -d --name browserless browserless/chrome

```

## Using a proxy [â€‹](https://docs.browserless.io/baas/v1/docker/config\#using-a-proxy "Direct link to Using a proxy")

You'll often want to use a load-balancer, or reverse proxy, in front of browserless for SSL termination or to load balance across a fleet of browserless instances. In certain cases, browserless does generate links (like in the /sessions API), in which case this link builder needs to be aware of how it should route sessions.

In order to handle this, you can specify three parameters: `PROXY_HOST`, `PROXY_PORT` and `PROXY_SSL` to browserless. This will tell certain APIs to generate links with the prior information.

```codeBlockLines_p187
$ docker run -e "PROXY_HOST=browserless.my-domain.com" -e PROXY_PORT=443 -e PROXY_SSL=true -p 3000:3000 --restart always -d --name browserless browserless/chrome

```

Then, /sessions API calls will return properly formatted JSON resposnes:

```codeBlockLines_p187
[\
  {\
    "description": "",\
    "devtoolsFrontendUrl": "/devtools/inspector.html?wss=browserless.my-domain.com:443/devtools/page/C6962B3428FC8E42CDA6484AB5B57EAC",\
    "id": "C6962B3428FC8E42CDA6484AB5B57EAC",\
    "title": "Example Domain",\
    "type": "page",\
    "url": "https://www.example.com/",\
    "webSocketDebuggerUrl": "wss://browserless.my-domain.com:443/devtools/page/C6962B3428FC8E42CDA6484AB5B57EAC",\
    "browserId": "b519351a-355e-47d5-82cc-7c240cfa40f3",\
    "browserWSEndpoint": "wss://browserless.my-domain.com:443/devtools/browser/b519351a-355e-47d5-82cc-7c240cfa40f3",\
    "port": "42169",\
    "trackingId": null\
  }\
]

```

- [All Options](https://docs.browserless.io/baas/v1/docker/config#all-options)
- [Chrome information](https://docs.browserless.io/baas/v1/docker/config#chrome-information)
- [Port](https://docs.browserless.io/baas/v1/docker/config#port)
- [Max Concurrent Sessions](https://docs.browserless.io/baas/v1/docker/config#max-concurrent-sessions)
- [Connection Timeout](https://docs.browserless.io/baas/v1/docker/config#connection-timeout)
- [Max Queue Length](https://docs.browserless.io/baas/v1/docker/config#max-queue-length)
- [Pre-booting Chrome](https://docs.browserless.io/baas/v1/docker/config#pre-booting-chrome)
- [Pre-boot quantity](https://docs.browserless.io/baas/v1/docker/config#pre-boot-quantity)
- [Demo Mode](https://docs.browserless.io/baas/v1/docker/config#demo-mode)
- [Defining a host bind](https://docs.browserless.io/baas/v1/docker/config#defining-a-host-bind)
- [Defining a workspace location](https://docs.browserless.io/baas/v1/docker/config#defining-a-workspace-location)
- [Deleting workspace files automatically](https://docs.browserless.io/baas/v1/docker/config#deleting-workspace-files-automatically)
- [Defining a time to delete workspace files](https://docs.browserless.io/baas/v1/docker/config#defining-a-time-to-delete-workspace-files)
- [Disabling the debugger](https://docs.browserless.io/baas/v1/docker/config#disabling-the-debugger)
- [Disable download behavior](https://docs.browserless.io/baas/v1/docker/config#disable-download-behavior)
- [Securing your instance](https://docs.browserless.io/baas/v1/docker/config#securing-your-instance)
- [Logging](https://docs.browserless.io/baas/v1/docker/config#logging)
- [Enable CORS](https://docs.browserless.io/baas/v1/docker/config#enable-cors)
- [Enable XVFB](https://docs.browserless.io/baas/v1/docker/config#enable-xvfb)
- [Exit on health failure](https://docs.browserless.io/baas/v1/docker/config#exit-on-health-failure)
- [Persisting Metrics](https://docs.browserless.io/baas/v1/docker/config#persisting-metrics)
- [Exposing built-in modules to `/function`](https://docs.browserless.io/baas/v1/docker/config#exposing-built-in-modules-to-function)
- [Exposing external modules to `/function`](https://docs.browserless.io/baas/v1/docker/config#exposing-external-modules-to-function)
- [Keeping Chrome Alive](https://docs.browserless.io/baas/v1/docker/config#keeping-chrome-alive)
- [Chrome Refresh Time](https://docs.browserless.io/baas/v1/docker/config#chrome-refresh-time)
- [Single Run Mode](https://docs.browserless.io/baas/v1/docker/config#single-run-mode)
- [Default Block Ads](https://docs.browserless.io/baas/v1/docker/config#default-block-ads)
- [Default Headless](https://docs.browserless.io/baas/v1/docker/config#default-headless)
- [Default Launch Args](https://docs.browserless.io/baas/v1/docker/config#default-launch-args)
- [Default Ignore HTTPS](https://docs.browserless.io/baas/v1/docker/config#default-ignore-https)
- [Default Ignore Default Args](https://docs.browserless.io/baas/v1/docker/config#default-ignore-default-args)
- [Default User Data Dir](https://docs.browserless.io/baas/v1/docker/config#default-user-data-dir)
- [Disable Routes](https://docs.browserless.io/baas/v1/docker/config#disable-routes)
- [Enable API GET](https://docs.browserless.io/baas/v1/docker/config#enable-api-get)
- [Function Incognito Mode](https://docs.browserless.io/baas/v1/docker/config#function-incognito-mode)
- [Using a proxy](https://docs.browserless.io/baas/v1/docker/config#using-a-proxy)

---

### Extending the Docker Image | Browserless.io
Original URL: https://docs.browserless.io/baas/v1/docker/extending-docker

[Skip to main content](https://docs.browserless.io/baas/v1/docker/extending-docker#__docusaurus_skipToContent_fallback)



DEPRECATION WARNING

This documentation is for BaaS v1, which is no longer actively supported. If you are a new user, please refer to the updated documentation for [BaaS v2](https://docs.browserless.io/enterprise/docker/extending) or [BrowserQL](https://docs.browserless.io/browserql/start).

> For hosted accounts, if you want to use a third-party module please [get in touch!](https://www.browserless.io/contact)

browserless includes a few extra packages that make it easy to get going with most of the use-cases we've seen. However if you're using the `/function` API, or other API's wherein you want to load npm modules, then you'll need to extend our image so that you can install these dependencies. The process if fairly easy in docker to do so.

## 1\. Create your own Dockerfile [â€‹](https://docs.browserless.io/baas/v1/docker/extending-docker\#1-create-your-own-dockerfile "Direct link to 1. Create your own Dockerfile")

First, you'll want to write your own `Dockerfile`. In the example below, we're going to add the `aws-sdk` module.

```codeBlockLines_p187
FROM browserless/chrome:latest

# Install the AWS SDK
RUN npm install aws-sdk

```

Feel free to change the `FROM` value here. It's generally a good practice to "pin" this version to value that won't change. For instance, if we want to use version [1.15.0](https://github.com/browserless/browserless/blob/v1/CHANGELOG.md#1150) of browserless, and puppeteer `1.19.0`, we'd have done:

```codeBlockLines_p187
FROM browserless/chrome:1.15.0-puppeteer-1.19.0

# Install the AWS SDK
RUN npm install aws-sdk

```

In either case, save your file and let's proceed.

## 2\. Build the docker image [â€‹](https://docs.browserless.io/baas/v1/docker/extending-docker\#2-build-the-docker-image "Direct link to 2. Build the docker image")

Once the you have the file saved, it's as simple as building the image.

```codeBlockLines_p187
$ docker build -t my/browserless:latest .

```

Here, we're using a "dumby" user of `my` and a repo of `browserless`, tagging it as the \`latest. Feel free to change these however you see fit, especially if you want to push this built image into docker's public cloud or your own private image registry.

It'll likely take a few minutes to pull all the dependencies locally and build, however subsequent builds will be much quicker since they'll have a local cache.

## 3\. Run the image [â€‹](https://docs.browserless.io/baas/v1/docker/extending-docker\#3-run-the-image "Direct link to 3. Run the image")

Now that you have a custom-built version you can apply all the same arguments to your start command (all environment variables and so on apply), you'll simply change the image you're running when you startup (note that we're whitelisting this new module, allowing browserless to execute it for security purposes).

Here's an example of running the newly built image with the module whitelisted.

```codeBlockLines_p187
$ docker run -p 3000:3000 -e FUNCTION_EXTERNALS='["aws-sdk"]' my/browserless:latest

```

Now your calls to `/function` and others will have access to the `aws-sdk` module:

```codeBlockLines_p187
$ curl -X POST \
  http://localhost:3000/function \
  -H 'Content-Type: application/javascript' \
  -d 'const aws = require('\''aws-sdk'\'');

module.exports = async () => {
  const data = Object.keys(aws);

  return {
    data,
    type: '\''text/plain'\'',
  };
};'

```

That's it! If you need to add more simply install your modules in the `Dockerfile`, build the image, and run it!

- [1\. Create your own Dockerfile](https://docs.browserless.io/baas/v1/docker/extending-docker#1-create-your-own-dockerfile)
- [2\. Build the docker image](https://docs.browserless.io/baas/v1/docker/extending-docker#2-build-the-docker-image)
- [3\. Run the image](https://docs.browserless.io/baas/v1/docker/extending-docker#3-run-the-image)

---

### Docker Quick Start | Browserless.io
Original URL: https://docs.browserless.io/baas/v1/docker/quickstart

[Skip to main content](https://docs.browserless.io/baas/v1/docker/quickstart#__docusaurus_skipToContent_fallback)



DEPRECATION WARNING

This documentation is for BaaS v1, which is no longer actively supported. If you are a new user, please refer to the updated documentation for [BaaS v2](https://docs.browserless.io/enterprise/docker/quickstart) or [BrowserQL](https://docs.browserless.io/browserql/start).

The docker image that powers the core of browserless is available for free for open-source projects. Using it is about as simple as using the browserless service itself with the only difference being that you'll have to launch and manage the infrastructure.

If you're interested in reading about setting up a project, then checkout the [quick-start guide here](https://docs.browserless.io/).

At a high-level, we'll do the following:

1. Run the docker image
2. Update our app to connect to this image.

## 1\. Run it with some sensible defaults [â€‹](https://docs.browserless.io/baas/v1/docker/quickstart\#1-run-it-with-some-sensible-defaults "Direct link to 1. Run it with some sensible defaults")

Running the docker image is similar to other `docker run` commands, and all options are passed in via environment variables. In the example below, we're starting with the image with a maximum concurrency of `10`, further requests will remain open and ran when a slot opens up.

After the image is pulled (one time only), then you'll see the first of our logs, which will print the final configuration.

```codeBlockLines_p187
$ docker run \
  --rm \
  -p 3000:3000 \
  -e "MAX_CONCURRENT_SESSIONS=10" \
  browserless/chrome:latest

```

Feel free to visit [http://localhost:3000](http://localhost:3000/) to see if the image is running properly. You can also read more about the different variables on our [docker section](https://docs.browserless.io/baas/v1/docker/config).

## 2\. Update your app to use browserless [â€‹](https://docs.browserless.io/baas/v1/docker/quickstart\#2-update-your-app-to-use-browserless "Direct link to 2. Update your app to use browserless")

Once we have browserless running we can simply use it inside of our application instead of launching it locally:

```codeBlockLines_p187
const express = require('express');
const puppeteer = require('puppeteer-core');

const app = express();

app.get('/image', async (req, res) => {
  // This was puppeteer.launch()
  const browser = await puppeteer.connect({ browserWSEndpoint: 'ws://localhost:3000' });
  const page = await browser.newPage();

  await page.goto('http://www.example.com/');
  const data = await page.screenshot();
  browser.close();

  return res.end(data, 'binary');
});

app.listen(8080);

```

## What's next? [â€‹](https://docs.browserless.io/baas/v1/docker/quickstart\#whats-next "Direct link to What's next?")

There's a lot more that you can configure and tune in browserless to handle the needs of your application. Be sure to read about all the options it exposes and how to get the most out of the browserless image!

- [1\. Run it with some sensible defaults](https://docs.browserless.io/baas/v1/docker/quickstart#1-run-it-with-some-sensible-defaults)
- [2\. Update your app to use browserless](https://docs.browserless.io/baas/v1/docker/quickstart#2-update-your-app-to-use-browserless)
- [What's next?](https://docs.browserless.io/baas/v1/docker/quickstart#whats-next)

---

### Docker Webhooks | Browserless.io
Original URL: https://docs.browserless.io/baas/v1/docker/webhooks

[Skip to main content](https://docs.browserless.io/baas/v1/docker/webhooks#__docusaurus_skipToContent_fallback)



DEPRECATION WARNING

This documentation is for BaaS v1, which is no longer actively supported. If you are a new user, please refer to the updated documentation for [BaaS v2](https://docs.browserless.io/enterprise/docker/webhooks) or [BrowserQL](https://docs.browserless.io/browserql/start).

When launching the docker image you can configure it to "callback" to a web-based URL when certain events occur. For instance, you can have it call an HTTP URI when sessions are queued or rejected.

For each URL, when the associated event happens, browserless will do a `GET` call on the provided URL. It doesn't listen to responses or failures, however it's a good idea to answer it back immediately to close any open connections.

Below is a list of all possible options. Be sure to check back often and see when more are added!

## Queuing [â€‹](https://docs.browserless.io/baas/v1/docker/webhooks\#queuing "Direct link to Queuing")

Setting a `QUEUE_ALERT_URL` will trigger the image to call a the specified URL when queuing begins to happen. You can set this to any HTTP URL as seen below:

```codeBlockLines_p187
$ docker run -e "QUEUE_ALERT_URL=https://my.website.com/queued" -p 3000:3000 --restart always -d --name browserless browserless/chrome

```

## Rejections [â€‹](https://docs.browserless.io/baas/v1/docker/webhooks\#rejections "Direct link to Rejections")

Setting a `REJECT_ALERT_URL` will trigger the image to call a the specified URL when rejections begins to happen. You can set this to any HTTP URL as seen below:

```codeBlockLines_p187
$ docker run -e "REJECT_ALERT_URL=https://my.website.com/rejected" -p 3000:3000 --restart always -d --name browserless browserless/chrome

```

## Timeouts [â€‹](https://docs.browserless.io/baas/v1/docker/webhooks\#timeouts "Direct link to Timeouts")

Setting a `TIMEOUT_ALERT_URL` will trigger the image to call a the specified URL when time-outs begins to happen. You can set this to any HTTP URL as seen below:

```codeBlockLines_p187
$ docker run -e "TIMEOUT_ALERT_URL=https://my.website.com/time-out" -p 3000:3000 --restart always -d --name browserless browserless/chrome

```

## Health Failure [â€‹](https://docs.browserless.io/baas/v1/docker/webhooks\#health-failure "Direct link to Health Failure")

Setting a `FAILED_HEALTH_URL` will trigger the image to call a the specified URL when the health of the instance is critical (over 99% on CPU and memory). You can use this event to potentially restart the image or replace it.

```codeBlockLines_p187
$ docker run -e "FAILED_HEALTH_URL=https://my.website.com/failed-health" -p 3000:3000 --restart always -d --name browserless browserless/chrome

```

## Need something else? [â€‹](https://docs.browserless.io/baas/v1/docker/webhooks\#need-something-else "Direct link to Need something else?")

If you're looking for hooks for other events, please [let us know](https://www.browserless.io/contact).

- [Queuing](https://docs.browserless.io/baas/v1/docker/webhooks#queuing)
- [Rejections](https://docs.browserless.io/baas/v1/docker/webhooks#rejections)
- [Timeouts](https://docs.browserless.io/baas/v1/docker/webhooks#timeouts)
- [Health Failure](https://docs.browserless.io/baas/v1/docker/webhooks#health-failure)
- [Need something else?](https://docs.browserless.io/baas/v1/docker/webhooks#need-something-else)

---

### Best Practices | Browserless.io
Original URL: https://docs.browserless.io/baas/v1/hosted-service/best-practices

[Skip to main content](https://docs.browserless.io/baas/v1/hosted-service/best-practices#__docusaurus_skipToContent_fallback)



DEPRECATION WARNING

This documentation is for BaaS v1, which is no longer actively supported. If you are a new user, please refer to the updated documentation for [BaaS v2](https://docs.browserless.io/baas/troubleshooting/best-practices) or [BrowserQL](https://docs.browserless.io/browserql/start).

Aside from getting everything setup and running, there's a few best practices that'll help ensure your sessions are operating well. Below is a couple of highlights for running healthy headless scripts.

## Make sure you close your session [â€‹](https://docs.browserless.io/baas/v1/hosted-service/best-practices\#make-sure-you-close-your-session "Direct link to Make sure you close your session")

When finished with work, or on errors, make sure you run `browser.close` so that other sessions may start. browserless _will_ terminate long-running sessions via the timeout setting, but it's always a good idea to close tidly whenever you're finished.

```codeBlockLines_p187
const browser = await puppeteer.connect({
  browserWSEndpoint: `wss://chrome.browserless.io?token=YOUR-TOKEN-HERE`,
});

const page = await browser.newPage();

try {
  await page.goto('https://www.browserless.io/');
  await page.screenshot({ path: './browserless.png' });
  browser.close();
} catch (error) {
  console.error({ error }, 'Something happened!');
  browser.close();
}

```

## Reduce `await`'s as much as possible [â€‹](https://docs.browserless.io/baas/v1/hosted-service/best-practices\#reduce-awaits-as-much-as-possible "Direct link to reduce-awaits-as-much-as-possible")

Most of the puppeteer is async, meaning any command with `await` in front of it (or `.then`'s) is going to make a round-trip from your application to browserless and back. While you can only do so much to limit this you should definitely try and do as much as possible. For instance, use `page.evaluate` over `page.$selector` as you can accomplish a lot in one `evaluate` versus multiple `$selector` calls.

**DON'T DO**

```codeBlockLines_p187
const $button = await page.$('.buy-now');
const buttonText = await $button.getProperty('innerText');
const clicked = await $button.click();

```

**DO**

```codeBlockLines_p187
const buttonText = await page.evaluate(() => {
  const $button = document.querySelector('.buy-now');
  const clicked = $button.click();

  return $button.innerText;
});

```

## Use the GraphQL API to do pre-session checks [â€‹](https://docs.browserless.io/baas/v1/hosted-service/best-practices\#use-the-graphql-api-to-do-pre-session-checks "Direct link to Use the GraphQL API to do pre-session checks")

If you've been getting rejections or queued, be sure to use the GraphQL API to do pre-session checks. This allows your workers to remain up and healthy, allowing sessions to go smoothly.

```codeBlockLines_p187
# https://api.browserless.io/graphql
{
  pressure(apiToken: "YOUR-API-TOKEN") {
    running
    recentlyRejected
    queued
    isAvailable
    date
  }
}

```

This request will return a JSON object with the following payload:

```codeBlockLines_p187
// JSON returned
{
  "data": {
    "pressure": {
      "running": 0,
      "recentlyRejected": 0,
      "queued": 0,
      "isAvailable": true,
      "date": 1524762532204
    }
  }
}

```

You can use the `isAvailable` boolean to check to see if the instance can handle more connections. Otherwise you're free to write any sort of custom check with the provided JSON response.

## Seen Improvements Yourself? [â€‹](https://docs.browserless.io/baas/v1/hosted-service/best-practices\#seen-improvements-yourself "Direct link to Seen Improvements Yourself?")

If you've seen improvements or have practices you think the community would benefit from, we'd [love to hear from you!](https://www.browserless.io/contact)

- [Make sure you close your session](https://docs.browserless.io/baas/v1/hosted-service/best-practices#make-sure-you-close-your-session)
- [Reduce `await`'s as much as possible](https://docs.browserless.io/baas/v1/hosted-service/best-practices#reduce-awaits-as-much-as-possible)
- [Use the GraphQL API to do pre-session checks](https://docs.browserless.io/baas/v1/hosted-service/best-practices#use-the-graphql-api-to-do-pre-session-checks)
- [Seen Improvements Yourself?](https://docs.browserless.io/baas/v1/hosted-service/best-practices#seen-improvements-yourself)

---

### Browserless GraphQL API | Browserless.io
Original URL: https://docs.browserless.io/baas/v1/hosted-service/graphql-api

[Skip to main content](https://docs.browserless.io/baas/v1/hosted-service/graphql-api#__docusaurus_skipToContent_fallback)



DEPRECATION WARNING

This documentation is for BaaS v1, which is no longer actively supported. If you are a new user, please refer to the updated documentation for [BaaS v2](https://docs.browserless.io/enterprise/private-deployment/graphql-api) or [BrowserQL](https://docs.browserless.io/browserql/start).

Aside from providing the default `chrome.browserless.io` domain for running sessions, browserless also exposes a GraphQL API for other operations. This document goes over some critical queries.

info

The graphql API only applies to Dedicated and Enterprise accounts.

## Pressure [â€‹](https://docs.browserless.io/baas/v1/hosted-service/graphql-api\#pressure "Direct link to Pressure")

The `pressure` query shows how much load your instance(s) are under, and whether they can accept more traffic or not. This is real-time, so if you need to check if your instance can take more traffic you can do a request to check prior to running your `puppeteer.connect` call.

warning

The pressure queries are still in BETA and may experience breaking schema changes.

```codeBlockLines_p187
# https://api.browserless.io/graphql
{
  pressure(apiToken: "YOUR-API-TOKEN") {
    running
    recentlyRejected
    queued
    isAvailable
    date
  }
}

```

This request will return a JSON object with the following payload:

```codeBlockLines_p187
{
  "data": {
    "pressure": {
      "running": 0,
      "recentlyRejected": 0,
      "queued": 0,
      "isAvailable": true,
      "date": 1524762532204
    }
  }
}

```

## Metrics [â€‹](https://docs.browserless.io/baas/v1/hosted-service/graphql-api\#metrics "Direct link to Metrics")

The `metrics` query gives you insight to how your worker(s) are performing. It details things like successful, rejected, and timed-out sessions. Eventually this will be expanded to include things like average session-time and other helpful data-points.

Below is an example of a request for `metrics` and the responding payload.

warning

The metrics queries are still in BETA and may experience breaking schema changes.

```codeBlockLines_p187
# https://api.browserless.io/graphql
{
  metrics(apiToken: "YOUR-API-TOKEN") {
    successful
    rejected
    timedout
    queued
    cpu
    memory
    date
  }
}

```

This request returns an array of object detailing the metrics of your instance(s). If there's more than one instance stats are aggregated together in 5-minute intervals. CPU and Memory are averaged across instances.

```codeBlockLines_p187
{
  "data": {
    "metrics": [\
      {\
        "successful": 0,\
        "rejected": 0,\
        "timedout": 0,\
        "queued": 0,\
        "cpu": 0.002734375,\
        "memory": 0.9055320561641963,\
        "date": 1524227700000\
      },\
      //...\
    ]
  }
}

```

## Account Status [â€‹](https://docs.browserless.io/baas/v1/hosted-service/graphql-api\#account-status "Direct link to Account Status")

The `accountStatus` query provides information about your account's usage and worker status. This is particularly useful for:

- Checking remaining time on usage-based accounts
- Monitoring worker launch status on dedicated plans

```codeBlockLines_p187
# https://api.browserless.io/graphql
{
  accountStatus(apiToken: "YOUR-API-TOKEN") {
    launching
    secondsAvailable
  }
}

```

This request returns an object with the following information:

```codeBlockLines_p187
{
  "data": {
    "accountStatus": {
      "launching": false,
      "secondsAvailable": 3600
    }
  }
}

```

The response includes:

- `launching`: Boolean indicating if a new worker is being launched (for legacy dedicated plans)
- `secondsAvailable`: Number of seconds remaining on your account (for legacy usage-based accounts)

info

This query is specifically for legacy accounts. For current account information, please refer to the [BaaS v2 documentation](https://docs.browserless.io/enterprise/private-deployment/graphql-api).

warning

For security purposes, we limit the number of failed GraphQL request attempts. If you encounter rate limiting errors, you'll need to wait until the top of the hour before making additional requests.

## See More [â€‹](https://docs.browserless.io/baas/v1/hosted-service/graphql-api\#see-more "Direct link to See More")

There's a lot more you can do in the GraphQL API behind browserless, so be sure to [check it out here](https://api.browserless.io/graphql/)!

- [Pressure](https://docs.browserless.io/baas/v1/hosted-service/graphql-api#pressure)
- [Metrics](https://docs.browserless.io/baas/v1/hosted-service/graphql-api#metrics)
- [Account Status](https://docs.browserless.io/baas/v1/hosted-service/graphql-api#account-status)
- [See More](https://docs.browserless.io/baas/v1/hosted-service/graphql-api#see-more)

---

### How it works | Browserless.io
Original URL: https://docs.browserless.io/baas/v1/hosted-service/how-it-works

[Skip to main content](https://docs.browserless.io/baas/v1/hosted-service/how-it-works#__docusaurus_skipToContent_fallback)



DEPRECATION WARNING

This documentation is for BaaS v1, which is no longer actively supported. If you are a new user, please refer to the updated documentation for [BaaS v2](https://docs.browserless.io/baas/session-management/reconnect) or [BrowserQL](https://docs.browserless.io/browserql/start).

warning

Libraries that only allow a `host` and `port` option are not well supported by the Browserless service since you cannot properly send in API tokens. If you're looking to integrate into the hosted service, read more about our REST API's and the `/function` [endpoint here](https://www.browserless.io/blog/2018/05/26/browserless-functions/#browserless-functions).

Browserless works almost identically to how most libraries and web-drivers work when ran locally. There's no additional software you need to install on your production machines or complicated setup steps. As a matter of fact, the only thing you really need to when using the Browserless service is merely change where your code references Chrome.

Browserless runs Chrome in a cloud environment, and exposes most of the [Chrome remote protocol](https://chromedevtools.github.io/devtools-protocol/) to you. On top of exposing these commands, it also:

- Isolates your session from all others.
- Can run concurrent requests without interfering with others.
- Cleans up sessions after 30 seconds.
- Starts a clean copy of Chrome for each session.
- Restarts automatically if anything crashes.
- Queues requests if thresholds are met.

## How sessions work [â€‹](https://docs.browserless.io/baas/v1/hosted-service/how-it-works\#how-sessions-work "Direct link to How sessions work")

### Via `browserWSEndpoint` [â€‹](https://docs.browserless.io/baas/v1/hosted-service/how-it-works\#via-browserwsendpoint "Direct link to via-browserwsendpoint")

Libraries like puppeteer and chrome-remote-interface can hook into an existing Chrome instance by WebSocket. The hosted Browserless service only supports this type of interface since you can pass in tokens and other query-params. Typically you only need to replace how you start Chrome with a connect-like statement:

```codeBlockLines_p187
// Connecting to Chrome locally
const browser = await puppeteer.launch();

// Connecting to browserless
const browser = await puppeteer.connect({
  browserWSEndpoint: 'wss://chrome.browserless.io/?token=YOUR_API_TOKEN',
});

```

After that your code should remain exactly the same.

### Via `host` and `port` [â€‹](https://docs.browserless.io/baas/v1/hosted-service/how-it-works\#via-host-and-port "Direct link to via-host-and-port")

Many libraries will issue an HTTP request to one of the `/json` endpoints exposed by Chrome's dev protocol. When this request happens, Browserless will respond with the resulting payload to allow remote programs to interact with it.

If you're looking to use the Browserless service with non-Node language, it's better to use the REST API's and `/function` endpoint as Browserless _can_ run puppeteer code for you. Take a look at our blog post about this interface [here](https://www.browserless.io/blog/2018/05/26/browserless-functions/#browserless-functions).

**Introspection Request**

```codeBlockLines_p187
# curl https://chrome.browserless.io/json?token=YOUR_API_TOKEN_HERE
[\
   {\
      "description":"",\
      "devtoolsFrontendUrl":"/devtools/inspector.html?ws=138.197.93.72:3000/devtools/page/da78a5e7-1db5-4d47-a2a5-07885088ad07",\
      "id":"da78a5e7-1db5-4d47-a2a5-07885088ad07",\
      "title":"about:blank",\
      "type":"page",\
      "url":"about:blank",\
      "webSocketDebuggerUrl":"ws://138.197.93.72:3000/devtools/page/da78a5e7-1db5-4d47-a2a5-07885088ad07"\
   }\
]

```

The WebSocket endpoints are where commands from the protocol are emitted into, and Chrome will then emit responses back. Browserless does not modify or alter any of these messages. Once your session and underlying websocket are closed, Browserless will automatically clear that Target and session data.

- [How sessions work](https://docs.browserless.io/baas/v1/hosted-service/how-it-works#how-sessions-work)
  - [Via `browserWSEndpoint`](https://docs.browserless.io/baas/v1/hosted-service/how-it-works#via-browserwsendpoint)
  - [Via `host` and `port`](https://docs.browserless.io/baas/v1/hosted-service/how-it-works#via-host-and-port)

---

### Load Balancers | Browserless.io
Original URL: https://docs.browserless.io/baas/v1/hosted-service/load-balancers

[Skip to main content](https://docs.browserless.io/baas/v1/hosted-service/load-balancers#__docusaurus_skipToContent_fallback)



DEPRECATION WARNING

This documentation is for BaaS v1, which is no longer actively supported. If you are a new user, please refer to the updated documentation for [BaaS v2](https://docs.browserless.io/baas/load-balancers) or [BrowserQL](https://docs.browserless.io/browserql/start).

The Cloud Subscription plans, Dedicated plans and Enterprise plans have load balancing mechanisms built-in. This docs will provide further information on how they work on each plan. For Enterprise plans we provision you your very own load-balancer.

## Cloud subscriptions' load balancing [â€‹](https://docs.browserless.io/baas/v1/hosted-service/load-balancers\#cloud-subscriptions-load-balancing "Direct link to Cloud subscriptions' load balancing")

When you fire a request to our endpoint, be it `https://chrome.browserless.io` or `wss://chrome.browserles.io`, it will go through our load balancers and will be sent to one of our instances to be handled. We list our shared fleet's [IP addresses for whitelisting](https://www.browserless.io/docs/whitelist#current-ip-address-lists) purposes.

Our cloud-unit fleet is comprised of many machines running browserless, and our load-balancer will automatically determine which machine to handle the request. If, say, a machine is too overloaded to handle the inbound connection then our load-balancer routes the request to another. In very plain terms we use a modified least-connected algorithm to ensure your request is handled appropriately.

## Dedicated workers' load balancing [â€‹](https://docs.browserless.io/baas/v1/hosted-service/load-balancers\#dedicated-workers-load-balancing "Direct link to Dedicated workers' load balancing")

Your worker can be located in 4 different sites: San Francisco, New York, Amsterdam, or London. If you request to `https://chrome.browserless.io` or `wss://chrome.browserles.io`, it'll travel to San Francisco then to your worker.

In order to improve the latency by having a worker located closer to your client, you'll want to use the load balancer closest to your machine, these are the load balancers available for you to point your traffic to:

1. West load balancer (SFO): `https://chrome-us-west.browserless.io`
2. East load balancer (NYC): `https://chrome-us-east.browserless.io`
3. UK load balancer (LON): `https://chrome-eu-uk.browserless.io`
4. AMS load balancer (AMS): `https://chrome-eu-ams.browserless.io`

### Multiple worker load balancing [â€‹](https://docs.browserless.io/baas/v1/hosted-service/load-balancers\#multiple-worker-load-balancing "Direct link to Multiple worker load balancing")

When you have multiple instances, it'll automatically load-balance amongst them by least connections. If you want to handle load-balancing on your end, you can get the endpoint for every individual worker by clicking on the URL in the "Address" Column in the Production Workers table available in your [account dashboard](https://cloud.browserless.io/account/).

- [Cloud subscriptions' load balancing](https://docs.browserless.io/baas/v1/hosted-service/load-balancers#cloud-subscriptions-load-balancing)
- [Dedicated workers' load balancing](https://docs.browserless.io/baas/v1/hosted-service/load-balancers#dedicated-workers-load-balancing)
  - [Multiple worker load balancing](https://docs.browserless.io/baas/v1/hosted-service/load-balancers#multiple-worker-load-balancing)

---

### Proxies | Browserless.io
Original URL: https://docs.browserless.io/baas/v1/hosted-service/proxying

[Skip to main content](https://docs.browserless.io/baas/v1/hosted-service/proxying#__docusaurus_skipToContent_fallback)


DEPRECATION WARNING

This documentation is for BaaS v1, which is no longer actively supported. If you are a new user, please refer to the updated documentation for [BaaS v2](https://docs.browserless.io/baas/proxies) or [BrowserQL](https://docs.browserless.io/browserql/start).

If you need to use proxies with v1, you can use external/third-party proxies. See our documentation on [using external proxies](https://docs.browserless.io/baas/v1/recipes/using-a-proxy) for more information.

info

Our [in-built residential](https://docs.browserless.io/baas/proxies) proxies are only available on Browserless V2, which is available in production via three domains: `production-sfo.browserless.io`, `production-lon.browserless.io`, and `production-ams.browserless.io`.

---

### Browserless Terminology | Browserless.io
Original URL: https://docs.browserless.io/baas/v1/hosted-service/terminology

[Skip to main content](https://docs.browserless.io/baas/v1/hosted-service/terminology#__docusaurus_skipToContent_fallback)



DEPRECATION WARNING

This documentation is for BaaS v1, which is no longer actively supported. If you are a new user, please refer to the updated documentation for [BaaS v2](https://docs.browserless.io/enterprise/terminology) or [BrowserQL](https://docs.browserless.io/browserql/start).

On the main browserless.io site, and inside this documentation site, you'll notice we use a few terms like "worker" or "session". Below is a list of commonly-used terms and what they mean.

## Worker [â€‹](https://docs.browserless.io/baas/v1/hosted-service/terminology\#worker "Direct link to Worker")

A worker is an instance of the Browserless container, running on a virtual-machine. The size of the worker will dictate what types of sites and interactions you can do. For Browserless Enterprise customers, we go through an onboarding process where we help pick the right size and class of machine in order to properly support your workloads.

## Session [â€‹](https://docs.browserless.io/baas/v1/hosted-service/terminology\#session "Direct link to Session")

A session is anytime Chrome is actively running and connected to. Browserless, however, automatically queues up to 2X this amount without any changes in your app's code for _Enterprise plans_ only. Our cloud-unit fleet is provisioned such that you shouldn't ever encounter a sluggish connection. This allows you to set a baseline of traffic throughput, but allows for "bursts" of traffic without having to adjust any of your code (just keep using `puppeteer.connect`).

If more sessions are needed, [please reach out to us](https://www.browserless.io/contact).

## Pressure [â€‹](https://docs.browserless.io/baas/v1/hosted-service/terminology\#pressure "Direct link to Pressure")

info

The Pressure API is only available for Enterprise plans that run on a dedicated fleet of machines.

Pressure indicates how much traffic is going on in your workers at any given time. Using the GraphQL API, you can fetch important details like `isAvailable` to see if your workers can handle another connection. Doing so will ensure your account doesn't get overloaded and become unresponsive.

```codeBlockLines_p187
# https://api.browserless.io/graphql
{
  pressure(apiToken: "YOUR_API_KEY") {
    running
    recentlyRejected
    queued
    isAvailable
    date
  }
}

```

This request will return a JSON object with the following payload:

```codeBlockLines_p187
// JSON returned
{
  "data": {
    "pressure": {
      "running": 0,
      "recentlyRejected": 0,
      "queued": 0,
      "isAvailable": true,
      "date": 1524762532204
    }
  }
}

```

## More Coming [â€‹](https://docs.browserless.io/baas/v1/hosted-service/terminology\#more-coming "Direct link to More Coming")

Did we miss something? [Send us an email and let us know!](https://www.browserless.io/contact)

- [Worker](https://docs.browserless.io/baas/v1/hosted-service/terminology#worker)
- [Session](https://docs.browserless.io/baas/v1/hosted-service/terminology#session)
- [Pressure](https://docs.browserless.io/baas/v1/hosted-service/terminology#pressure)
- [More Coming](https://docs.browserless.io/baas/v1/hosted-service/terminology#more-coming)

---

### Using your API token | Browserless.io
Original URL: https://docs.browserless.io/baas/v1/hosted-service/token

[Skip to main content](https://docs.browserless.io/baas/v1/hosted-service/token#__docusaurus_skipToContent_fallback)



DEPRECATION WARNING

This documentation is for BaaS v1, which is no longer actively supported. If you are a new user, please refer to the updated documentation for [BaaS v2](https://docs.browserless.io/baas/start) or [BrowserQL](https://docs.browserless.io/browserql/start).

When you sign-up for a browserless account, we create a unique token that allows you to interact with the service. Once your worker(s) are ready you should use this token anytime you interact with the service.

You can use this token with most of our integrations by simply appending a `?token=YOUR-API-TOKEN` as a query-string parameter. **The only exception is the webdriver integration as most libraries strip query-parameters for remote servers**. For webdriver connections, use the format `https://YOUR-API-TOKEN@chrome.browserless.io/webdriver`.

For the purposes of illustrating these examples, we'll assume your API-TOKEN is `094632bb-e326-4c63-b953-82b55700b14c`.

## Example integrations [â€‹](https://docs.browserless.io/baas/v1/hosted-service/token\#example-integrations "Direct link to Example integrations")

### Puppeteer with your API Token [â€‹](https://docs.browserless.io/baas/v1/hosted-service/token\#puppeteer-with-your-api-token "Direct link to Puppeteer with your API Token")

```codeBlockLines_p187
const browser = puppeteer.connect({
  browserWSEndpoint: 'wss://chrome.browserless.io?token=094632bb-e326-4c63-b953-82b55700b14c',
});

```

### REST with your API Token [â€‹](https://docs.browserless.io/baas/v1/hosted-service/token\#rest-with-your-api-token "Direct link to REST with your API Token")

#### Query parameter [â€‹](https://docs.browserless.io/baas/v1/hosted-service/token\#query-parameter "Direct link to Query parameter")

The basic way to send your API token over HTTP, is to simply add it as a query parameter:

```codeBlockLines_p187
curl -X POST \
  https://chrome.browserless.io/content?token=094632bb-e326-4c63-b953-82b55700b14c \
  -H 'Cache-Control: no-cache' \
  -H 'Content-Type: application/json' \
  -d '
{
  "url": "https://example.com/"
}'

```

#### Header Authentication [â€‹](https://docs.browserless.io/baas/v1/hosted-service/token\#header-authentication "Direct link to Header Authentication")

You can also add an `Authorization` header for REST API requests as well. Browserless uses the `Basic` auth scheme to get the token:

warning

As per [the HTTP specification](https://httpwg.org/specs/rfc9110.html#authentication), the token **must** be encoded in base64, otherwise you can get `4XX` or `5XX` responses.

```codeBlockLines_p187
curl -X POST \
  https://chrome.browserless.io/content \
  -H 'Cache-Control: no-cache' \
  -H 'Content-Type: application/json' \
  -H 'Authorization: Basic MDk0NjMyYmItZTMyNi00YzYzLWI5NTMtODJiNTU3MDBiMTRj' \
  -d '
{
  "url": "https://example.com/"
}'

```

### Webdriver with your API Token [â€‹](https://docs.browserless.io/baas/v1/hosted-service/token\#webdriver-with-your-api-token "Direct link to Webdriver with your API Token")

warning

Webdriver and Selenium are deprecated in Browserless V2 and beyond, and will eventually be removed altogether from our cloud.

```codeBlockLines_p187
const chromeCapabilities = webdriver.Capabilities.chrome();
chromeCapabilities.set('browserless:token', '094632bb-e326-4c63-b953-82b55700b14c');
chromeCapabilities.set('goog:chromeOptions', {
  args: [\
    '--disable-background-timer-throttling',\
    '--disable-backgrounding-occluded-windows',\
    '--disable-breakpad',\
    '--disable-component-extensions-with-background-pages',\
    '--disable-dev-shm-usage',\
    '--disable-extensions',\
    '--disable-features=TranslateUI,BlinkGenPropertyTrees',\
    '--disable-ipc-flooding-protection',\
    '--disable-renderer-backgrounding',\
    '--enable-features=NetworkService,NetworkServiceInProcess',\
    '--force-color-profile=srgb',\
    '--hide-scrollbars',\
    '--metrics-recording-only',\
    '--mute-audio',\
    '--headless',\
    '--no-sandbox',\
  ],
});

const driver = new webdriver.Builder()
  .forBrowser('chrome')
  .withCapabilities(chromeCapabilities)
  .usingServer('https://chrome.browserless.io/webdriver')
  .build();

```

- [Example integrations](https://docs.browserless.io/baas/v1/hosted-service/token#example-integrations)
  - [Puppeteer with your API Token](https://docs.browserless.io/baas/v1/hosted-service/token#puppeteer-with-your-api-token)
  - [REST with your API Token](https://docs.browserless.io/baas/v1/hosted-service/token#rest-with-your-api-token)
  - [Webdriver with your API Token](https://docs.browserless.io/baas/v1/hosted-service/token#webdriver-with-your-api-token)

---

### Versions on the usage based service | Browserless.io
Original URL: https://docs.browserless.io/baas/v1/hosted-service/versions

[Skip to main content](https://docs.browserless.io/baas/v1/hosted-service/versions#__docusaurus_skipToContent_fallback)



DEPRECATION WARNING

This documentation is for BaaS v1, which is no longer actively supported. If you are a new user, please refer to the updated documentation for [BaaS v2](https://docs.browserless.io/baas/versions) or [BrowserQL](https://docs.browserless.io/browserql/start).

info

This information applies for users that use API keys on the [cloud unit-based or usage-based plan](https://www.browserless.io/sign-up-usage).

Our workers that service the usage based API keys are updated every so often, here are the versions that the hosted version currently has for certain libraries, global timeout and CLI flags supported.

## Current versions used in usage based workers [â€‹](https://docs.browserless.io/baas/v1/hosted-service/versions\#current-versions-used-in-usage-based-workers "Direct link to Current versions used in usage based workers")

Last update: November 13th, 2023.

1. puppeteer 2. chromedriver: `118.0.5993.70`
3. playwright-core: `1.33.0`, `1.34.3`, `1.35.1`, `1.36.2`, `1.37.1`, and `1.38.1`

info

If your code is mysteriously crashing, try using the exact version mentioned above, as some older but especially more recent versions than the above may cause conflicts.

## Global timeout [â€‹](https://docs.browserless.io/baas/v1/hosted-service/versions\#global-timeout "Direct link to Global timeout")

By default, the global timeout is set to 15 minutes for usage-based and cloud unit-based API Keys, if you need your sessions to run longer than that, you'll want to consider upgrading to a dedicated account in order to modify this setting.

## CLI flags supported [â€‹](https://docs.browserless.io/baas/v1/hosted-service/versions\#cli-flags-supported "Direct link to CLI flags supported")

```codeBlockLines_p187
--proxy-server,
--window-size,
--disable-web-security,
--enable-features,
--disable-web-security,
--disable-setuid-sandbox,
--lang,
--font-render-hinting,
--force-color-profile,
stealth,
ignoreDefaultArgs,
headless,
token,
blockAds,
ignoreHTTPSErrors,
slowMo,

```

## Playwright's versioning [â€‹](https://docs.browserless.io/baas/v1/hosted-service/versions\#playwrights-versioning "Direct link to Playwright's versioning")

It is important to note that Playwright's [`connect` method](https://playwright.dev/docs/api/class-browsertype#browser-type-connect) is tightly version-coupled. Your client version must be either `1.33.0`, `1.34.3`, `1.35.1`, `1.36.2`, `1.37.1`, or `1.38.1`

Playwright's `connectOverCDP` doesn't always need to match the same playwright version on our usage based workers. This method is generally backwards/forwards compatible since it communicates directly through CDP, with the caveat to be slightly slower due to having more communication over the devtools protocol.

- [Current versions used in usage based workers](https://docs.browserless.io/baas/v1/hosted-service/versions#current-versions-used-in-usage-based-workers)
- [Global timeout](https://docs.browserless.io/baas/v1/hosted-service/versions#global-timeout)
- [CLI flags supported](https://docs.browserless.io/baas/v1/hosted-service/versions#cli-flags-supported)
- [Playwright's versioning](https://docs.browserless.io/baas/v1/hosted-service/versions#playwrights-versioning)

---

### Whitelisting the IP addresses of the shared fleet | Browserless.io
Original URL: https://docs.browserless.io/baas/v1/hosted-service/whitelist

[Skip to main content](https://docs.browserless.io/baas/v1/hosted-service/whitelist#__docusaurus_skipToContent_fallback)



DEPRECATION WARNING

This documentation is for BaaS v1, which is no longer actively supported. If you are a new user, please refer to the updated documentation for [BaaS v2](https://docs.browserless.io/baas/troubleshooting/whitelisting-ips) or [BrowserQL](https://docs.browserless.io/browserql/start).

If you restrict access to your infrastructure, you can whitelist our service through IP address to allow communicating to your systems.

## Dedicated plans [â€‹](https://docs.browserless.io/baas/v1/hosted-service/whitelist\#dedicated-plans "Direct link to Dedicated plans")

Your worker's IP addresses are listed under the Production Worker's section in the Public IP column.

## Cloud-subscription plans (Shared fleet) [â€‹](https://docs.browserless.io/baas/v1/hosted-service/whitelist\#cloud-subscription-plans-shared-fleet "Direct link to Cloud-subscription plans (Shared fleet)")

The table below lists the most recent IP addresses from our shared fleet for you to whitelist.

The workers that service the cloud-subscription plans may change every few months, since we add more workers according to the demand increase, and also when there are maintenance tasks that require relaunching.

## Current IP Address lists [â€‹](https://docs.browserless.io/baas/v1/hosted-service/whitelist\#current-ip-address-lists "Direct link to Current IP Address lists")

Below is the most recent list of IP addresses on our shared-fleet.

Date of last update: March/28/2025.

| IP address |
| --- |
| 146.190.53.75 |
| 146.190.53.72 |
| 146.190.175.184 |
| 147.182.250.161 |
| 164.92.125.142 |
| 164.92.125.134 |
| 146.190.143.216 |
| 146.190.127.114 |
| 146.190.143.212 |
| 24.199.123.163 |
| 24.199.111.199 |
| 146.190.159.230 |
| 146.190.159.176 |
| 24.199.103.126 |
| 159.223.205.248 |
| 137.184.226.226 |
| 146.190.159.171 |
| 24.144.81.223 |
| 137.184.235.213 |
| 146.190.139.82 |
| 164.92.125.23 |
| 159.223.205.48 |
| 146.190.159.67 |
| 164.92.125.19 |
| 146.190.130.128 |
| 137.184.179.6 |
| 137.184.178.146 |
| 164.92.109.217 |
| 164.92.109.12 |
| 143.198.129.119 |
| 165.232.140.251 |
| 24.199.105.203 |
| 143.198.111.152 |
| 143.198.99.228 |
| 24.144.94.186 |
| 146.190.53.55 |
| 164.90.145.42 |
| 143.198.99.72 |
| 146.190.53.52 |
| 144.126.211.154 |
| 143.244.181.136 |
| 146.190.57.39 |
| 144.126.220.231 |
| 143.198.131.227 |
| 143.244.188.238 |
| 147.182.203.53 |
| 146.190.143.211 |
| 146.190.131.136 |
| 24.199.115.166 |
| 137.184.12.124 |
| 209.38.79.187 |
| 209.38.68.13 |
| 209.38.74.36 |
| 164.92.95.6 |
| 209.38.75.204 |
| 209.38.67.232 |
| 209.38.70.84 |
| 209.38.73.120 |
| 143.198.129.120 |
| 143.198.136.242 |
| 146.190.114.39 |
| 146.190.118.62 |
| 146.190.59.199 |
| 146.190.116.90 |
| 146.190.34.116 |
| 64.23.239.117 |
| 64.23.238.239 |
| 64.23.235.163 |
| 64.23.238.31 |
| 64.23.238.124 |
| 64.23.232.196 |
| 64.23.234.46 |
| 164.90.159.169 |
| 164.90.155.253 |
| 64.23.235.171 |
| 64.23.215.208 |
| 64.23.167.192 |
| 64.23.215.190 |
| 137.184.3.181 |
| 143.198.109.32 |
| 146.190.44.51 |
| 161.35.229.21 |
| 161.35.229.77 |
| 161.35.237.149 |
| 161.35.233.103 |
| 134.209.180.180 |
| 134.209.189.197 |
| 134.209.188.237 |
| 134.209.186.0 |
| 134.209.187.201 |
| 134.209.186.65 |
| 209.97.186.36 |
| 167.172.61.214 |
| 46.101.92.250 |
| 46.101.87.212 |
| 134.209.25.165 |
| 134.209.25.209 |
| 134.209.25.215 |
| 134.209.17.68 |
| 134.209.17.100 |
| 134.209.25.201 |
| 134.209.17.116 |
| 134.209.25.53 |
| 144.126.204.196 |
| 134.209.25.97 |
| 152.42.138.139 |
| 157.245.73.238 |
| 167.71.77.118 |
| 167.71.74.138 |
| 157.245.70.98 |

Or you can download it [as a txt file](https://docs.browserless.io/assets/files/ips-a37a4fd5146bde60402d7c270401ce97.txt) or [a json file](https://docs.browserless.io/assets/files/ips-8e7fda4a41344669859fb22b4df54d56.json).

- [Dedicated plans](https://docs.browserless.io/baas/v1/hosted-service/whitelist#dedicated-plans)
- [Cloud-subscription plans (Shared fleet)](https://docs.browserless.io/baas/v1/hosted-service/whitelist#cloud-subscription-plans-shared-fleet)
- [Current IP Address lists](https://docs.browserless.io/baas/v1/hosted-service/whitelist#current-ip-address-lists)

---

### Worker settings | Browserless.io
Original URL: https://docs.browserless.io/baas/v1/hosted-service/worker-settings

[Skip to main content](https://docs.browserless.io/baas/v1/hosted-service/worker-settings#__docusaurus_skipToContent_fallback)



DEPRECATION WARNING

This documentation is for BaaS v1, which is no longer actively supported. If you are a new user, please refer to the updated documentation for [BaaS v2](https://docs.browserless.io/enterprise/private-deployment/worker-settings) or [BrowserQL](https://docs.browserless.io/browserql/start).

info

This information applies for users that have Dedicated or Enterprise worker(s) in the capacity-based plan.

To customize your worker settings, log in to your [browserless account](https://cloud.browserless.io/account/) and click on the the gear icon in the Production Workers tab.
There are several settings that you can tweak for your dedicated workers in the popup that appears.

## Puppeteer version and global timeout [â€‹](https://docs.browserless.io/baas/v1/hosted-service/worker-settings\#puppeteer-version-and-global-timeout "Direct link to Puppeteer version and global timeout")

The first two dropdown fields will allow you to pick the chrome/puppeteer version and the global timeout.

### Supported chrome/puppeteer versions [â€‹](https://docs.browserless.io/baas/v1/hosted-service/worker-settings\#supported-chromepuppeteer-versions "Direct link to Supported chrome/puppeteer versions")

By default, you will have the latest version. If a newer version is released, we notify through email and your workers will update automatically the next time your workers are relaunched or restarted. If you want to pin your workers to a specific version, you'll have to select one of these versions from the dropdown.

### Global timeout [â€‹](https://docs.browserless.io/baas/v1/hosted-service/worker-settings\#global-timeout "Direct link to Global timeout")

Once the duration of your session reaches the global timeout, it will be terminated.

If your session runs into an exception and your script doesn't handle it properly, your browser process might not exit properly, causing it to hang and remain open, which leads to consuming unnecessary resources, until it reaches the global timeout. It's always a best practice to [implement exception handling in your scripts](https://hackernoon.com/7-tips-to-making-your-puppeteer-scripts-more-bulletproof) to avoid this.

## Concurrency and Queue [â€‹](https://docs.browserless.io/baas/v1/hosted-service/worker-settings\#concurrency-and-queue "Direct link to Concurrency and Queue")

The max concurrency and queue can be modified by using the slider.

### Concurrency tips [â€‹](https://docs.browserless.io/baas/v1/hosted-service/worker-settings\#concurrency-tips "Direct link to Concurrency tips")

If you experience many timeouts/errors and rarely see queued sessions, your worker may be running out of resources and your worker is getting gridlocked. You can limit the max concurrency so that sessions don't run out of resources and hit the queue faster.

### Queue tips [â€‹](https://docs.browserless.io/baas/v1/hosted-service/worker-settings\#queue-tips "Direct link to Queue tips")

If you use an external queueing system, you'll want to set your queue to 0, so that we return an error immediately after your concurrency limit has been reached. Bear in mind this feature may not be 100% flawless, due to the async implementation, a request may slip through the cracks if two requests are being received by the server exactly at the same time, so don't panic if a request gets queued even when set to 0.

## Session health checks [â€‹](https://docs.browserless.io/baas/v1/hosted-service/worker-settings\#session-health-checks "Direct link to Session health checks")

If this feature is checked on, your worker will check the health of your worker before a session connects, be it an api call or library call; if the load balancer determines your worker(s) can't handle another request, it will throw a 5xx response code. Disabling this will send the requests to your worker blindly, forcing it to take the request independently of the health of the worker.

## Stealth mode [â€‹](https://docs.browserless.io/baas/v1/hosted-service/worker-settings\#stealth-mode "Direct link to Stealth mode")

This feature implements puppeteer-extra-plugin-stealth, which injects user behavior to your page, helping your sessions avoid basic bot detecting techniques.

## Experimental features [â€‹](https://docs.browserless.io/baas/v1/hosted-service/worker-settings\#experimental-features "Direct link to Experimental features")

The following features are experimental, which means they are to be used with caution, since they can have caveats you should consider before enabling them.

### Pre-boot chrome [â€‹](https://docs.browserless.io/baas/v1/hosted-service/worker-settings\#pre-boot-chrome "Direct link to Pre-boot chrome")

This feature will launch browser instances and keep them in a pool of instances in order to cut-down on the boot time. Read more about [pre-booting chrome](https://www.browserless.io/docs/docker.html#pre-booting-chrome).

The caveat to this feature is that it may impact performance, since there will be more browsers open than necessary at a given point, which take up resources, hence reducing the available resources for your sessions that are actually running.

### Enable GET APIs [â€‹](https://docs.browserless.io/baas/v1/hosted-service/worker-settings\#enable-get-apis "Direct link to Enable GET APIs")

This feature allows you to enable special /GET handlers for our APIs. This is handy for cases where you need to directly call our services from a cache-layer like a CDN. Read more information on the [/GET APIs](https://www.browserless.io/docs/api-get).

Please do not call the hosted service from the browser as it will reveal your secret token!

### Automatic health restarts [â€‹](https://docs.browserless.io/baas/v1/hosted-service/worker-settings\#automatic-health-restarts "Direct link to Automatic health restarts")

This feature will restart your worker automatically when CPU or Memory usage are above 100% for a period of time (by default 5 minutes). Read more about [exiting on health failure](https://www.browserless.io/docs/docker.html#exit-on-health-failure)

- [Puppeteer version and global timeout](https://docs.browserless.io/baas/v1/hosted-service/worker-settings#puppeteer-version-and-global-timeout)
  - [Supported chrome/puppeteer versions](https://docs.browserless.io/baas/v1/hosted-service/worker-settings#supported-chromepuppeteer-versions)
  - [Global timeout](https://docs.browserless.io/baas/v1/hosted-service/worker-settings#global-timeout)
- [Concurrency and Queue](https://docs.browserless.io/baas/v1/hosted-service/worker-settings#concurrency-and-queue)
  - [Concurrency tips](https://docs.browserless.io/baas/v1/hosted-service/worker-settings#concurrency-tips)
  - [Queue tips](https://docs.browserless.io/baas/v1/hosted-service/worker-settings#queue-tips)
- [Session health checks](https://docs.browserless.io/baas/v1/hosted-service/worker-settings#session-health-checks)
- [Stealth mode](https://docs.browserless.io/baas/v1/hosted-service/worker-settings#stealth-mode)
- [Experimental features](https://docs.browserless.io/baas/v1/hosted-service/worker-settings#experimental-features)
  - [Pre-boot chrome](https://docs.browserless.io/baas/v1/hosted-service/worker-settings#pre-boot-chrome)
  - [Enable GET APIs](https://docs.browserless.io/baas/v1/hosted-service/worker-settings#enable-get-apis)
  - [Automatic health restarts](https://docs.browserless.io/baas/v1/hosted-service/worker-settings#automatic-health-restarts)

---

### Capybara | Browserless.io
Original URL: https://docs.browserless.io/baas/v1/libraries/capybara

[Skip to main content](https://docs.browserless.io/baas/v1/libraries/capybara#__docusaurus_skipToContent_fallback)



DEPRECATION WARNING

This documentation is for BaaS v1, which is no longer actively supported. If you are a new user, please refer to the updated documentation for [BaaS v2](https://docs.browserless.io/baas/start) or [BrowserQL](https://docs.browserless.io/browserql/start).

You can now use the `Capybara` library with browserless! Similar to most libraries based on the webdriver protocol, you simply need to tell `Capybara` _where_ to talk with Chrome. This is a pretty quick change to make:

```codeBlockLines_p187
require 'capybara'
require 'selenium-webdriver'

# Done for demo purposes here!
Capybara.server = :puma, { Silent: true }

Capybara.register_driver :remote_chrome do |app|
  Capybara::Selenium::Driver.new(app,
    :browser              => :remote,
    :url                  => 'https://YOUR_API_TOKEN_HERE@chrome.browserless.io/webdriver',
    :options => Selenium::WebDriver::Remote::Capabilities.chrome("goog:chromeOptions" => {
      "args" => [\
        "--headless",\
        "--no-sandbox"\
      ]
    }),
  )
end

Capybara.default_driver = :remote_chrome

browser = Capybara.current_session
browser.visit 'https://browserless.io/'
puts browser.html
browser.driver.quit

```

This will simply log out the HTML from the Example demo, however it'll give you a great starting place for using Capybara alongside browserless.

Be sure to [let us know if you have questions or issues](https://www.browserless.io/contact).

## Pausing for the debugger [â€‹](https://docs.browserless.io/baas/v1/libraries/capybara\#pausing-for-the-debugger "Direct link to Pausing for the debugger")

You can use the built-in `desired_capabilities` parameter in Selenium's API to tell browserless to pause your script on startup, allowing you to visit the account page and click the Session link to view it as it runs. This is helpful if your script executes extremely quickly, making debugging harder to do.

```codeBlockLines_p187
# Tell browserless to pause on startup:
Capybara.register_driver :remote_chrome do |app|
  Capybara::Selenium::Driver.new(app, {
    :browser              => :remote,
    :url                  => 'https://YOUR_API_TOKEN_HERE@chrome.browserless.io/webdriver',
    :desired_capabilities => Selenium::WebDriver::Remote::Capabilities.chrome(
      "goog:chromeOptions" => { "args" => [ "--headless", "--no-sandbox" ] },
      # PAUSE!
      "browserless.pause": true
    ),
  })
end

```

## Specifying a different timeout [â€‹](https://docs.browserless.io/baas/v1/libraries/capybara\#specifying-a-different-timeout "Direct link to Specifying a different timeout")

You can also override the global timeout for sessions by specifying a `browserless.timeout` capability as well:

```codeBlockLines_p187
# Set timeout to 30 seconds
Capybara.register_driver :remote_chrome do |app|
  Capybara::Selenium::Driver.new(app, {
    :browser              => :remote,
    :url                  => 'https://YOUR_API_TOKEN_HERE@chrome.browserless.io/webdriver',
    :desired_capabilities => Selenium::WebDriver::Remote::Capabilities.chrome(
      "goog:chromeOptions" => { "args" => [ "--headless", "--no-sandbox" ] },
      # 30 seconds in milliseconds
      "browserless.timeout": 30000
    ),
  })
end

```

- [Pausing for the debugger](https://docs.browserless.io/baas/v1/libraries/capybara#pausing-for-the-debugger)
- [Specifying a different timeout](https://docs.browserless.io/baas/v1/libraries/capybara#specifying-a-different-timeout)

---

### Go (chromedp) | Browserless.io
Original URL: https://docs.browserless.io/baas/v1/libraries/go-cdp

[Skip to main content](https://docs.browserless.io/baas/v1/libraries/go-cdp#__docusaurus_skipToContent_fallback)


DEPRECATION WARNING

This documentation is for BaaS v1, which is no longer actively supported. If you are a new user, please refer to the updated documentation for [BaaS v2](https://docs.browserless.io/baas/libraries/chromedp) or [BrowserQL](https://docs.browserless.io/browserql/start).

We're happy to offer beta support of the excellent Go library [chromedp](https://pptr.dev/api/puppeteer.cdpsession)!

Usage of the library remains similar to how you'd run your application locally, simply use the `RemoteAllocator` to connect to browserless API.

An example of navigating to the Example.com site, and getting the title, is listed below as a jumping off point:

```codeBlockLines_p187
package main

import (
    "context"
    "flag"
    "log"

    "github.com/chromedp/chromedp"
)

func main() {
    devtoolsWsURL := flag.String("devtools-ws-url", "wss://chrome.browserless.io?token=****", "DevTools WebSsocket URL")
    flag.Parse()

    allocatorContext, cancel := chromedp.NewRemoteAllocator(context.Background(), *devtoolsWsURL,chromedp.NoModifyURL)
    defer cancel()

    ctx, cancel := chromedp.NewContext(allocatorContext)
    defer cancel()

    var title string
    if err := chromedp.Run(ctx,
        chromedp.Navigate("https://example.com"),
        chromedp.Title(&title),
    ); err != nil {
        log.Fatalf("Failed getting title of example.com: %v", err)
    }

    log.Println("Got title of:", title)
}

```

Be sure to [let us know if you have questions or issues](https://www.browserless.io/contact).

---

### Java (Selenium) | Browserless.io
Original URL: https://docs.browserless.io/baas/v1/libraries/java

[Skip to main content](https://docs.browserless.io/baas/v1/libraries/java#__docusaurus_skipToContent_fallback)


DEPRECATION WARNING

This documentation is for BaaS v1, which is no longer actively supported. If you are a new user, please refer to the updated documentation for [BaaS v2](https://docs.browserless.io/baas/start) or [BrowserQL](https://docs.browserless.io/browserql/start).

Browserless now supports the Selenium library for Java, provided by OpenQA! Similar to all our selenium integrations you can specify your authorization token by specifying an additional capability of `browserless:token`. You'll also want to ensure `--headless` and `--no-sandbox` are set as well.

Here's a small example:

```codeBlockLines_p187
import java.net.*;
import org.openqa.selenium.*;
import org.openqa.selenium.chrome.*;
import org.openqa.selenium.remote.*;

public class Browserless {
  public static void main() throws MalformedURLException {

    final ChromeOptions chromeOptions = new ChromeOptions();

    chromeOptions.addArguments("--no-sandbox");
    chromeOptions.addArguments("--headless");
    chromeOptions.addArguments("--disable-dev-shm-usage");
    chromeOptions.setCapability("browserless:token", "YOUR-API-TOKEN");

    WebDriver driver = new RemoteWebDriver(
        new URL("https://chrome.browserless.io/webdriver"),
        chromeOptions
    );

    driver.get("https://www.example.com");
    driver.quit();
  }
}

```

This will simply navigate to the Example website, however it'll give you a great starting place for using Java Selenium alongside browserless.

Be sure to [let us know if you have questions or issues](https://www.browserless.io/contact).

---

### PHP (cURL) | Browserless.io
Original URL: https://docs.browserless.io/baas/v1/libraries/php

[Skip to main content](https://docs.browserless.io/baas/v1/libraries/php#__docusaurus_skipToContent_fallback)


DEPRECATION WARNING

This documentation is for BaaS v1, which is no longer actively supported. If you are a new user, please refer to the updated documentation for [BaaS v2](https://docs.browserless.io/baas/libraries/php) or [BrowserQL](https://docs.browserless.io/browserql/start).

Browserless can run in PHP by using cURL.
Here's a small example:

```codeBlockLines_p187
<?php

$curl = curl_init();

curl_setopt_array($curl, [\
  CURLOPT_URL => "https://chrome.browserless.io/screenshot?token=xxxxxx",\
  CURLOPT_RETURNTRANSFER => true,\
  CURLOPT_ENCODING => "",\
  CURLOPT_MAXREDIRS => 10,\
  CURLOPT_TIMEOUT => 30,\
  CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\
  CURLOPT_CUSTOMREQUEST => "POST",\
  CURLOPT_POSTFIELDS => "{\n  \"url\": \"https://example.com/\",\n\t\"options\": {\n\t\t\"fullPage\": true,\n\t\t\"encoding\": \"base64\"\n\t}\n}",\
  CURLOPT_HTTPHEADER => [\
    "Content-Type: application/json"\
  ],\
]);

$response = curl_exec($curl);
$err = curl_error($curl);

curl_close($curl);

if ($err) {
  echo "cURL Error #:" . $err;
} else {
  echo $response;
}

```

This will simply take a screenshot of the Example website and return it encoded in base64 format, however it'll give you a great starting place for using our APIs through cURL in PHP.

Be sure to [let us know if you have questions or issues](https://www.browserless.io/contact).

---

### Playwright | Browserless.io
Original URL: https://docs.browserless.io/baas/v1/libraries/playwright

[Skip to main content](https://docs.browserless.io/baas/v1/libraries/playwright#__docusaurus_skipToContent_fallback)



DEPRECATION WARNING

This documentation is for BaaS v1, which is no longer actively supported. If you are a new user, please refer to the updated documentation for [BaaS v2](https://docs.browserless.io/baas/start#connecting-playwright) or [BrowserQL](https://docs.browserless.io/browserql/start).

`playwright` is a new cross-browser library written by Microsoft to aide in cross-browser testing and development. This page helps you get started quickly connecting remotely to browserless instead of launching browsers locally. You can find more detailed documentation on [playwright's documentation site](https://playwright.dev/docs/api/class-browsertype#browser-type-connect-over-cdp).

We support playwright in several languages:

- [Javascript](https://docs.browserless.io/baas/v1/libraries/playwright#javascript-playwright)
- [Java](https://docs.browserless.io/baas/v1/libraries/playwright#java-playwright)
- [C#.NET](https://docs.browserless.io/baas/v1/libraries/playwright#cnet-playwright)
- [Python](https://docs.browserless.io/baas/v1/libraries/playwright#python-playwright)

> NOTE: To avoid errors with no apparent reason, please make sure your playwright version is compatible with one of these [versions.](https://www.browserless.io/docs/versions#playwrights-versioning).

## Javascript playwright [â€‹](https://docs.browserless.io/baas/v1/libraries/playwright\#javascript-playwright "Direct link to Javascript playwright")

We support `playwright` for Javascript out of the box via their `pw.chromium.connect` method. As of now, we only support their `chromium` option, but we're working on other browsers as well.

browserless supports two different methods for connecting via playwright, each with its own benefits and drawbacks. In short, there are two API methods that we support:

### `playwright.chromium.connect(wsEndpoint: string)` [â€‹](https://docs.browserless.io/baas/v1/libraries/playwright\#playwrightchromiumconnectwsendpoint-string "Direct link to playwrightchromiumconnectwsendpoint-string")

The standard `connect` method uses playwright's built-in browser-server to handle the connection. This, generally, is a faster and more fully-featured method since it supports most of the playwright parameters (such as using a proxy and more). However, since this requires the usage of playwright in our implementation, things like ad-blocking and stealth aren't supported. In order to utilize those, you'll need to see our integration with `connectOverCDP`.

> NOTE: If you are using a usage-based or cloud unit-based API key, your playwright version must match one of our supported versions, read more info on [playwright compatible versions.](https://www.browserless.io/docs/versions)

**Take a screenshot in playwright**

```codeBlockLines_p187
const pw = require('playwright');

(async () => {
  const browser = await pw.chromium.connect(
    'wss://chrome.browserless.io/playwright?token=YOUR-API-TOKEN'
  );
  const context = await browser.newContext();
  const page = await context.newPage();

  await page.goto('https://www.example.com/');
  await page.screenshot({ path: 'example.png' });

  await browser.close();
})();

```

### `playwright.chromium.connectOverCDP(wsEndpoint: string)` [â€‹](https://docs.browserless.io/baas/v1/libraries/playwright\#playwrightchromiumconnectovercdpwsendpoint-string "Direct link to playwrightchromiumconnectovercdpwsendpoint-string")

The "connectOverCDP" endpoint allows playwright to connect through Chrome's DevTools Protocol. While this is more functionally similar to how puppeteer operates, it does come with a slight performance hit since sessions are more "chatty" over the network versus playwright's `connect`. Because it's similar to puppeteer, you can use one of our built-in helpers like ad-blocking or stealth to your session. If you're wanting to use playwright's proxy helper then you'll need to use the `connect` method instead.

**Take a screenshot in playwright**

```codeBlockLines_p187
const pw = require('playwright');

(async () => {
  const browser = await pw.chromium.connectOverCDP(
    'wss://chrome.browserless.io?token=YOUR-API-TOKEN'
  );
  const context = await browser.newContext();
  const page = await context.newPage();

  await page.goto('https://www.example.com/');
  await page.screenshot({ path: 'example.png' });

  await browser.close();
})();

```

## Java playwright [â€‹](https://docs.browserless.io/baas/v1/libraries/playwright\#java-playwright "Direct link to Java playwright")

We support `playwright` for Java out of the box via their `playwright.chromium().connectOverCDP` method. As of now, we only support their `chromium` option, but we're working on other browsers as well.

Here's a simple snippet of its implementation.

**Scrape a site title with playwright**

```codeBlockLines_p187
import com.microsoft.playwright.*;

 public class Main {
   public static void main(String[] args) {
    try (Playwright playwright = Playwright.create()) {
      BrowserType chromium = playwright.chromium();
      Browser browser = playwright.chromium().connectOverCDP("wss://chrome.browserless.io?token=YOUR-API-TOKEN");
      Page page = browser.newPage();
      page.navigate("https://example.com");
      System.out.println(page.title());
      browser.close();
    }
     catch(Exception exception){
       System.out.println(exception);
     }
  }
}

```

### Alternate method that allows using authenticated proxies [â€‹](https://docs.browserless.io/baas/v1/libraries/playwright\#alternate-method-that-allows-using-authenticated-proxies "Direct link to Alternate method that allows using authenticated proxies")

Here's a slightly more complex way to instantiate the page through a context. This technique is useful because we can apply options to the context, such as a proxy.

**Use a proxy with remote playwright**

```codeBlockLines_p187
import com.microsoft.playwright.Browser;
import com.microsoft.playwright.Page;
import com.microsoft.playwright.Playwright;
import com.microsoft.playwright.options.*;

public class Main {
  public static void main(String[] args) {
    try {
      Playwright playwright = Playwright.create();
      Browser browser = playwright.chromium().connectOverCDP("wss://chrome.browserless.io?token=YOUR-API-TOKEN");
      var context = browser.newContext(new Browser.NewContextOptions()
        .setProxy(new Proxy("https://YOUR-PROXY-SERVER-DOMAIN:PORT")
          .setUsername("proxyUsername")
          .setPassword("proxyPassword")));

      Page page = context.newPage();
      page.navigate("https://www.whatismyip.com/", new Page.NavigateOptions()
                    .setWaitUntil(WaitUntilState.DOMCONTENTLOADED));
      String myIP = page.innerHTML(".the-ipv4");
      System.out.println(myIP);
      browser.close();
    } catch (Exception exception) {
      exception.printStackTrace();
    }
  }
}

```

## C\#.NET Playwright [â€‹](https://docs.browserless.io/baas/v1/libraries/playwright\#cnet-playwright "Direct link to C\#.NET Playwright")

We support `playwright` for C#.NET out of the box via their `playwright.Chromium.connectOverCDPAsync` method. As of now, we only support their `chromium` option, but we're working on other browsers as well.

**Take a screenshot in playwright**

```codeBlockLines_p187
using Microsoft.Playwright;
using System.Threading.Tasks;
using System;

class Program
{
    public static async Task Main()
    {
        try{
          using var playwright = await Playwright.CreateAsync();
          await using var browser = await playwright.Chromium.ConnectOverCDPAsync("wss://chrome.browserless.io?token=YOUR-API-TOKEN");
          var page = await browser.NewPageAsync();
          await page.GotoAsync("https://example.com/", new PageGotoOptions { WaitUntil = WaitUntilState.NetworkIdle });
          await page.ScreenshotAsync(new PageScreenshotOptions { Path = "example.png" });
        }
        catch (Exception e){
        Debug.WriteLine(e.ToString());
      }
    }
}

```

## Python playwright [â€‹](https://docs.browserless.io/baas/v1/libraries/playwright\#python-playwright "Direct link to Python playwright")

We support `playwright` for Python out of the box via their `playwright.chromium().connect_over_cdp` method.

Here's a simple snippet of its implementation, we can add additional features through the context, such as a proxy, shown below as well, feel free to remove that if you're not going to use one.

Find more of the [playwright documentation for python here.](https://playwright.dev/python/docs/api/class-browsercontext)

```codeBlockLines_p187
from playwright.sync_api import sync_playwright

with sync_playwright() as p:
  browser = p.chromium.connect_over_cdp('wss://chrome.browserless.io?token=your_token')
  context = browser.new_context()
  page = context.new_page()
  page.goto('http://www.example.com',wait_until='domcontentloaded')
  print(page.content())
  context.close()

```

**Use a proxy with remote playwright in Python**

Simply add the proxy parameter to the `new_context` as shown below.

```codeBlockLines_p187
  context = browser.new_context(
    proxy={"server": "http://proxyprovider.com:porthere", "username": "yourusername", "password": "yourpassword"}
  )

```

You can use all the same APIs and helper functions directly with browserless, and begin to scale out your `playwright` applications and tests today.

What's more, [is that you can use all of the same launch arguments for puppeteer](https://docs.browserless.io/baas/v1/options/chrome-flags), directly with `playwright` and `connectOverCDP`!

- [Javascript playwright](https://docs.browserless.io/baas/v1/libraries/playwright#javascript-playwright)
  - [`playwright.chromium.connect(wsEndpoint: string)`](https://docs.browserless.io/baas/v1/libraries/playwright#playwrightchromiumconnectwsendpoint-string)
  - [`playwright.chromium.connectOverCDP(wsEndpoint: string)`](https://docs.browserless.io/baas/v1/libraries/playwright#playwrightchromiumconnectovercdpwsendpoint-string)
- [Java playwright](https://docs.browserless.io/baas/v1/libraries/playwright#java-playwright)
  - [Alternate method that allows using authenticated proxies](https://docs.browserless.io/baas/v1/libraries/playwright#alternate-method-that-allows-using-authenticated-proxies)
- [C#.NET Playwright](https://docs.browserless.io/baas/v1/libraries/playwright#cnet-playwright)
- [Python playwright](https://docs.browserless.io/baas/v1/libraries/playwright#python-playwright)

---

### Python (Playwright) | Browserless.io
Original URL: https://docs.browserless.io/baas/v1/libraries/playwright-python

[Skip to main content](https://docs.browserless.io/baas/v1/libraries/playwright-python#__docusaurus_skipToContent_fallback)



DEPRECATION WARNING

This documentation is for BaaS v1, which is no longer actively supported. If you are a new user, please refer to the updated documentation for [BaaS v2](https://docs.browserless.io/baas/start#connecting-playwright) or [BrowserQL](https://docs.browserless.io/browserql/start).

We support `playwright` for Python out of the box via their `playwright.chromium().connect_over_cdp` method.

Here's a simple snippet of its implementation, we can add additional features through the context, such as a proxy, shown below as well, feel free to remove that if you're not going to use one.

Find more of the [playwright documentation for python here.](https://playwright.dev/python/docs/api/class-browsercontext)

```codeBlockLines_p187
from playwright.sync_api import sync_playwright

with sync_playwright() as p:
  browser = p.chromium.connect_over_cdp('wss://chrome.browserless.io?token=your_token')
  context = browser.new_context()
  page = context.new_page()
  page.goto('http://www.example.com',wait_until='domcontentloaded')
  print(page.content())
  context.close()

```

## Built-in proxy [â€‹](https://docs.browserless.io/baas/v1/libraries/playwright-python\#built-in-proxy "Direct link to Built-in proxy")

Use our in-built residential proxies seamlessly, which will consume units from your subscription, more info here.
Your connection would look like this

```codeBlockLines_p187
  browser = p.chromium.connect_over_cdp('wss://chrome.browserless.io?token=your_token&proxy=residential&proxySticky&proxyCountry=us')

```

You can set your IP address to be geolocated in a specific country with the [&proxyCountry flag](https://www.browserless.io/docs/proxying#all-proxy-options).

## Third party proxies [â€‹](https://docs.browserless.io/baas/v1/libraries/playwright-python\#third-party-proxies "Direct link to Third party proxies")

If you want to bring your own third party proxy, add these parameters to the `new_context` as shown below.

```codeBlockLines_p187
  context = browser.new_context(
    proxy={"server": "http://proxyprovider.com:porthere", "username": "yourusername", "password": "yourpassword"}
  )

```

- [Built-in proxy](https://docs.browserless.io/baas/v1/libraries/playwright-python#built-in-proxy)
- [Third party proxies](https://docs.browserless.io/baas/v1/libraries/playwright-python#third-party-proxies)

---

### Puppeteer | Browserless.io
Original URL: https://docs.browserless.io/baas/v1/libraries/puppeteer

[Skip to main content](https://docs.browserless.io/baas/v1/libraries/puppeteer#__docusaurus_skipToContent_fallback)



DEPRECATION WARNING

This documentation is for BaaS v1, which is no longer actively supported. If you are a new user, please refer to the updated documentation for [BaaS v2](https://docs.browserless.io/baas/start#connecting-puppeteer) or [BrowserQL](https://docs.browserless.io/browserql/start).

Puppeteer is well-supported by browserless, and is easy to upgrade an existing service or app to use it. In order to use the browserless service, simply change the following:

**Before browserless**

```codeBlockLines_p187
import puppeteer from 'puppeteer';

(async () => {
  const browser = await puppeteer.launch();
  const page = await browser.newPage();

  // Remember to catch errors and close!
})();

```

**After browserless**

```codeBlockLines_p187
import puppeteer from 'puppeteer';

(async () => {
  const browser = await puppeteer.connect({
    browserWSEndpoint: `wss://chrome.browserless.io/`,
  });
  const page = await browser.newPage();

  // Remember to catch errors and close!
})();

```

Please note that if you're running the docker container to replace the location of `wss://chrome.browserless.io/` to wherever your container is running.

## Specifying launch flags [â€‹](https://docs.browserless.io/baas/v1/libraries/puppeteer\#specifying-launch-flags "Direct link to Specifying launch flags")

You can specify launch-arguments through query-string parameters inside the `browserWSEndpoint`. As an example, if you want to start the browser with a pre-defined width and height you can specify it like so:

**Setting width and height**

```codeBlockLines_p187
import puppeteer from 'puppeteer';

(async () => {
  const browser = await puppeteer.connect({
    browserWSEndpoint: `wss://chrome.browserless.io?--window-size=1200,900`,
  });
  const page = await browser.newPage();

  // Remember to catch errors and close!
})();

```

- [Specifying launch flags](https://docs.browserless.io/baas/v1/libraries/puppeteer#specifying-launch-flags)

---

### Pyppeteer (Python) - UNMAINTAINED | Browserless.io
Original URL: https://docs.browserless.io/baas/v1/libraries/pyppeteer

[Skip to main content](https://docs.browserless.io/baas/v1/libraries/pyppeteer#__docusaurus_skipToContent_fallback)


DEPRECATION WARNING

This documentation is for BaaS v1, which is no longer actively supported. If you are a new user, please refer to the updated documentation for [BaaS v2](https://docs.browserless.io/baas/libraries/pyppeteer) or [BrowserQL](https://docs.browserless.io/browserql/start).

> NOTE: We suggest not using this library anymore as it is now unmaintained, please consider [playwright-python](https://www.browserless.io/docs/playwright#python-playwright) as an alternative.

You can use your existing python infrastructure today with browserless by using [Pyppeteer](https://github.com/pyppeteer/pyppeteer), an unofficial python port of puppeteer.

Below is a small example of getting started:

```codeBlockLines_p187
import asyncio
import pyppeteer

async def main():
  browser = await pyppeteer.launcher.connect(
    browserWSEndpoint='wss://chrome.browserless.io?token='+YOUR_API_TOKEN_HERE
    )
  page = await browser.newPage()
  url = "https://www.example.com"
  await page.goto(url)
  values = await page.evaluate('''() => document.querySelector('h1').innerHTML
    ''')
  print(values)
  await browser.close()

asyncio.get_event_loop().run_until_complete(main())

```

This will simply navigate to the example website and return the title, however it'll give you a great starting place for using Pyppeteer alongside browserless.

Be sure to [let us know if you have questions or issues](https://www.browserless.io/contact).

---

### Scrapy (Python) | Browserless.io
Original URL: https://docs.browserless.io/baas/v1/libraries/scrapy

[Skip to main content](https://docs.browserless.io/baas/v1/libraries/scrapy#__docusaurus_skipToContent_fallback)


DEPRECATION WARNING

This documentation is for BaaS v1, which is no longer actively supported. If you are a new user, please refer to the updated documentation for [BaaS v2](https://docs.browserless.io/baas/libraries/scrapy) or [BrowserQL](https://docs.browserless.io/browserql/start).

You can use Scrapy alongside [our `/content` API](https://docs.browserless.io/baas/v1/apis/content) to scrape data. All you need to do is use the start\_requests() method to make a query to the `/content` API, while keeping your scraping code the same.

Since Scrapy uses HTTP requests to just download the HTML page and build a DOM-like abstraction to be scrapped, **it can only return the initial render of a page without interacting with it**. On the other hand, the `/content` API asure the HTML content is not just downloaded, but rendered and evaluated inside a browser.

All you need to do is implement the `start_requests()` method to make a query to the `/content` API, while keeping your scraping code the same.

```codeBlockLines_p187
import json
import scrapy

class PptrDocsSpider(scrapy.Spider):
    name = "pptr-docs"

    def start_requests (self):
        options = {
            "url": "https://puppeteer.github.io/pptr.dev/",
            "gotoOptions": { "waitUntil": "networkidle0" }
        }

        yield scrapy.Request(
            url="https://chrome.browserless.io/content?token=YOUR_API_TOKEN_HERE",
            method='POST',
            dont_filter=True,
            headers={"Content-Type": "application/json"},
            body=json.dumps(options)
        )

    def parse(self, response):
        entries = response.css('sidebar-component a.pptr-sidebar-item')
        for entry in entries:
            yield{
                'title' : entry.css('::text').get(),
                'url' : entry.css('::attr(href)').get(),
            }

```

You can use [all the options available in the `/content` API](https://chrome.browserless.io/docs/#/Browser%20API/post_content), use stealth mode, our residential proxies and more! For more reference, please see this [blogpost](https://www.browserless.io/blog/2024/02/15/scrapy-headless/).

---

### Selenium | Browserless.io
Original URL: https://docs.browserless.io/baas/v1/libraries/selenium

[Skip to main content](https://docs.browserless.io/baas/v1/libraries/selenium#__docusaurus_skipToContent_fallback)


DEPRECATION WARNING

This documentation is for BaaS v1, which is no longer actively supported. If you are a new user, please refer to the updated documentation for [BaaS v2](https://docs.browserless.io/baas/start) or [BrowserQL](https://docs.browserless.io/browserql/start).

We're happy to support the web-driver protocol, largely used by Selenium. You'll likely need to consult your libraries documentation since there's many options and alternatives for remote connections. Below is a small example of using the `chrome-webdriver` library and how to use browserless with it.

**Before**

```codeBlockLines_p187
const webdriver = require('selenium-webdriver');
const fs = require('fs');

const chromeCapabilities = webdriver.Capabilities.chrome();
chromeCapabilities.set('goog:chromeOptions', {
  // Set args similar to puppeteer's for best performance
  args: [\
    '--disable-background-timer-throttling',\
    '--disable-backgrounding-occluded-windows',\
    '--disable-breakpad',\
    '--disable-component-extensions-with-background-pages',\
    '--disable-dev-shm-usage',\
    '--disable-extensions',\
    '--disable-features=TranslateUI,BlinkGenPropertyTrees',\
    '--disable-ipc-flooding-protection',\
    '--disable-renderer-backgrounding',\
    '--enable-features=NetworkService,NetworkServiceInProcess',\
    '--force-color-profile=srgb',\
    '--hide-scrollbars',\
    '--metrics-recording-only',\
    '--mute-audio',\
    '--headless',\
    '--no-sandbox',\
  ],
});

const driver = new webdriver.Builder()
  .forBrowser('chrome')
  .withCapabilities(chromeCapabilities)
  .build();

(async () => {
  try {
    await driver.get('https://www.example.com/');

    // Take screenshot of results page. Save to disk.
    const base64png = await driver.takeScreenshot();
    fs.writeFileSync('.no-git/screenshot.png', new Buffer(base64png, 'base64'));
  } finally {
    driver.quit();
  }
})();

```

**After**

```codeBlockLines_p187
const webdriver = require('selenium-webdriver');
const fs = require('fs');

const chromeCapabilities = webdriver.Capabilities.chrome();
chromeCapabilities.set('browserless:token', 'YOUR-API-TOKEN');
chromeCapabilities.set('goog:chromeOptions', {
  args: [\
    '--disable-background-timer-throttling',\
    '--disable-backgrounding-occluded-windows',\
    '--disable-breakpad',\
    '--disable-component-extensions-with-background-pages',\
    '--disable-dev-shm-usage',\
    '--disable-extensions',\
    '--disable-features=TranslateUI,BlinkGenPropertyTrees',\
    '--disable-ipc-flooding-protection',\
    '--disable-renderer-backgrounding',\
    '--enable-features=NetworkService,NetworkServiceInProcess',\
    '--force-color-profile=srgb',\
    '--hide-scrollbars',\
    '--metrics-recording-only',\
    '--mute-audio',\
    '--headless',\
    '--no-sandbox',\
  ],
});

const driver = new webdriver.Builder()
  .forBrowser('chrome')
  .withCapabilities(chromeCapabilities)
  // Specify browserless for the server
  .usingServer('https://chrome.browserless.io/webdriver')
  .build();

(async () => {
  try {
    await driver.get('https://www.example.com/');

    // Take screenshot of results page. Save to disk.
    const base64png = await driver.takeScreenshot();
    fs.writeFileSync('.no-git/screenshot.png', new Buffer(base64png, 'base64'));
  } finally {
    driver.quit();
  }
})();

```

If you're using the hosted service, be sure to set the extra option for the browserless token:

**Token Auth**

```codeBlockLines_p187
chromeCapabilities.set('browserless:token', 'YOUR-API-TOKEN');

```

The reason you can't append use the standard `?token=YOUR-API-TOKEN` is due to limitations in many of the Selenium libraries where query-string parameters are dropped from the server URL.

---

### .NET Selenium (C#) | Browserless.io
Original URL: https://docs.browserless.io/baas/v1/libraries/selenium-dotnet

[Skip to main content](https://docs.browserless.io/baas/v1/libraries/selenium-dotnet#__docusaurus_skipToContent_fallback)


DEPRECATION WARNING

This documentation is for BaaS v1, which is no longer actively supported. If you are a new user, please refer to the updated documentation for [BaaS v2](https://docs.browserless.io/baas/start) or [BrowserQL](https://docs.browserless.io/browserql/start).

Browserless now supports the .NET Selenium library provided by OpenQA! Similar to all our selenium integrations, you can specify your authorization token by specifying an additional capability of `browserless:token`. Note that this is _not_ a capability that Chrome understands natively, and will throw an error, so you must specify `true` as your 3rd argument.

Here's a full example:

```codeBlockLines_p187
using System;
using OpenQA.Selenium;
using OpenQA.Selenium.Remote;
using OpenQA.Selenium.Chrome;

namespace BrowserlessSelenium
{
    class Program
    {
        static void Main(string[] args)
        {
            IWebDriver driver;
            ChromeOptions options = new ChromeOptions();

            // Set launch args similar to puppeteer's for best performance
            options.AddArgument("--disable-background-timer-throttling");
            options.AddArgument("--disable-backgrounding-occluded-windows");
            options.AddArgument("--disable-breakpad");
            options.AddArgument("--disable-component-extensions-with-background-pages");
            options.AddArgument("--disable-dev-shm-usage");
            options.AddArgument("--disable-extensions");
            options.AddArgument("--disable-features=TranslateUI,BlinkGenPropertyTrees");
            options.AddArgument("--disable-ipc-flooding-protection");
            options.AddArgument("--disable-renderer-backgrounding");
            options.AddArgument("--enable-features=NetworkService,NetworkServiceInProcess");
            options.AddArgument("--force-color-profile=srgb");
            options.AddArgument("--hide-scrollbars");
            options.AddArgument("--metrics-recording-only");
            options.AddArgument("--mute-audio");
            options.AddArgument("--headless");
            options.AddArgument("--no-sandbox");

            options.AddAdditionalOption("browserless:token", "YOUR-API-TOKEN");
            options.AddAdditionalOption("browserless:timeout", 60000);//optional flag to set a different timeout value than the default
            options.AddAdditionalOption("browserless:stealth", True);//optional flag to enable Stealth
            options.AddAdditionalOption("browserless:blockAds", True);//optional flag to enable blockAds
            options.AddAdditionalOption("browserless:trackingId", "AwENCwMHDQoHBgwKBAUODQ");//optional flag to enable trackingId
            options.AddAdditionalOption("browserless:pauseOnConnect", True);//optional flag to enable pauseOnConnect

            driver = new RemoteWebDriver(
              new Uri("https://chrome.browserless.io/webdriver"), options.ToCapabilities()
            );

            driver.Navigate().GoToUrl("https://example.com");
            Console.WriteLine(driver.Title);

            // Always call `quit` to ensure your session cleans up properly and you're not charged for unused time
            driver.Quit();
        }
    }
}

```

This will simply log out the Title from the Example website, however it'll give you a great starting place for using .NET alongside browserless.

Be sure to [let us know if you have questions or issues](https://www.browserless.io/contact).

---

### Python (Selenium) | Browserless.io
Original URL: https://docs.browserless.io/baas/v1/libraries/selenium-python

[Skip to main content](https://docs.browserless.io/baas/v1/libraries/selenium-python#__docusaurus_skipToContent_fallback)



DEPRECATION WARNING

This documentation is for BaaS v1, which is no longer actively supported. If you are a new user, please refer to the updated documentation for [BaaS v2](https://docs.browserless.io/baas/start) or [BrowserQL](https://docs.browserless.io/browserql/start).

You can use your existing python infrastructure today with browserless by using the selenium webdriver library.

As with most selenium libraries, you'll need to install the webdriver dependency, and set browserless as your remote webdriver. You'll also use `set_capability` to specify your browserless.io token when making requests to the hosted service.

Below there are some small examples of getting started:

## Selenium 4 [â€‹](https://docs.browserless.io/baas/v1/libraries/selenium-python\#selenium-4 "Direct link to Selenium 4")

```codeBlockLines_p187
# Selenium 4
from selenium import webdriver

chrome_options = webdriver.ChromeOptions()
chrome_options.set_capability('browserless:token', 'YOUR-API-TOKEN')
chrome_options.add_argument("--no-sandbox")
chrome_options.add_argument("--headless")

driver = webdriver.Remote(
    command_executor='https://chrome.browserless.io/webdriver',
    options=chrome_options
)

driver.get("https://www.example.com")
print(driver.title)
driver.quit()

```

## Selenium 3 [â€‹](https://docs.browserless.io/baas/v1/libraries/selenium-python\#selenium-3 "Direct link to Selenium 3")

```codeBlockLines_p187
# Selenium 3
from selenium import webdriver
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.common.desired_capabilities import DesiredCapabilities

chrome_options = webdriver.ChromeOptions()
chrome_options.set_capability('browserless:token', 'YOUR-API-TOKEN')
chrome_options.add_argument("--no-sandbox")
chrome_options.add_argument("--headless")

driver = webdriver.Remote(
  command_executor='https://chrome.browserless.io/webdriver',
  desired_capabilities=chrome_options.to_capabilities()
)

driver.get("https://www.example.com")
print(driver.title)
driver.quit()

```

This will simply navigate to the Example website and print the title, however it'll give you a great starting place for using Java Selenium alongside browserless.

Be sure to [let us know if you have questions or issues](https://www.browserless.io/contact).

- [Selenium 4](https://docs.browserless.io/baas/v1/libraries/selenium-python#selenium-4)
- [Selenium 3](https://docs.browserless.io/baas/v1/libraries/selenium-python#selenium-3)

---

### Using /get API | Browserless.io
Original URL: https://docs.browserless.io/baas/v1/options/api-get

[Skip to main content](https://docs.browserless.io/baas/v1/options/api-get#__docusaurus_skipToContent_fallback)



DEPRECATION WARNING

This documentation is for BaaS v1, which is no longer actively supported. If you are a new user, please refer to the updated documentation for [BaaS v2](https://docs.browserless.io/baas/start) or [BrowserQL](https://docs.browserless.io/browserql/start).

In recent version of browserless we've enabled special /GET handlers for our APIs. This is handy for cases where you need to directly call our services from a cache-layer like a CDN.

> Please do not call the hosted service from the browser as it will reveal your secret token!

In order to use this feature on the hosted service, you'll need to restart or update your worker(s) to do so. Simply click the "Restart Workers" button, and toggle the "Enable API GET" switch. Once restart you should be able to issue GET calls.

In docker, you'll need to set the `ENABLE_API_GET` environment variable to `true`.

## Making the request [â€‹](https://docs.browserless.io/baas/v1/options/api-get\#making-the-request "Direct link to Making the request")

Similar to our POST APIs (/content, /screenshot, /pdf, /scrape and /stats), you'll need to send a JSON payload to browserless. However, since we're issuing a GET call instead of a POST, you'll need to stringify your JSON body and append it to the URL of the call as a query-string `body` parameter.

Here's a simple example of doing a screenshot with the example.com website.

**Before (POST)**

```codeBlockLines_p187
curl -X POST \
  https://chrome.browserless.io/screenshot?token=MY_API_TOKEN \
  -H 'Cache-Control: no-cache' \
  -H 'Content-Type: application/json' \
  -d '{
  "url": "https://example.com/",
  "options": {
    "fullPage": true,
    "type": "jpeg",
    "quality": 75
  }
}'

```

**After (GET)**

```codeBlockLines_p187
curl -X GET \
  https://chrome.browserless.io/screenshot?token=MY_API_TOKEN&body=%7B%22url%22%3A%22https%3A%2F%2Fexample.com%2F%22%2C%22options%22%3A%7B%22fullPage%22%3Atrue%2C%22type%22%3A%22jpeg%22%2C%22quality%22%3A75%7D%7D

```

You'll note that we've both stringified the JSON, and encoded it for URL transmission. Because of how much space this takes, it's generally recommended to use the POST version, however certain use-cases might benefit from this GET feature.

- [Making the request](https://docs.browserless.io/baas/v1/options/api-get#making-the-request)

---

### Launch Options | Browserless.io
Original URL: https://docs.browserless.io/baas/v1/options/chrome-flags

[Skip to main content](https://docs.browserless.io/baas/v1/options/chrome-flags#__docusaurus_skipToContent_fallback)



DEPRECATION WARNING

This documentation is for BaaS v1, which is no longer actively supported. If you are a new user, please refer to the updated documentation for [BaaS v2](https://docs.browserless.io/baas/start) or [BrowserQL](https://docs.browserless.io/browserql/start).

- [Launching with a proxy](https://docs.browserless.io/baas/v1/options/chrome-flags#launching-with-a-proxy)
- [Blocking Ads](https://docs.browserless.io/baas/v1/options/chrome-flags#blocking-ads)
- [Running in Stealth](https://docs.browserless.io/baas/v1/options/chrome-flags#running-in-stealth)
- [Specifying a user-data-dir](https://docs.browserless.io/baas/v1/options/chrome-flags#caching-with-user-data-dir)
- [Keeping the browser alive](https://docs.browserless.io/baas/v1/options/chrome-flags#keeping-the-browser-alive)
- [Setting a width and height](https://docs.browserless.io/baas/v1/options/chrome-flags#starting-chrome-with-a-width-and-height)
- [Ignoring default flags](https://docs.browserless.io/baas/v1/options/chrome-flags#ignoring-default-flags)
- [Setting headless](https://docs.browserless.io/baas/v1/options/chrome-flags#setting-headless)
- [Overriding puppeteer launch args](https://docs.browserless.io/baas/v1/options/chrome-flags#overriding-puppeteers-launch-args)
- [Setting a Tracking ID](https://docs.browserless.io/baas/v1/options/chrome-flags#setting-a-tracking-id)
- [Overriding the session timer](https://docs.browserless.io/baas/v1/options/chrome-flags#overriding-the-session-timer)
- [Other parameters](https://docs.browserless.io/baas/v1/options/chrome-flags#other-parameters)

Browserless let's you control how Chrome is started via query-string parameters in your `puppeteer.connect`'s `browserWSEndpoint` URL, or in your REST API. This is useful in cases where you might need to start Chrome at a certain width and height, or need to use a proxy for visiting pages behind a firewall. Browserless (both hosted and self-hosted) lets you send launch arguments by specifying them as query-string parameters.

> If you've launched workers in a different region, be sure to use the appropriate load-balancer on your account page for a faster connection.

## Launching with a proxy [â€‹](https://docs.browserless.io/baas/v1/options/chrome-flags\#launching-with-a-proxy "Direct link to Launching with a proxy")

> Please note that many proxies only support Chromium revisions in less than puppeteer 1.18.0. This is due to Chromium dropping support for Proxy-Authorization headers. Check your proxies documentation for how to properly authenticate, and ensure that you don't need to set a Proxy-Authorization header.

```codeBlockLines_p187
wss://chrome.browserless.io/?token=YOUR_API_KEY&--proxy-server=https://my-proxy.com

```

You can start Chrome and have it issues requests via a proxy by using the query-string parameter of `--proxy-server=${server}`. This will have Chrome issues requests through the proxy server as opposed to issuing plain network requests.

NOTE: If using an authenticated proxy, where you must provide a username and password, refer to your libraries documentation on how to handle this.

## Blocking ads [â€‹](https://docs.browserless.io/baas/v1/options/chrome-flags\#blocking-ads "Direct link to Blocking ads")

> Available in all accounts in browserless version 1.7.0 and beyond

You can use our built-in ad-blocker for both `puppeteer.connect()` and REST API calls. You'll simply need to add a query-string parameter of `?blockAds` to your URL when connecting:

```codeBlockLines_p187
wss://chrome.browserless.io/?token=YOUR_API_KEY&blockAds

```

Or for REST API calls:

```codeBlockLines_p187
https://chrome.browserless.io/?token=YOUR_API_KEY&blockAds

```

When new pages are created, browserless will inject a request-interceptor. If a domain matches a known site, we'll abort the call. This greatly reduces the number of inbound networks calls, and can significantly improve performance.

## Running in Stealth [â€‹](https://docs.browserless.io/baas/v1/options/chrome-flags\#running-in-stealth "Direct link to Running in Stealth")

Newer versions of our docker image, and in our cloud environment, now include a `stealth` argument that utilizes `puppeteer-extra-stealth` to help ensure your requests run stealthfully. As with all of our launch options, simply connect or query our APIs with a `stealth` argument:

```codeBlockLines_p187
wss://chrome.browserless.io/?token=YOUR_API_KEY&stealth

```

Or for REST API calls:

```codeBlockLines_p187
https://chrome.browserless.io/?token=YOUR_API_KEY&stealth

```

## Caching with user-data-dir [â€‹](https://docs.browserless.io/baas/v1/options/chrome-flags\#caching-with-user-data-dir "Direct link to Caching with user-data-dir")

> Setting a user-data-dir is only available for Dedicated and self-hosted accounts (not on usage-based or cloud unit-based).

You can launch Chrome and specify a "user-data-dir" on each request to cache and make future sessions faster:

```codeBlockLines_p187
wss://chrome.browserless.io/?token=YOUR_API_KEY&--user-data-dir=~/browserless-cache-123

```

This can be used in conjuction with all our API's and integrations.

## Keeping the browser alive [â€‹](https://docs.browserless.io/baas/v1/options/chrome-flags\#keeping-the-browser-alive "Direct link to Keeping the browser alive")

> This feature is only supported in our puppeteer integration, and only on Dedicated and self-hosted deployments.

By default, browserless automatically closes chrome when the session disconnects. This generally meets most of the use-cases we've seen out there. However, there may be times when you want to keep the browser open even after your finished. You can do this with a `keepalive` parameter.

`keepalive` specifies how long browserless should keep the browser process open for possible reconnection later.

**Keep chrome open for 5 minutes after disconnecting**

```codeBlockLines_p187
puppeteer.connect({
  browserWSEndpoint: 'wss://chrome.browserless.io/?token=YOUR_API_KEY&keepalive=300000',
});

```

Should you use `keepalive` in your connect call, you'll also want to ensure that `browser.disconnect` is called _and not_ `browser.close`, as the latter will kill the Chrome process.

Once your app disconnects, either by design or in case of an interuppted session, we will keep the browser open for the keepalive specified (in the above example this would be 5 minutes). After that, regardless of any reconnected sessions, browserless will kill the chromium process.

In order to reconnect to an existing session, simply call the `/session` endpoint, or for Dedicated accounts use the GraphQL `sessions` query. This call will return all active sessions back, including a `browserWSEndpoint` payload you can use to re-connect puppeteer back to the browser. When combined with a `trackingId` this can make for a powerful integration and a lot of flexibility.

## Starting Chrome with a width and height [â€‹](https://docs.browserless.io/baas/v1/options/chrome-flags\#starting-chrome-with-a-width-and-height "Direct link to Starting Chrome with a width and height")

```codeBlockLines_p187
wss://chrome.browserless.io/?token=YOUR_API_KEY&--window-size=1200,900

```

You can also specify the dimensions Chrome should start with via the `--window-size` parameter. The value here should be a string of X and Y dimensions which translate to width and height (IE: '800,600').

## Ignoring default flags [â€‹](https://docs.browserless.io/baas/v1/options/chrome-flags\#ignoring-default-flags "Direct link to Ignoring default flags")

By default puppeteer specifies a certain number of launch flags in order to provide the best experience. In order to turn these off you'll need to tell browserless to ignore them. Be careful ignoring these args as it might cause chromium to become unstable or refuse to launch.

```codeBlockLines_p187
wss://chrome.browserless.io/?token=YOUR_API_KEY&ignoreDefaultArgs=--hide-scrollbars,--disable-default-apps

```

## Setting headless [â€‹](https://docs.browserless.io/baas/v1/options/chrome-flags\#setting-headless "Direct link to Setting headless")

In many cases setting headless won't matter, as browserless will default to this to `true`. In some special circumastances it's important to set this to `false`. As an example, our screencast API sets this to `false` in order to appropriately load an extension for testing.

```codeBlockLines_p187
wss://chrome.browserless.io/?token=YOUR_API_KEY&headless=false

```

## Overriding Puppeteer's launch args [â€‹](https://docs.browserless.io/baas/v1/options/chrome-flags\#overriding-puppeteers-launch-args "Direct link to Overriding Puppeteer's launch args")

Since `puppeteer.connect` differs greatly from `puppeteer.launch`, browserless a way to pass in certain parameters to "override" puppeteer's default launch arguments. These are specified through query-string parameters, and can be applied like so:

**Ignore HTTPS Errors**

```codeBlockLines_p187
// Via puppeteer.launch()
puppeteer.launch({
  ignoreHTTPSErrors: true,
});

// Via puppeteer.connect()
puppeteer.connect({
  browserWSEndpoint: 'wss://chrome.browserless.io?token=YOUR-API-TOKEN',
  ignoreHTTPSErrors: true,
});

```

**Slow Mo**

```codeBlockLines_p187
// Via puppeteer.launch()
puppeteer.launch({
  slowMo: 1000,
});

// Via puppeteer.connect()
puppeteer.connect({
  browserWSEndpoint: 'wss://chrome.browserless.io?token=YOUR-API-TOKEN',
  slowMo: 1000,
});

```

**Ignore default args**

```codeBlockLines_p187
// Via puppeteer.launch()
puppeteer.launch({
  ignoreDefaultArgs: true,
});

// Via puppeteer.connect()
puppeteer.connect({
  browserWSEndpoint: 'wss://chrome.browserless.io?token=YOUR-API-TOKEN&ignoreDefaultArgs=true',
});

```

## Setting a tracking ID [â€‹](https://docs.browserless.io/baas/v1/options/chrome-flags\#setting-a-tracking-id "Direct link to Setting a tracking ID")

> Tracking ID's, and the workspace queries, are only available for Dedicated and self-hosted accounts (not usage-based or cloud unit-based).

Sometimes it's useful to associate particular sessions of browserless with some other part of your application. For those instances we have mechanism called `trackingId`.

When this query-string parameter is present in a REST API call, or `puppeteer.connect`, browserless will scope both file downloads and `GET /sessions` calls to reveal the `trackingId` of the original call. For instance:

```codeBlockLines_p187
// Connect with a "trackingId" in the browserWSEndpoint:
puppeteer.connect({
  browserWSEndpoint:
    'wss://chrome.browserless.io?token=YOUR-API-TOKEN&trackingId=AwENCwMHDQoHBgwKBAUODQ',
});

// Do some work, download files
browser.close();

```

Will save downloads to a sub-directory of `AwENCwMHDQoHBgwKBAUODQ` in the workspace. Thus, a `GET /workspace` call results in the following:

```codeBlockLines_p187
[\
  {\
    created: '2019-07-15T22:11:40.157Z',\
    isDirectory: false,\
    name: 'data.csv',\
    path: '/workspace/AwENCwMHDQoHBgwKBAUODQ/data.csv',\
    size: 52,\
    workspaceId: 'AwENCwMHDQoHBgwKBAUODQ',\
  },\
];

```

Similarly, a `GET /session` call will reveal a property to identify that particular session:

```codeBlockLines_p187
[\
  {\
    "description": "",\
    "devtoolsFrontendUrl": "/devtools/inspector.html?ws=127.0.0.1:3000/devtools/page/6875C09959939E88D9BD30EC1FE1AAF0",\
    "id": "6875C09959939E88D9BD30EC1FE1AAF0",\
    "title": "Example Domain",\
    "type": "page",\
    "url": "https://example.com/",\
    "webSocketDebuggerUrl": "ws://127.0.0.1:3000/devtools/page/6875C09959939E88D9BD30EC1FE1AAF0",\
    "port": "62932",\
    "trackingId": "AwENCwMHDQoHBgwKBAUODQ"\
  }\
]

```

We'll be adding more behavioral and logging changes to surface this tracking-ID as it makes sense, so be sure to check back often to see how this can help you in your application development.

## Overriding the session timer [â€‹](https://docs.browserless.io/baas/v1/options/chrome-flags\#overriding-the-session-timer "Direct link to Overriding the session timer")

By default, your sessions (REST API, puppeteer.connect _and_ webdriver) are governed by a timeout. This is set via your account page for the hosted service, or by specifying `CONNECTION_TIMEOUT` in the `docker run` command. You can, on a per-job basis, override this.

For `puppeteer.connect` and REST API's, simply specify a `?timeout` query-string parameter, with the value being the time in milliseconds for the session to execute:

```codeBlockLines_p187
# REST API (10-second limit):
https://chrome.browserless.io?token=YOUR-API-TOKEN&timeout=10000

# puppeteer.connect URL (10-second limit):
wss://chrome.browserless.io?token=YOUR-API-TOKEN&timeout=10000

```

For webdriver, you must add an additional capability:

```codeBlockLines_p187
const webdriver = require('selenium-webdriver');

const chromeCapabilities = webdriver.Capabilities.chrome();
// Set the session to a 10-second limit
chromeCapabilities.set('browserless.timeout', 10000);

```

For other runtimes and selenium libraries be sure to consult your libraries documentation, or [contact us](https://www.browserless.io/contact)

## Other parameters [â€‹](https://docs.browserless.io/baas/v1/options/chrome-flags\#other-parameters "Direct link to Other parameters")

By default browserless looks for query-string parameters beginning with `--` and passes them to Chrome upon boot. This means that most flags are supported even if they aren't documented. You can also see how we parse parameters by [reading through our code here](https://github.com/browserless/browserless/blob/v1/src/chrome-helper.ts#L88).

At this time, only certain flags and query-parameters are allowed for usage-based accounts and cloud unit-based, and are listed below:

- --proxy-server,
- --window-size,
- --disable-web-security,
- --enable-features,
- --disable-web-security,
- --disable-setuid-sandbox,
- --lang,
- --font-render-hinting,
- --force-color-profile,
- stealth,
- ignoreDefaultArgs,
- headless,
- token,
- blockAds,
- ignoreHTTPSErrors,
- slowMo,

- [Launching with a proxy](https://docs.browserless.io/baas/v1/options/chrome-flags#launching-with-a-proxy)
- [Blocking ads](https://docs.browserless.io/baas/v1/options/chrome-flags#blocking-ads)
- [Running in Stealth](https://docs.browserless.io/baas/v1/options/chrome-flags#running-in-stealth)
- [Caching with user-data-dir](https://docs.browserless.io/baas/v1/options/chrome-flags#caching-with-user-data-dir)
- [Keeping the browser alive](https://docs.browserless.io/baas/v1/options/chrome-flags#keeping-the-browser-alive)
- [Starting Chrome with a width and height](https://docs.browserless.io/baas/v1/options/chrome-flags#starting-chrome-with-a-width-and-height)
- [Ignoring default flags](https://docs.browserless.io/baas/v1/options/chrome-flags#ignoring-default-flags)
- [Setting headless](https://docs.browserless.io/baas/v1/options/chrome-flags#setting-headless)
- [Overriding Puppeteer's launch args](https://docs.browserless.io/baas/v1/options/chrome-flags#overriding-puppeteers-launch-args)
- [Setting a tracking ID](https://docs.browserless.io/baas/v1/options/chrome-flags#setting-a-tracking-id)
- [Overriding the session timer](https://docs.browserless.io/baas/v1/options/chrome-flags#overriding-the-session-timer)
- [Other parameters](https://docs.browserless.io/baas/v1/options/chrome-flags#other-parameters)

---

### How to bypass bot detection | Browserless.io
Original URL: https://docs.browserless.io/baas/v1/recipes/bot-detection

[Skip to main content](https://docs.browserless.io/baas/v1/recipes/bot-detection#__docusaurus_skipToContent_fallback)



DEPRECATION WARNING

This documentation is for BaaS v1, which is no longer actively supported. If you are a new user, please refer to the updated documentation for [BaaS v2](https://docs.browserless.io/baas/avoid-bot-detection/stealth) or [BrowserQL](https://docs.browserless.io/browserql/start).

Websites can have a different level of anti-bot mechanisms depending on the sensitivity of their data and budget. If your automations about being blocked, setting these three flags will bypass most anti-bot mechanisms.

## Flags to bypass bot detection [â€‹](https://docs.browserless.io/baas/v1/recipes/bot-detection\#flags-to-bypass-bot-detection "Direct link to Flags to bypass bot detection")

### Use the `&headless=false` flag [â€‹](https://docs.browserless.io/baas/v1/recipes/bot-detection\#use-the-headlessfalse-flag "Direct link to use-the-headlessfalse-flag")

Most bot detectors will check your user-agent, which by default explicitly claims you're running headless chrome. This is a dead giveaway. It can be changed by setting a specific user-agent but we highly recommend you use the &headless=false flag instead, which changes your user-agent to a more credible one.

### Use the `&stealth` flag [â€‹](https://docs.browserless.io/baas/v1/recipes/bot-detection\#use-the-stealth-flag "Direct link to use-the-stealth-flag")

The stealth flag implements Puppeteer's puppeteer-extra-plugin-stealth plugin which applies various techniques to make detection of headless puppeteer harder. This flag may backfire and be easily detected by some sites, so consider avoiding it as well.

### Use our [in-built proxy](https://www.browserless.io/docs/proxying) or use a [third-party proxy](https://www.browserless.io/docs/using-a-proxy) [â€‹](https://docs.browserless.io/baas/v1/recipes/bot-detection\#use-our-in-built-proxy-or-use-a-third-party-proxy "Direct link to use-our-in-built-proxy-or-use-a-third-party-proxy")

Finally, the hardest sites to crack down check your IP address; there are two type of bocks that can occur, those based on type of IP, and those based on frequency of requests (rate-limits).

- Sites checking the type of IP address will detect your data-center IP addresses when using Browserless. To overcome this, using a proxy with residential IP addresses will be the best option.
- Sites that work the first few times and then stop working, are probably rate-limiting and it's not the residential part of it that blocks us. For these cases, you don't necessarily need a residential proxy and data-center IP addresses that rotate should be enough.

## Additional strategies [â€‹](https://docs.browserless.io/baas/v1/recipes/bot-detection\#additional-strategies "Direct link to Additional strategies")

If none of these do the trick, get in touch with us at [support@browserless.io](mailto:support@browserless.io) >.

We have more trick up our sleeves we can show you, such as captcha solving and our newest BQL tool on our current v2 build, upgrade to the latest build to learn [new bypassing methods](https://docs.browserless.io/baas/avoid-bot-detection/stealth).

- [Flags to bypass bot detection](https://docs.browserless.io/baas/v1/recipes/bot-detection#flags-to-bypass-bot-detection)
  - [Use the `&headless=false` flag](https://docs.browserless.io/baas/v1/recipes/bot-detection#use-the-headlessfalse-flag)
  - [Use the `&stealth` flag](https://docs.browserless.io/baas/v1/recipes/bot-detection#use-the-stealth-flag)
  - [Use our in-built proxy or use a third-party proxy](https://docs.browserless.io/baas/v1/recipes/bot-detection#use-our-in-built-proxy-or-use-a-third-party-proxy)
- [Additional strategies](https://docs.browserless.io/baas/v1/recipes/bot-detection#additional-strategies)

---

### Dealing with file downloads in puppeteer | Browserless.io
Original URL: https://docs.browserless.io/baas/v1/recipes/downloading-files

[Skip to main content](https://docs.browserless.io/baas/v1/recipes/downloading-files#__docusaurus_skipToContent_fallback)



DEPRECATION WARNING

This documentation is for BaaS v1, which is no longer actively supported. If you are a new user, please refer to the updated documentation for [BaaS v2](https://docs.browserless.io/baas/start) or [BrowserQL](https://docs.browserless.io/browserql/start).

Because of the tight coupling between Chrome and the local file-system it can be hard to determine _where_ files are being downloaded, and subsequently process/remove them. Because of this complex nature we offer two mechanisms in which to deal with file downloads in browserless: using our `/download` API, or manage the downloads via the `/workspace` API.

## Using the /download API [â€‹](https://docs.browserless.io/baas/v1/recipes/downloading-files\#using-the-download-api "Direct link to Using the /download API")

Much like the `/function` API, the `/download` API allows you to `POST` a module to run that will return the file the browser downloads. Here's an example of a puppeteer script that will return a CSV file:

```codeBlockLines_p187
const puppeteer = require('puppeteer');

async function run() {
  const browser = await puppeteer.launch();
  const page = await browser.newPage();

  // Here we generate a CSV file and have the browser download it
  await page.evaluate(() => {
    const rows = [\
      ['name1', 'city1', 'some other info'],\
      ['name2', 'city2', 'more info'],\
    ];
    let csvContent = 'data:text/csv;charset=utf-8,';
    rows.forEach(function (rowArray) {
      let row = rowArray.join(',');
      csvContent += row + '\r\n';
    });
    const encodedUri = encodeURI(csvContent);
    const link = document.createElement('a');
    link.setAttribute('href', encodedUri);
    link.setAttribute('download', 'data.csv');
    document.body.appendChild(link);

    return link.click();
  });
}

run();

```

This might come as a surprise, but unfortunately in puppeteer there's no way to know if the file downloaded, or an API to even get it. You'll have to _know_ ahead of time where files are kept, and watch the file-system for it to complete!

browserless can save you all of that pain by using the simple `/download` API. Here's that same example:

```codeBlockLines_p187
curl -X POST \
  https://chrome.browserless.io/download?token=YOUR-API-TOKEN \
  -H 'Content-Type: application/javascript' \
  -d 'module.exports = async ({ page }) => {
    await page.evaluate(() => {
        const rows = [\
            ["name1", "city1", "some other info"],\
            ["name2", "city2", "more info"]\
        ];
        let csvContent = "data:text/csv;charset=utf-8,";
        rows.forEach(function(rowArray){
            let row = rowArray.join(",");
            csvContent += row + "\r\n";
        });
        const encodedUri = encodeURI(csvContent);
        const link = document.createElement("a");
        link.setAttribute("href", encodedUri);
        link.setAttribute("download", "data.csv");
        document.body.appendChild(link);

        return link.click();
    });
};'

```

This will process your code, create a new temporary directory, execute your script, watch for the download to complete and return it with an appropriate Content-Type (plus delete it from within the container). If there's an issue in the process, browserless will return semantic HTTP codes, and messages relaying what exactly happened to help with debugging.

This can save you numerous hassles as it takes care of all the low-level work involved in dealing with file-downloads, but if you're curious on how to accomplish this without this API read below!

## Using the `/workspace` API [â€‹](https://docs.browserless.io/baas/v1/recipes/downloading-files\#using-the-workspace-api "Direct link to using-the-workspace-api")

The /workspace API allows for users to manually upload and download files that browserless (and thus Chrome) can access. In our prior example, we didn't care about the file-system in any capacity, however that changes if you wish to continue to use puppeteer in your code-base and call it programatically.

### 1\. Mount the `WORKSPACE_DIR` someplace [â€‹](https://docs.browserless.io/baas/v1/recipes/downloading-files\#1-mount-the-workspace_dir-someplace "Direct link to 1-mount-the-workspace_dir-someplace")

By default, the internal `WORKSPACE_DIR` in browserless is set to the operating-system's temporary directory. It's best if you can mount it in an ephemeral location, but any directory with write-privileges is fine:

```codeBlockLines_p187
docker run -e "WORKSPACE_DIR=/home/browserless" -p 3000:3000 --restart always -d --name browserless browserless/chrome:latest

```

Now that is done we can instrument puppeteer to use it as the directory to download files.

### 2\. Tell puppeteer where to download files [â€‹](https://docs.browserless.io/baas/v1/recipes/downloading-files\#2-tell-puppeteer-where-to-download-files "Direct link to 2. Tell puppeteer where to download files")

Chrome defaults to downloading files in various places, depending on the operating system. In our case, we want to tell it where since it provides greater flexibility on sharing files and processing them in an expedited manner.

In order to tell puppeteer where to store files you'll have to reach into some internals so that things work appropriately:

```codeBlockLines_p187
await page._client.send('Page.setDownloadBehavior', {
  behavior: 'allow',
  // This path must match the WORKSPACE_DIR in Step 1
  downloadPath: '/home/browserless',
});

```

Unfortunately you can't use the the [CDP Session](https://pptr.dev/#?product=Puppeteer&version=v1.11.0&show=api-class-cdpsession) manager to do this as it'll only apply to _that_ newly created CDP session, hence why it's required to to talk directly with the `_client` module on the `page` object.

Once this is set you can now emit whatever action to download the file!

### 3\. Download the file in the page [â€‹](https://docs.browserless.io/baas/v1/recipes/downloading-files\#3-download-the-file-in-the-page "Direct link to 3. Download the file in the page")

By whatever means, this is the step where you'll download the file in the browser. Using our prior example we'll set this to generate a file for illustration purposes:

```codeBlockLines_p187
await page._client.send('Page.setDownloadBehavior', {
  behavior: 'allow',
  // This path must match the WORKSPACE_DIR in Step 1
  downloadPath: '/home/browserless',
});
await page.evaluate(() => {
  const rows = [\
    ['name1', 'city1', 'some other info'],\
    ['name2', 'city2', 'more info'],\
  ];
  let csvContent = 'data:text/csv;charset=utf-8,';
  rows.forEach(function (rowArray) {
    let row = rowArray.join(',');
    csvContent += row + '\r\n';
  });
  const encodedUri = encodeURI(csvContent);
  const link = document.createElement('a');
  link.setAttribute('href', encodedUri);
  link.setAttribute('download', 'data.csv');
  document.body.appendChild(link);

  return link.click();
});

```

This will trigger the file to download to the file-system _inside of browserless_.

### 4\. Download the file [â€‹](https://docs.browserless.io/baas/v1/recipes/downloading-files\#4-download-the-file "Direct link to 4. Download the file")

Unfortunately you'll have to know the file's name in order to deal with it appropriately, but since browserless ships with a `/workspace` API we can use a simple `GET` request to see what's on the disk!

**Get downloads on browserless**

```codeBlockLines_p187
# Curl browserless and see what files it has
curl -X GET \
  https://chrome.browserless.io/workspace?token=MY_API_TOKEN

```

This will return a list of files, which we can then use a subsequent `GET` call to download.

```codeBlockLines_p187
[\
  {\
    "isDirectory": false,\
    "name": "data.csv",\
    "size": 2649\
  }\
]

```

Now that we know the file is there, and the name of it, we can issue our `GET` call to download it:

```codeBlockLines_p187
curl -X GET \
  https://chrome.browserless.io/workspace/data.csv?token=MY_API_TOKEN

```

Once we have it in our possession, a simple `DELETE` call will remove it from browserless' file-system:

```codeBlockLines_p187
curl -X DELETE \
  https://chrome.browserless.io/workspace/data.csv?token=MY_API_TOKEN

```

As you can see there's a lot involved in dealing with file-downloads: managing the directory where they reside, telling puppeteer _where_ to download them, and interacting with the file-system to get/delete them once we're done. If this seems like too much of a task then we highly recommend using the `/download` API and letting browserless deal with all the low-level internals.

- [Using the /download API](https://docs.browserless.io/baas/v1/recipes/downloading-files#using-the-download-api)
- [Using the `/workspace` API](https://docs.browserless.io/baas/v1/recipes/downloading-files#using-the-workspace-api)
  - [1\. Mount the `WORKSPACE_DIR` someplace](https://docs.browserless.io/baas/v1/recipes/downloading-files#1-mount-the-workspace_dir-someplace)
  - [2\. Tell puppeteer where to download files](https://docs.browserless.io/baas/v1/recipes/downloading-files#2-tell-puppeteer-where-to-download-files)
  - [3\. Download the file in the page](https://docs.browserless.io/baas/v1/recipes/downloading-files#3-download-the-file-in-the-page)
  - [4\. Download the file](https://docs.browserless.io/baas/v1/recipes/downloading-files#4-download-the-file)

---

### Setting a user agent | Browserless.io
Original URL: https://docs.browserless.io/baas/v1/recipes/setting-a-user-agent

[Skip to main content](https://docs.browserless.io/baas/v1/recipes/setting-a-user-agent#__docusaurus_skipToContent_fallback)



DEPRECATION WARNING

This documentation is for BaaS v1, which is no longer actively supported. If you are a new user, please refer to the updated documentation for [BaaS v2](https://docs.browserless.io/baas/avoid-bot-detection/user-agent) or [BrowserQL](https://docs.browserless.io/browserql/start).

TheÂ User-AgentÂ request headerÂ is a characteristic string that lets servers and network peers identify the application, operating system, vendor, and/or version of the requesting user agent.

Many sites use this information to render the site differently for each user, and sometimes even for rudimentary bot detection. If you run chrome headless and want to take a screenshot of a page, it's a good idea to set a user agent so that web fonts load properly.

## Code [â€‹](https://docs.browserless.io/baas/v1/recipes/setting-a-user-agent\#code "Direct link to Code")

You can set the user agent from code, in puppeteer it would be like this:

```codeBlockLines_p187
await page.setUserAgent(
  'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/84.0.4147.125 Safari/537.36'
);

```

## REST API [â€‹](https://docs.browserless.io/baas/v1/recipes/setting-a-user-agent\#rest-api "Direct link to REST API")

If you're using our APIs like /screenshot, /content, /pdf, or /scrape, you can also set the user agent in the body of your request.

```codeBlockLines_p187
{
  "userAgent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/84.0.4147.125 Safari/537.36"
}

```

## Hosted service [â€‹](https://docs.browserless.io/baas/v1/recipes/setting-a-user-agent\#hosted-service "Direct link to Hosted service")

If you're on a usage-based, cloud unit-based or capacity-based account, you can change the user agent as so

```codeBlockLines_p187
const browser = await puppeteer.connect({
  browserWSEndpoint:
    'wss://chrome.browserless.io?token=YOUR_API_KEY&--user-agent=Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/100.0.4896.127 Safari/537.36',
});

```

## Self-hosting [â€‹](https://docs.browserless.io/baas/v1/recipes/setting-a-user-agent\#self-hosting "Direct link to Self-hosting")

If you're self hosting, you can set the user agent as a default launch argument.

```codeBlockLines_p187
    docker run -e "DEFAULT_LAUNCH_ARGS=[\"--user-agent=Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/100.0.4896.127 Safari/537.36\"]" -p 3000:3000 --restart always -d --name browserless browserless/chrome

```

- [Code](https://docs.browserless.io/baas/v1/recipes/setting-a-user-agent#code)
- [REST API](https://docs.browserless.io/baas/v1/recipes/setting-a-user-agent#rest-api)
- [Hosted service](https://docs.browserless.io/baas/v1/recipes/setting-a-user-agent#hosted-service)
- [Self-hosting](https://docs.browserless.io/baas/v1/recipes/setting-a-user-agent#self-hosting)

---

### Using a proxy in Puppeteer | Browserless.io
Original URL: https://docs.browserless.io/baas/v1/recipes/using-a-proxy

[Skip to main content](https://docs.browserless.io/baas/v1/recipes/using-a-proxy#__docusaurus_skipToContent_fallback)



DEPRECATION WARNING

This documentation is for BaaS v1, which is no longer actively supported. If you are a new user, please refer to the updated documentation for [BaaS v2](https://docs.browserless.io/baas/proxies) or [BrowserQL](https://docs.browserless.io/browserql/start).

success

We now have our own built-in residential proxy! [See this document here for how to use it.](https://docs.browserless.io/baas/proxies)

Both browserless, and Chrome itself, support the usage of external proxies. Paid cloud-unit plans have access to a built-in proxy which requires no additional work on your part. [See more about that here.](https://docs.browserless.io/baas/proxies).

If you want to use an external, or 3rd party proxy, please continue to read below. In general there's two things you'll have to do:

- Specify the address of where the proxy is with the `--proxy-server` switch.
- Optionally, you'll also need to send in your username and password if the proxy is authenticated.

## Specifying the proxy [â€‹](https://docs.browserless.io/baas/v1/recipes/using-a-proxy\#specifying-the-proxy "Direct link to Specifying the proxy")

Regardless of whether or not you're using our REST API's or the puppeteer integration, you'll need to specify _where_ the proxy is. Chrome has a command-line flag to do this, and we support this in browserless via the following query-string parameter:

```codeBlockLines_p187
?--proxy-server=https://YOUR-PROXY-SERVER-DOMAIN:PORT

```

You can set this parameter in our [live debugger](https://chrome.browserless.io/) by clicking on the gear icon on the left panel and modifying the Browser URL field.

If you're using a proxy that doesn't require a password (maybe just an IP address filter), then that's it! You're free to now use this proxy going forward! Otherwise read on.

## Using username and password [â€‹](https://docs.browserless.io/baas/v1/recipes/using-a-proxy\#using-username-and-password "Direct link to Using username and password")

### Method 1: page.authenticate [â€‹](https://docs.browserless.io/baas/v1/recipes/using-a-proxy\#method-1-pageauthenticate "Direct link to Method 1: page.authenticate")

Most proxies will require some means of authentication. There's generally two ways you can do this in Puppeteer, and also in browserless. The first more common method is the `page.authenticate`:

```codeBlockLines_p187
await page.authenticate({
  username: 'joel',
  password: 'browserless-rocks',
});

```

Doing this will apply these parameters to your network requests going forward.

In our REST API's you can specify these fields with the following in your POST JSON body. These parameters work for the `pdf`, `content` and `screenshot` APIs:

```codeBlockLines_p187
{
  "authenticate": {
    "username": "joel",
    "password": "browserless-rocks"
  }
}

```

### Method 2: page.setExtraHTTPHeaders [â€‹](https://docs.browserless.io/baas/v1/recipes/using-a-proxy\#method-2-pagesetextrahttpheaders "Direct link to Method 2: page.setExtraHTTPHeaders")

The other mechanism is to use HTTP headers to send in extra authorization information. Puppeteer makes this pretty easy by allowing us to send in new HTTP headers via `page.setExtraHTTPHeaders`:

> NOTE: This is deprecated in most libraries now, so it's worth keeping in mind that using authentication methods in each library is now the standard.

```codeBlockLines_p187
// Remember to base64 encode your username:password!
await page.setExtraHTTPHeaders({
  'Proxy-Authorization': 'Basic username:password',
  // OR
  Authorization: 'Basic username:password',
});

```

Refer to your libraries documentation on what the name of the headers is, and how to properly encode it.

We also allow this in our REST APIs as well, via the `setExtraHTTPHeaders` property:

```codeBlockLines_p187
{
  "setExtraHTTPHeaders": {
    "Proxy-Authorization": "Basic username:password",
    // OR
    "Authorization": "Basic username:password"
  }
}

```

This will allow your REST APIs to utilize the prior provided proxy!

- [Specifying the proxy](https://docs.browserless.io/baas/v1/recipes/using-a-proxy#specifying-the-proxy)
- [Using username and password](https://docs.browserless.io/baas/v1/recipes/using-a-proxy#using-username-and-password)
  - [Method 1: page.authenticate](https://docs.browserless.io/baas/v1/recipes/using-a-proxy#method-1-pageauthenticate)
  - [Method 2: page.setExtraHTTPHeaders](https://docs.browserless.io/baas/v1/recipes/using-a-proxy#method-2-pagesetextrahttpheaders)

---

### Watching your sessions | Browserless.io
Original URL: https://docs.browserless.io/baas/v1/recipes/watch-sessions

[Skip to main content](https://docs.browserless.io/baas/v1/recipes/watch-sessions#__docusaurus_skipToContent_fallback)



DEPRECATION WARNING

This documentation is for BaaS v1, which is no longer actively supported. If you are a new user, please refer to the updated documentation for [BaaS v2](https://docs.browserless.io/enterprise/watching-sessions) or [BrowserQL](https://docs.browserless.io/browserql/start).

Both the browserless docker image, and Dedicated hosted plans, have the ability to watch sessions as they run. As with most of our APIs and features, they're strongly geared towards engineers building on top of browserless. It's with these engineers in mind that we've written this document on how to watch your sessions as you work, broken up into three different methods.

1. [Watching sessions on the docker image](https://docs.browserless.io/baas/v1/recipes/watch-sessions#watching-sessions-on-the-docker-image)
2. [Using the Sessions tab in the Dedicated plans](https://docs.browserless.io/baas/v1/recipes/watch-sessions#using-the-sessions-tab-in-the-dedicated-plans)
3. Programmatically watching your sessions on Dedicated plans

## Watching sessions on the docker image [â€‹](https://docs.browserless.io/baas/v1/recipes/watch-sessions\#watching-sessions-on-the-docker-image "Direct link to Watching sessions on the docker image")

To use the session viewer on the docker image, you don't need to do anything special in your code or how you connect to browserless. The only change you might make is add a `trackingId` to your connect call in order to sort or filter sessions to the one you care about.

In any case, the first step is to start the container as usual:

```codeBlockLines_p187
$ docker run --name browserless --rm -p 3000:3000 browserless/chrome:latest

```

Then, in your application or script connect to it.

```codeBlockLines_p187
const puppeteer = require('puppeteer');

(async () => {
  let browser = null;

  try {
    // If your script executes too quickly, you can add a ?pause query parameter
    // to the connect call to pause the script from running until you're watching it
    browser = await puppeteer.connect({
      browserWSEndpoint: `ws://localhost:3000`,
    });
    const page = await browser.newPage();
    await page.goto('https://example.com/');
  } catch (error) {
    console.log(error);
  } finally {
    browser && browser.close();
  }
})();

```

In your browser, you can visit [http://localhost:3000](http://localhost:3000/), click on the Settings icon in the top left, and click the link for the session:

If your session is immediately closing, then you can keep it open by _not_ calling browser.close at the end (just remember to terminate your script with CTRL+C or similar).

## Using the Sessions tab in the Dedicated plans [â€‹](https://docs.browserless.io/baas/v1/recipes/watch-sessions\#using-the-sessions-tab-in-the-dedicated-plans "Direct link to Using the Sessions tab in the Dedicated plans")

In Dedicated plans, you can see your active sessions at any time by going to the Sessions portion of the account page.

Pressing the "Fetch Running Sessions" button will retrieve actively running sessions across all your workers, and show them here. The "Debugger" Link will then open up the page that you can run and view these sessions.

Anytime you connect, you can immediately see the results here after pushing the "Fetch Running Sessions" button.

## Programmatically watching your sessions on Dedicated plans [â€‹](https://docs.browserless.io/baas/v1/recipes/watch-sessions\#programmatically-watching-your-sessions-on-dedicated-plans "Direct link to Programmatically watching your sessions on Dedicated plans")

Thanks to our powerful GraphQL API, you can programmatically retrieve your running sessions with a simple GraphQL API call. This simple feature allows you to build powerful integrations against browserless: end-users are able to witness their automation running, engineers can debug live production issues, and you can more easily pinpoint problems in your scripts.

When setting this up, you'll want to ensure that you don't accidentally expose your sessions to other users. It's for this reason that we've create a `trackingId`, which allows you to filter and more easily distinguish between running sessions.

For those that want to see the full example, see below. We'll break it down step-by-step afterwards.

**TL;DR the goods**

```codeBlockLines_p187
const puppeteer = require('puppeteer');
const fetch = require('node-fetch');
const apiToken = 'YOUR-API-TOKEN';
const trackingId = 'some-unique-id';

const getSessionsById = (trackingId) => {
  return fetch('https://api.browserless.io/graphql', {
    method: 'POST',
    headers: {
      'content-type': 'application/json',
    },
    body: JSON.stringify({
      query: `
        query getSessions($trackingId: String!, $apiToken: String!) {
          sessions(apiToken: $apiToken, trackingId: $trackingId) {
            description
            devtoolsFrontendUrl
            id
            title
            url
            trackingId
            browserId
            browserWSEndpoint
          }
        }
      `,
      variables: {
        trackingId,
        apiToken,
      },
    }),
  })
    .then((res) => res.json())
    .then((res) => res.data.sessions)
    .catch((error) => {
      console.log(`Error retrieving sessions ${error.message}`);
      return null;
    });
};

const run = async () => {
  const sleep = (ms) => new Promise((res) => setTimeout(res, ms));

  let browser = null;

  try {
    browser = await puppeteer.connect({
      browserWSEndpoint: `wss://chrome.browserless.io?token=${apiToken}&trackingId=${trackingId}`,
    });

    const page = await browser.newPage();
    await page.goto('https://example.com');

    const [session] = await getSessionsById(trackingId);

    if (!session) {
      throw new Error(`Error retrieving session!`);
    }

    console.log(`Open: ${session.devtoolsFrontendUrl} in your browser!`);

    // Let the page stay open for 30 seconds so we can debug!
    await sleep(30000);
  } catch (error) {
    console.error(`Saw error when running: ${error.message}`);
  } finally {
    if (browser) {
      console.log(`Shutting down the browser.`);
      browser.close();
    }
  }
};

run();

```

### Selecting the modules to use [â€‹](https://docs.browserless.io/baas/v1/recipes/watch-sessions\#selecting-the-modules-to-use "Direct link to Selecting the modules to use")

For this automated example, we're using the `puppeteer` module as well as the `node-fetch` package. Puppeteer is used for running the browser, and `node-fetch` for doing the API calls to browserless to get sessions.

You're free to use whatever modules you like, including Selenium or even axios, however we've found that puppeteer and node-fetch are the most common across the web.

Once done, let's setup the function to get sessions from the GraphQL endpoint!

### Fetching sessions [â€‹](https://docs.browserless.io/baas/v1/recipes/watch-sessions\#fetching-sessions "Direct link to Fetching sessions")

Our function below takes a single argument: the trackingId we intend to use for the session. In a production system, you should _always_ make this ID unique as it'll prevent you from accidentally watching the wrong session. If you need a recommendation, we suggest something like a UUID or a GUID library.

```codeBlockLines_p187
const getSessionsById = (trackingId) => {
  return fetch('https://api.browserless.io/graphql', {
    method: 'POST',
    headers: {
      'content-type': 'application/json',
    },
    body: JSON.stringify({
      query: `
        query getSessions($trackingId: String!, $apiToken: String!) {
          sessions(apiToken: $apiToken, trackingId: $trackingId) {
            description
            devtoolsFrontendUrl
            id
            title
            url
            trackingId
            browserId
            browserWSEndpoint
          }
        }
      `,
      variables: {
        trackingId,
        apiToken,
      },
    });
  })
  .then((res) => res.json())
  .then((res) => res.data.sessions)
  .catch((error) => {
    console.log(`Error retrieving sessions ${error.message}`);
    return null;
  });
};

```

The below query is the underlying GraphQL request, that says we want to retrieve the following properties for our session. In our example we only make use of the `devtoolsFrontendUrl`, so you're free to remove the others if you wish, they're there for educational purposes.

```codeBlockLines_p187
query getSessions($trackingId: String!, $apiToken: String!) {
  sessions(apiToken: $apiToken, trackingId: $trackingId) {
    description
    devtoolsFrontendUrl
    id
    title
    url
    trackingId
    browserId
    browserWSEndpoint
  }
}

```

In GraphQL terms, we're setting up a "function" here that retrieves sessions with your API Token and trackingId. The response will contain something like:

```codeBlockLines_p187
{
  "data": {
    "sessions": [\
      {\
        "description": "",\
        "devtoolsFrontendUrl": "https://chrome.browserless.io/p/53616c7465645...",\
        "id": "CE39322DD6F46305A46FF92A0B41E4F2",\
        "title": "Example Site",\
        "url": "https://example.com",\
        "trackingId": "some-unique-id",\
        "browserId": "a69f18cf-23d9-4b5e-82c0-b817f2fd4e82",\
        "browserWSEndpoint": "wss://chrome.browserless.io/p/53616c7465645f5f325..."\
      }\
    ]
  }
}

```

> In all of our returned links we _omit_ your API token, so you'll need to add it to the link manually to visit it. This is done for security purposes.

**Hooking up puppeteer**

In our puppeteer setup, the `run` function, we start the browser and begin to write our script. Once we know the page is open, we use our GraphQL fetching function to get the active sessions (filtered by trackingId), and log the response.

In reality you can do whatever you'd like with this response: save it in a database or load it in a user's page. However, once the session is done the link will no longer respond properly, and the session will return a `404`.

Here's that code again:

```codeBlockLines_p187
const run = async () => {
  const sleep = (ms) => new Promise((res) => setTimeout(res, ms));

  let browser = null;

  try {
    browser = await puppeteer.connect({
      browserWSEndpoint: `wss://chrome.browserless.io?token=${apiToken}&trackingId=${trackingId}`,
    });

    const page = await browser.newPage();
    await page.goto('https://example.com');

    const [session] = await getSessionsById(trackingId);

    if (!session) {
      throw new Error(`Error retrieving session!`);
    }

    console.log(
      `Open: ${session.devtoolsFrontendUrl} in your browser (be sure to add your &token to it!)`
    );

    // Let the page stay open for 30 seconds so we can debug!
    await sleep(30000);
  } catch (error) {
    console.error(`Saw error when running: ${error.message}`);
  } finally {
    if (browser) {
      console.log(`Shutting down the browser.`);
      browser.close();
    }
  }
};

```

You'll note that we have a `page.waitFor` call in here as well: this is to ensure you have time to visit the debugging page. In a production system, the page interactions can happen quickly, and so it's easy to go to a debug page and miss all of the interactivity. If it's crucial that you witness the script as it runs we recommend pausing the script on startup with the `&pause` query-string parameter in your `puppeteer.connect` call.

That's it! You've successfully setup a running puppeteer session, and have a way to view the session as needed! If you've found this helpful, or need help with an issue, please [let us know](https://www.browserless.io/contact)

- [Watching sessions on the docker image](https://docs.browserless.io/baas/v1/recipes/watch-sessions#watching-sessions-on-the-docker-image)
- [Using the Sessions tab in the Dedicated plans](https://docs.browserless.io/baas/v1/recipes/watch-sessions#using-the-sessions-tab-in-the-dedicated-plans)
- [Programmatically watching your sessions on Dedicated plans](https://docs.browserless.io/baas/v1/recipes/watch-sessions#programmatically-watching-your-sessions-on-dedicated-plans)
  - [Selecting the modules to use](https://docs.browserless.io/baas/v1/recipes/watch-sessions#selecting-the-modules-to-use)
  - [Fetching sessions](https://docs.browserless.io/baas/v1/recipes/watch-sessions#fetching-sessions)

---

### Quick Start | Browserless.io
Original URL: https://docs.browserless.io/baas/v1/start

[Skip to main content](https://docs.browserless.io/baas/v1/start#__docusaurus_skipToContent_fallback)



DEPRECATION WARNING

This documentation is for BaaS v1, which is no longer actively supported. If you are a new user, please refer to the updated documentation for [BaaS v2](https://docs.browserless.io/baas/start) or [BrowserQL](https://docs.browserless.io/browserql/start).

Welcome to the quick-start! Below are the top three integration we support, with quick directions on getting up and running with popular methods. See the sidebar for all the other supported API's and REST methods!

**Choose your library**

- [Using Puppeteer](https://docs.browserless.io/baas/v1/start#using-puppeteer)
- [Using Playwright](https://docs.browserless.io/baas/v1/libraries/playwright)
- [Using Selenium or WebDriver](https://docs.browserless.io/baas/v1/start#using-selenium-or-webdriver)

## Using Puppeteer [â€‹](https://docs.browserless.io/baas/v1/start\#using-puppeteer "Direct link to Using Puppeteer")

Whether you're looking to get started, or already have an established codebase, browserless aims to make the transition as easy as possible. At a high-level, you'll need to do the following:

1. [Install puppeteer](https://docs.browserless.io/baas/v1/start#1-install-puppeteer)
2. [Setup your app](https://docs.browserless.io/baas/v1/start#2-setup-your-app)
3. [Update your app to use browserless](https://docs.browserless.io/baas/v1/start#3-update-your-app-to-use-browserless)

### 1\. Install puppeteer [â€‹](https://docs.browserless.io/baas/v1/start\#1-install-puppeteer "Direct link to 1. Install puppeteer")

If you haven't chosen a library yet we highly recommend [puppeteer](https://github.com/puppeteer/puppeteer/) as it's fairly active and has many maintainers. It's also built by the developers of Chrome, so it's one of the highest quality libraries around.

**Installing puppeteer**

```codeBlockLines_p187
$ npm i --save puppeteer
# or
> yarn add puppeteer

```

In development you'll likely want to install puppeteer's bundled version of Chromium, however you won't need this in production as Chrome is all taken care of for you by browserless. To disable the downloading of puppeteer, simply add an environment variable when installing:

**Install for production**

```codeBlockLines_p187
# Linux
$ PUPPETEER_SKIP_CHROMIUM_DOWNLOAD=true
# Windows
set PUPPETEER_SKIP_CHROMIUM_DOWNLOAD=true

$ npm install --production
# or yarn install --production

```

You can read more about puppeteer's environment variables [here](https://pptr.dev/#environment-variables).

### 2\. Setup your app [â€‹](https://docs.browserless.io/baas/v1/start\#2-setup-your-app "Direct link to 2. Setup your app")

As an example let's write a screenshot service that takes a picture of the website and downloads it. We'll setup a route on the `/image` path and take a picture of a static webpage (though you can make this configurable if you wish):

**Screenshot service**

```codeBlockLines_p187
const express = require('express');
const puppeteer = require('puppeteer');

const app = express();

app.get('/image', async (req, res) => {
  // puppeteer.launch() => Chrome running locally (on the same hardware)
  let browser = null;

  try {
    browser = await puppeteer.launch();
    const page = await browser.newPage();

    await page.goto('http://www.example.com/');
    const screenshot = await page.screenshot();

    res.end(screenshot, 'binary');
  } catch (error) {
    if (!res.headersSent) {
      res.status(400).send(error.message);
    }
  } finally {
    if (browser) {
      browser.close();
    }
  }
});

app.listen(8080, () => console.log('Listening on PORT: 8080'));

```

With that in place, let's re-work some of our functionality to use browserless in production.

### 3\. Update your app to use browserless [â€‹](https://docs.browserless.io/baas/v1/start\#3-update-your-app-to-use-browserless "Direct link to 3. Update your app to use browserless")

Once we have browserless account setup, or have it running via docker, we can simply "connect" to it in our application instead of launching Chrome.

warning

It's very important to close the browser for unit-based, otherwise you'll spend seconds on the browser running. The best practice is to implement try/catch blocks and set a custom timeout to last less than the 15 minute global timeout set by default, per your requirements.

**Screenshot service with browserless**

```codeBlockLines_p187
const express = require('express');
const puppeteer = require('puppeteer');
const IS_PRODUCTION = process.env.NODE_ENV === 'production';

const app = express();

const getBrowser = () =>
  IS_PRODUCTION
    ? // Connect to browserless so we don't run Chrome on the same hardware in production
      puppeteer.connect({ browserWSEndpoint: 'wss://chrome.browserless.io?token=YOUR-API-TOKEN' })
    : // Run the browser locally while in development
      puppeteer.launch();

app.get('/image', async (req, res) => {
  let browser = null;

  try {
    browser = await getBrowser();
    const page = await browser.newPage();

    await page.goto('http://www.example.com/');
    const screenshot = await page.screenshot();

    res.end(screenshot, 'binary');
  } catch (error) {
    if (!res.headersSent) {
      res.status(400).send(error.message);
    }
  } finally {
    if (browser) {
      browser.close();
    }
  }
});

app.listen(8080, () => console.log('Listening on PORT: 8080'));

```

That's it! Now you don't have to worry about bundling Chrome or it's dependencies in production and can continue to develop your application.

Below is a sample cURL call that will use your new service to ensure it's all working:

```codeBlockLines_p187
$ curl -X GET -o temp.png http://localhost:8080/image

```

## Using Selenium or WebDriver [â€‹](https://docs.browserless.io/baas/v1/start\#using-selenium-or-webdriver "Direct link to Using Selenium or WebDriver")

Browserless exposes the WebDriver protocol at [https://chrome.browserless.io/webdriver](https://chrome.browserless.io/webdriver). Updating your tests, continuous-integration tests, or application to use it is as simple as specifying a remote connection.

1. [Setup WebDriver.](https://docs.browserless.io/baas/v1/start#setup-webdriver)
2. [Update the builder to use browserless.](https://docs.browserless.io/baas/v1/start#update-the-builder-to-use-browserless)

### Setup WebDriver [â€‹](https://docs.browserless.io/baas/v1/start\#setup-webdriver "Direct link to Setup WebDriver")

For the purposes of this example we'll be using the Ruby bindings, but almost every language has an accompanying library for WebDriver. Be sure to consult your runtime's library for more direct instructions.

```codeBlockLines_p187
# You must specify --headless and --no-sandbox
options = Selenium::WebDriver::Chrome::Options.new
options.add_argument('--headless')
options.add_argument('--no-sandbox')

# Use the webdriver for going to sites, taking pictures, anything else. Make sure you close the browser when done.
driver = Selenium::WebDriver.for :chrome, options: options

```

Once that's setup, be sure to verify your script works locally before proceeding to rule out any unwanted behavior.

### Update the builder to use browserless [â€‹](https://docs.browserless.io/baas/v1/start\#update-the-builder-to-use-browserless "Direct link to Update the builder to use browserless")

Once you have script working locally, the next step is to specify browserless as the remote server. This will give you the ability to run multiple browsers in parallel, greatly reducing the amount of time your tests take.

```codeBlockLines_p187
# You must specify --headless and --no-sandbox
caps = Selenium::WebDriver::Remote::Capabilities.chrome("goog:chromeOptions" => {
  "args" => [\
    "--disable-background-timer-throttling",\
    "--disable-backgrounding-occluded-windows",\
    "--disable-breakpad",\
    "--disable-component-extensions-with-background-pages",\
    "--disable-dev-shm-usage",\
    "--disable-extensions",\
    "--disable-features=TranslateUI,BlinkGenPropertyTrees",\
    "--disable-ipc-flooding-protection",\
    "--disable-renderer-backgrounding",\
    "--enable-features=NetworkService,NetworkServiceInProcess",\
    "--force-color-profile=srgb",\
    "--hide-scrollbars",\
    "--metrics-recording-only",\
    "--mute-audio",\
    "--headless",\
    "--no-sandbox"\
  ]
})
caps['browserless:token'] = 'YOUR-API-TOKEN'
driver = Selenium::WebDriver.for :remote, url: "https://chrome.browserless.io/webdriver", desired_capabilities: caps

# Use the webdriver for going to sites, taking pictures. Make sure you close the browser when done.
driver = Selenium::WebDriver.for :chrome, options: options

```

That's it! Once you've verified it's all working properly, the next step is to conditionally use browserless only when running in a continuous integration environment.

### What's next? [â€‹](https://docs.browserless.io/baas/v1/start\#whats-next "Direct link to What's next?")

There's a lot more that you can configure and tune in browserless to handle the needs of your application. Be sure to read about all the options it exposes and how to get the most out of browserless.

- [Using Puppeteer](https://docs.browserless.io/baas/v1/start#using-puppeteer)
  - [1\. Install puppeteer](https://docs.browserless.io/baas/v1/start#1-install-puppeteer)
  - [2\. Setup your app](https://docs.browserless.io/baas/v1/start#2-setup-your-app)
  - [3\. Update your app to use browserless](https://docs.browserless.io/baas/v1/start#3-update-your-app-to-use-browserless)
- [Using Selenium or WebDriver](https://docs.browserless.io/baas/v1/start#using-selenium-or-webdriver)
  - [Setup WebDriver](https://docs.browserless.io/baas/v1/start#setup-webdriver)
  - [Update the builder to use browserless](https://docs.browserless.io/baas/v1/start#update-the-builder-to-use-browserless)
  - [What's next?](https://docs.browserless.io/baas/v1/start#whats-next)

---

### Browserless.io
Original URL: https://docs.browserless.io/baas/v2/06-Private-Deployment/versions

[Skip to main content](https://docs.browserless.io/baas/v2/06-Private-Deployment/versions#__docusaurus_skipToContent_fallback)

# Page Not Found

We could not find what you were looking for.

Please contact the owner of the site that linked you to the original URL and let them know their link is broken.

---

### Versions on the shared fleet | Browserless.io
Original URL: https://docs.browserless.io/baas/versions

[Skip to main content](https://docs.browserless.io/baas/versions#__docusaurus_skipToContent_fallback)



Our workers that service plans such as the Starter and Scale plans are updated every so often, here are the versions that the hosted version currently has for certain libraries, global timeout and CLI flags supported.

## Current versions used in usage based workers [â€‹](https://docs.browserless.io/baas/versions\#current-versions-used-in-usage-based-workers "Direct link to Current versions used in usage based workers")

Last update: February 24, 2025.

1. **Puppeteer**: `24.2.1`
2. **Playwright**: `1.50.1`, `1.49.1`, `1.48.2`, `1.47.2`, `1.46.1`, `1.45.3`, `1.44.1`, `1.43.1`, `1.42.1`, `1.41.2`
3. **Chromium**: `133.0.6943.16`
4. **Chrome**: `133.0.6943.127`
5. **Firefox**: `134.0`
6. **Webkit**: `18.2`

info

If your code is mysteriously crashing, try using the exact version mentioned above, as some older but especially more recent versions than the above may cause conflicts.

## Global timeout [â€‹](https://docs.browserless.io/baas/versions\#global-timeout "Direct link to Global timeout")

By default, the global timeout is set to 15 minutes for usage-based and cloud unit-based API Keys, if you need your sessions to run longer than that, you'll want to consider upgrading to a dedicated account in order to modify this setting.

## CLI flags supported [â€‹](https://docs.browserless.io/baas/versions\#cli-flags-supported "Direct link to CLI flags supported")

```codeBlockLines_p187
--proxy-server,
--window-size,
--disable-web-security,
--enable-features,
--disable-web-security,
--disable-setuid-sandbox,
--lang,
--font-render-hinting,
--force-color-profile,
stealth,
ignoreDefaultArgs,
headless,
token,
blockAds,
ignoreHTTPSErrors,
slowMo,

```

## Playwright's versioning [â€‹](https://docs.browserless.io/baas/versions\#playwrights-versioning "Direct link to Playwright's versioning")

It is important to note that Playwright's [`connect` method](https://playwright.dev/docs/api/class-browsertype#browser-type-connect) is tightly version-coupled. Your client version must be either one of the ones listed above.

Playwright's `connectOverCDP` doesn't always need to match the same playwright version on our usage based workers. This method is generally backwards/forwards compatible since it communicates directly through CDP, with the caveat to be slightly slower due to having more communication over the devtools protocol.

- [Current versions used in usage based workers](https://docs.browserless.io/baas/versions#current-versions-used-in-usage-based-workers)
- [Global timeout](https://docs.browserless.io/baas/versions#global-timeout)
- [CLI flags supported](https://docs.browserless.io/baas/versions#cli-flags-supported)
- [Playwright's versioning](https://docs.browserless.io/baas/versions#playwrights-versioning)

---

### include | Browserless.io
Original URL: https://docs.browserless.io/bql-schema/operations/directives/include

[Skip to main content](https://docs.browserless.io/bql-schema/operations/directives/include#__docusaurus_skipToContent_fallback)


Directs the executor to include this field or fragment only when the `if` argument is true.

```codeBlockLines_p187
directive @include(
  if: Boolean!
) on
  | FIELD
  | FRAGMENT_SPREAD
  | INLINE_FRAGMENT

```

### Arguments [â€‹](https://docs.browserless.io/bql-schema/operations/directives/include\#arguments "Direct link to Arguments")

#### [`include.if`](https://docs.browserless.io/bql-schema/operations/directives/include\#)Â â—Â [`Boolean!`](https://docs.browserless.io/bql-schema/types/scalars/boolean) non-nullscalar [â€‹](https://docs.browserless.io/bql-schema/operations/directives/include\#includeifboolean-- "Direct link to includeifboolean--")

Included when true.

- [Arguments](https://docs.browserless.io/bql-schema/operations/directives/include#arguments)

---

### skip | Browserless.io
Original URL: https://docs.browserless.io/bql-schema/operations/directives/skip

[Skip to main content](https://docs.browserless.io/bql-schema/operations/directives/skip#__docusaurus_skipToContent_fallback)


Directs the executor to skip this field or fragment when the `if` argument is true.

```codeBlockLines_p187
directive @skip(
  if: Boolean!
) on
  | FIELD
  | FRAGMENT_SPREAD
  | INLINE_FRAGMENT

```

### Arguments [â€‹](https://docs.browserless.io/bql-schema/operations/directives/skip\#arguments "Direct link to Arguments")

#### [`skip.if`](https://docs.browserless.io/bql-schema/operations/directives/skip\#)Â â—Â [`Boolean!`](https://docs.browserless.io/bql-schema/types/scalars/boolean) non-nullscalar [â€‹](https://docs.browserless.io/bql-schema/operations/directives/skip\#skipifboolean-- "Direct link to skipifboolean--")

Skipped when true.

- [Arguments](https://docs.browserless.io/bql-schema/operations/directives/skip#arguments)

---

### Browserless.io
Original URL: https://docs.browserless.io/bql-schema/operations/mutations

[Skip to main content](https://docs.browserless.io/bql-schema/operations/mutations#__docusaurus_skipToContent_fallback)

# Page Not Found

We could not find what you were looking for.

Please contact the owner of the site that linked you to the original URL and let them know their link is broken.

---

### back | Browserless.io
Original URL: https://docs.browserless.io/bql-schema/operations/mutations/back

[Skip to main content](https://docs.browserless.io/bql-schema/operations/mutations/back#__docusaurus_skipToContent_fallback)


Goes back in browser history, optionally accepting waitUntil and timeout arguments. Returns null if no back is possible

Example:

```codeBlockLines_p187
mutation GoBack {
  firstNav: goto(url: "https://example.com") {
    time
  }

  secondNav: goto(url: "https://browserless.com") {
    time
  }

  back(waitUntil: domContentLoaded) {
    status
  }
}

```

```codeBlockLines_p187
back(
  timeout: Float
  waitUntil: WaitUntilHistory = load
): HTTPResponse

```

### Arguments [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/back\#arguments "Direct link to Arguments")

#### [`back.timeout`](https://docs.browserless.io/bql-schema/operations/mutations/back\#)Â â—Â [`Float`](https://docs.browserless.io/bql-schema/types/scalars/float) scalar [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/back\#backtimeoutfloat- "Direct link to backtimeoutfloat-")

The maximum amount of time, in milliseconds, to wait for the page to load, overriding any defaults. Default timeout is 30 seconds, or 30000.

#### [`back.waitUntil`](https://docs.browserless.io/bql-schema/operations/mutations/back\#)Â â—Â [`WaitUntilHistory`](https://docs.browserless.io/bql-schema/types/enums/wait-until-history) enum [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/back\#backwaituntilwaituntilhistory- "Direct link to backwaituntilwaituntilhistory-")

When to consider the page fully-loaded and proceed with further execution

### Type [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/back\#type "Direct link to Type")

#### [`HTTPResponse`](https://docs.browserless.io/bql-schema/types/objects/httpresponse) object [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/back\#httpresponse- "Direct link to httpresponse-")

Response returned after a navigation event

- [Arguments](https://docs.browserless.io/bql-schema/operations/mutations/back#arguments)
- [Type](https://docs.browserless.io/bql-schema/operations/mutations/back#type)

---

### checkbox | Browserless.io
Original URL: https://docs.browserless.io/bql-schema/operations/mutations/checkbox

[Skip to main content](https://docs.browserless.io/bql-schema/operations/mutations/checkbox#__docusaurus_skipToContent_fallback)


Sets or un-sets the value of a checkbox on the page

Example:

```codeBlockLines_p187
mutation ClickCheckbox {
  goto(url: "https://example.com") {
    status
  }

  checkbox(
    checked: true
    selector: "input[type='checkbox']"
  ) {
    time
  }
}

```

```codeBlockLines_p187
checkbox(
  checked: Boolean!
  selector: String!
  scroll: Boolean = true
  timeout: Float
  visible: Boolean = false
  wait: Boolean = true
): ClickResponse

```

### Arguments [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/checkbox\#arguments "Direct link to Arguments")

#### [`checkbox.checked`](https://docs.browserless.io/bql-schema/operations/mutations/checkbox\#)Â â—Â [`Boolean!`](https://docs.browserless.io/bql-schema/types/scalars/boolean) non-nullscalar [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/checkbox\#checkboxcheckedboolean-- "Direct link to checkboxcheckedboolean--")

Whether or not the input should be checked

#### [`checkbox.selector`](https://docs.browserless.io/bql-schema/operations/mutations/checkbox\#)Â â—Â [`String!`](https://docs.browserless.io/bql-schema/types/scalars/string) non-nullscalar [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/checkbox\#checkboxselectorstring-- "Direct link to checkboxselectorstring--")

The CSS selector of the element on the page you want to check/uncheck

#### [`checkbox.scroll`](https://docs.browserless.io/bql-schema/operations/mutations/checkbox\#)Â â—Â [`Boolean`](https://docs.browserless.io/bql-schema/types/scalars/boolean) scalar [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/checkbox\#checkboxscrollboolean- "Direct link to checkboxscrollboolean-")

Whether or not to scroll to the element prior to clicking, defaults to true

#### [`checkbox.timeout`](https://docs.browserless.io/bql-schema/operations/mutations/checkbox\#)Â â—Â [`Float`](https://docs.browserless.io/bql-schema/types/scalars/float) scalar [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/checkbox\#checkboxtimeoutfloat- "Direct link to checkboxtimeoutfloat-")

How long to wait for the element to appear before timing out on the handler, overriding any defaults. Default timeout is 30 seconds, or 30000.

#### [`checkbox.visible`](https://docs.browserless.io/bql-schema/operations/mutations/checkbox\#)Â â—Â [`Boolean`](https://docs.browserless.io/bql-schema/types/scalars/boolean) scalar [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/checkbox\#checkboxvisibleboolean- "Direct link to checkboxvisibleboolean-")

Whether or not to check/uncheck the element only if it's visible

#### [`checkbox.wait`](https://docs.browserless.io/bql-schema/operations/mutations/checkbox\#)Â â—Â [`Boolean`](https://docs.browserless.io/bql-schema/types/scalars/boolean) scalar [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/checkbox\#checkboxwaitboolean- "Direct link to checkboxwaitboolean-")

Whether or not to wait for the element to present in the DOM

### Type [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/checkbox\#type "Direct link to Type")

#### [`ClickResponse`](https://docs.browserless.io/bql-schema/types/objects/click-response) object [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/checkbox\#clickresponse- "Direct link to clickresponse-")

Response returned after having clicked on an element

- [Arguments](https://docs.browserless.io/bql-schema/operations/mutations/checkbox#arguments)
- [Type](https://docs.browserless.io/bql-schema/operations/mutations/checkbox#type)

---

### click | Browserless.io
Original URL: https://docs.browserless.io/bql-schema/operations/mutations/click

[Skip to main content](https://docs.browserless.io/bql-schema/operations/mutations/click#__docusaurus_skipToContent_fallback)


Waits for the element to be visible, scrolls to it, then clicks on it with native events

Example:

```codeBlockLines_p187
mutation ClickButton {
  goto(url: "https://example.com") {
    status
  }

  click(selector: "a") {
    time
  }
}

```

```codeBlockLines_p187
click(
  selector: String!
  scroll: Boolean = true
  timeout: Float
  visible: Boolean = false
  wait: Boolean = true
): ClickResponse

```

### Arguments [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/click\#arguments "Direct link to Arguments")

#### [`click.selector`](https://docs.browserless.io/bql-schema/operations/mutations/click\#)Â â—Â [`String!`](https://docs.browserless.io/bql-schema/types/scalars/string) non-nullscalar [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/click\#clickselectorstring-- "Direct link to clickselectorstring--")

A query-selector compatible string, JavaScript that returns an HTML Node, OR a Browserless-deep query. Examples include:

- A simple `<button />` Element:
`selector: "button"`

- A JavaScript snippet that returns a button element
`selector: "document.querySelector('button')"`

- A Browserless Deep query. These queries must start with a "<" character.
Deep queries will traverse all iframes, shadow-doms (open or closed), and more.
`selector: "< button"`


Here's a deep query that filters by iframes with a url of "example.com" and a button with a class of active
`selector: "< https://example.com/* button.active"`

#### [`click.scroll`](https://docs.browserless.io/bql-schema/operations/mutations/click\#)Â â—Â [`Boolean`](https://docs.browserless.io/bql-schema/types/scalars/boolean) scalar [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/click\#clickscrollboolean- "Direct link to clickscrollboolean-")

Whether or not to scroll to the element prior to clicking, defaults to true

#### [`click.timeout`](https://docs.browserless.io/bql-schema/operations/mutations/click\#)Â â—Â [`Float`](https://docs.browserless.io/bql-schema/types/scalars/float) scalar [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/click\#clicktimeoutfloat- "Direct link to clicktimeoutfloat-")

How long to wait for the element to appear before timing out on the click handler, overriding any defaults. Default timeout is 30 seconds, or 30000.

#### [`click.visible`](https://docs.browserless.io/bql-schema/operations/mutations/click\#)Â â—Â [`Boolean`](https://docs.browserless.io/bql-schema/types/scalars/boolean) scalar [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/click\#clickvisibleboolean- "Direct link to clickvisibleboolean-")

Whether or not to click the element only if it's visible

#### [`click.wait`](https://docs.browserless.io/bql-schema/operations/mutations/click\#)Â â—Â [`Boolean`](https://docs.browserless.io/bql-schema/types/scalars/boolean) scalar [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/click\#clickwaitboolean- "Direct link to clickwaitboolean-")

Whether or not to wait for the element to present in the DOM

### Type [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/click\#type "Direct link to Type")

#### [`ClickResponse`](https://docs.browserless.io/bql-schema/types/objects/click-response) object [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/click\#clickresponse- "Direct link to clickresponse-")

Response returned after having clicked on an element

- [Arguments](https://docs.browserless.io/bql-schema/operations/mutations/click#arguments)
- [Type](https://docs.browserless.io/bql-schema/operations/mutations/click#type)

---

### content | Browserless.io
Original URL: https://docs.browserless.io/bql-schema/operations/mutations/content

[Skip to main content](https://docs.browserless.io/bql-schema/operations/mutations/content#__docusaurus_skipToContent_fallback)


Sets the given HTML content on the page with an optional waitUntil parameter

Example:

```codeBlockLines_p187
mutation SetContent {
  content(html: "<h1>Hello, World!</h1>") {
    status
  }
}

```

```codeBlockLines_p187
content(
  html: String!
  waitUntil: WaitUntilHistory
): HTTPResponse

```

### Arguments [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/content\#arguments "Direct link to Arguments")

#### [`content.html`](https://docs.browserless.io/bql-schema/operations/mutations/content\#)Â â—Â [`String!`](https://docs.browserless.io/bql-schema/types/scalars/string) non-nullscalar [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/content\#contenthtmlstring-- "Direct link to contenthtmlstring--")

When present, sets the content of page to the value passed, then returns the pages content

#### [`content.waitUntil`](https://docs.browserless.io/bql-schema/operations/mutations/content\#)Â â—Â [`WaitUntilHistory`](https://docs.browserless.io/bql-schema/types/enums/wait-until-history) enum [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/content\#contentwaituntilwaituntilhistory- "Direct link to contentwaituntilwaituntilhistory-")

When to consider the page fully-loaded and proceed with further execution, used in conjunction with the value parameter

### Type [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/content\#type "Direct link to Type")

#### [`HTTPResponse`](https://docs.browserless.io/bql-schema/types/objects/httpresponse) object [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/content\#httpresponse- "Direct link to httpresponse-")

Response returned after a navigation event

- [Arguments](https://docs.browserless.io/bql-schema/operations/mutations/content#arguments)
- [Type](https://docs.browserless.io/bql-schema/operations/mutations/content#type)

---

### cookies | Browserless.io
Original URL: https://docs.browserless.io/bql-schema/operations/mutations/cookies

[Skip to main content](https://docs.browserless.io/bql-schema/operations/mutations/cookies#__docusaurus_skipToContent_fallback)


Sets and gets cookies on the page

Example:

```codeBlockLines_p187
mutation SetCookies {
  # Get the cookies on the page
  getCookies: cookies {
    cookies {
      name
      value
    }
  }

  # Set a cookie on the page
  setCookies: cookies(cookies: [\
      {\
        name: "my-cookie"\
        value: "my-value"\
        url: "https://example.com"\
      }\
  ]) {
    cookies {
      name
      value
    }
  }
}

```

```codeBlockLines_p187
cookies(
  cookies: [CookieInput]
): CookieResponse

```

### Arguments [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/cookies\#arguments "Direct link to Arguments")

#### [`cookies.cookies`](https://docs.browserless.io/bql-schema/operations/mutations/cookies\#)Â â—Â [`[CookieInput]`](https://docs.browserless.io/bql-schema/types/inputs/cookie-input) listinput [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/cookies\#cookiescookiescookieinput-- "Direct link to cookiescookiescookieinput--")

The cookies to set on the page

### Type [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/cookies\#type "Direct link to Type")

#### [`CookieResponse`](https://docs.browserless.io/bql-schema/types/objects/cookie-response) object [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/cookies\#cookieresponse- "Direct link to cookieresponse-")

The response returned after setting or getting cookies

- [Arguments](https://docs.browserless.io/bql-schema/operations/mutations/cookies#arguments)
- [Type](https://docs.browserless.io/bql-schema/operations/mutations/cookies#type)

---

### evaluate | Browserless.io
Original URL: https://docs.browserless.io/bql-schema/operations/mutations/evaluate

[Skip to main content](https://docs.browserless.io/bql-schema/operations/mutations/evaluate#__docusaurus_skipToContent_fallback)


Evaluates JavaScript client-side, via raw content or a URL to some JavaScript code, in the browser's page environment

Example:

```codeBlockLines_p187
mutation EvaluateScript {
  byContent: evaluate(content: "2 + 2") {
    value
  }

  byUrl: evaluate(url: "https://example.com/script.js") {
    value
  }
}

```

```codeBlockLines_p187
evaluate(
  content: String
  timeout: Float
  url: String
): EvaluateResponse

```

### Arguments [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/evaluate\#arguments "Direct link to Arguments")

#### [`evaluate.content`](https://docs.browserless.io/bql-schema/operations/mutations/evaluate\#)Â â—Â [`String`](https://docs.browserless.io/bql-schema/types/scalars/string) scalar [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/evaluate\#evaluatecontentstring- "Direct link to evaluatecontentstring-")

The raw script you'd like to evaluate. This code gets wrapped in an async function so you can use `return` at the end as well as `await` and other async concepts. You can return any stringified value from this function

#### [`evaluate.timeout`](https://docs.browserless.io/bql-schema/operations/mutations/evaluate\#)Â â—Â [`Float`](https://docs.browserless.io/bql-schema/types/scalars/float) scalar [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/evaluate\#evaluatetimeoutfloat- "Direct link to evaluatetimeoutfloat-")

A timeout to wait for the script to finish evaluating, overriding any defaults. Useful for async scripts that may be longer running. Default timeout is 30 seconds, or 30000.

#### [`evaluate.url`](https://docs.browserless.io/bql-schema/operations/mutations/evaluate\#)Â â—Â [`String`](https://docs.browserless.io/bql-schema/types/scalars/string) scalar [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/evaluate\#evaluateurlstring- "Direct link to evaluateurlstring-")

The URL of the script you'd like to evaluate. This code gets wrapped in an async function so you can use `return` at the end as well as `await` and other async
concepts. You can return any stringified value from this function

### Type [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/evaluate\#type "Direct link to Type")

#### [`EvaluateResponse`](https://docs.browserless.io/bql-schema/types/objects/evaluate-response) object [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/evaluate\#evaluateresponse- "Direct link to evaluateresponse-")

Response returned after evaluating a script

- [Arguments](https://docs.browserless.io/bql-schema/operations/mutations/evaluate#arguments)
- [Type](https://docs.browserless.io/bql-schema/operations/mutations/evaluate#type)

---

### forward | Browserless.io
Original URL: https://docs.browserless.io/bql-schema/operations/mutations/forward

[Skip to main content](https://docs.browserless.io/bql-schema/operations/mutations/forward#__docusaurus_skipToContent_fallback)


Goes forward in browser history, optionally accepting waitUntil and timeout arguments. Returns null if no forward is possible

Example:

```codeBlockLines_p187
mutation GoForward {
  firstNav: goto(url: "https://example.com", waitUntil: load) {
    time
  }

  secondNav: goto(url: "https://browserless.io", waitUntil: load) {
    time
  }

  back(waitUntil: domContentLoaded) {
    status
  }

  forward(waitUntil: domContentLoaded) {
    status
  }
}

```

```codeBlockLines_p187
forward(
  timeout: Float
  waitUntil: WaitUntilHistory = load
): HTTPResponse

```

### Arguments [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/forward\#arguments "Direct link to Arguments")

#### [`forward.timeout`](https://docs.browserless.io/bql-schema/operations/mutations/forward\#)Â â—Â [`Float`](https://docs.browserless.io/bql-schema/types/scalars/float) scalar [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/forward\#forwardtimeoutfloat- "Direct link to forwardtimeoutfloat-")

The maximum amount of time, in milliseconds, to wait for the page to load, overriding any defaults. Default timeout is 30 seconds, or 30000.

#### [`forward.waitUntil`](https://docs.browserless.io/bql-schema/operations/mutations/forward\#)Â â—Â [`WaitUntilHistory`](https://docs.browserless.io/bql-schema/types/enums/wait-until-history) enum [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/forward\#forwardwaituntilwaituntilhistory- "Direct link to forwardwaituntilwaituntilhistory-")

When to consider the page fully-loaded and proceed with further execution

### Type [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/forward\#type "Direct link to Type")

#### [`HTTPResponse`](https://docs.browserless.io/bql-schema/types/objects/httpresponse) object [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/forward\#httpresponse- "Direct link to httpresponse-")

Response returned after a navigation event

- [Arguments](https://docs.browserless.io/bql-schema/operations/mutations/forward#arguments)
- [Type](https://docs.browserless.io/bql-schema/operations/mutations/forward#type)

---

### goto | Browserless.io
Original URL: https://docs.browserless.io/bql-schema/operations/mutations/goto

[Skip to main content](https://docs.browserless.io/bql-schema/operations/mutations/goto#__docusaurus_skipToContent_fallback)


Navigates to a URL with an optional waitUntil parameter and timeout parameter

Example:

```codeBlockLines_p187
mutation Goto {
  goto(url: "https://example.com") {
    status
  }
}

```

```codeBlockLines_p187
goto(
  url: String!
  timeout: Float
  waitUntil: WaitUntilGoto = load
): HTTPResponse

```

### Arguments [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/goto\#arguments "Direct link to Arguments")

#### [`goto.url`](https://docs.browserless.io/bql-schema/operations/mutations/goto\#)Â â—Â [`String!`](https://docs.browserless.io/bql-schema/types/scalars/string) non-nullscalar [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/goto\#gotourlstring-- "Direct link to gotourlstring--")

The fully-qualified URL of the page you'd like to navigate to

#### [`goto.timeout`](https://docs.browserless.io/bql-schema/operations/mutations/goto\#)Â â—Â [`Float`](https://docs.browserless.io/bql-schema/types/scalars/float) scalar [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/goto\#gototimeoutfloat- "Direct link to gototimeoutfloat-")

The maximum amount of time, in milliseconds, to wait for the page to load, overriding any defaults. Default timeout is 30 seconds, or 30000.

#### [`goto.waitUntil`](https://docs.browserless.io/bql-schema/operations/mutations/goto\#)Â â—Â [`WaitUntilGoto`](https://docs.browserless.io/bql-schema/types/enums/wait-until-goto) enum [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/goto\#gotowaituntilwaituntilgoto- "Direct link to gotowaituntilwaituntilgoto-")

When to consider the page fully-loaded and proceed with further execution

### Type [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/goto\#type "Direct link to Type")

#### [`HTTPResponse`](https://docs.browserless.io/bql-schema/types/objects/httpresponse) object [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/goto\#httpresponse- "Direct link to httpresponse-")

Response returned after a navigation event

- [Arguments](https://docs.browserless.io/bql-schema/operations/mutations/goto#arguments)
- [Type](https://docs.browserless.io/bql-schema/operations/mutations/goto#type)

---

### hover | Browserless.io
Original URL: https://docs.browserless.io/bql-schema/operations/mutations/hover

[Skip to main content](https://docs.browserless.io/bql-schema/operations/mutations/hover#__docusaurus_skipToContent_fallback)


Waits for the element to be visible, scrolls to it, then hover on it with native events

Example:

```codeBlockLines_p187
mutation HoverElement {
  goto(url: "https://example.com") {
    status
  }

  hover(selector: "a") {
    time
  }
}

```

```codeBlockLines_p187
hover(
  scroll: Boolean = true
  selector: String
  timeout: Float
  visible: Boolean = false
  wait: Boolean = true
  x: Float
  y: Float
): HoverResponse

```

### Arguments [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/hover\#arguments "Direct link to Arguments")

#### [`hover.scroll`](https://docs.browserless.io/bql-schema/operations/mutations/hover\#)Â â—Â [`Boolean`](https://docs.browserless.io/bql-schema/types/scalars/boolean) scalar [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/hover\#hoverscrollboolean- "Direct link to hoverscrollboolean-")

Whether or not to scroll to the element, defaults to true

#### [`hover.selector`](https://docs.browserless.io/bql-schema/operations/mutations/hover\#)Â â—Â [`String`](https://docs.browserless.io/bql-schema/types/scalars/string) scalar [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/hover\#hoverselectorstring- "Direct link to hoverselectorstring-")

The CSS selector of the element on the page you want to hover on

#### [`hover.timeout`](https://docs.browserless.io/bql-schema/operations/mutations/hover\#)Â â—Â [`Float`](https://docs.browserless.io/bql-schema/types/scalars/float) scalar [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/hover\#hovertimeoutfloat- "Direct link to hovertimeoutfloat-")

How long to wait for the element to appear before timing out, overriding any defaults. Default timeout is 30 seconds, or 30000.

#### [`hover.visible`](https://docs.browserless.io/bql-schema/operations/mutations/hover\#)Â â—Â [`Boolean`](https://docs.browserless.io/bql-schema/types/scalars/boolean) scalar [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/hover\#hovervisibleboolean- "Direct link to hovervisibleboolean-")

Whether or not to hover on the element only if it's visible

#### [`hover.wait`](https://docs.browserless.io/bql-schema/operations/mutations/hover\#)Â â—Â [`Boolean`](https://docs.browserless.io/bql-schema/types/scalars/boolean) scalar [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/hover\#hoverwaitboolean- "Direct link to hoverwaitboolean-")

Whether or not to wait for the element to present in the DOM

#### [`hover.x`](https://docs.browserless.io/bql-schema/operations/mutations/hover\#)Â â—Â [`Float`](https://docs.browserless.io/bql-schema/types/scalars/float) scalar [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/hover\#hoverxfloat- "Direct link to hoverxfloat-")

The X coordinate, in pixels, to hover on the page

#### [`hover.y`](https://docs.browserless.io/bql-schema/operations/mutations/hover\#)Â â—Â [`Float`](https://docs.browserless.io/bql-schema/types/scalars/float) scalar [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/hover\#hoveryfloat- "Direct link to hoveryfloat-")

The Y coordinate, in pixels, to hover on the page

### Type [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/hover\#type "Direct link to Type")

#### [`HoverResponse`](https://docs.browserless.io/bql-schema/types/objects/hover-response) object [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/hover\#hoverresponse- "Direct link to hoverresponse-")

Response returned after having hovered over an element

- [Arguments](https://docs.browserless.io/bql-schema/operations/mutations/hover#arguments)
- [Type](https://docs.browserless.io/bql-schema/operations/mutations/hover#type)

---

### html | Browserless.io
Original URL: https://docs.browserless.io/bql-schema/operations/mutations/html

[Skip to main content](https://docs.browserless.io/bql-schema/operations/mutations/html#__docusaurus_skipToContent_fallback)


Returns the HTML content of the page or selector when specified. This API can also "clean" HTML markup returned by specifying a "clean" argument with numerous options. Features of the "clean" argument include removal of non-text nodes, removal of DOM attributes, as well as removal of excessive whitespace and newlines. Using "clean" can save nearly 1,000 times the payload size. Useful for LLM's and other scenarios

Example:

```codeBlockLines_p187
mutation GetHTML {
  goto(url: "https://example.com") {
    status
  }
  html(selector: "h1") {
    html
  }
}

```

Remove non-text DOM nodes and all Node attributes, but preserve the DOM tree

```codeBlockLines_p187
mutation GetHTML {
  goto(url: "https://example.com") {
    status
  }

  html(clean: {
    removeAttributes: true
    removeNonTextNodes: true
  }) {
    html
  }
}

```

```codeBlockLines_p187
html(
  selector: String
  timeout: Float
  visible: Boolean = false
  clean: CleanInput
): HTMLResponse

```

### Arguments [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/html\#arguments "Direct link to Arguments")

#### [`html.selector`](https://docs.browserless.io/bql-schema/operations/mutations/html\#)Â â—Â [`String`](https://docs.browserless.io/bql-schema/types/scalars/string) scalar [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/html\#htmlselectorstring- "Direct link to htmlselectorstring-")

The DOM selector of the given element you want to return the HTML of

#### [`html.timeout`](https://docs.browserless.io/bql-schema/operations/mutations/html\#)Â â—Â [`Float`](https://docs.browserless.io/bql-schema/types/scalars/float) scalar [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/html\#htmltimeoutfloat- "Direct link to htmltimeoutfloat-")

The maximum amount of time, in milliseconds, to wait for the selector to appear, overriding any defaults. Default timeout is 30 seconds, or 30000.

#### [`html.visible`](https://docs.browserless.io/bql-schema/operations/mutations/html\#)Â â—Â [`Boolean`](https://docs.browserless.io/bql-schema/types/scalars/boolean) scalar [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/html\#htmlvisibleboolean- "Direct link to htmlvisibleboolean-")

Whether or not to return the HTMLÏ€ content of the element only if it's visible

#### [`html.clean`](https://docs.browserless.io/bql-schema/operations/mutations/html\#)Â â—Â [`CleanInput`](https://docs.browserless.io/bql-schema/types/inputs/clean-input) input [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/html\#htmlcleancleaninput- "Direct link to htmlcleancleaninput-")

Specifies conditions for "cleaning" HTML, useful for minimizing the amount of markup returned for cases like LLMs and more. See nested options for parameters.

### Type [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/html\#type "Direct link to Type")

#### [`HTMLResponse`](https://docs.browserless.io/bql-schema/types/objects/htmlresponse) object [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/html\#htmlresponse- "Direct link to htmlresponse-")

HTML content of a page

- [Arguments](https://docs.browserless.io/bql-schema/operations/mutations/html#arguments)
- [Type](https://docs.browserless.io/bql-schema/operations/mutations/html#type)

---

### if | Browserless.io
Original URL: https://docs.browserless.io/bql-schema/operations/mutations/if

[Skip to main content](https://docs.browserless.io/bql-schema/operations/mutations/if#__docusaurus_skipToContent_fallback)


Triggers a nested branch of work when a given condition is `true`. Does not wait for these items and is a point-in-time check. Use the wait method if you're wanting to await certain behaviors to be present

Example:

```codeBlockLines_p187
mutation If {
  goto(url: "https://example.com") {
    status
  }

  # Will only trigger the screenshot if the h1 is present
  if(selector: "h1") {
    screenshot {
      base64
    }
  }
}

```

```codeBlockLines_p187
if(
  request: RequestInput
  response: ResponseInput
  selector: String
  visible: Boolean = false
): Mutation

```

### Arguments [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/if\#arguments "Direct link to Arguments")

#### [`if.request`](https://docs.browserless.io/bql-schema/operations/mutations/if\#)Â â—Â [`RequestInput`](https://docs.browserless.io/bql-schema/types/inputs/request-input) input [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/if\#ifrequestrequestinput- "Direct link to ifrequestrequestinput-")

Triggers the nested conditions if a request has been made with the following conditions

#### [`if.response`](https://docs.browserless.io/bql-schema/operations/mutations/if\#)Â â—Â [`ResponseInput`](https://docs.browserless.io/bql-schema/types/inputs/response-input) input [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/if\#ifresponseresponseinput- "Direct link to ifresponseresponseinput-")

Triggers the nested conditions if a response has been received with the following conditions

#### [`if.selector`](https://docs.browserless.io/bql-schema/operations/mutations/if\#)Â â—Â [`String`](https://docs.browserless.io/bql-schema/types/scalars/string) scalar [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/if\#ifselectorstring- "Direct link to ifselectorstring-")

Triggers the subsequent conditions if the selector is immediately present

#### [`if.visible`](https://docs.browserless.io/bql-schema/operations/mutations/if\#)Â â—Â [`Boolean`](https://docs.browserless.io/bql-schema/types/scalars/boolean) scalar [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/if\#ifvisibleboolean- "Direct link to ifvisibleboolean-")

When using selectors in conditionals this options sets whether their or not to consider if they're visible to the viewport

### Type [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/if\#type "Direct link to Type")

#### [`Mutation`](https://docs.browserless.io/bql-schema/types/objects/mutation) object [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/if\#mutation- "Direct link to mutation-")

Below is a list of all available API options for the service. Click on an API for options, examples, and even argument details.

For more comprehensive examples and recipes, [see our documentation site here](https://docs.browserless.io/).

- [Arguments](https://docs.browserless.io/bql-schema/operations/mutations/if#arguments)
- [Type](https://docs.browserless.io/bql-schema/operations/mutations/if#type)

---

### ifnot | Browserless.io
Original URL: https://docs.browserless.io/bql-schema/operations/mutations/ifnot

[Skip to main content](https://docs.browserless.io/bql-schema/operations/mutations/ifnot#__docusaurus_skipToContent_fallback)


Triggers a nested branch of work when a given condition is `false`. This method does not wait for these items and is a point-in-time check. Use the wait method if you're wanting to await certain behaviors to be present

Example:

```codeBlockLines_p187
mutation IfNot {
  goto(url: "https://example.com") {
    status
  }

  # Will only trigger the screenshot if the h2 is not present
  ifnot(selector: "h2") {
    screenshot {
      base64
    }
  }
}

```

```codeBlockLines_p187
ifnot(
  request: RequestInput
  response: ResponseInput
  selector: String
): Mutation

```

### Arguments [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/ifnot\#arguments "Direct link to Arguments")

#### [`ifnot.request`](https://docs.browserless.io/bql-schema/operations/mutations/ifnot\#)Â â—Â [`RequestInput`](https://docs.browserless.io/bql-schema/types/inputs/request-input) input [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/ifnot\#ifnotrequestrequestinput- "Direct link to ifnotrequestrequestinput-")

Triggers the nested conditions if a request has been made with the following conditions

#### [`ifnot.response`](https://docs.browserless.io/bql-schema/operations/mutations/ifnot\#)Â â—Â [`ResponseInput`](https://docs.browserless.io/bql-schema/types/inputs/response-input) input [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/ifnot\#ifnotresponseresponseinput- "Direct link to ifnotresponseresponseinput-")

Triggers the nested conditions if a response has been received with the following conditions

#### [`ifnot.selector`](https://docs.browserless.io/bql-schema/operations/mutations/ifnot\#)Â â—Â [`String`](https://docs.browserless.io/bql-schema/types/scalars/string) scalar [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/ifnot\#ifnotselectorstring- "Direct link to ifnotselectorstring-")

Triggers the subsequent conditions if the selector is immediately present

### Type [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/ifnot\#type "Direct link to Type")

#### [`Mutation`](https://docs.browserless.io/bql-schema/types/objects/mutation) object [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/ifnot\#mutation- "Direct link to mutation-")

Below is a list of all available API options for the service. Click on an API for options, examples, and even argument details.

For more comprehensive examples and recipes, [see our documentation site here](https://docs.browserless.io/).

- [Arguments](https://docs.browserless.io/bql-schema/operations/mutations/ifnot#arguments)
- [Type](https://docs.browserless.io/bql-schema/operations/mutations/ifnot#type)

---

### javaScriptEnabled | Browserless.io
Original URL: https://docs.browserless.io/bql-schema/operations/mutations/java-script-enabled

[Skip to main content](https://docs.browserless.io/bql-schema/operations/mutations/java-script-enabled#__docusaurus_skipToContent_fallback)


Sets and gets JavaScript execution on the page

**Note: changing this value won't affect scripts that have already been run. It will take full effect on the next navigation.**

Example:

```codeBlockLines_p187
mutation JavaScript {
  status: javaScriptEnabled {
    enabled
  }

  disable: javaScriptEnabled(enabled: false) {
    enabled
  }

  enable: javaScriptEnabled(enabled: true) {
    enabled
  }
}

```

```codeBlockLines_p187
javaScriptEnabled(
  enabled: Boolean
): JavaScriptResponse

```

### Arguments [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/java-script-enabled\#arguments "Direct link to Arguments")

#### [`javaScriptEnabled.enabled`](https://docs.browserless.io/bql-schema/operations/mutations/java-script-enabled\#)Â â—Â [`Boolean`](https://docs.browserless.io/bql-schema/types/scalars/boolean) scalar [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/java-script-enabled\#javascriptenabledenabledboolean- "Direct link to javascriptenabledenabledboolean-")

Whether or not to enable JavaScript on the page

### Type [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/java-script-enabled\#type "Direct link to Type")

#### [`JavaScriptResponse`](https://docs.browserless.io/bql-schema/types/objects/java-script-response) object [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/java-script-enabled\#javascriptresponse- "Direct link to javascriptresponse-")

The response returned after enabling or disabling JavaScript on the page

- [Arguments](https://docs.browserless.io/bql-schema/operations/mutations/java-script-enabled#arguments)
- [Type](https://docs.browserless.io/bql-schema/operations/mutations/java-script-enabled#type)

---

### liveURL | Browserless.io
Original URL: https://docs.browserless.io/bql-schema/operations/mutations/live-url

[Skip to main content](https://docs.browserless.io/bql-schema/operations/mutations/live-url#__docusaurus_skipToContent_fallback)


Returns a fully-qualified, user-shareable live-URL for streaming the web-browser to an end-user, optionally interactive.

**Set 30 second timer for interaction**

```codeBlockLines_p187
mutation LiveURL {
  goto(url: "https://example.com") {
    status
  }
  liveURL {
    liveURL
  }
}

```

**Don't allow interaction at all**

```codeBlockLines_p187
mutation LiveURL {
  goto(url: "https://example.com") {
    status
  }
  liveURL(interactable: false) {
    liveURL
  }
}

```

**Low quality for better bandwidth**

```codeBlockLines_p187
mutation LiveURL {
  goto(url: "https://example.com") {
    status
  }
  liveURL(quality: 20 type: jpeg) {
    liveURL
  }
}

```

```codeBlockLines_p187
liveURL(
  timeout: Float
  interactable: Boolean = true
  type: LiveURLStreamType = jpeg
  quality: Int = 100
): LiveURLResponse

```

### Arguments [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/live-url\#arguments "Direct link to Arguments")

#### [`liveURL.timeout`](https://docs.browserless.io/bql-schema/operations/mutations/live-url\#)Â â—Â [`Float`](https://docs.browserless.io/bql-schema/types/scalars/float) scalar [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/live-url\#liveurltimeoutfloat- "Direct link to liveurltimeoutfloat-")

The maximum time allowed for the browser to remain alive. Once the time is reached, the end-user will receive a prompt that the session has closed

#### [`liveURL.interactable`](https://docs.browserless.io/bql-schema/operations/mutations/live-url\#)Â â—Â [`Boolean`](https://docs.browserless.io/bql-schema/types/scalars/boolean) scalar [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/live-url\#liveurlinteractableboolean- "Direct link to liveurlinteractableboolean-")

Whether the session is interactable or not. Set to "false" to not allow click and mouse events to be forwarded through to the end-user

#### [`liveURL.type`](https://docs.browserless.io/bql-schema/operations/mutations/live-url\#)Â â—Â [`LiveURLStreamType`](https://docs.browserless.io/bql-schema/types/enums/live-urlstream-type) enum [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/live-url\#liveurltypeliveurlstreamtype- "Direct link to liveurltypeliveurlstreamtype-")

The binary-type of the streamed imaged. "jpeg" will consumer lower bandwidth and useful low bandwidth networks and devices. "png" is a much higher quality but will consume considerably more bandwidth.

Use "jpeg" when setting a custom quality

#### [`liveURL.quality`](https://docs.browserless.io/bql-schema/operations/mutations/live-url\#)Â â—Â [`Int`](https://docs.browserless.io/bql-schema/types/scalars/int) scalar [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/live-url\#liveurlqualityint- "Direct link to liveurlqualityint-")

The quality of the stream, represented as number from 1 - 100. Only used when "type" is "jpeg"

### Type [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/live-url\#type "Direct link to Type")

#### [`LiveURLResponse`](https://docs.browserless.io/bql-schema/types/objects/live-urlresponse) object [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/live-url\#liveurlresponse- "Direct link to liveurlresponse-")

The response from the Live-URL query

- [Arguments](https://docs.browserless.io/bql-schema/operations/mutations/live-url#arguments)
- [Type](https://docs.browserless.io/bql-schema/operations/mutations/live-url#type)

---

### mapSelector | Browserless.io
Original URL: https://docs.browserless.io/bql-schema/operations/mutations/map-selector

[Skip to main content](https://docs.browserless.io/bql-schema/operations/mutations/map-selector#__docusaurus_skipToContent_fallback)


Specify a selector that returns multiple nodes in a document (similar to `document.querySelectorAll`), or JavaScript that returns a NodeList, and this API will respond with details about those DOM nodes. Similar to how "map" works in most functional programming languages and libraries. Useful for mapping over repetitive data in sites and pages like product listings or search results. This will automatically wait for the selector to be present on the page, and is configurable with the "wait" and "timeout" options.

For getting arbitrary DOM attributes back you can specify them via the `attribute(name: "data-custom-attribute")` property. This will return an object with `name` and `value` properties.

You may also continuously map further nested items as well, for instance this query might get all books on a page, and then a nested `mapSelector` call might list all sellers of that book, or shipping speeds. Hierarchy of data is preserved to pass through the hierarchical data modeled inside the DOM.

This API will always return a list of results back regardless if one or more items are found, or `null` if none are found.

Using aliases can also give the returned JSON more meaning and better model the data returned by this powerful API.

**Simple Example**

```codeBlockLines_p187
mutation HNLinks {
  goto(url: "https://news.ycombinator.com") {
    status
  }

  # Get all the top links HTML
  mapSelector(selector: ".athing") {
    innerHTML
  }
}

```

**Nested Example With Aliases**

```codeBlockLines_p187
mutation HNLinksWithMetaData {
  goto(url: "https://news.ycombinator.com") {
    status
  }

  # Get all textual content
  posts: mapSelector(selector: ".athing") {
    postName: innerText

    # Get the author(s)
    authors: mapSelector(selector: ".author") {
      authorName: innerText
    }

    # Get the post score
    score: mapSelector(selector: ".score") {
      score: innerText
    }
  }
}

```

```codeBlockLines_p187
mapSelector(
  selector: String!
  timeout: Float
  wait: Boolean = true
): [MapSelectorResponse]

```

### Arguments [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/map-selector\#arguments "Direct link to Arguments")

#### [`mapSelector.selector`](https://docs.browserless.io/bql-schema/operations/mutations/map-selector\#)Â â—Â [`String!`](https://docs.browserless.io/bql-schema/types/scalars/string) non-nullscalar [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/map-selector\#mapselectorselectorstring-- "Direct link to mapselectorselectorstring--")

A `document.querySelectorAll` compatible string, or JavaScript that returns a DOM NodeList. Examples include:

- A list of `<button />` Elements:
`selector: "button"`

- A JavaScript snippet that returns a button element
`selector: "document.querySelectorAll('button')"`


#### [`mapSelector.timeout`](https://docs.browserless.io/bql-schema/operations/mutations/map-selector\#)Â â—Â [`Float`](https://docs.browserless.io/bql-schema/types/scalars/float) scalar [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/map-selector\#mapselectortimeoutfloat- "Direct link to mapselectortimeoutfloat-")

How long to wait for the element to appear before timing out, overriding any defaults. Default timeout is 30 seconds, or 30000.

#### [`mapSelector.wait`](https://docs.browserless.io/bql-schema/operations/mutations/map-selector\#)Â â—Â [`Boolean`](https://docs.browserless.io/bql-schema/types/scalars/boolean) scalar [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/map-selector\#mapselectorwaitboolean- "Direct link to mapselectorwaitboolean-")

Whether or not to wait for the selectors to present in the DOM

### Type [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/map-selector\#type "Direct link to Type")

#### [`MapSelectorResponse`](https://docs.browserless.io/bql-schema/types/objects/map-selector-response) object [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/map-selector\#mapselectorresponse- "Direct link to mapselectorresponse-")

Response returned from a Map Selector

- [Arguments](https://docs.browserless.io/bql-schema/operations/mutations/map-selector#arguments)
- [Type](https://docs.browserless.io/bql-schema/operations/mutations/map-selector#type)

---

### pdf | Browserless.io
Original URL: https://docs.browserless.io/bql-schema/operations/mutations/pdf

[Skip to main content](https://docs.browserless.io/bql-schema/operations/mutations/pdf#__docusaurus_skipToContent_fallback)


Generates a PDF of the page with the print CSS media type

Example:

```codeBlockLines_p187
mutation PDF {
  goto(url: "https://example.com", waitUntil: firstMeaningfulPaint) {
    status
  }

  simple: pdf {
    base64
  }

  customArgs: pdf(
    format: a5
    displayHeaderFooter: true
    headerTemplate: "<span style=\"font-size: 16pt;\">Hello World</span>"
  ) {
    base64
  }
}

```

```codeBlockLines_p187
pdf(
  displayHeaderFooter: Boolean
  format: PDFPageFormat
  footerTemplate: String
  generateDocumentOutline: Boolean
  generateTaggedPDF: Boolean
  landscape: Boolean
  printBackground: Boolean
  scale: Float
  timeout: Float
  width: FloatOrString
  headerTemplate: String
  height: FloatOrString
  marginBottom: FloatOrString
  marginLeft: FloatOrString
  marginRight: FloatOrString
  marginTop: FloatOrString
  pageRanges: String
  preferCSSPageSize: Boolean
  transferMode: String
): PDFResponse

```

### Arguments [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/pdf\#arguments "Direct link to Arguments")

#### [`pdf.displayHeaderFooter`](https://docs.browserless.io/bql-schema/operations/mutations/pdf\#)Â â—Â [`Boolean`](https://docs.browserless.io/bql-schema/types/scalars/boolean) scalar [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/pdf\#pdfdisplayheaderfooterboolean- "Direct link to pdfdisplayheaderfooterboolean-")

Display header and footer. Defaults to false

#### [`pdf.format`](https://docs.browserless.io/bql-schema/operations/mutations/pdf\#)Â â—Â [`PDFPageFormat`](https://docs.browserless.io/bql-schema/types/enums/pdfpage-format) enum [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/pdf\#pdfformatpdfpageformat- "Direct link to pdfformatpdfpageformat-")

The page format to use for the PDF

#### [`pdf.footerTemplate`](https://docs.browserless.io/bql-schema/operations/mutations/pdf\#)Â â—Â [`String`](https://docs.browserless.io/bql-schema/types/scalars/string) scalar [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/pdf\#pdffootertemplatestring- "Direct link to pdffootertemplatestring-")

HTML template for the print footer. Should use the same format as the `headerTemplate`.

#### [`pdf.generateDocumentOutline`](https://docs.browserless.io/bql-schema/operations/mutations/pdf\#)Â â—Â [`Boolean`](https://docs.browserless.io/bql-schema/types/scalars/boolean) scalar [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/pdf\#pdfgeneratedocumentoutlineboolean- "Direct link to pdfgeneratedocumentoutlineboolean-")

Whether or not to embed the document outline into the PDF

#### [`pdf.generateTaggedPDF`](https://docs.browserless.io/bql-schema/operations/mutations/pdf\#)Â â—Â [`Boolean`](https://docs.browserless.io/bql-schema/types/scalars/boolean) scalar [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/pdf\#pdfgeneratetaggedpdfboolean- "Direct link to pdfgeneratetaggedpdfboolean-")

Whether or not to generate tagged (accessible) PDF. Defaults to embedded choice

#### [`pdf.landscape`](https://docs.browserless.io/bql-schema/operations/mutations/pdf\#)Â â—Â [`Boolean`](https://docs.browserless.io/bql-schema/types/scalars/boolean) scalar [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/pdf\#pdflandscapeboolean- "Direct link to pdflandscapeboolean-")

Paper orientation. Defaults to false

#### [`pdf.printBackground`](https://docs.browserless.io/bql-schema/operations/mutations/pdf\#)Â â—Â [`Boolean`](https://docs.browserless.io/bql-schema/types/scalars/boolean) scalar [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/pdf\#pdfprintbackgroundboolean- "Direct link to pdfprintbackgroundboolean-")

Print background graphics. Defaults to false

#### [`pdf.scale`](https://docs.browserless.io/bql-schema/operations/mutations/pdf\#)Â â—Â [`Float`](https://docs.browserless.io/bql-schema/types/scalars/float) scalar [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/pdf\#pdfscalefloat- "Direct link to pdfscalefloat-")

Scale of the webpage rendering. Defaults to 1

#### [`pdf.timeout`](https://docs.browserless.io/bql-schema/operations/mutations/pdf\#)Â â—Â [`Float`](https://docs.browserless.io/bql-schema/types/scalars/float) scalar [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/pdf\#pdftimeoutfloat- "Direct link to pdftimeoutfloat-")

The maximum amount of time, in milliseconds, to wait for the PDF to be generated. Default timeout is 30 seconds, or 30000.

#### [`pdf.width`](https://docs.browserless.io/bql-schema/operations/mutations/pdf\#)Â â—Â [`FloatOrString`](https://docs.browserless.io/bql-schema/types/scalars/float-or-string) scalar [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/pdf\#pdfwidthfloatorstring- "Direct link to pdfwidthfloatorstring-")

Width in inches or CSS unit. Defaults to 8.5 inches

#### [`pdf.headerTemplate`](https://docs.browserless.io/bql-schema/operations/mutations/pdf\#)Â â—Â [`String`](https://docs.browserless.io/bql-schema/types/scalars/string) scalar [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/pdf\#pdfheadertemplatestring- "Direct link to pdfheadertemplatestring-")

HTML template for the print header. Should be valid HTML markup with following
classes used to inject printing values into them:

- `date`: formatted print date
- `title`: document title
- `url`: document location
- `pageNumber`: current page number
- `totalPages`: total pages in the document

For example, `<span class=title></span>` would generate span containing the title

#### [`pdf.height`](https://docs.browserless.io/bql-schema/operations/mutations/pdf\#)Â â—Â [`FloatOrString`](https://docs.browserless.io/bql-schema/types/scalars/float-or-string) scalar [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/pdf\#pdfheightfloatorstring- "Direct link to pdfheightfloatorstring-")

Height in inches or CSS unit. Defaults to 11 inches

#### [`pdf.marginBottom`](https://docs.browserless.io/bql-schema/operations/mutations/pdf\#)Â â—Â [`FloatOrString`](https://docs.browserless.io/bql-schema/types/scalars/float-or-string) scalar [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/pdf\#pdfmarginbottomfloatorstring- "Direct link to pdfmarginbottomfloatorstring-")

Bottom margin in inches or CSS unit. Defaults to 1cm (~0.4 inches).

#### [`pdf.marginLeft`](https://docs.browserless.io/bql-schema/operations/mutations/pdf\#)Â â—Â [`FloatOrString`](https://docs.browserless.io/bql-schema/types/scalars/float-or-string) scalar [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/pdf\#pdfmarginleftfloatorstring- "Direct link to pdfmarginleftfloatorstring-")

Left margin in inches or CSS unit. Defaults to 1cm (~0.4 inches).

#### [`pdf.marginRight`](https://docs.browserless.io/bql-schema/operations/mutations/pdf\#)Â â—Â [`FloatOrString`](https://docs.browserless.io/bql-schema/types/scalars/float-or-string) scalar [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/pdf\#pdfmarginrightfloatorstring- "Direct link to pdfmarginrightfloatorstring-")

Right margin in inches or CSS unit. Defaults to 1cm (~0.4 inches).

#### [`pdf.marginTop`](https://docs.browserless.io/bql-schema/operations/mutations/pdf\#)Â â—Â [`FloatOrString`](https://docs.browserless.io/bql-schema/types/scalars/float-or-string) scalar [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/pdf\#pdfmargintopfloatorstring- "Direct link to pdfmargintopfloatorstring-")

Top margin in inches or CSS unit. Defaults to 1cm (~0.4 inches).

#### [`pdf.pageRanges`](https://docs.browserless.io/bql-schema/operations/mutations/pdf\#)Â â—Â [`String`](https://docs.browserless.io/bql-schema/types/scalars/string) scalar [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/pdf\#pdfpagerangesstring- "Direct link to pdfpagerangesstring-")

Paper ranges to print, one based, e.g., '1-5, 8, 11-13'. Pages are
printed in the document order, not in the order specified, and no
more than once. Defaults to empty string, which implies the entire document is printed.
The page numbers are quietly capped to actual page count of the
document, and ranges beyond the end of the document are ignored.
If this results in no pages to print, an error is reported.
It is an error to specify a range with start greater than end

#### [`pdf.preferCSSPageSize`](https://docs.browserless.io/bql-schema/operations/mutations/pdf\#)Â â—Â [`Boolean`](https://docs.browserless.io/bql-schema/types/scalars/boolean) scalar [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/pdf\#pdfprefercsspagesizeboolean- "Direct link to pdfprefercsspagesizeboolean-")

Whether or not to prefer page size as defined by css. Defaults to false,
in which case the content will be scaled to fit the paper size

#### [`pdf.transferMode`](https://docs.browserless.io/bql-schema/operations/mutations/pdf\#)Â â—Â [`String`](https://docs.browserless.io/bql-schema/types/scalars/string) scalar [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/pdf\#pdftransfermodestring- "Direct link to pdftransfermodestring-")

Return as stream (PrintToPDFRequestTransferMode enum)

### Type [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/pdf\#type "Direct link to Type")

#### [`PDFResponse`](https://docs.browserless.io/bql-schema/types/objects/pdfresponse) object [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/pdf\#pdfresponse- "Direct link to pdfresponse-")

The response returned after generating a PDF

- [Arguments](https://docs.browserless.io/bql-schema/operations/mutations/pdf#arguments)
- [Type](https://docs.browserless.io/bql-schema/operations/mutations/pdf#type)

---

### preferences | Browserless.io
Original URL: https://docs.browserless.io/bql-schema/operations/mutations/preferences

[Skip to main content](https://docs.browserless.io/bql-schema/operations/mutations/preferences#__docusaurus_skipToContent_fallback)


Sets configuration for the entirety of the session, replacing defaults like the 30 second timeout default

Example:

```codeBlockLines_p187
mutation Preferences {
  preferences(timeout: 10000) {
    timeout
  }
}

```

```codeBlockLines_p187
preferences(
  timeout: Float = 30000
): DefaultResponse

```

### Arguments [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/preferences\#arguments "Direct link to Arguments")

#### [`preferences.timeout`](https://docs.browserless.io/bql-schema/operations/mutations/preferences\#)Â â—Â [`Float`](https://docs.browserless.io/bql-schema/types/scalars/float) scalar [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/preferences\#preferencestimeoutfloat- "Direct link to preferencestimeoutfloat-")

Sets a default timeout for all methods, including 'goto', 'type', 'wait', etc. Default timeout is 30 seconds, or 30000.

### Type [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/preferences\#type "Direct link to Type")

#### [`DefaultResponse`](https://docs.browserless.io/bql-schema/types/objects/default-response) object [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/preferences\#defaultresponse- "Direct link to defaultresponse-")

Default response for all methods

- [Arguments](https://docs.browserless.io/bql-schema/operations/mutations/preferences#arguments)
- [Type](https://docs.browserless.io/bql-schema/operations/mutations/preferences#type)

---

### proxy | Browserless.io
Original URL: https://docs.browserless.io/bql-schema/operations/mutations/proxy

[Skip to main content](https://docs.browserless.io/bql-schema/operations/mutations/proxy#__docusaurus_skipToContent_fallback)


Proxies requests, by a specified set of conditions, through either the Browserless residential proxy or through an external proxy. Only requests that match these conditions are proxied and the rest are sent from the instance's own IP address.

Use the "server" argument to specify an external proxy for Browserless to use for requests. For requests with authentication, the username and password should be included in the URL using Basic Authentication. See the examples below for more information on how to format those URLs.

**Using the browserless proxy for all requests and proxy through Brazil**

```codeBlockLines_p187
proxy(
  url: "*"
  country: BR
) {
  time
}

```

**Using an external proxy for all requests**

```codeBlockLines_p187
proxy(
  url: "*"
  server: "http://username:password@my-proxy.com:12321"
) {
  time
}

```

**Using the Browserless proxy for only document requests and proxying through France**

```codeBlockLines_p187
proxy(
  url: "*"
  type: document
  country: FR
) {
  time
}

```

```codeBlockLines_p187
proxy(
  country: CountryType
  city: String
  state: String
  sticky: Boolean
  server: String
  method: [Method]
  operator: OperatorTypes = or
  type: [ResourceType]
  url: [String]
): ProxyResponse

```

### Arguments [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/proxy\#arguments "Direct link to Arguments")

#### [`proxy.country`](https://docs.browserless.io/bql-schema/operations/mutations/proxy\#)Â â—Â [`CountryType`](https://docs.browserless.io/bql-schema/types/enums/country-type) enum [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/proxy\#proxycountrycountrytype- "Direct link to proxycountrycountrytype-")

The country you wish to proxy through. Only allowed when using the browserless.io proxy and no `server` argument.

#### [`proxy.city`](https://docs.browserless.io/bql-schema/operations/mutations/proxy\#)Â â—Â [`String`](https://docs.browserless.io/bql-schema/types/scalars/string) scalar [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/proxy\#proxycitystring- "Direct link to proxycitystring-")

The city you wish to proxy through. Any spaces should be removed and all casing lowercase. For instance, "New York City" should be "newyorkcity"

#### [`proxy.state`](https://docs.browserless.io/bql-schema/operations/mutations/proxy\#)Â â—Â [`String`](https://docs.browserless.io/bql-schema/types/scalars/string) scalar [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/proxy\#proxystatestring- "Direct link to proxystatestring-")

The state or provence you wish to proxy through. Any spaces should be removed and all casing lowercase. For instance, "Rhode Island" would be "rhodeisland" and "New Brunswick" would be "newbrunswick"

#### [`proxy.sticky`](https://docs.browserless.io/bql-schema/operations/mutations/proxy\#)Â â—Â [`Boolean`](https://docs.browserless.io/bql-schema/types/scalars/boolean) scalar [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/proxy\#proxystickyboolean- "Direct link to proxystickyboolean-")

Whether or not you want the same IP to be used for subsequent requests matching the pattern

#### [`proxy.server`](https://docs.browserless.io/bql-schema/operations/mutations/proxy\#)Â â—Â [`String`](https://docs.browserless.io/bql-schema/types/scalars/string) scalar [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/proxy\#proxyserverstring- "Direct link to proxyserverstring-")

An external proxy to use for these requests matching the specified patterns set in the other arguments. When this is set then `country`, `city`, `state` and `sticky` options will throw errors as these are only valid for the browserless.io proxy network

#### [`proxy.method`](https://docs.browserless.io/bql-schema/operations/mutations/proxy\#)Â â—Â [`[Method]`](https://docs.browserless.io/bql-schema/types/enums/method) listenum [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/proxy\#proxymethodmethod-- "Direct link to proxymethodmethod--")

The Method(s) of the request you'd like to proxy

#### [`proxy.operator`](https://docs.browserless.io/bql-schema/operations/mutations/proxy\#)Â â—Â [`OperatorTypes`](https://docs.browserless.io/bql-schema/types/enums/operator-types) enum [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/proxy\#proxyoperatoroperatortypes- "Direct link to proxyoperatoroperatortypes-")

Whether to "or" conditions together, meaning any condition that matches will be proxied, or "and" them together meaning every condition must match to proxy the request.

#### [`proxy.type`](https://docs.browserless.io/bql-schema/operations/mutations/proxy\#)Â â—Â [`[ResourceType]`](https://docs.browserless.io/bql-schema/types/enums/resource-type) listenum [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/proxy\#proxytyperesourcetype-- "Direct link to proxytyperesourcetype--")

The content-type of the request you'd like to proxy requests to

#### [`proxy.url`](https://docs.browserless.io/bql-schema/operations/mutations/proxy\#)Â â—Â [`[String]`](https://docs.browserless.io/bql-schema/types/scalars/string) listscalar [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/proxy\#proxyurlstring-- "Direct link to proxyurlstring--")

A glob-style URL pattern to match requests, and if matched, are proxied through

### Type [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/proxy\#type "Direct link to Type")

#### [`ProxyResponse`](https://docs.browserless.io/bql-schema/types/objects/proxy-response) object [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/proxy\#proxyresponse- "Direct link to proxyresponse-")

Response returned after setting up the proxy patterns

- [Arguments](https://docs.browserless.io/bql-schema/operations/mutations/proxy#arguments)
- [Type](https://docs.browserless.io/bql-schema/operations/mutations/proxy#type)

---

### querySelector | Browserless.io
Original URL: https://docs.browserless.io/bql-schema/operations/mutations/query-selector

[Skip to main content](https://docs.browserless.io/bql-schema/operations/mutations/query-selector#__docusaurus_skipToContent_fallback)


Passes through certain properties of the browsers' own `document.querySelector` API

Example:

```codeBlockLines_p187
mutation QuerySelector {
  goto(url: "https://example.com") {
    status
  }

  query: querySelector(selector: "h1") {
    innerHTML
  }
}

```

```codeBlockLines_p187
querySelector(
  selector: String!
  timeout: Float
  visible: Boolean = false
): QuerySelectorResponse

```

### Arguments [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/query-selector\#arguments "Direct link to Arguments")

#### [`querySelector.selector`](https://docs.browserless.io/bql-schema/operations/mutations/query-selector\#)Â â—Â [`String!`](https://docs.browserless.io/bql-schema/types/scalars/string) non-nullscalar [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/query-selector\#queryselectorselectorstring-- "Direct link to queryselectorselectorstring--")

#### [`querySelector.timeout`](https://docs.browserless.io/bql-schema/operations/mutations/query-selector\#)Â â—Â [`Float`](https://docs.browserless.io/bql-schema/types/scalars/float) scalar [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/query-selector\#queryselectortimeoutfloat- "Direct link to queryselectortimeoutfloat-")

#### [`querySelector.visible`](https://docs.browserless.io/bql-schema/operations/mutations/query-selector\#)Â â—Â [`Boolean`](https://docs.browserless.io/bql-schema/types/scalars/boolean) scalar [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/query-selector\#queryselectorvisibleboolean- "Direct link to queryselectorvisibleboolean-")

### Type [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/query-selector\#type "Direct link to Type")

#### [`QuerySelectorResponse`](https://docs.browserless.io/bql-schema/types/objects/query-selector-response) object [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/query-selector\#queryselectorresponse- "Direct link to queryselectorresponse-")

The response returned after querying the page for a selector

- [Arguments](https://docs.browserless.io/bql-schema/operations/mutations/query-selector#arguments)
- [Type](https://docs.browserless.io/bql-schema/operations/mutations/query-selector#type)

---

### querySelectorAll | Browserless.io
Original URL: https://docs.browserless.io/bql-schema/operations/mutations/query-selector-all

[Skip to main content](https://docs.browserless.io/bql-schema/operations/mutations/query-selector-all#__docusaurus_skipToContent_fallback)


Passes through certain properties of the browsers' own `document.querySelectorAll` API

Example:

````codeBlockLines_p187
mutation QuerySelectorAll &#x007B;
  goto(url: "https://example.com") &#x007B;
    status
  &#x007D;

  query: querySelectorAll(selector: "h1") &#x007B;
    innerHTML
  &#x007D;
&#x007D;

```graphql
querySelectorAll(
selector: String!
timeout: Float
visible: Boolean = false
): [QuerySelectorResponse]

````

### Arguments [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/query-selector-all\#arguments "Direct link to Arguments")

#### [`querySelectorAll.selector`](https://docs.browserless.io/bql-schema/operations/mutations/query-selector-all\#)Â â—Â [`String!`](https://docs.browserless.io/bql-schema/types/scalars/string) non-nullscalar [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/query-selector-all\#queryselectorallselectorstring-- "Direct link to queryselectorallselectorstring--")

#### [`querySelectorAll.timeout`](https://docs.browserless.io/bql-schema/operations/mutations/query-selector-all\#)Â â—Â [`Float`](https://docs.browserless.io/bql-schema/types/scalars/float) scalar [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/query-selector-all\#queryselectoralltimeoutfloat- "Direct link to queryselectoralltimeoutfloat-")

#### [`querySelectorAll.visible`](https://docs.browserless.io/bql-schema/operations/mutations/query-selector-all\#)Â â—Â [`Boolean`](https://docs.browserless.io/bql-schema/types/scalars/boolean) scalar [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/query-selector-all\#queryselectorallvisibleboolean- "Direct link to queryselectorallvisibleboolean-")

### Type [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/query-selector-all\#type "Direct link to Type")

#### [`QuerySelectorResponse`](https://docs.browserless.io/bql-schema/types/objects/query-selector-response) object [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/query-selector-all\#queryselectorresponse- "Direct link to queryselectorresponse-")

The response returned after querying the page for a selector

- [Arguments](https://docs.browserless.io/bql-schema/operations/mutations/query-selector-all#arguments)
- [Type](https://docs.browserless.io/bql-schema/operations/mutations/query-selector-all#type)

---

### reconnect | Browserless.io
Original URL: https://docs.browserless.io/bql-schema/operations/mutations/reconnect

[Skip to main content](https://docs.browserless.io/bql-schema/operations/mutations/reconnect#__docusaurus_skipToContent_fallback)


Returns a payload with reconnection information in order to reconnect back to the same browser session

Example:

```codeBlockLines_p187
mutation Reconnect {
  goto(url: "https://example.com") {
    status
  }

  reconnect(timeout: 30000) {
    browserQLEndpoint
    browserWSEndpoint
    devtoolsFrontendUrl
    webSocketDebuggerUrl
  }
}

```

```codeBlockLines_p187
reconnect(
  timeout: Float = 30000
): ReconnectionResponse

```

### Arguments [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/reconnect\#arguments "Direct link to Arguments")

#### [`reconnect.timeout`](https://docs.browserless.io/bql-schema/operations/mutations/reconnect\#)Â â—Â [`Float`](https://docs.browserless.io/bql-schema/types/scalars/float) scalar [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/reconnect\#reconnecttimeoutfloat- "Direct link to reconnecttimeoutfloat-")

The amount of time, in milliseconds, to leave the browser open without a connection before it is manually terminated. Defaults to 30 seconds

### Type [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/reconnect\#type "Direct link to Type")

#### [`ReconnectionResponse`](https://docs.browserless.io/bql-schema/types/objects/reconnection-response) object [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/reconnect\#reconnectionresponse- "Direct link to reconnectionresponse-")

The response received after attempting to reconnect a BrowserQL session

- [Arguments](https://docs.browserless.io/bql-schema/operations/mutations/reconnect#arguments)
- [Type](https://docs.browserless.io/bql-schema/operations/mutations/reconnect#type)

---

### reject | Browserless.io
Original URL: https://docs.browserless.io/bql-schema/operations/mutations/reject

[Skip to main content](https://docs.browserless.io/bql-schema/operations/mutations/reject#__docusaurus_skipToContent_fallback)


Rejects requests by a specified URL pattern, method, or type and operator. You may supply a single pattern, or a list (array) of them. This mutation, by default, will reject any requests that match _any_ pattern, which we call an "or" operator. To reject requests where conditions must all match, specify an "and" operator in the mutation. Note that this only has an effect when the query is executing, so scripts that return quickly will likely see assets loading in the editor as these rejections only happen when mutations are executing.

* * *

**Rejecting images or media**

```codeBlockLines_p187
mutation RejectImages {
  reject(type: [image, media]) {
    enabled
    time
  }
  goto(url: "https://cnn.com"
  waitUntil: firstContentfulPaint) {
    status
    time
  }
}

```

* * *

**Rejecting media when coming from google.com domain**

```codeBlockLines_p187
mutation Reject {
  reject(
    operator: and
    type: image
    url: "*google.com*"
  ) {
    enabled
    time
  }
  goto(url: "https://cnn.com"
  waitUntil: firstContentfulPaint) {
    status
    time
  }
}

```

```codeBlockLines_p187
reject(
  enabled: Boolean = true
  method: [Method]
  operator: OperatorTypes = or
  type: [ResourceType]
  url: [String]
): RejectResponse

```

### Arguments [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/reject\#arguments "Direct link to Arguments")

#### [`reject.enabled`](https://docs.browserless.io/bql-schema/operations/mutations/reject\#)Â â—Â [`Boolean`](https://docs.browserless.io/bql-schema/types/scalars/boolean) scalar [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/reject\#rejectenabledboolean- "Direct link to rejectenabledboolean-")

Whether or not to enable request rejections

#### [`reject.method`](https://docs.browserless.io/bql-schema/operations/mutations/reject\#)Â â—Â [`[Method]`](https://docs.browserless.io/bql-schema/types/enums/method) listenum [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/reject\#rejectmethodmethod-- "Direct link to rejectmethodmethod--")

The Method of the request you'd like to reject

#### [`reject.operator`](https://docs.browserless.io/bql-schema/operations/mutations/reject\#)Â â—Â [`OperatorTypes`](https://docs.browserless.io/bql-schema/types/enums/operator-types) enum [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/reject\#rejectoperatoroperatortypes- "Direct link to rejectoperatoroperatortypes-")

Whether to "or" conditions together, meaning any condition that matches will be rejected, or "and" them together meaning every condition must match to reject the request.

#### [`reject.type`](https://docs.browserless.io/bql-schema/operations/mutations/reject\#)Â â—Â [`[ResourceType]`](https://docs.browserless.io/bql-schema/types/enums/resource-type) listenum [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/reject\#rejecttyperesourcetype-- "Direct link to rejecttyperesourcetype--")

The type of resource you'd like to reject request to

#### [`reject.url`](https://docs.browserless.io/bql-schema/operations/mutations/reject\#)Â â—Â [`[String]`](https://docs.browserless.io/bql-schema/types/scalars/string) listscalar [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/reject\#rejecturlstring-- "Direct link to rejecturlstring--")

The glob-style URL pattern you'd like to reject requests to

### Type [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/reject\#type "Direct link to Type")

#### [`RejectResponse`](https://docs.browserless.io/bql-schema/types/objects/reject-response) object [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/reject\#rejectresponse- "Direct link to rejectresponse-")

The response parameters for the reject mutation

- [Arguments](https://docs.browserless.io/bql-schema/operations/mutations/reject#arguments)
- [Type](https://docs.browserless.io/bql-schema/operations/mutations/reject#type)

---

### reload | Browserless.io
Original URL: https://docs.browserless.io/bql-schema/operations/mutations/reload

[Skip to main content](https://docs.browserless.io/bql-schema/operations/mutations/reload#__docusaurus_skipToContent_fallback)


Reloads the given page with an optional waitUntil parameter and timeout parameter

Example:

```codeBlockLines_p187
mutation Reload {
  goto(url: "https://example.com") {
    status
  }
  reload(timeout: 10000) {
    status
  }
}

```

```codeBlockLines_p187
reload(
  timeout: Float
  waitUntil: WaitUntilHistory = load
): HTTPResponse

```

### Arguments [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/reload\#arguments "Direct link to Arguments")

#### [`reload.timeout`](https://docs.browserless.io/bql-schema/operations/mutations/reload\#)Â â—Â [`Float`](https://docs.browserless.io/bql-schema/types/scalars/float) scalar [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/reload\#reloadtimeoutfloat- "Direct link to reloadtimeoutfloat-")

The maximum amount of time, in milliseconds, to wait for the page to load, overriding any defaults. Default timeout is 30 seconds, or 30000.

#### [`reload.waitUntil`](https://docs.browserless.io/bql-schema/operations/mutations/reload\#)Â â—Â [`WaitUntilHistory`](https://docs.browserless.io/bql-schema/types/enums/wait-until-history) enum [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/reload\#reloadwaituntilwaituntilhistory- "Direct link to reloadwaituntilwaituntilhistory-")

When to consider the page fully-loaded and proceed with further execution

### Type [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/reload\#type "Direct link to Type")

#### [`HTTPResponse`](https://docs.browserless.io/bql-schema/types/objects/httpresponse) object [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/reload\#httpresponse- "Direct link to httpresponse-")

Response returned after a navigation event

- [Arguments](https://docs.browserless.io/bql-schema/operations/mutations/reload#arguments)
- [Type](https://docs.browserless.io/bql-schema/operations/mutations/reload#type)

---

### request | Browserless.io
Original URL: https://docs.browserless.io/bql-schema/operations/mutations/request

[Skip to main content](https://docs.browserless.io/bql-schema/operations/mutations/request#__docusaurus_skipToContent_fallback)


Returns request information made by the Browser with optional filters via arguments. You may filter the returned results by a lob-like URL-pattern, the method of the request or the type of request. Applying an operator to this will then change the behavior by either "and"ing the filters together or "or"ing them. This API will automatically wait for the request to be made if none is immediately found which you can turn off by disabling the "wait" option.

**Getting all "Document" requests**

```codeBlockLines_p187
  mutation DocumentRequests {
    goto(url: "https://example.com/", waitUntil: load) {
      status
    }
    request(type:document) {
      url
      type
      method
      headers {
        name
        value
      }
    }
  }

```

**Load all "GET" AJAX Requests**

```codeBlockLines_p187
  mutation AJAXGetCalls {
    goto(url: "https://msn.com/", waitUntil: load) {
      status
    }
    request(type: xhr, method: GET, operator: and) {
      url
      type
      method
      headers {
        name
        value
      }
    }
  }

```

```codeBlockLines_p187
request(
  type: [ResourceType]
  method: [Method]
  timeout: Float
  url: [String]
  wait: Boolean = true
  operator: OperatorTypes = or
): [RequestResponse]

```

### Arguments [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/request\#arguments "Direct link to Arguments")

#### [`request.type`](https://docs.browserless.io/bql-schema/operations/mutations/request\#)Â â—Â [`[ResourceType]`](https://docs.browserless.io/bql-schema/types/enums/resource-type) listenum [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/request\#requesttyperesourcetype-- "Direct link to requesttyperesourcetype--")

The type content-type of the request to match against

#### [`request.method`](https://docs.browserless.io/bql-schema/operations/mutations/request\#)Â â—Â [`[Method]`](https://docs.browserless.io/bql-schema/types/enums/method) listenum [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/request\#requestmethodmethod-- "Direct link to requestmethodmethod--")

The method of the request to return results for

#### [`request.timeout`](https://docs.browserless.io/bql-schema/operations/mutations/request\#)Â â—Â [`Float`](https://docs.browserless.io/bql-schema/types/scalars/float) scalar [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/request\#requesttimeoutfloat- "Direct link to requesttimeoutfloat-")

How long to wait for the request(s) to be made before timing out, overriding any defaults. Default timeout is 30 seconds, or 30000. "wait" parameter must also be "true".

#### [`request.url`](https://docs.browserless.io/bql-schema/operations/mutations/request\#)Â â—Â [`[String]`](https://docs.browserless.io/bql-schema/types/scalars/string) listscalar [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/request\#requesturlstring-- "Direct link to requesturlstring--")

The pattern of the request URL to wait for, using glob-style pattern-matching

#### [`request.wait`](https://docs.browserless.io/bql-schema/operations/mutations/request\#)Â â—Â [`Boolean`](https://docs.browserless.io/bql-schema/types/scalars/boolean) scalar [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/request\#requestwaitboolean- "Direct link to requestwaitboolean-")

Whether or not to wait for the request to be made. When set to `true`, generally only one request is returned since this API will wait for the first request that matches any patterns to be returned

#### [`request.operator`](https://docs.browserless.io/bql-schema/operations/mutations/request\#)Â â—Â [`OperatorTypes`](https://docs.browserless.io/bql-schema/types/enums/operator-types) enum [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/request\#requestoperatoroperatortypes- "Direct link to requestoperatoroperatortypes-")

When applying arguments like URL or method, this operator will either "and" them together, or "or" them together. Default is "or"

### Type [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/request\#type "Direct link to Type")

#### [`RequestResponse`](https://docs.browserless.io/bql-schema/types/objects/request-response) object [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/request\#requestresponse- "Direct link to requestresponse-")

Response returned from the request API

- [Arguments](https://docs.browserless.io/bql-schema/operations/mutations/request#arguments)
- [Type](https://docs.browserless.io/bql-schema/operations/mutations/request#type)

---

### response | Browserless.io
Original URL: https://docs.browserless.io/bql-schema/operations/mutations/response

[Skip to main content](https://docs.browserless.io/bql-schema/operations/mutations/response#__docusaurus_skipToContent_fallback)


Returns response information, filtered by the provided arguments, made by the browser. You may optionally filter the returned results by a glob-like URL-pattern, the Method of the response or the Type of response. Applying an operator to this will then change the behavior by either "and"ing the filters together, or "or"ing them. This API will automatically wait for the response to be made if none is immediately found which you can turn off by disabling the "wait" option.

**Getting all "Document" responses**

```codeBlockLines_p187
  mutation DocumentResponses{
    goto(url: "https://example.com/", waitUntil: load) {
      status
    }
    response(type:document) {
      url
      body
      headers {
        name
        value
      }
    }
  }

```

**Load all "GET" AJAX Responses**

```codeBlockLines_p187
  mutation AJAXGetCalls {
    goto(url: "https://msn.com/", waitUntil: load) {
      status
    }
    response(type: xhr, method: GET, operator: and) {
      url
      type
      method
      body
      headers {
        name
        value
      }
    }
  }

```

```codeBlockLines_p187
response(
  status: [Int]
  method: [Method]
  operator: OperatorTypes = or
  timeout: Float
  type: [ResourceType]
  url: [String]
  wait: Boolean = true
): [ResponseResponse]

```

### Arguments [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/response\#arguments "Direct link to Arguments")

#### [`response.status`](https://docs.browserless.io/bql-schema/operations/mutations/response\#)Â â—Â [`[Int]`](https://docs.browserless.io/bql-schema/types/scalars/int) listscalar [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/response\#responsestatusint-- "Direct link to responsestatusint--")

The status codes response to return results for

#### [`response.method`](https://docs.browserless.io/bql-schema/operations/mutations/response\#)Â â—Â [`[Method]`](https://docs.browserless.io/bql-schema/types/enums/method) listenum [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/response\#responsemethodmethod-- "Direct link to responsemethodmethod--")

The method of the response to return results for

#### [`response.operator`](https://docs.browserless.io/bql-schema/operations/mutations/response\#)Â â—Â [`OperatorTypes`](https://docs.browserless.io/bql-schema/types/enums/operator-types) enum [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/response\#responseoperatoroperatortypes- "Direct link to responseoperatoroperatortypes-")

When applying arguments like URL or method, this operator will either "and" them together, or "or" them together. Default is "or"

#### [`response.timeout`](https://docs.browserless.io/bql-schema/operations/mutations/response\#)Â â—Â [`Float`](https://docs.browserless.io/bql-schema/types/scalars/float) scalar [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/response\#responsetimeoutfloat- "Direct link to responsetimeoutfloat-")

How long to wait for the response(s) to be made before timing out, overriding any defaults. Default timeout is 30 seconds, or 30000. "wait" parameter must also be "true".

#### [`response.type`](https://docs.browserless.io/bql-schema/operations/mutations/response\#)Â â—Â [`[ResourceType]`](https://docs.browserless.io/bql-schema/types/enums/resource-type) listenum [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/response\#responsetyperesourcetype-- "Direct link to responsetyperesourcetype--")

The type content-type of the response to match against

#### [`response.url`](https://docs.browserless.io/bql-schema/operations/mutations/response\#)Â â—Â [`[String]`](https://docs.browserless.io/bql-schema/types/scalars/string) listscalar [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/response\#responseurlstring-- "Direct link to responseurlstring--")

The pattern of the response URL to wait for, using glob-style pattern-matching

#### [`response.wait`](https://docs.browserless.io/bql-schema/operations/mutations/response\#)Â â—Â [`Boolean`](https://docs.browserless.io/bql-schema/types/scalars/boolean) scalar [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/response\#responsewaitboolean- "Direct link to responsewaitboolean-")

Whether or not to wait for the response to be received. When set to `true`, generally only one response is returned since this API will wait for the first response that matches any patterns to be returned

### Type [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/response\#type "Direct link to Type")

#### [`ResponseResponse`](https://docs.browserless.io/bql-schema/types/objects/response-response) object [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/response\#responseresponse- "Direct link to responseresponse-")

Response returned from the response API

- [Arguments](https://docs.browserless.io/bql-schema/operations/mutations/response#arguments)
- [Type](https://docs.browserless.io/bql-schema/operations/mutations/response#type)

---

### screenshot | Browserless.io
Original URL: https://docs.browserless.io/bql-schema/operations/mutations/screenshot

[Skip to main content](https://docs.browserless.io/bql-schema/operations/mutations/screenshot#__docusaurus_skipToContent_fallback)


Screenshots the page or a specific selector

Example:

```codeBlockLines_p187
mutation Screenshot {
  goto(url: "https://example.com") {
    status
  }

  screenshot {
    base64
  }
}

```

```codeBlockLines_p187
screenshot(
  captureBeyondViewport: Boolean
  clip: ScreenshotClip
  fromSurface: Boolean
  fullPage: Boolean
  omitBackground: Boolean
  optimizeForSpeed: Boolean
  quality: Float
  selector: String
  type: ScreenshotType
  timeout: Float
): ScreenshotResponse

```

### Arguments [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/screenshot\#arguments "Direct link to Arguments")

#### [`screenshot.captureBeyondViewport`](https://docs.browserless.io/bql-schema/operations/mutations/screenshot\#)Â â—Â [`Boolean`](https://docs.browserless.io/bql-schema/types/scalars/boolean) scalar [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/screenshot\#screenshotcapturebeyondviewportboolean- "Direct link to screenshotcapturebeyondviewportboolean-")

Capture the screenshot beyond the viewport.
Default: False if there is no clip. True otherwise

#### [`screenshot.clip`](https://docs.browserless.io/bql-schema/operations/mutations/screenshot\#)Â â—Â [`ScreenshotClip`](https://docs.browserless.io/bql-schema/types/inputs/screenshot-clip) input [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/screenshot\#screenshotclipscreenshotclip- "Direct link to screenshotclipscreenshotclip-")

Specifies the region of the page/element to clip

#### [`screenshot.fromSurface`](https://docs.browserless.io/bql-schema/operations/mutations/screenshot\#)Â â—Â [`Boolean`](https://docs.browserless.io/bql-schema/types/scalars/boolean) scalar [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/screenshot\#screenshotfromsurfaceboolean- "Direct link to screenshotfromsurfaceboolean-")

Capture the screenshot from the surface, rather than the view.
Default: True

#### [`screenshot.fullPage`](https://docs.browserless.io/bql-schema/operations/mutations/screenshot\#)Â â—Â [`Boolean`](https://docs.browserless.io/bql-schema/types/scalars/boolean) scalar [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/screenshot\#screenshotfullpageboolean- "Direct link to screenshotfullpageboolean-")

When True, takes a screenshot of the full page.
Default: False

#### [`screenshot.omitBackground`](https://docs.browserless.io/bql-schema/operations/mutations/screenshot\#)Â â—Â [`Boolean`](https://docs.browserless.io/bql-schema/types/scalars/boolean) scalar [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/screenshot\#screenshotomitbackgroundboolean- "Direct link to screenshotomitbackgroundboolean-")

Hides default white background and allows capturing screenshots with transparency.
Default: False

#### [`screenshot.optimizeForSpeed`](https://docs.browserless.io/bql-schema/operations/mutations/screenshot\#)Â â—Â [`Boolean`](https://docs.browserless.io/bql-schema/types/scalars/boolean) scalar [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/screenshot\#screenshotoptimizeforspeedboolean- "Direct link to screenshotoptimizeforspeedboolean-")

Optimize image encoding for speed, not for resulting size.
Default: False

#### [`screenshot.quality`](https://docs.browserless.io/bql-schema/operations/mutations/screenshot\#)Â â—Â [`Float`](https://docs.browserless.io/bql-schema/types/scalars/float) scalar [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/screenshot\#screenshotqualityfloat- "Direct link to screenshotqualityfloat-")

Quality of the image, between 0-100. Not applicable to png images.

#### [`screenshot.selector`](https://docs.browserless.io/bql-schema/operations/mutations/screenshot\#)Â â—Â [`String`](https://docs.browserless.io/bql-schema/types/scalars/string) scalar [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/screenshot\#screenshotselectorstring- "Direct link to screenshotselectorstring-")

The CSS selector of the element on the page you want to screenshot

#### [`screenshot.type`](https://docs.browserless.io/bql-schema/operations/mutations/screenshot\#)Â â—Â [`ScreenshotType`](https://docs.browserless.io/bql-schema/types/enums/screenshot-type) enum [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/screenshot\#screenshottypescreenshottype- "Direct link to screenshottypescreenshottype-")

The final format of the screenshot

#### [`screenshot.timeout`](https://docs.browserless.io/bql-schema/operations/mutations/screenshot\#)Â â—Â [`Float`](https://docs.browserless.io/bql-schema/types/scalars/float) scalar [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/screenshot\#screenshottimeoutfloat- "Direct link to screenshottimeoutfloat-")

The maximum amount of time, in milliseconds, to wait for the screenshot to be taken. Default timeout is 30 seconds, or 30000.

### Type [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/screenshot\#type "Direct link to Type")

#### [`ScreenshotResponse`](https://docs.browserless.io/bql-schema/types/objects/screenshot-response) object [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/screenshot\#screenshotresponse- "Direct link to screenshotresponse-")

The response returned after generating a Screenshot

- [Arguments](https://docs.browserless.io/bql-schema/operations/mutations/screenshot#arguments)
- [Type](https://docs.browserless.io/bql-schema/operations/mutations/screenshot#type)

---

### scroll | Browserless.io
Original URL: https://docs.browserless.io/bql-schema/operations/mutations/scroll

[Skip to main content](https://docs.browserless.io/bql-schema/operations/mutations/scroll#__docusaurus_skipToContent_fallback)


Waits for a selector, then scrolls to it on the page or an x,y coordinate in pixels

Example:

```codeBlockLines_p187
mutation Scroll {
  goto(url: "https://example.com") {
    status
  }

  scroll(selector: "h1") {
    time
  }
}

```

```codeBlockLines_p187
scroll(
  selector: String
  timeout: Float
  visible: Boolean = false
  wait: Boolean = true
  x: Float
  y: Float
): ScrollResponse

```

### Arguments [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/scroll\#arguments "Direct link to Arguments")

#### [`scroll.selector`](https://docs.browserless.io/bql-schema/operations/mutations/scroll\#)Â â—Â [`String`](https://docs.browserless.io/bql-schema/types/scalars/string) scalar [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/scroll\#scrollselectorstring- "Direct link to scrollselectorstring-")

The DOM selector of the element on the page you want to scroll to

#### [`scroll.timeout`](https://docs.browserless.io/bql-schema/operations/mutations/scroll\#)Â â—Â [`Float`](https://docs.browserless.io/bql-schema/types/scalars/float) scalar [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/scroll\#scrolltimeoutfloat- "Direct link to scrolltimeoutfloat-")

How long to wait for the element to appear before timing out, overriding any defaults. Default timeout is 30 seconds, or 30000.

#### [`scroll.visible`](https://docs.browserless.io/bql-schema/operations/mutations/scroll\#)Â â—Â [`Boolean`](https://docs.browserless.io/bql-schema/types/scalars/boolean) scalar [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/scroll\#scrollvisibleboolean- "Direct link to scrollvisibleboolean-")

Whether or not to scroll to the element only if it's visible

#### [`scroll.wait`](https://docs.browserless.io/bql-schema/operations/mutations/scroll\#)Â â—Â [`Boolean`](https://docs.browserless.io/bql-schema/types/scalars/boolean) scalar [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/scroll\#scrollwaitboolean- "Direct link to scrollwaitboolean-")

Whether or not to wait for the element, then scroll to it

#### [`scroll.x`](https://docs.browserless.io/bql-schema/operations/mutations/scroll\#)Â â—Â [`Float`](https://docs.browserless.io/bql-schema/types/scalars/float) scalar [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/scroll\#scrollxfloat- "Direct link to scrollxfloat-")

The X coordinate, in pixels, to scroll to

#### [`scroll.y`](https://docs.browserless.io/bql-schema/operations/mutations/scroll\#)Â â—Â [`Float`](https://docs.browserless.io/bql-schema/types/scalars/float) scalar [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/scroll\#scrollyfloat- "Direct link to scrollyfloat-")

The Y coordinate, in pixels, to scroll to

### Type [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/scroll\#type "Direct link to Type")

#### [`ScrollResponse`](https://docs.browserless.io/bql-schema/types/objects/scroll-response) object [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/scroll\#scrollresponse- "Direct link to scrollresponse-")

Response returned after having scrolling inside the page

- [Arguments](https://docs.browserless.io/bql-schema/operations/mutations/scroll#arguments)
- [Type](https://docs.browserless.io/bql-schema/operations/mutations/scroll#type)

---

### select | Browserless.io
Original URL: https://docs.browserless.io/bql-schema/operations/mutations/select

[Skip to main content](https://docs.browserless.io/bql-schema/operations/mutations/select#__docusaurus_skipToContent_fallback)


Selects a value from a dropdown or multiple select element

Example:

```codeBlockLines_p187
mutation Select {
  goto(url: "https://example.com") {
    status
  }

  single: select(
    selector: "select"
    value: "option1"
  ) {
    time
  }

  multi: select(
    selector: "select"
    value: ["option1", "option2"]
  ) {
    time
  }
}

```

```codeBlockLines_p187
select(
  timeout: Float
  scroll: Boolean = true
  selector: String!
  value: StringOrArray!
  visible: Boolean = false
  wait: Boolean = true
): SelectResponse

```

### Arguments [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/select\#arguments "Direct link to Arguments")

#### [`select.timeout`](https://docs.browserless.io/bql-schema/operations/mutations/select\#)Â â—Â [`Float`](https://docs.browserless.io/bql-schema/types/scalars/float) scalar [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/select\#selecttimeoutfloat- "Direct link to selecttimeoutfloat-")

How long to wait for the element to appear before timing out on the handler, overriding any defaults. Default timeout is 30 seconds, or 30000.

#### [`select.scroll`](https://docs.browserless.io/bql-schema/operations/mutations/select\#)Â â—Â [`Boolean`](https://docs.browserless.io/bql-schema/types/scalars/boolean) scalar [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/select\#selectscrollboolean- "Direct link to selectscrollboolean-")

Whether or not to scroll to the select element prior to selecting, defaults to true

#### [`select.selector`](https://docs.browserless.io/bql-schema/operations/mutations/select\#)Â â—Â [`String!`](https://docs.browserless.io/bql-schema/types/scalars/string) non-nullscalar [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/select\#selectselectorstring-- "Direct link to selectselectorstring--")

The CSS selector of the element on the page you want to select a value from

#### [`select.value`](https://docs.browserless.io/bql-schema/operations/mutations/select\#)Â â—Â [`StringOrArray!`](https://docs.browserless.io/bql-schema/types/scalars/string-or-array) non-nullscalar [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/select\#selectvaluestringorarray-- "Direct link to selectvaluestringorarray--")

The value or values to select from the dropdown or multiple select element

#### [`select.visible`](https://docs.browserless.io/bql-schema/operations/mutations/select\#)Â â—Â [`Boolean`](https://docs.browserless.io/bql-schema/types/scalars/boolean) scalar [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/select\#selectvisibleboolean- "Direct link to selectvisibleboolean-")

Whether or not to select the element only if it's visible

#### [`select.wait`](https://docs.browserless.io/bql-schema/operations/mutations/select\#)Â â—Â [`Boolean`](https://docs.browserless.io/bql-schema/types/scalars/boolean) scalar [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/select\#selectwaitboolean- "Direct link to selectwaitboolean-")

Whether or not to wait for the select to present in the DOM

### Type [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/select\#type "Direct link to Type")

#### [`SelectResponse`](https://docs.browserless.io/bql-schema/types/objects/select-response) object [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/select\#selectresponse- "Direct link to selectresponse-")

The response returned after selecting a value from a dropdown or multiple select element

- [Arguments](https://docs.browserless.io/bql-schema/operations/mutations/select#arguments)
- [Type](https://docs.browserless.io/bql-schema/operations/mutations/select#type)

---

### solve | Browserless.io
Original URL: https://docs.browserless.io/bql-schema/operations/mutations/solve

[Skip to main content](https://docs.browserless.io/bql-schema/operations/mutations/solve#__docusaurus_skipToContent_fallback)


ðŸš¨ **EXPERIMENTAL** ðŸš¨
Solves a captcha or other challenge, specified by the "type" of captcha to solve

Example:

```codeBlockLines_p187
mutation SolveCaptcha {
  goto(url: "https://protected.domain") {
    status
  }

  solve(type: hcaptcha) {
    found
    solved
    time
  }
}

```

```codeBlockLines_p187
solve(
  type: CaptchaTypes!
  timeout: Float
  wait: Boolean = true
): CaptchaResponse

```

### Arguments [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/solve\#arguments "Direct link to Arguments")

#### [`solve.type`](https://docs.browserless.io/bql-schema/operations/mutations/solve\#)Â â—Â [`CaptchaTypes!`](https://docs.browserless.io/bql-schema/types/enums/captcha-types) non-nullenum [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/solve\#solvetypecaptchatypes-- "Direct link to solvetypecaptchatypes--")

An enum of the type of captcha to look for and solve

#### [`solve.timeout`](https://docs.browserless.io/bql-schema/operations/mutations/solve\#)Â â—Â [`Float`](https://docs.browserless.io/bql-schema/types/scalars/float) scalar [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/solve\#solvetimeoutfloat- "Direct link to solvetimeoutfloat-")

A time, in milliseconds, to wait for a captcha to appear. Only valid when wait = true.
If a captcha is found then this timer doesn't have an effect on timing-out the solve

#### [`solve.wait`](https://docs.browserless.io/bql-schema/operations/mutations/solve\#)Â â—Â [`Boolean`](https://docs.browserless.io/bql-schema/types/scalars/boolean) scalar [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/solve\#solvewaitboolean- "Direct link to solvewaitboolean-")

Whether or not to wait for the Captcha to be present on the page

### Type [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/solve\#type "Direct link to Type")

#### [`CaptchaResponse`](https://docs.browserless.io/bql-schema/types/objects/captcha-response) object [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/solve\#captcharesponse- "Direct link to captcharesponse-")

Response returned after a captcha has been solved

- [Arguments](https://docs.browserless.io/bql-schema/operations/mutations/solve#arguments)
- [Type](https://docs.browserless.io/bql-schema/operations/mutations/solve#type)

---

### text | Browserless.io
Original URL: https://docs.browserless.io/bql-schema/operations/mutations/text

[Skip to main content](https://docs.browserless.io/bql-schema/operations/mutations/text#__docusaurus_skipToContent_fallback)


Returns the text content on the given page or by selector when specified

Example:

```codeBlockLines_p187
mutation GetText {
  goto(url: "https://example.com") {
    status
  }

  selector: text(selector: "h1") {
      text
  }

  fullPage: text {
    text
  }
}

```

```codeBlockLines_p187
text(
  timeout: Float
  selector: String
  visible: Boolean = false
  clean: CleanInput
): TextResponse

```

### Arguments [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/text\#arguments "Direct link to Arguments")

#### [`text.timeout`](https://docs.browserless.io/bql-schema/operations/mutations/text\#)Â â—Â [`Float`](https://docs.browserless.io/bql-schema/types/scalars/float) scalar [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/text\#texttimeoutfloat- "Direct link to texttimeoutfloat-")

The maximum amount of time, in milliseconds, to wait for the selector to appear, overriding any defaults. Default timeout is 30 seconds, or 30000.

#### [`text.selector`](https://docs.browserless.io/bql-schema/operations/mutations/text\#)Â â—Â [`String`](https://docs.browserless.io/bql-schema/types/scalars/string) scalar [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/text\#textselectorstring- "Direct link to textselectorstring-")

The DOM selector of the given element you want to return the text of

#### [`text.visible`](https://docs.browserless.io/bql-schema/operations/mutations/text\#)Â â—Â [`Boolean`](https://docs.browserless.io/bql-schema/types/scalars/boolean) scalar [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/text\#textvisibleboolean- "Direct link to textvisibleboolean-")

Whether or not to return the text content of the element only if it's visible

#### [`text.clean`](https://docs.browserless.io/bql-schema/operations/mutations/text\#)Â â—Â [`CleanInput`](https://docs.browserless.io/bql-schema/types/inputs/clean-input) input [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/text\#textcleancleaninput- "Direct link to textcleancleaninput-")

Specifies conditions for "cleaning" the returned text, useful for minimizing the amount of markup returned for cases like LLMs and more. See nested options for parameters.

### Type [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/text\#type "Direct link to Type")

#### [`TextResponse`](https://docs.browserless.io/bql-schema/types/objects/text-response) object [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/text\#textresponse- "Direct link to textresponse-")

Text content of a page

- [Arguments](https://docs.browserless.io/bql-schema/operations/mutations/text#arguments)
- [Type](https://docs.browserless.io/bql-schema/operations/mutations/text#type)

---

### title | Browserless.io
Original URL: https://docs.browserless.io/bql-schema/operations/mutations/title

[Skip to main content](https://docs.browserless.io/bql-schema/operations/mutations/title#__docusaurus_skipToContent_fallback)


Returns the title of the page that the browser is currently at

Example:

```codeBlockLines_p187
mutation GetTitle {
  goto(url: "https://example.com") {
    status
  }

  title {
    title
  }
}

```

```codeBlockLines_p187
title: TitleResponse

```

### Type [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/title\#type "Direct link to Type")

#### [`TitleResponse`](https://docs.browserless.io/bql-schema/types/objects/title-response) object [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/title\#titleresponse- "Direct link to titleresponse-")

Response returned after the page's title has been set or get

- [Type](https://docs.browserless.io/bql-schema/operations/mutations/title#type)

---

### type | Browserless.io
Original URL: https://docs.browserless.io/bql-schema/operations/mutations/type

[Skip to main content](https://docs.browserless.io/bql-schema/operations/mutations/type#__docusaurus_skipToContent_fallback)


Types text into an element by scrolling to it, clicking it, then emitting key events for every character

Example:

```codeBlockLines_p187
mutation Type {
  goto(url: "https://example.com") {
    status
  }

  type(
    text: "Hello, World!"
    selector: "input[type='text']"
  ) {
    time
  }
}

```

```codeBlockLines_p187
type(
  text: String!
  selector: String!
  delay: [Int] = [50, 200]
  interactable: Boolean = true
  scroll: Boolean = true
  timeout: Float
  visible: Boolean = false
  wait: Boolean = true
): TypeResponse

```

### Arguments [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/type\#arguments "Direct link to Arguments")

#### [`type.text`](https://docs.browserless.io/bql-schema/operations/mutations/type\#)Â â—Â [`String!`](https://docs.browserless.io/bql-schema/types/scalars/string) non-nullscalar [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/type\#typetextstring-- "Direct link to typetextstring--")

The text content you want to type into the element

#### [`type.selector`](https://docs.browserless.io/bql-schema/operations/mutations/type\#)Â â—Â [`String!`](https://docs.browserless.io/bql-schema/types/scalars/string) non-nullscalar [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/type\#typeselectorstring-- "Direct link to typeselectorstring--")

The CSS selector of the element on the page you want to type text into

#### [`type.delay`](https://docs.browserless.io/bql-schema/operations/mutations/type\#)Â â—Â [`[Int]`](https://docs.browserless.io/bql-schema/types/scalars/int) listscalar [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/type\#typedelayint-- "Direct link to typedelayint--")

The amount of delay between keystrokes in milliseconds. Values are used as a range and chosen at random

#### [`type.interactable`](https://docs.browserless.io/bql-schema/operations/mutations/type\#)Â â—Â [`Boolean`](https://docs.browserless.io/bql-schema/types/scalars/boolean) scalar [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/type\#typeinteractableboolean- "Direct link to typeinteractableboolean-")

Whether or not to check if element can be interacted with by hovering over it and seeing if the element
is available at that x and y position

#### [`type.scroll`](https://docs.browserless.io/bql-schema/operations/mutations/type\#)Â â—Â [`Boolean`](https://docs.browserless.io/bql-schema/types/scalars/boolean) scalar [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/type\#typescrollboolean- "Direct link to typescrollboolean-")

Whether or not to scroll to the element prior to typing, defaults to true

#### [`type.timeout`](https://docs.browserless.io/bql-schema/operations/mutations/type\#)Â â—Â [`Float`](https://docs.browserless.io/bql-schema/types/scalars/float) scalar [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/type\#typetimeoutfloat- "Direct link to typetimeoutfloat-")

How long to wait for the element to appear before timing out, overriding any defaults. Default timeout is 30 seconds, or 30000.

#### [`type.visible`](https://docs.browserless.io/bql-schema/operations/mutations/type\#)Â â—Â [`Boolean`](https://docs.browserless.io/bql-schema/types/scalars/boolean) scalar [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/type\#typevisibleboolean- "Direct link to typevisibleboolean-")

Whether or not to type into the element only if it's visible

#### [`type.wait`](https://docs.browserless.io/bql-schema/operations/mutations/type\#)Â â—Â [`Boolean`](https://docs.browserless.io/bql-schema/types/scalars/boolean) scalar [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/type\#typewaitboolean- "Direct link to typewaitboolean-")

Whether or not to wait for the element to present in the DOM

### Type [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/type\#type "Direct link to Type")

#### [`TypeResponse`](https://docs.browserless.io/bql-schema/types/objects/type-response) object [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/type\#typeresponse- "Direct link to typeresponse-")

Response returned after having typed into an element

- [Arguments](https://docs.browserless.io/bql-schema/operations/mutations/type#arguments)
- [Type](https://docs.browserless.io/bql-schema/operations/mutations/type#type)

---

### url | Browserless.io
Original URL: https://docs.browserless.io/bql-schema/operations/mutations/url

[Skip to main content](https://docs.browserless.io/bql-schema/operations/mutations/url#__docusaurus_skipToContent_fallback)


Returns the URL of the page that the browser is currently at

Example:

```codeBlockLines_p187
mutation GetURL {
  goto(url: "https://example.com") {
    status
  }

  url {
    url
  }
}

```

```codeBlockLines_p187
url: URLResponse

```

### Type [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/url\#type "Direct link to Type")

#### [`URLResponse`](https://docs.browserless.io/bql-schema/types/objects/urlresponse) object [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/url\#urlresponse- "Direct link to urlresponse-")

Response returned after the URL of the page has been set or get

- [Type](https://docs.browserless.io/bql-schema/operations/mutations/url#type)

---

### verify | Browserless.io
Original URL: https://docs.browserless.io/bql-schema/operations/mutations/verify

[Skip to main content](https://docs.browserless.io/bql-schema/operations/mutations/verify#__docusaurus_skipToContent_fallback)


ðŸš¨ **EXPERIMENTAL** ðŸš¨
Clicks a verification button to assert human-like

Example:

```codeBlockLines_p187
mutation Verify {
  goto(url: "https://protected.domain") {
    status
  }

  verify(type: cloudflare) {
    found
    solved
    time
  }
}

```

```codeBlockLines_p187
verify(
  type: VerifyTypes!
  timeout: Float
  wait: Boolean = true
): CaptchaResponse

```

### Arguments [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/verify\#arguments "Direct link to Arguments")

#### [`verify.type`](https://docs.browserless.io/bql-schema/operations/mutations/verify\#)Â â—Â [`VerifyTypes!`](https://docs.browserless.io/bql-schema/types/enums/verify-types) non-nullenum [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/verify\#verifytypeverifytypes-- "Direct link to verifytypeverifytypes--")

An enum of the type of captcha to look for and solve

#### [`verify.timeout`](https://docs.browserless.io/bql-schema/operations/mutations/verify\#)Â â—Â [`Float`](https://docs.browserless.io/bql-schema/types/scalars/float) scalar [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/verify\#verifytimeoutfloat- "Direct link to verifytimeoutfloat-")

A time, in milliseconds, to wait for a verification to appear. Only valid when wait = true. Default timeout is 30 seconds, or 30000.

#### [`verify.wait`](https://docs.browserless.io/bql-schema/operations/mutations/verify\#)Â â—Â [`Boolean`](https://docs.browserless.io/bql-schema/types/scalars/boolean) scalar [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/verify\#verifywaitboolean- "Direct link to verifywaitboolean-")

Whether or not to wait for the verification to be present on the page

### Type [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/verify\#type "Direct link to Type")

#### [`CaptchaResponse`](https://docs.browserless.io/bql-schema/types/objects/captcha-response) object [â€‹](https://docs.browserless.io/bql-schema/operations/mutations/verify\#captcharesponse- "Direct link to captcharesponse-")

Response returned after a captcha has been solved

- [Arguments](https://docs.browserless.io/bql-schema/operations/mutations/verify#arguments)
- [Type](https://docs.browserless.io/bql-schema/operations/mutations/verify#type)

---

### browser | Browserless.io
Original URL: https://docs.browserless.io/bql-schema/operations/queries/browser

[Skip to main content](https://docs.browserless.io/bql-schema/operations/queries/browser#__docusaurus_skipToContent_fallback)


The Version of the browser

```codeBlockLines_p187
browser: String

```

### Type [â€‹](https://docs.browserless.io/bql-schema/operations/queries/browser\#type "Direct link to Type")

#### [`String`](https://docs.browserless.io/bql-schema/types/scalars/string) scalar [â€‹](https://docs.browserless.io/bql-schema/operations/queries/browser\#string- "Direct link to string-")

The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.

- [Type](https://docs.browserless.io/bql-schema/operations/queries/browser#type)

---

### version | Browserless.io
Original URL: https://docs.browserless.io/bql-schema/operations/queries/version

[Skip to main content](https://docs.browserless.io/bql-schema/operations/queries/version#__docusaurus_skipToContent_fallback)


The Version of this server

```codeBlockLines_p187

```

### Type [â€‹](https://docs.browserless.io/bql-schema/operations/queries/version\#type "Direct link to Type")

#### [`String`](https://docs.browserless.io/bql-schema/types/scalars/string) scalar [â€‹](https://docs.browserless.io/bql-schema/operations/queries/version\#string- "Direct link to string-")

The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.

- [Type](https://docs.browserless.io/bql-schema/operations/queries/version#type)

---

### Responses | Browserless.io
Original URL: https://docs.browserless.io/bql-schema/responses

[Skip to main content](https://docs.browserless.io/bql-schema/responses#__docusaurus_skipToContent_fallback)


This page presents reference for all mutations responses.

## `CaptchaResponse` [â€‹](https://docs.browserless.io/bql-schema/responses\#captcharesponse "Direct link to captcharesponse")

Represents the response structure for solving a captcha.

| **Field** | **Type** | **Description** |
| --- | --- | --- |
| `time` | `Float` | The total time it took to find and solve the captcha. |
| `found` | `Boolean` | Indicates if a captcha was found. |
| `solved` | `Boolean` | Indicates if a captcha was found and solved. |
| `token` | `String` | The solved token of the captcha response, if any is provided. |

## `ClickResponse` [â€‹](https://docs.browserless.io/bql-schema/responses\#clickresponse "Direct link to clickresponse")

Represents the response structure for clicking on an element.

| **Field** | **Type** | **Description** |
| --- | --- | --- |
| `selector` | `String` | The selector text of the clicked element, if specified. |
| `x` | `Float` | The x-coordinate of the click, in pixels, on the page. |
| `y` | `Float` | The y-coordinate of the click, in pixels, on the page. |
| `time` | `Float` | The amount of time, in milliseconds, elapsed since the start of clicking to completion. |

## `CookieResponse` [â€‹](https://docs.browserless.io/bql-schema/responses\#cookieresponse "Direct link to cookieresponse")

Represents the response structure for setting and retrieving cookies.

| **Field** | **Type** | **Description** |
| --- | --- | --- |
| `cookies` | `[StandardCookie]` | A standard cookie object with the values of the set cookies. |
| `time` | `Float` | The time it took to set the cookies. |

## `DefaultResponse` [â€‹](https://docs.browserless.io/bql-schema/responses\#defaultresponse "Direct link to defaultresponse")

Represents the default response structure for methods.

| **Field** | **Type** | **Description** |
| --- | --- | --- |
| `timeout` | `Float` | The default timeout for all methods. |

## `EvaluateResponse` [â€‹](https://docs.browserless.io/bql-schema/responses\#evaluateresponse "Direct link to evaluateresponse")

Represents the response structure for evaluating a script in the browser.

| **Field** | **Type** | **Description** |
| --- | --- | --- |
| `value` | `String` | The returned value of the script, if any. |
| `time` | `Float` | The time it took for the evaluate call to complete. |

## `HTMLResponse` [â€‹](https://docs.browserless.io/bql-schema/responses\#htmlresponse "Direct link to htmlresponse")

Represents the response structure for retrieving a page's HTML content.

| **Field** | **Type** | **Description** |
| --- | --- | --- |
| `html` | `String` | The content of the page's HTML. |
| `time` | `Float` | The amount of time, in milliseconds, elapsed since the start of content retrieval to completion. |

## `HTTPResponse` [â€‹](https://docs.browserless.io/bql-schema/responses\#httpresponse "Direct link to httpresponse")

Represents the HTTP response structure for a page load.

| **Field** | **Type** | **Description** |
| --- | --- | --- |
| `status` | `Int` | The status code of the response from the initial page load. |
| `text` | `String` | The status text of the response from the initial page load, generally `"ok"`. |
| `url` | `String` | The final URL of the page after any potential redirects or URL rewrites. |
| `time` | `Float` | The amount of time, in milliseconds, elapsed since the start of navigation to completion. |

## `HoverResponse` [â€‹](https://docs.browserless.io/bql-schema/responses\#hoverresponse "Direct link to hoverresponse")

Represents the response structure for hovering over an element.

| **Field** | **Type** | **Description** |
| --- | --- | --- |
| `selector` | `String` | The selector text of the hovered element. |
| `x` | `Float` | The x-coordinate in pixels, on the page. |
| `y` | `Float` | The y-coordinate in pixels, on the page. |
| `time` | `Float` | The amount of time, in milliseconds, elapsed since the start to completion. |

## `JavaScriptResponse` [â€‹](https://docs.browserless.io/bql-schema/responses\#javascriptresponse "Direct link to javascriptresponse")

Represents the response structure for enabling or disabling JavaScript on a page.

| **Field** | **Type** | **Description** |
| --- | --- | --- |
| `enabled` | `Boolean` | Whether JavaScript is enabled on the page. |
| `time` | `Float` | The time it took to perform this action. |

## `PDFResponse` [â€‹](https://docs.browserless.io/bql-schema/responses\#pdfresponse "Direct link to pdfresponse")

Represents the response structure for generating a PDF.

| **Field** | **Type** | **Description** |
| --- | --- | --- |
| `base64` | `String` | Base64 encoded PDF content. |
| `size` | `Float` | The size of the resulting PDF in bytes. |
| `time` | `Float` | The time it took to generate the PDF. |

## `QuerySelectorResponse` [â€‹](https://docs.browserless.io/bql-schema/responses\#queryselectorresponse "Direct link to queryselectorresponse")

Represents the response structure for querying an element using `querySelector`.

| **Field** | **Type** | **Description** |
| --- | --- | --- |
| `id` | `String` | The element's identifier, reflecting the `id` global attribute. |
| `childElementCount` | `Float` | The number of child elements of this element. |
| `className` | `String` | The value of the class attribute of the specified element. |
| `innerHTML` | `String` | The HTML or XML markup contained within the element. |
| `innerText` | `String` | The text contained within the element. |
| `localName` | `String` | The local part of the qualified name of the element. |
| `outerHTML` | `String` | The serialized HTML fragment describing the element and its descendants. |

## `ReconnectionResponse` [â€‹](https://docs.browserless.io/bql-schema/responses\#reconnectionresponse "Direct link to reconnectionresponse")

Represents the response structure for reconnecting to a browser session.

| **Field** | **Type** | **Description** |
| --- | --- | --- |
| `browserQLEndpoint` | `String` | The fully-qualified URL to reconnect future BrowserQL sessions. Token information might be required. |
| `browserWSEndpoint` | `String` | The fully-qualified URL of the browserWSEndpoint for use with libraries like Playwright or Puppeteer. Token information might be required. |
| `devtoolsFrontendUrl` | `String` | The fully-qualified URL of the devtools resources for remotely loading Chrome's developer tools. |
| `webSocketDebuggerUrl` | `String` | The underlying page's WebSocketDebuggerUrl for libraries that operate on a page rather than a browser object. |

## `ScrollResponse` [â€‹](https://docs.browserless.io/bql-schema/responses\#scrollresponse "Direct link to scrollresponse")

Represents the response structure for scrolling to an element or coordinate.

| **Field** | **Type** | **Description** |
| --- | --- | --- |
| `selector` | `String` | The CSS selector of the element on the page scrolled to. |
| `x` | `Float` | The x-coordinate, in pixels, to scroll to. |
| `y` | `Float` | The y-coordinate, in pixels, to scroll to. |
| `time` | `Float` | The amount of time, in milliseconds, elapsed since the start of scrolling to completion. |

## `ScreenshotResponse` [â€‹](https://docs.browserless.io/bql-schema/responses\#screenshotresponse "Direct link to screenshotresponse")

Represents the response structure for taking a screenshot.

| **Field** | **Type** | **Description** |
| --- | --- | --- |
| `base64` | `String` | The base64 encoded image of the screenshot. |
| `format` | `String` | The format of the screenshot. |
| `time` | `Float` | The time it took to take the screenshot. |

## `SelectResponse` [â€‹](https://docs.browserless.io/bql-schema/responses\#selectresponse "Direct link to selectresponse")

Represents the response structure for selecting a value from a dropdown or multiple select element.

| **Field** | **Type** | **Description** |
| --- | --- | --- |
| `selector` | `String` | The selector of the element you selected from. |
| `value` | `StringOrArray` | The value or values you selected from the select element. |
| `time` | `Float` | The amount of time, in milliseconds, elapsed since the start of selecting to completion. |

## `TextResponse` [â€‹](https://docs.browserless.io/bql-schema/responses\#textresponse "Direct link to textresponse")

Represents the response structure for retrieving the textual content of a page.

| **Field** | **Type** | **Description** |
| --- | --- | --- |
| `text` | `String` | The textual content of the page. |
| `time` | `Float` | The amount of time, in milliseconds, elapsed since the start of text retrieval to completion. |

## `TitleResponse` [â€‹](https://docs.browserless.io/bql-schema/responses\#titleresponse "Direct link to titleresponse")

Represents the response structure for retrieving the title of the current page.

| **Field** | **Type** | **Description** |
| --- | --- | --- |
| `title` | `String` | The title of the current page. |

## `TypeResponse` [â€‹](https://docs.browserless.io/bql-schema/responses\#typeresponse "Direct link to typeresponse")

Represents the response structure for typing text into an element.

| **Field** | **Type** | **Description** |
| --- | --- | --- |
| `selector` | `String` | The selector of the element you typed into. |
| `text` | `String` | The textual content that was typed. |
| `x` | `Float` | The x-coordinate of the element, in pixels, on the page. |
| `y` | `Float` | The y-coordinate of the element, in pixels, on the page. |
| `time` | `Float` | The amount of time, in milliseconds, elapsed since the start of typing to completion. |

## `URLResponse` [â€‹](https://docs.browserless.io/bql-schema/responses\#urlresponse "Direct link to urlresponse")

Represents the response structure for retrieving the URL of the current page.

| **Field** | **Type** | **Description** |
| --- | --- | --- |
| `url` | `String` | The URL of the current page. |

## `VerifyResponse` [â€‹](https://docs.browserless.io/bql-schema/responses\#verifyresponse "Direct link to verifyresponse")

Represents the response structure for a verification action.

| **Field** | **Type** | **Description** |
| --- | --- | --- |
| `time` | `Float` | The total time it took to find and click the verification. |
| `found` | `Boolean` | Indicates if a verification was found. |
| `solved` | `Boolean` | Indicates if a verification was found and clicked. |

## `WaitForRequest` [â€‹](https://docs.browserless.io/bql-schema/responses\#waitforrequest "Direct link to waitforrequest")

Represents the response structure for waiting for a specific request.

| **Field** | **Type** | **Description** |
| --- | --- | --- |
| `time` | `Float` | The period of time elapsed, in milliseconds, waited for. |
| `url` | `String` | The URL parameter used to match the response with. |

## `WaitForResponse` [â€‹](https://docs.browserless.io/bql-schema/responses\#waitforresponse "Direct link to waitforresponse")

Represents the response structure for waiting for a specific response.

| **Field** | **Type** | **Description** |
| --- | --- | --- |
| `time` | `Float` | The period of time elapsed, in milliseconds, waited for. |
| `status` | `Int` | The status code of the response. |
| `url` | `String` | The URL parameter used to match the response with. |

## `WaitForSelector` [â€‹](https://docs.browserless.io/bql-schema/responses\#waitforselector "Direct link to waitforselector")

Represents the response structure for waiting for a selector.

| **Field** | **Type** | **Description** |
| --- | --- | --- |
| `time` | `Float` | The period of time elapsed, in milliseconds, waited for. |
| `selector` | `String` | The selector waited for. |
| `x` | `Float` | The x-coordinate position, in pixels, left of the viewport. |
| `y` | `Float` | The y-coordinate position, in pixels, top of the viewport. |
| `width` | `Float` | The width, in pixels, of the element. |
| `height` | `Float` | The height, in pixels, of the element. |

## `WaitForTimeout` [â€‹](https://docs.browserless.io/bql-schema/responses\#waitfortimeout "Direct link to waitfortimeout")

Represents the response structure for waiting a specified period.

| **Field** | **Type** | **Description** |
| --- | --- | --- |
| `time` | `Float` | The period of time elapsed, in milliseconds, waited for. |

- [`CaptchaResponse`](https://docs.browserless.io/bql-schema/responses#captcharesponse)
- [`ClickResponse`](https://docs.browserless.io/bql-schema/responses#clickresponse)
- [`CookieResponse`](https://docs.browserless.io/bql-schema/responses#cookieresponse)
- [`DefaultResponse`](https://docs.browserless.io/bql-schema/responses#defaultresponse)
- [`EvaluateResponse`](https://docs.browserless.io/bql-schema/responses#evaluateresponse)
- [`HTMLResponse`](https://docs.browserless.io/bql-schema/responses#htmlresponse)
- [`HTTPResponse`](https://docs.browserless.io/bql-schema/responses#httpresponse)
- [`HoverResponse`](https://docs.browserless.io/bql-schema/responses#hoverresponse)
- [`JavaScriptResponse`](https://docs.browserless.io/bql-schema/responses#javascriptresponse)
- [`PDFResponse`](https://docs.browserless.io/bql-schema/responses#pdfresponse)
- [`QuerySelectorResponse`](https://docs.browserless.io/bql-schema/responses#queryselectorresponse)
- [`ReconnectionResponse`](https://docs.browserless.io/bql-schema/responses#reconnectionresponse)
- [`ScrollResponse`](https://docs.browserless.io/bql-schema/responses#scrollresponse)
- [`ScreenshotResponse`](https://docs.browserless.io/bql-schema/responses#screenshotresponse)
- [`SelectResponse`](https://docs.browserless.io/bql-schema/responses#selectresponse)
- [`TextResponse`](https://docs.browserless.io/bql-schema/responses#textresponse)
- [`TitleResponse`](https://docs.browserless.io/bql-schema/responses#titleresponse)
- [`TypeResponse`](https://docs.browserless.io/bql-schema/responses#typeresponse)
- [`URLResponse`](https://docs.browserless.io/bql-schema/responses#urlresponse)
- [`VerifyResponse`](https://docs.browserless.io/bql-schema/responses#verifyresponse)
- [`WaitForRequest`](https://docs.browserless.io/bql-schema/responses#waitforrequest)
- [`WaitForResponse`](https://docs.browserless.io/bql-schema/responses#waitforresponse)
- [`WaitForSelector`](https://docs.browserless.io/bql-schema/responses#waitforselector)
- [`WaitForTimeout`](https://docs.browserless.io/bql-schema/responses#waitfortimeout)

---

### BrowserQL Schema | Browserless.io
Original URL: https://docs.browserless.io/bql-schema/schema

[Skip to main content](https://docs.browserless.io/bql-schema/schema#__docusaurus_skipToContent_fallback)

This document is a complete technical specification of our full-length GraphQL API, called BrowserQL. This document is designed for developers and engineers that want a precise and low-level understanding of the API structure. For more introductory how-to and getting-started guides, [click here](https://docs.browserless.io/browserql/start).

This GraphQL schema contains every mutation, but to get you started the ones you'll use most will probably include:

- [goto](https://docs.browserless.io/bql-schema/operations/mutations/goto)
- [reject](https://docs.browserless.io/bql-schema/operations/mutations/reject)
- [proxy](https://docs.browserless.io/bql-schema/operations/mutations/proxy)
- [click](https://docs.browserless.io/bql-schema/operations/mutations/click)
- [type](https://docs.browserless.io/bql-schema/operations/mutations/type)
- [html](https://docs.browserless.io/bql-schema/operations/mutations/html)
- [reconnect](https://docs.browserless.io/bql-schema/operations/mutations/reconnect)

---

### Schemas | Browserless.io
Original URL: https://docs.browserless.io/bql-schema/schemas

[Skip to main content](https://docs.browserless.io/bql-schema/schemas#__docusaurus_skipToContent_fallback)


This page presents reference for all remaining schemas.

## `CaptchaTypes` [â€‹](https://docs.browserless.io/bql-schema/schemas\#captchatypes "Direct link to captchatypes")

Represents an enumeration of supported captcha types.

| **Enum Value** | **Description** |
| --- | --- |
| `hcaptcha` | Represents the hCaptcha type. |
| `recaptcha` | Represents the reCaptcha type. |

## `CookieInput` [â€‹](https://docs.browserless.io/bql-schema/schemas\#cookieinput "Direct link to cookieinput")

Represents the structure for defining cookie input properties.

| **Field** | **Type** | **Description** |
| --- | --- | --- |
| `name` | `String!` | The cookie's name. |
| `value` | `String!` | The cookie's value. |
| `url` | `String` | The request-URI to associate with the cookie, affecting default domain, path, source port, and scheme. |
| `domain` | `String` | The domain associated with the cookie. |
| `path` | `String` | The path associated with the cookie. |
| `secure` | `Boolean` | Indicates if the cookie is secure. |
| `httpOnly` | `Boolean` | Indicates if the cookie is HTTP-only. |
| `sameSite` | `CookieSameSite` | Specifies the `SameSite` policy for the cookie. |
| `expires` | `Float` | The expiration date of the cookie as a timestamp. Session cookie if not set. |

## `CookieSameSite` [â€‹](https://docs.browserless.io/bql-schema/schemas\#cookiesamesite "Direct link to cookiesamesite")

Represents an enumeration of supported `SameSite` cookie policies.

| **Enum Value** | **Description** |
| --- | --- |
| `Strict` | Strict `SameSite` policy. |
| `Lax` | Lax `SameSite` policy. |
| `None` | No `SameSite` policy enforced. |

## `Method` [â€‹](https://docs.browserless.io/bql-schema/schemas\#method "Direct link to method")

Represents an enumeration of supported HTTP methods for waiting.

| **Enum Value** | **Description** |
| --- | --- |
| `GET` | HTTP GET method. |
| `HEAD` | HTTP HEAD method. |
| `POST` | HTTP POST method. |
| `PUT` | HTTP PUT method. |
| `DELETE` | HTTP DELETE method. |
| `CONNECT` | HTTP CONNECT method. |
| `OPTIONS` | HTTP OPTIONS method. |
| `TRACE` | HTTP TRACE method. |
| `PATCH` | HTTP PATCH method. |

## `PDFPageFormat` [â€‹](https://docs.browserless.io/bql-schema/schemas\#pdfpageformat "Direct link to pdfpageformat")

Represents an enumeration of supported PDF page formats.

| **Enum Value** | **Dimensions** |
| --- | --- |
| `letter` | 8.5in x 11in |
| `legal` | 8.5in x 14in |
| `tabloid` | 11in x 17in |
| `ledger` | 17in x 11in |
| `a0` | 33.1102in x 46.811in |
| `a1` | 23.3858in x 33.1102in |
| `a2` | 16.5354in x 23.3858in |
| `a3` | 11.6929in x 16.5354in |
| `a4` | 8.2677in x 11.6929in |
| `a5` | 5.8268in x 8.2677in |
| `a6` | 4.1339in x 5.8268in |

## `RequestInput` [â€‹](https://docs.browserless.io/bql-schema/schemas\#requestinput "Direct link to requestinput")

Represents the structure for specifying input for HTTP request monitoring.

| **Field** | **Type** | **Description** |
| --- | --- | --- |
| `url` | `String` | The pattern of the request URL to wait for, using glob-style pattern-matching. |
| `method` | `Method` | The HTTP method of the request. |

## `ResponseInput` [â€‹](https://docs.browserless.io/bql-schema/schemas\#responseinput "Direct link to responseinput")

Represents the structure for specifying input for HTTP response monitoring.

| **Field** | **Type** | **Description** |
| --- | --- | --- |
| `url` | `String` | The pattern of the response URL to wait for, using glob-style pattern-matching. |
| `codes` | `[Int]` | The HTTP response code(s) to wait for. Can be a single HTTP code or a list of desired codes. |

## `ScreenshotClip` [â€‹](https://docs.browserless.io/bql-schema/schemas\#screenshotclip "Direct link to screenshotclip")

Represents the structure for specifying a region to clip in a screenshot.

| **Field** | **Type** | **Description** |
| --- | --- | --- |
| `x` | `Float` | The x-coordinate to start clipping, in pixels. |
| `y` | `Float` | The y-coordinate to start clipping, in pixels. |
| `width` | `Float` | The width of the clip, in pixels. |
| `height` | `Float` | The height of the clip, in pixels. |
| `scale` | `Float` | The scale factor of the clip. |

## `ScreenshotType` [â€‹](https://docs.browserless.io/bql-schema/schemas\#screenshottype "Direct link to screenshottype")

Represents an enumeration of supported screenshot formats.

| **Enum Value** | **Description** |
| --- | --- |
| `jpeg` | JPEG image format. |
| `png` | PNG image format. |
| `webp` | WEBP image format. |

## `StandardCookie` [â€‹](https://docs.browserless.io/bql-schema/schemas\#standardcookie "Direct link to standardcookie")

Represents the structure of a standard cookie object.

| **Field** | **Type** | **Description** |
| --- | --- | --- |
| `name` | `String!` | The cookie's name. |
| `value` | `String!` | The cookie's value. |
| `url` | `String` | The request-URI to associate with the cookie, affecting default domain, path, source port, and scheme. |
| `domain` | `String` | The domain associated with the cookie. |
| `path` | `String` | The path associated with the cookie. |
| `secure` | `Boolean` | Indicates if the cookie is secure. |
| `httpOnly` | `Boolean` | Indicates if the cookie is HTTP-only. |
| `sameSite` | `CookieSameSite` | Specifies the `SameSite` policy for the cookie. |
| `expires` | `Float` | The expiration date of the cookie as a timestamp. Session cookie if not set. |

## `VerifyTypes` [â€‹](https://docs.browserless.io/bql-schema/schemas\#verifytypes "Direct link to verifytypes")

Represents an enumeration of supported verification types.

| **Enum Value** | **Description** |
| --- | --- |
| `cloudflare` | Represents the Cloudflare verification type. |

## `WaitUntilGoto` [â€‹](https://docs.browserless.io/bql-schema/schemas\#waituntilgoto "Direct link to waituntilgoto")

Represents an enumeration of options for determining when the page is considered loaded.

| **Enum Value** | **Description** |
| --- | --- |
| `commit` | Fired when a network response is received and the document starts loading. |
| `domContentLoaded` | Fired when the `DOMContentLoaded` event is fired. |
| `load` | Fired when the `load` event occurs. |
| `firstMeaningfulPaint` | Indicates when the primary content of the page is visible to the user. |
| `firstContentfulPaint` | The render time of the largest image or text block visible in the viewport. |
| `networkIdle` | Fired when there are no network connections for at least 500 ms. Use with caution. |
| `interactiveTime` | Chrome's best guess as to when the page becomes interactable. Use with caution. |

## `WaitUntilHistory` [â€‹](https://docs.browserless.io/bql-schema/schemas\#waituntilhistory "Direct link to waituntilhistory")

Represents an enumeration of options for determining when the history event occurs.

| **Enum Value** | **Description** |
| --- | --- |
| `commit` | Fired when a network response is received and the document starts loading. |
| `domContentLoaded` | Fired when the `DOMContentLoaded` event is fired. |
| `load` | Fired when the `load` event occurs. |
| `networkIdle` | Fired when there are no network connections for at least 500 ms. Use with caution. |

- [`CaptchaTypes`](https://docs.browserless.io/bql-schema/schemas#captchatypes)
- [`CookieInput`](https://docs.browserless.io/bql-schema/schemas#cookieinput)
- [`CookieSameSite`](https://docs.browserless.io/bql-schema/schemas#cookiesamesite)
- [`Method`](https://docs.browserless.io/bql-schema/schemas#method)
- [`PDFPageFormat`](https://docs.browserless.io/bql-schema/schemas#pdfpageformat)
- [`RequestInput`](https://docs.browserless.io/bql-schema/schemas#requestinput)
- [`ResponseInput`](https://docs.browserless.io/bql-schema/schemas#responseinput)
- [`ScreenshotClip`](https://docs.browserless.io/bql-schema/schemas#screenshotclip)
- [`ScreenshotType`](https://docs.browserless.io/bql-schema/schemas#screenshottype)
- [`StandardCookie`](https://docs.browserless.io/bql-schema/schemas#standardcookie)
- [`VerifyTypes`](https://docs.browserless.io/bql-schema/schemas#verifytypes)
- [`WaitUntilGoto`](https://docs.browserless.io/bql-schema/schemas#waituntilgoto)
- [`WaitUntilHistory`](https://docs.browserless.io/bql-schema/schemas#waituntilhistory)

---

### deprecated | Browserless.io
Original URL: https://docs.browserless.io/bql-schema/types/directives/deprecated

[Skip to main content](https://docs.browserless.io/bql-schema/types/directives/deprecated#__docusaurus_skipToContent_fallback)


Marks an element of a GraphQL schema as no longer supported.

```codeBlockLines_p187
directive @deprecated(
  reason: String = "No longer supported"
) on
  | FIELD_DEFINITION
  | ARGUMENT_DEFINITION
  | INPUT_FIELD_DEFINITION
  | ENUM_VALUE

```

### Arguments [â€‹](https://docs.browserless.io/bql-schema/types/directives/deprecated\#arguments "Direct link to Arguments")

#### [`deprecated.reason`](https://docs.browserless.io/bql-schema/types/directives/deprecated\#)Â â—Â [`String`](https://docs.browserless.io/bql-schema/types/scalars/string) scalar [â€‹](https://docs.browserless.io/bql-schema/types/directives/deprecated\#deprecatedreasonstring- "Direct link to deprecatedreasonstring-")

Explains why this element was deprecated, usually also including a suggestion for how to access supported similar data. Formatted using the Markdown syntax, as specified by [CommonMark](https://commonmark.org/).

- [Arguments](https://docs.browserless.io/bql-schema/types/directives/deprecated#arguments)

---

### oneOf | Browserless.io
Original URL: https://docs.browserless.io/bql-schema/types/directives/one-of

[Skip to main content](https://docs.browserless.io/bql-schema/types/directives/one-of#__docusaurus_skipToContent_fallback)

Indicates exactly one field must be supplied and this field must not be `null`.

```codeBlockLines_p187
directive @oneOf on INPUT_OBJECT

```

---

### specifiedBy | Browserless.io
Original URL: https://docs.browserless.io/bql-schema/types/directives/specified-by

[Skip to main content](https://docs.browserless.io/bql-schema/types/directives/specified-by#__docusaurus_skipToContent_fallback)


Exposes a URL that specifies the behavior of this scalar.

```codeBlockLines_p187
directive @specifiedBy(
  url: String!
) on SCALAR

```

### Arguments [â€‹](https://docs.browserless.io/bql-schema/types/directives/specified-by\#arguments "Direct link to Arguments")

#### [`specifiedBy.url`](https://docs.browserless.io/bql-schema/types/directives/specified-by\#)Â â—Â [`String!`](https://docs.browserless.io/bql-schema/types/scalars/string) non-nullscalar [â€‹](https://docs.browserless.io/bql-schema/types/directives/specified-by\#specifiedbyurlstring-- "Direct link to specifiedbyurlstring--")

The URL that specifies the behavior of this scalar.

- [Arguments](https://docs.browserless.io/bql-schema/types/directives/specified-by#arguments)

---

### CaptchaTypes | Browserless.io
Original URL: https://docs.browserless.io/bql-schema/types/enums/captcha-types

[Skip to main content](https://docs.browserless.io/bql-schema/types/enums/captcha-types#__docusaurus_skipToContent_fallback)


The different types of captchas that can be solved

```codeBlockLines_p187
enum CaptchaTypes {
  hcaptcha
  recaptcha
}

```

### Values [â€‹](https://docs.browserless.io/bql-schema/types/enums/captcha-types\#values "Direct link to Values")

#### [`CaptchaTypes.hcaptcha`](https://docs.browserless.io/bql-schema/types/enums/captcha-types\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/captcha-types\#captchatypeshcaptcha "Direct link to captchatypeshcaptcha")

hCaptcha captcha type

#### [`CaptchaTypes.recaptcha`](https://docs.browserless.io/bql-schema/types/enums/captcha-types\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/captcha-types\#captchatypesrecaptcha "Direct link to captchatypesrecaptcha")

reCAPTCHA captcha type

### Member Of [â€‹](https://docs.browserless.io/bql-schema/types/enums/captcha-types\#member-of "Direct link to Member Of")

[`solve`](https://docs.browserless.io/bql-schema/operations/mutations/solve) mutation

- [Values](https://docs.browserless.io/bql-schema/types/enums/captcha-types#values)
- [Member Of](https://docs.browserless.io/bql-schema/types/enums/captcha-types#member-of)

---

### CookieSameSite | Browserless.io
Original URL: https://docs.browserless.io/bql-schema/types/enums/cookie-same-site

[Skip to main content](https://docs.browserless.io/bql-schema/types/enums/cookie-same-site#__docusaurus_skipToContent_fallback)


The values a cookie's SameSite attribute can hold

```codeBlockLines_p187
enum CookieSameSite {
  Strict
  Lax
  None
}

```

### Values [â€‹](https://docs.browserless.io/bql-schema/types/enums/cookie-same-site\#values "Direct link to Values")

#### [`CookieSameSite.Strict`](https://docs.browserless.io/bql-schema/types/enums/cookie-same-site\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/cookie-same-site\#cookiesamesitestrict "Direct link to cookiesamesitestrict")

Cookies are only sent in a first-party context and not sent along with requests initiated by third party websites

#### [`CookieSameSite.Lax`](https://docs.browserless.io/bql-schema/types/enums/cookie-same-site\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/cookie-same-site\#cookiesamesitelax "Direct link to cookiesamesitelax")

Cookies are withheld on cross-site sub-requests, such as calls to load images or frames, but are sent when a user navigates to the URL from an external site

#### [`CookieSameSite.None`](https://docs.browserless.io/bql-schema/types/enums/cookie-same-site\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/cookie-same-site\#cookiesamesitenone "Direct link to cookiesamesitenone")

Cookies are sent in all contexts, in responses to both first-party and cross-origin requests

### Member Of [â€‹](https://docs.browserless.io/bql-schema/types/enums/cookie-same-site\#member-of "Direct link to Member Of")

[`CookieInput`](https://docs.browserless.io/bql-schema/types/inputs/cookie-input) inputÂ â—Â [`StandardCookie`](https://docs.browserless.io/bql-schema/types/objects/standard-cookie) object

- [Values](https://docs.browserless.io/bql-schema/types/enums/cookie-same-site#values)
- [Member Of](https://docs.browserless.io/bql-schema/types/enums/cookie-same-site#member-of)

---

### CountryType | Browserless.io
Original URL: https://docs.browserless.io/bql-schema/types/enums/country-type

[Skip to main content](https://docs.browserless.io/bql-schema/types/enums/country-type#__docusaurus_skipToContent_fallback)


The two-letter ISO code for the specified country

```codeBlockLines_p187
enum CountryType {
  AD
  AE
  AF
  AG
  AL
  AM
  AO
  AR
  AT
  AU
  AW
  AX
  AZ
  BA
  BB
  BD
  BE
  BF
  BG
  BH
  BI
  BJ
  BM
  BN
  BO
  BQ
  BR
  BS
  BT
  BW
  BY
  BZ
  CA
  CD
  CG
  CH
  CI
  CL
  CM
  CN
  CO
  CR
  CU
  CV
  CW
  CY
  CZ
  DE
  DJ
  DK
  DM
  DO
  DZ
  EC
  EE
  EG
  ES
  ET
  FI
  FJ
  FO
  FR
  GA
  GB
  GD
  GE
  GF
  GG
  GH
  GI
  GM
  GN
  GP
  GR
  GT
  GU
  GY
  HK
  HN
  HR
  HT
  HU
  ID
  IE
  IL
  IM
  IN
  IQ
  IR
  IS
  IT
  JE
  JM
  JO
  JP
  KE
  KG
  KH
  KN
  KR
  KW
  KY
  KZ
  LA
  LB
  LC
  LI
  LK
  LR
  LS
  LT
  LU
  LV
  LY
  MA
  MC
  MD
  ME
  MG
  MK
  ML
  MM
  MN
  MO
  MQ
  MR
  MS
  MT
  MU
  MV
  MW
  MX
  MY
  MZ
  NA
  NC
  NG
  NI
  NL
  NO
  NP
  NZ
  OM
  PA
  PE
  PF
  PG
  PH
  PK
  PL
  PR
  PS
  PT
  PY
  QA
  RE
  RO
  RS
  RU
  RW
  SC
  SE
  SG
  SI
  SK
  SL
  SM
  SN
  SO
  SR
  SS
  ST
  SV
  SX
  SY
  SZ
  TC
  TG
  TH
  TJ
  TN
  TR
  TT
  TW
  TZ
  UA
  UG
  US
  UY
  UZ
  VC
  VE
  VG
  VI
  VN
  WS
  YT
  ZA
  ZM
  ZW
}

```

### Values [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#values "Direct link to Values")

#### [`CountryType.AD`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypead "Direct link to countrytypead")

Andorra

#### [`CountryType.AE`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypeae "Direct link to countrytypeae")

United Arab Emirates

#### [`CountryType.AF`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypeaf "Direct link to countrytypeaf")

Afghanistan

#### [`CountryType.AG`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypeag "Direct link to countrytypeag")

Antigua and Barbuda

#### [`CountryType.AL`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypeal "Direct link to countrytypeal")

Albania

#### [`CountryType.AM`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypeam "Direct link to countrytypeam")

Armenia

#### [`CountryType.AO`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypeao "Direct link to countrytypeao")

Angola

#### [`CountryType.AR`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypear "Direct link to countrytypear")

Argentina

#### [`CountryType.AT`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypeat "Direct link to countrytypeat")

Austria

#### [`CountryType.AU`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypeau "Direct link to countrytypeau")

Australia

#### [`CountryType.AW`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypeaw "Direct link to countrytypeaw")

Aruba

#### [`CountryType.AX`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypeax "Direct link to countrytypeax")

Ã…land Islands

#### [`CountryType.AZ`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypeaz "Direct link to countrytypeaz")

Azerbaijan

#### [`CountryType.BA`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypeba "Direct link to countrytypeba")

Bosnia and Herzegovina

#### [`CountryType.BB`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypebb "Direct link to countrytypebb")

Barbados

#### [`CountryType.BD`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypebd "Direct link to countrytypebd")

Bangladesh

#### [`CountryType.BE`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypebe "Direct link to countrytypebe")

Belgium

#### [`CountryType.BF`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypebf "Direct link to countrytypebf")

Burkina Faso

#### [`CountryType.BG`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypebg "Direct link to countrytypebg")

Bulgaria

#### [`CountryType.BH`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypebh "Direct link to countrytypebh")

Bahrain

#### [`CountryType.BI`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypebi "Direct link to countrytypebi")

Burundi

#### [`CountryType.BJ`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypebj "Direct link to countrytypebj")

Benin

#### [`CountryType.BM`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypebm "Direct link to countrytypebm")

Bermuda

#### [`CountryType.BN`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypebn "Direct link to countrytypebn")

Brunei Darussalam

#### [`CountryType.BO`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypebo "Direct link to countrytypebo")

Plurinational State of Bolivia

#### [`CountryType.BQ`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypebq "Direct link to countrytypebq")

Sint Eustatius and Saba Bonaire

#### [`CountryType.BR`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypebr "Direct link to countrytypebr")

Brazil

#### [`CountryType.BS`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypebs "Direct link to countrytypebs")

Bahamas

#### [`CountryType.BT`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypebt "Direct link to countrytypebt")

Bhutan

#### [`CountryType.BW`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypebw "Direct link to countrytypebw")

Botswana

#### [`CountryType.BY`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypeby "Direct link to countrytypeby")

Belarus

#### [`CountryType.BZ`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypebz "Direct link to countrytypebz")

Belize

#### [`CountryType.CA`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypeca "Direct link to countrytypeca")

Canada

#### [`CountryType.CD`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypecd "Direct link to countrytypecd")

Congo, The Democratic Republic of the

#### [`CountryType.CG`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypecg "Direct link to countrytypecg")

Congo

#### [`CountryType.CH`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypech "Direct link to countrytypech")

Switzerland

#### [`CountryType.CI`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypeci "Direct link to countrytypeci")

CÃ´te d'Ivoire

#### [`CountryType.CL`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypecl "Direct link to countrytypecl")

Chile

#### [`CountryType.CM`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypecm "Direct link to countrytypecm")

Cameroon

#### [`CountryType.CN`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypecn "Direct link to countrytypecn")

China

#### [`CountryType.CO`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypeco "Direct link to countrytypeco")

Colombia

#### [`CountryType.CR`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypecr "Direct link to countrytypecr")

Costa Rica

#### [`CountryType.CU`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypecu "Direct link to countrytypecu")

Cuba

#### [`CountryType.CV`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypecv "Direct link to countrytypecv")

Cabo Verde

#### [`CountryType.CW`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypecw "Direct link to countrytypecw")

CuraÃ§ao

#### [`CountryType.CY`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypecy "Direct link to countrytypecy")

Cyprus

#### [`CountryType.CZ`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypecz "Direct link to countrytypecz")

Czechia

#### [`CountryType.DE`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypede "Direct link to countrytypede")

Germany

#### [`CountryType.DJ`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypedj "Direct link to countrytypedj")

Djibouti

#### [`CountryType.DK`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypedk "Direct link to countrytypedk")

Denmark

#### [`CountryType.DM`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypedm "Direct link to countrytypedm")

Dominica

#### [`CountryType.DO`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypedo "Direct link to countrytypedo")

Dominican Republic

#### [`CountryType.DZ`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypedz "Direct link to countrytypedz")

Algeria

#### [`CountryType.EC`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypeec "Direct link to countrytypeec")

Ecuador

#### [`CountryType.EE`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypeee "Direct link to countrytypeee")

Estonia

#### [`CountryType.EG`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypeeg "Direct link to countrytypeeg")

Egypt

#### [`CountryType.ES`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypees "Direct link to countrytypees")

Spain

#### [`CountryType.ET`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypeet "Direct link to countrytypeet")

Ethiopia

#### [`CountryType.FI`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypefi "Direct link to countrytypefi")

Finland

#### [`CountryType.FJ`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypefj "Direct link to countrytypefj")

Fiji

#### [`CountryType.FO`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypefo "Direct link to countrytypefo")

Faroe Islands

#### [`CountryType.FR`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypefr "Direct link to countrytypefr")

France

#### [`CountryType.GA`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypega "Direct link to countrytypega")

Gabon

#### [`CountryType.GB`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypegb "Direct link to countrytypegb")

United Kingdom

#### [`CountryType.GD`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypegd "Direct link to countrytypegd")

Grenada

#### [`CountryType.GE`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypege "Direct link to countrytypege")

Georgia

#### [`CountryType.GF`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypegf "Direct link to countrytypegf")

French Guiana

#### [`CountryType.GG`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypegg "Direct link to countrytypegg")

Guernsey

#### [`CountryType.GH`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypegh "Direct link to countrytypegh")

Ghana

#### [`CountryType.GI`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypegi "Direct link to countrytypegi")

Gibraltar

#### [`CountryType.GM`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypegm "Direct link to countrytypegm")

Gambia

#### [`CountryType.GN`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypegn "Direct link to countrytypegn")

Guinea

#### [`CountryType.GP`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypegp "Direct link to countrytypegp")

Guadeloupe

#### [`CountryType.GR`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypegr "Direct link to countrytypegr")

Greece

#### [`CountryType.GT`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypegt "Direct link to countrytypegt")

Guatemala

#### [`CountryType.GU`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypegu "Direct link to countrytypegu")

Guam

#### [`CountryType.GY`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypegy "Direct link to countrytypegy")

Guyana

#### [`CountryType.HK`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypehk "Direct link to countrytypehk")

Hong Kong

#### [`CountryType.HN`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypehn "Direct link to countrytypehn")

Honduras

#### [`CountryType.HR`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypehr "Direct link to countrytypehr")

Croatia

#### [`CountryType.HT`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypeht "Direct link to countrytypeht")

Haiti

#### [`CountryType.HU`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypehu "Direct link to countrytypehu")

Hungary

#### [`CountryType.ID`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypeid "Direct link to countrytypeid")

Indonesia

#### [`CountryType.IE`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypeie "Direct link to countrytypeie")

Ireland

#### [`CountryType.IL`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypeil "Direct link to countrytypeil")

Israel

#### [`CountryType.IM`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypeim "Direct link to countrytypeim")

Isle of Man

#### [`CountryType.IN`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypein "Direct link to countrytypein")

India

#### [`CountryType.IQ`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypeiq "Direct link to countrytypeiq")

Iraq

#### [`CountryType.IR`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypeir "Direct link to countrytypeir")

Iran, Islamic Republic of

#### [`CountryType.IS`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypeis "Direct link to countrytypeis")

Iceland

#### [`CountryType.IT`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypeit "Direct link to countrytypeit")

Italy

#### [`CountryType.JE`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypeje "Direct link to countrytypeje")

Jersey

#### [`CountryType.JM`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypejm "Direct link to countrytypejm")

Jamaica

#### [`CountryType.JO`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypejo "Direct link to countrytypejo")

Jordan

#### [`CountryType.JP`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypejp "Direct link to countrytypejp")

Japan

#### [`CountryType.KE`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypeke "Direct link to countrytypeke")

Kenya

#### [`CountryType.KG`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypekg "Direct link to countrytypekg")

Kyrgyzstan

#### [`CountryType.KH`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypekh "Direct link to countrytypekh")

Cambodia

#### [`CountryType.KN`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypekn "Direct link to countrytypekn")

Saint Kitts and Nevis

#### [`CountryType.KR`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypekr "Direct link to countrytypekr")

Korea, Republic of

#### [`CountryType.KW`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypekw "Direct link to countrytypekw")

Kuwait

#### [`CountryType.KY`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypeky "Direct link to countrytypeky")

Cayman Islands

#### [`CountryType.KZ`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypekz "Direct link to countrytypekz")

Kazakhstan

#### [`CountryType.LA`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypela "Direct link to countrytypela")

Lao People's Democratic Republic

#### [`CountryType.LB`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypelb "Direct link to countrytypelb")

Lebanon

#### [`CountryType.LC`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypelc "Direct link to countrytypelc")

Saint Lucia

#### [`CountryType.LI`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypeli "Direct link to countrytypeli")

Liechtenstein

#### [`CountryType.LK`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypelk "Direct link to countrytypelk")

Sri Lanka

#### [`CountryType.LR`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypelr "Direct link to countrytypelr")

Liberia

#### [`CountryType.LS`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypels "Direct link to countrytypels")

Lesotho

#### [`CountryType.LT`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypelt "Direct link to countrytypelt")

Lithuania

#### [`CountryType.LU`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypelu "Direct link to countrytypelu")

Luxembourg

#### [`CountryType.LV`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypelv "Direct link to countrytypelv")

Latvia

#### [`CountryType.LY`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypely "Direct link to countrytypely")

Libya

#### [`CountryType.MA`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypema "Direct link to countrytypema")

Morocco

#### [`CountryType.MC`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypemc "Direct link to countrytypemc")

Monaco

#### [`CountryType.MD`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypemd "Direct link to countrytypemd")

Moldova, Republic of

#### [`CountryType.ME`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypeme "Direct link to countrytypeme")

Montenegro

#### [`CountryType.MG`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypemg "Direct link to countrytypemg")

Madagascar

#### [`CountryType.MK`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypemk "Direct link to countrytypemk")

North Macedonia

#### [`CountryType.ML`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypeml "Direct link to countrytypeml")

Mali

#### [`CountryType.MM`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypemm "Direct link to countrytypemm")

Myanmar

#### [`CountryType.MN`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypemn "Direct link to countrytypemn")

Mongolia

#### [`CountryType.MO`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypemo "Direct link to countrytypemo")

Macao

#### [`CountryType.MQ`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypemq "Direct link to countrytypemq")

Martinique

#### [`CountryType.MR`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypemr "Direct link to countrytypemr")

Mauritania

#### [`CountryType.MS`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypems "Direct link to countrytypems")

Montserrat

#### [`CountryType.MT`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypemt "Direct link to countrytypemt")

Malta

#### [`CountryType.MU`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypemu "Direct link to countrytypemu")

Mauritius

#### [`CountryType.MV`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypemv "Direct link to countrytypemv")

Maldives

#### [`CountryType.MW`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypemw "Direct link to countrytypemw")

Malawi

#### [`CountryType.MX`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypemx "Direct link to countrytypemx")

Mexico

#### [`CountryType.MY`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypemy "Direct link to countrytypemy")

Malaysia

#### [`CountryType.MZ`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypemz "Direct link to countrytypemz")

Mozambique

#### [`CountryType.NA`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypena "Direct link to countrytypena")

Namibia

#### [`CountryType.NC`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypenc "Direct link to countrytypenc")

New Caledonia

#### [`CountryType.NG`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypeng "Direct link to countrytypeng")

Nigeria

#### [`CountryType.NI`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypeni "Direct link to countrytypeni")

Nicaragua

#### [`CountryType.NL`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypenl "Direct link to countrytypenl")

Netherlands

#### [`CountryType.NO`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypeno "Direct link to countrytypeno")

Norway

#### [`CountryType.NP`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypenp "Direct link to countrytypenp")

Nepal

#### [`CountryType.NZ`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypenz "Direct link to countrytypenz")

New Zealand

#### [`CountryType.OM`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypeom "Direct link to countrytypeom")

Oman

#### [`CountryType.PA`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypepa "Direct link to countrytypepa")

Panama

#### [`CountryType.PE`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypepe "Direct link to countrytypepe")

Peru

#### [`CountryType.PF`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypepf "Direct link to countrytypepf")

French Polynesia

#### [`CountryType.PG`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypepg "Direct link to countrytypepg")

Papua New Guinea

#### [`CountryType.PH`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypeph "Direct link to countrytypeph")

Philippines

#### [`CountryType.PK`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypepk "Direct link to countrytypepk")

Pakistan

#### [`CountryType.PL`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypepl "Direct link to countrytypepl")

Poland

#### [`CountryType.PR`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypepr "Direct link to countrytypepr")

Puerto Rico

#### [`CountryType.PS`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypeps "Direct link to countrytypeps")

Palestine, State of

#### [`CountryType.PT`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypept "Direct link to countrytypept")

Portugal

#### [`CountryType.PY`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypepy "Direct link to countrytypepy")

Paraguay

#### [`CountryType.QA`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypeqa "Direct link to countrytypeqa")

Qatar

#### [`CountryType.RE`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypere "Direct link to countrytypere")

RÃ©union

#### [`CountryType.RO`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypero "Direct link to countrytypero")

Romania

#### [`CountryType.RS`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypers "Direct link to countrytypers")

Serbia

#### [`CountryType.RU`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytyperu "Direct link to countrytyperu")

Russian Federation

#### [`CountryType.RW`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytyperw "Direct link to countrytyperw")

Rwanda

#### [`CountryType.SC`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypesc "Direct link to countrytypesc")

Seychelles

#### [`CountryType.SE`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypese "Direct link to countrytypese")

Sweden

#### [`CountryType.SG`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypesg "Direct link to countrytypesg")

Singapore

#### [`CountryType.SI`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypesi "Direct link to countrytypesi")

Slovenia

#### [`CountryType.SK`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypesk "Direct link to countrytypesk")

Slovakia

#### [`CountryType.SL`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypesl "Direct link to countrytypesl")

Sierra Leone

#### [`CountryType.SM`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypesm "Direct link to countrytypesm")

San Marino

#### [`CountryType.SN`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypesn "Direct link to countrytypesn")

Senegal

#### [`CountryType.SO`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypeso "Direct link to countrytypeso")

Somalia

#### [`CountryType.SR`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypesr "Direct link to countrytypesr")

Suriname

#### [`CountryType.SS`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypess "Direct link to countrytypess")

South Sudan

#### [`CountryType.ST`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypest "Direct link to countrytypest")

Sao Tome and Principe

#### [`CountryType.SV`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypesv "Direct link to countrytypesv")

El Salvador

#### [`CountryType.SX`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypesx "Direct link to countrytypesx")

Sint Maarten (Dutch part)

#### [`CountryType.SY`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypesy "Direct link to countrytypesy")

Syrian Arab Republic

#### [`CountryType.SZ`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypesz "Direct link to countrytypesz")

Eswatini

#### [`CountryType.TC`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypetc "Direct link to countrytypetc")

Turks and Caicos Islands

#### [`CountryType.TG`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypetg "Direct link to countrytypetg")

Togo

#### [`CountryType.TH`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypeth "Direct link to countrytypeth")

Thailand

#### [`CountryType.TJ`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypetj "Direct link to countrytypetj")

Tajikistan

#### [`CountryType.TN`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypetn "Direct link to countrytypetn")

Tunisia

#### [`CountryType.TR`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypetr "Direct link to countrytypetr")

Turkey

#### [`CountryType.TT`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypett "Direct link to countrytypett")

Trinidad and Tobago

#### [`CountryType.TW`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypetw "Direct link to countrytypetw")

Taiwan, Province of China

#### [`CountryType.TZ`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypetz "Direct link to countrytypetz")

United Republic of Tanzania

#### [`CountryType.UA`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypeua "Direct link to countrytypeua")

Ukraine

#### [`CountryType.UG`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypeug "Direct link to countrytypeug")

Uganda

#### [`CountryType.US`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypeus "Direct link to countrytypeus")

United States of America

#### [`CountryType.UY`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypeuy "Direct link to countrytypeuy")

Uruguay

#### [`CountryType.UZ`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypeuz "Direct link to countrytypeuz")

Uzbekistan

#### [`CountryType.VC`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypevc "Direct link to countrytypevc")

Saint Vincent and the Grenadines

#### [`CountryType.VE`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypeve "Direct link to countrytypeve")

Bolivarian Republic of Venezuela

#### [`CountryType.VG`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypevg "Direct link to countrytypevg")

Virgin Islands, British

#### [`CountryType.VI`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypevi "Direct link to countrytypevi")

Virgin Islands, U.S.

#### [`CountryType.VN`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypevn "Direct link to countrytypevn")

Vietnam

#### [`CountryType.WS`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypews "Direct link to countrytypews")

Samoa

#### [`CountryType.YT`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypeyt "Direct link to countrytypeyt")

Mayotte

#### [`CountryType.ZA`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypeza "Direct link to countrytypeza")

South Africa

#### [`CountryType.ZM`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypezm "Direct link to countrytypezm")

Zambia

#### [`CountryType.ZW`](https://docs.browserless.io/bql-schema/types/enums/country-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#countrytypezw "Direct link to countrytypezw")

Zimbabwe

### Member Of [â€‹](https://docs.browserless.io/bql-schema/types/enums/country-type\#member-of "Direct link to Member Of")

[`proxy`](https://docs.browserless.io/bql-schema/operations/mutations/proxy) mutation

- [Values](https://docs.browserless.io/bql-schema/types/enums/country-type#values)
- [Member Of](https://docs.browserless.io/bql-schema/types/enums/country-type#member-of)

---

### LiveURLStreamType | Browserless.io
Original URL: https://docs.browserless.io/bql-schema/types/enums/live-urlstream-type

[Skip to main content](https://docs.browserless.io/bql-schema/types/enums/live-urlstream-type#__docusaurus_skipToContent_fallback)


The binary-type of the stream

```codeBlockLines_p187
enum LiveURLStreamType {
  jpeg
  png
}

```

### Values [â€‹](https://docs.browserless.io/bql-schema/types/enums/live-urlstream-type\#values "Direct link to Values")

#### [`LiveURLStreamType.jpeg`](https://docs.browserless.io/bql-schema/types/enums/live-urlstream-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/live-urlstream-type\#liveurlstreamtypejpeg "Direct link to liveurlstreamtypejpeg")

JPEG formatted binary type

#### [`LiveURLStreamType.png`](https://docs.browserless.io/bql-schema/types/enums/live-urlstream-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/live-urlstream-type\#liveurlstreamtypepng "Direct link to liveurlstreamtypepng")

PNG formatted binary type

### Member Of [â€‹](https://docs.browserless.io/bql-schema/types/enums/live-urlstream-type\#member-of "Direct link to Member Of")

[`liveURL`](https://docs.browserless.io/bql-schema/operations/mutations/live-url) mutation

- [Values](https://docs.browserless.io/bql-schema/types/enums/live-urlstream-type#values)
- [Member Of](https://docs.browserless.io/bql-schema/types/enums/live-urlstream-type#member-of)

---

### Method | Browserless.io
Original URL: https://docs.browserless.io/bql-schema/types/enums/method

[Skip to main content](https://docs.browserless.io/bql-schema/types/enums/method#__docusaurus_skipToContent_fallback)


The various HTTP-based methods to wait for

```codeBlockLines_p187
enum Method {
  CONNECT
  DELETE
  GET
  HEAD
  OPTIONS
  PATCH
  POST
  PUT
  TRACE
}

```

### Values [â€‹](https://docs.browserless.io/bql-schema/types/enums/method\#values "Direct link to Values")

#### [`Method.CONNECT`](https://docs.browserless.io/bql-schema/types/enums/method\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/method\#methodconnect "Direct link to methodconnect")

#### [`Method.DELETE`](https://docs.browserless.io/bql-schema/types/enums/method\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/method\#methoddelete "Direct link to methoddelete")

#### [`Method.GET`](https://docs.browserless.io/bql-schema/types/enums/method\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/method\#methodget "Direct link to methodget")

#### [`Method.HEAD`](https://docs.browserless.io/bql-schema/types/enums/method\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/method\#methodhead "Direct link to methodhead")

#### [`Method.OPTIONS`](https://docs.browserless.io/bql-schema/types/enums/method\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/method\#methodoptions "Direct link to methodoptions")

#### [`Method.PATCH`](https://docs.browserless.io/bql-schema/types/enums/method\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/method\#methodpatch "Direct link to methodpatch")

#### [`Method.POST`](https://docs.browserless.io/bql-schema/types/enums/method\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/method\#methodpost "Direct link to methodpost")

#### [`Method.PUT`](https://docs.browserless.io/bql-schema/types/enums/method\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/method\#methodput "Direct link to methodput")

#### [`Method.TRACE`](https://docs.browserless.io/bql-schema/types/enums/method\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/method\#methodtrace "Direct link to methodtrace")

### Member Of [â€‹](https://docs.browserless.io/bql-schema/types/enums/method\#member-of "Direct link to Member Of")

[`proxy`](https://docs.browserless.io/bql-schema/operations/mutations/proxy) mutationÂ â—Â [`reject`](https://docs.browserless.io/bql-schema/operations/mutations/reject) mutationÂ â—Â [`request`](https://docs.browserless.io/bql-schema/operations/mutations/request) mutationÂ â—Â [`RequestInput`](https://docs.browserless.io/bql-schema/types/inputs/request-input) inputÂ â—Â [`RequestResponse`](https://docs.browserless.io/bql-schema/types/objects/request-response) objectÂ â—Â [`response`](https://docs.browserless.io/bql-schema/operations/mutations/response) mutationÂ â—Â [`ResponseResponse`](https://docs.browserless.io/bql-schema/types/objects/response-response) objectÂ â—Â [`waitForRequest`](https://docs.browserless.io/bql-schema/operations/mutations/wait-for-request) mutation

- [Values](https://docs.browserless.io/bql-schema/types/enums/method#values)
- [Member Of](https://docs.browserless.io/bql-schema/types/enums/method#member-of)

---

### OperatorTypes | Browserless.io
Original URL: https://docs.browserless.io/bql-schema/types/enums/operator-types

[Skip to main content](https://docs.browserless.io/bql-schema/types/enums/operator-types#__docusaurus_skipToContent_fallback)


Logical operators for APIs that have conditions

```codeBlockLines_p187
enum OperatorTypes {
  and
  or
}

```

### Values [â€‹](https://docs.browserless.io/bql-schema/types/enums/operator-types\#values "Direct link to Values")

#### [`OperatorTypes.and`](https://docs.browserless.io/bql-schema/types/enums/operator-types\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/operator-types\#operatortypesand "Direct link to operatortypesand")

"and" logical operator

#### [`OperatorTypes.or`](https://docs.browserless.io/bql-schema/types/enums/operator-types\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/operator-types\#operatortypesor "Direct link to operatortypesor")

"or" logical operator

### Member Of [â€‹](https://docs.browserless.io/bql-schema/types/enums/operator-types\#member-of "Direct link to Member Of")

[`proxy`](https://docs.browserless.io/bql-schema/operations/mutations/proxy) mutationÂ â—Â [`reject`](https://docs.browserless.io/bql-schema/operations/mutations/reject) mutationÂ â—Â [`request`](https://docs.browserless.io/bql-schema/operations/mutations/request) mutationÂ â—Â [`response`](https://docs.browserless.io/bql-schema/operations/mutations/response) mutation

- [Values](https://docs.browserless.io/bql-schema/types/enums/operator-types#values)
- [Member Of](https://docs.browserless.io/bql-schema/types/enums/operator-types#member-of)

---

### PDFPageFormat | Browserless.io
Original URL: https://docs.browserless.io/bql-schema/types/enums/pdfpage-format

[Skip to main content](https://docs.browserless.io/bql-schema/types/enums/pdfpage-format#__docusaurus_skipToContent_fallback)


The values a pdf's Size attribute can hold

```codeBlockLines_p187
enum PDFPageFormat {
  a0
  a1
  a2
  a3
  a4
  a5
  a6
  legal
  letter
  ledger
  tabloid
}

```

### Values [â€‹](https://docs.browserless.io/bql-schema/types/enums/pdfpage-format\#values "Direct link to Values")

#### [`PDFPageFormat.a0`](https://docs.browserless.io/bql-schema/types/enums/pdfpage-format\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/pdfpage-format\#pdfpageformata0 "Direct link to pdfpageformata0")

33.1102in x 46.811in

#### [`PDFPageFormat.a1`](https://docs.browserless.io/bql-schema/types/enums/pdfpage-format\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/pdfpage-format\#pdfpageformata1 "Direct link to pdfpageformata1")

23.3858in x 33.1102in

#### [`PDFPageFormat.a2`](https://docs.browserless.io/bql-schema/types/enums/pdfpage-format\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/pdfpage-format\#pdfpageformata2 "Direct link to pdfpageformata2")

16.5354in x 23.3858in

#### [`PDFPageFormat.a3`](https://docs.browserless.io/bql-schema/types/enums/pdfpage-format\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/pdfpage-format\#pdfpageformata3 "Direct link to pdfpageformata3")

11.6929in x 16.5354in

#### [`PDFPageFormat.a4`](https://docs.browserless.io/bql-schema/types/enums/pdfpage-format\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/pdfpage-format\#pdfpageformata4 "Direct link to pdfpageformata4")

8.2677in x 11.6929in

#### [`PDFPageFormat.a5`](https://docs.browserless.io/bql-schema/types/enums/pdfpage-format\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/pdfpage-format\#pdfpageformata5 "Direct link to pdfpageformata5")

5.8268in x 8.2677in

#### [`PDFPageFormat.a6`](https://docs.browserless.io/bql-schema/types/enums/pdfpage-format\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/pdfpage-format\#pdfpageformata6 "Direct link to pdfpageformata6")

4.1339in x 5.8268in

#### [`PDFPageFormat.legal`](https://docs.browserless.io/bql-schema/types/enums/pdfpage-format\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/pdfpage-format\#pdfpageformatlegal "Direct link to pdfpageformatlegal")

8.5in x 14in

#### [`PDFPageFormat.letter`](https://docs.browserless.io/bql-schema/types/enums/pdfpage-format\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/pdfpage-format\#pdfpageformatletter "Direct link to pdfpageformatletter")

8.5in x 11in

#### [`PDFPageFormat.ledger`](https://docs.browserless.io/bql-schema/types/enums/pdfpage-format\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/pdfpage-format\#pdfpageformatledger "Direct link to pdfpageformatledger")

17in x 11in

#### [`PDFPageFormat.tabloid`](https://docs.browserless.io/bql-schema/types/enums/pdfpage-format\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/pdfpage-format\#pdfpageformattabloid "Direct link to pdfpageformattabloid")

11in x 17in

### Member Of [â€‹](https://docs.browserless.io/bql-schema/types/enums/pdfpage-format\#member-of "Direct link to Member Of")

[`pdf`](https://docs.browserless.io/bql-schema/operations/mutations/pdf) mutation

- [Values](https://docs.browserless.io/bql-schema/types/enums/pdfpage-format#values)
- [Member Of](https://docs.browserless.io/bql-schema/types/enums/pdfpage-format#member-of)

---

### ResourceType | Browserless.io
Original URL: https://docs.browserless.io/bql-schema/types/enums/resource-type

[Skip to main content](https://docs.browserless.io/bql-schema/types/enums/resource-type#__docusaurus_skipToContent_fallback)


The type of resource for a given network or HTTP request

```codeBlockLines_p187
enum ResourceType {
  cspviolationreport
  document
  eventsource
  fetch
  font
  image
  manifest
  media
  other
  ping
  prefetch
  preflight
  script
  signedexchange
  stylesheet
  texttrack
  websocket
  xhr
}

```

### Values [â€‹](https://docs.browserless.io/bql-schema/types/enums/resource-type\#values "Direct link to Values")

#### [`ResourceType.cspviolationreport`](https://docs.browserless.io/bql-schema/types/enums/resource-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/resource-type\#resourcetypecspviolationreport "Direct link to resourcetypecspviolationreport")

#### [`ResourceType.document`](https://docs.browserless.io/bql-schema/types/enums/resource-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/resource-type\#resourcetypedocument "Direct link to resourcetypedocument")

#### [`ResourceType.eventsource`](https://docs.browserless.io/bql-schema/types/enums/resource-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/resource-type\#resourcetypeeventsource "Direct link to resourcetypeeventsource")

#### [`ResourceType.fetch`](https://docs.browserless.io/bql-schema/types/enums/resource-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/resource-type\#resourcetypefetch "Direct link to resourcetypefetch")

#### [`ResourceType.font`](https://docs.browserless.io/bql-schema/types/enums/resource-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/resource-type\#resourcetypefont "Direct link to resourcetypefont")

#### [`ResourceType.image`](https://docs.browserless.io/bql-schema/types/enums/resource-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/resource-type\#resourcetypeimage "Direct link to resourcetypeimage")

#### [`ResourceType.manifest`](https://docs.browserless.io/bql-schema/types/enums/resource-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/resource-type\#resourcetypemanifest "Direct link to resourcetypemanifest")

#### [`ResourceType.media`](https://docs.browserless.io/bql-schema/types/enums/resource-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/resource-type\#resourcetypemedia "Direct link to resourcetypemedia")

#### [`ResourceType.other`](https://docs.browserless.io/bql-schema/types/enums/resource-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/resource-type\#resourcetypeother "Direct link to resourcetypeother")

#### [`ResourceType.ping`](https://docs.browserless.io/bql-schema/types/enums/resource-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/resource-type\#resourcetypeping "Direct link to resourcetypeping")

#### [`ResourceType.prefetch`](https://docs.browserless.io/bql-schema/types/enums/resource-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/resource-type\#resourcetypeprefetch "Direct link to resourcetypeprefetch")

#### [`ResourceType.preflight`](https://docs.browserless.io/bql-schema/types/enums/resource-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/resource-type\#resourcetypepreflight "Direct link to resourcetypepreflight")

#### [`ResourceType.script`](https://docs.browserless.io/bql-schema/types/enums/resource-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/resource-type\#resourcetypescript "Direct link to resourcetypescript")

#### [`ResourceType.signedexchange`](https://docs.browserless.io/bql-schema/types/enums/resource-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/resource-type\#resourcetypesignedexchange "Direct link to resourcetypesignedexchange")

#### [`ResourceType.stylesheet`](https://docs.browserless.io/bql-schema/types/enums/resource-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/resource-type\#resourcetypestylesheet "Direct link to resourcetypestylesheet")

#### [`ResourceType.texttrack`](https://docs.browserless.io/bql-schema/types/enums/resource-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/resource-type\#resourcetypetexttrack "Direct link to resourcetypetexttrack")

#### [`ResourceType.websocket`](https://docs.browserless.io/bql-schema/types/enums/resource-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/resource-type\#resourcetypewebsocket "Direct link to resourcetypewebsocket")

#### [`ResourceType.xhr`](https://docs.browserless.io/bql-schema/types/enums/resource-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/resource-type\#resourcetypexhr "Direct link to resourcetypexhr")

### Member Of [â€‹](https://docs.browserless.io/bql-schema/types/enums/resource-type\#member-of "Direct link to Member Of")

[`proxy`](https://docs.browserless.io/bql-schema/operations/mutations/proxy) mutationÂ â—Â [`reject`](https://docs.browserless.io/bql-schema/operations/mutations/reject) mutationÂ â—Â [`request`](https://docs.browserless.io/bql-schema/operations/mutations/request) mutationÂ â—Â [`RequestResponse`](https://docs.browserless.io/bql-schema/types/objects/request-response) objectÂ â—Â [`response`](https://docs.browserless.io/bql-schema/operations/mutations/response) mutationÂ â—Â [`ResponseResponse`](https://docs.browserless.io/bql-schema/types/objects/response-response) object

- [Values](https://docs.browserless.io/bql-schema/types/enums/resource-type#values)
- [Member Of](https://docs.browserless.io/bql-schema/types/enums/resource-type#member-of)

---

### ScreenshotType | Browserless.io
Original URL: https://docs.browserless.io/bql-schema/types/enums/screenshot-type

[Skip to main content](https://docs.browserless.io/bql-schema/types/enums/screenshot-type#__docusaurus_skipToContent_fallback)


The different types of screenshot formats

```codeBlockLines_p187
enum ScreenshotType {
  jpeg
  png
  webp
}

```

### Values [â€‹](https://docs.browserless.io/bql-schema/types/enums/screenshot-type\#values "Direct link to Values")

#### [`ScreenshotType.jpeg`](https://docs.browserless.io/bql-schema/types/enums/screenshot-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/screenshot-type\#screenshottypejpeg "Direct link to screenshottypejpeg")

JPEG image format

#### [`ScreenshotType.png`](https://docs.browserless.io/bql-schema/types/enums/screenshot-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/screenshot-type\#screenshottypepng "Direct link to screenshottypepng")

PNG image format

#### [`ScreenshotType.webp`](https://docs.browserless.io/bql-schema/types/enums/screenshot-type\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/screenshot-type\#screenshottypewebp "Direct link to screenshottypewebp")

WebP image format

### Member Of [â€‹](https://docs.browserless.io/bql-schema/types/enums/screenshot-type\#member-of "Direct link to Member Of")

[`screenshot`](https://docs.browserless.io/bql-schema/operations/mutations/screenshot) mutation

- [Values](https://docs.browserless.io/bql-schema/types/enums/screenshot-type#values)
- [Member Of](https://docs.browserless.io/bql-schema/types/enums/screenshot-type#member-of)

---

### VerifyTypes | Browserless.io
Original URL: https://docs.browserless.io/bql-schema/types/enums/verify-types

[Skip to main content](https://docs.browserless.io/bql-schema/types/enums/verify-types#__docusaurus_skipToContent_fallback)


The different types of verification methods that can be bypassed

```codeBlockLines_p187
enum VerifyTypes {
  cloudflare
}

```

### Values [â€‹](https://docs.browserless.io/bql-schema/types/enums/verify-types\#values "Direct link to Values")

#### [`VerifyTypes.cloudflare`](https://docs.browserless.io/bql-schema/types/enums/verify-types\#) [â€‹](https://docs.browserless.io/bql-schema/types/enums/verify-types\#verifytypescloudflare "Direct link to verifytypescloudflare")

Cloudflare protection

### Member Of [â€‹](https://docs.browserless.io/bql-schema/types/enums/verify-types\#member-of "Direct link to Member Of")

[`verify`](https://docs.browserless.io/bql-schema/operations/mutations/verify) mutation

- [Values](https://docs.browserless.io/bql-schema/types/enums/verify-types#values)
- [Member Of](https://docs.browserless.io/bql-schema/types/enums/verify-types#member-of)

---

### CleanInput | Browserless.io
Original URL: https://docs.browserless.io/bql-schema/types/inputs/clean-input

[Skip to main content](https://docs.browserless.io/bql-schema/types/inputs/clean-input#__docusaurus_skipToContent_fallback)


Options for cleaning up the DOM prior to exporting its content. Many options are available, and this query can destructively remove non-text DOM nodes, DOM attributes, and gratuitous whitespace characters. Since these operations are destructive in their nature it's recommended to run them at the very end of your query in order to preserve page functionality

```codeBlockLines_p187
input CleanInput {
  removeNonTextNodes: Boolean
  removeAttributes: Boolean
  removeRegex: Boolean
  selectors: [String!]
  attributes: [String]
  regexes: [String!]
}

```

### Fields [â€‹](https://docs.browserless.io/bql-schema/types/inputs/clean-input\#fields "Direct link to Fields")

#### [`CleanInput.removeNonTextNodes`](https://docs.browserless.io/bql-schema/types/inputs/clean-input\#)Â â—Â [`Boolean`](https://docs.browserless.io/bql-schema/types/scalars/boolean) scalar [â€‹](https://docs.browserless.io/bql-schema/types/inputs/clean-input\#cleaninputremovenontextnodesboolean- "Direct link to cleaninputremovenontextnodesboolean-")

When true (default is true) this will remove non-textual nodes from the DOM like scripts, links, video, canvas, etc. You may override this by specifying a `selectors` argument for DOM selectors to remove.

#### [`CleanInput.removeAttributes`](https://docs.browserless.io/bql-schema/types/inputs/clean-input\#)Â â—Â [`Boolean`](https://docs.browserless.io/bql-schema/types/scalars/boolean) scalar [â€‹](https://docs.browserless.io/bql-schema/types/inputs/clean-input\#cleaninputremoveattributesboolean- "Direct link to cleaninputremoveattributesboolean-")

When true (default is false) this will remove all attributes on all DOM nodes. Useful for "cleaning" up all HTML markup but preserving the structure overall. You can specify specific attributes to remove with `attributes` argument

#### [`CleanInput.removeRegex`](https://docs.browserless.io/bql-schema/types/inputs/clean-input\#)Â â—Â [`Boolean`](https://docs.browserless.io/bql-schema/types/scalars/boolean) scalar [â€‹](https://docs.browserless.io/bql-schema/types/inputs/clean-input\#cleaninputremoveregexboolean- "Direct link to cleaninputremoveregexboolean-")

Removes any characters in the HTML by a regex pattern and arn in order. By default this is true and removes newlines, returns, tabs, multi-spaces and HTML comments in that order. You may supply your own regex by using the `regexes` argument

#### [`CleanInput.selectors`](https://docs.browserless.io/bql-schema/types/inputs/clean-input\#)Â â—Â [`[String!]`](https://docs.browserless.io/bql-schema/types/scalars/string) listscalar [â€‹](https://docs.browserless.io/bql-schema/types/inputs/clean-input\#cleaninputselectorsstring-- "Direct link to cleaninputselectorsstring--")

A list of selectors to remove from the page when `removeNonTextNodes` is set to true ( `true` by default).

#### [`CleanInput.attributes`](https://docs.browserless.io/bql-schema/types/inputs/clean-input\#)Â â—Â [`[String]`](https://docs.browserless.io/bql-schema/types/scalars/string) listscalar [â€‹](https://docs.browserless.io/bql-schema/types/inputs/clean-input\#cleaninputattributesstring-- "Direct link to cleaninputattributesstring--")

A list of attributes to remove from all DOM nodes. When this isn't specified, and `removeAttributes` is true, all attributes on all DOM nodes are removed. `removeNonTextNodes` must be set to `true` for this to take effect

#### [`CleanInput.regexes`](https://docs.browserless.io/bql-schema/types/inputs/clean-input\#)Â â—Â [`[String!]`](https://docs.browserless.io/bql-schema/types/scalars/string) listscalar [â€‹](https://docs.browserless.io/bql-schema/types/inputs/clean-input\#cleaninputregexesstring-- "Direct link to cleaninputregexesstring--")

When `removeRegex` is set to "true" this list of regex items, without the beginning and ending `/`, are removed from the page. These are each run in order and replaced with a single space character to preserve some of their contents

### Member Of [â€‹](https://docs.browserless.io/bql-schema/types/inputs/clean-input\#member-of "Direct link to Member Of")

[`html`](https://docs.browserless.io/bql-schema/operations/mutations/html) mutationÂ â—Â [`text`](https://docs.browserless.io/bql-schema/operations/mutations/text) mutation

- [Fields](https://docs.browserless.io/bql-schema/types/inputs/clean-input#fields)
- [Member Of](https://docs.browserless.io/bql-schema/types/inputs/clean-input#member-of)

---

### CookieInput | Browserless.io
Original URL: https://docs.browserless.io/bql-schema/types/inputs/cookie-input

[Skip to main content](https://docs.browserless.io/bql-schema/types/inputs/cookie-input#__docusaurus_skipToContent_fallback)


The cookie to be sent to the page

```codeBlockLines_p187
input CookieInput {
  domain: String
  expires: Float
  httpOnly: Boolean
  name: String!
  path: String
  sameSite: CookieSameSite
  secure: Boolean
  url: String
  value: String!
}

```

### Fields [â€‹](https://docs.browserless.io/bql-schema/types/inputs/cookie-input\#fields "Direct link to Fields")

#### [`CookieInput.domain`](https://docs.browserless.io/bql-schema/types/inputs/cookie-input\#)Â â—Â [`String`](https://docs.browserless.io/bql-schema/types/scalars/string) scalar [â€‹](https://docs.browserless.io/bql-schema/types/inputs/cookie-input\#cookieinputdomainstring- "Direct link to cookieinputdomainstring-")

Cookie domain

#### [`CookieInput.expires`](https://docs.browserless.io/bql-schema/types/inputs/cookie-input\#)Â â—Â [`Float`](https://docs.browserless.io/bql-schema/types/scalars/float) scalar [â€‹](https://docs.browserless.io/bql-schema/types/inputs/cookie-input\#cookieinputexpiresfloat- "Direct link to cookieinputexpiresfloat-")

Cookie expiration date, session cookie if not set

#### [`CookieInput.httpOnly`](https://docs.browserless.io/bql-schema/types/inputs/cookie-input\#)Â â—Â [`Boolean`](https://docs.browserless.io/bql-schema/types/scalars/boolean) scalar [â€‹](https://docs.browserless.io/bql-schema/types/inputs/cookie-input\#cookieinputhttponlyboolean- "Direct link to cookieinputhttponlyboolean-")

True if cookie is http-only

#### [`CookieInput.name`](https://docs.browserless.io/bql-schema/types/inputs/cookie-input\#)Â â—Â [`String!`](https://docs.browserless.io/bql-schema/types/scalars/string) non-nullscalar [â€‹](https://docs.browserless.io/bql-schema/types/inputs/cookie-input\#cookieinputnamestring-- "Direct link to cookieinputnamestring--")

Cookie name

#### [`CookieInput.path`](https://docs.browserless.io/bql-schema/types/inputs/cookie-input\#)Â â—Â [`String`](https://docs.browserless.io/bql-schema/types/scalars/string) scalar [â€‹](https://docs.browserless.io/bql-schema/types/inputs/cookie-input\#cookieinputpathstring- "Direct link to cookieinputpathstring-")

Cookie path

#### [`CookieInput.sameSite`](https://docs.browserless.io/bql-schema/types/inputs/cookie-input\#)Â â—Â [`CookieSameSite`](https://docs.browserless.io/bql-schema/types/enums/cookie-same-site) enum [â€‹](https://docs.browserless.io/bql-schema/types/inputs/cookie-input\#cookieinputsamesitecookiesamesite- "Direct link to cookieinputsamesitecookiesamesite-")

Cookie SameSite type

#### [`CookieInput.secure`](https://docs.browserless.io/bql-schema/types/inputs/cookie-input\#)Â â—Â [`Boolean`](https://docs.browserless.io/bql-schema/types/scalars/boolean) scalar [â€‹](https://docs.browserless.io/bql-schema/types/inputs/cookie-input\#cookieinputsecureboolean- "Direct link to cookieinputsecureboolean-")

True if cookie is secure

#### [`CookieInput.url`](https://docs.browserless.io/bql-schema/types/inputs/cookie-input\#)Â â—Â [`String`](https://docs.browserless.io/bql-schema/types/scalars/string) scalar [â€‹](https://docs.browserless.io/bql-schema/types/inputs/cookie-input\#cookieinputurlstring- "Direct link to cookieinputurlstring-")

The request-URI to associate with the setting of the cookie. This value can affect the default domain, path, source port, and source scheme values of the created cookie

#### [`CookieInput.value`](https://docs.browserless.io/bql-schema/types/inputs/cookie-input\#)Â â—Â [`String!`](https://docs.browserless.io/bql-schema/types/scalars/string) non-nullscalar [â€‹](https://docs.browserless.io/bql-schema/types/inputs/cookie-input\#cookieinputvaluestring-- "Direct link to cookieinputvaluestring--")

Cookie value

### Member Of [â€‹](https://docs.browserless.io/bql-schema/types/inputs/cookie-input\#member-of "Direct link to Member Of")

[`cookies`](https://docs.browserless.io/bql-schema/operations/mutations/cookies) mutation

- [Fields](https://docs.browserless.io/bql-schema/types/inputs/cookie-input#fields)
- [Member Of](https://docs.browserless.io/bql-schema/types/inputs/cookie-input#member-of)

---

### RequestInput | Browserless.io
Original URL: https://docs.browserless.io/bql-schema/types/inputs/request-input

[Skip to main content](https://docs.browserless.io/bql-schema/types/inputs/request-input#__docusaurus_skipToContent_fallback)


The specific request to perform a conditional action on

```codeBlockLines_p187
input RequestInput {
  method: Method
  url: String
}

```

### Fields [â€‹](https://docs.browserless.io/bql-schema/types/inputs/request-input\#fields "Direct link to Fields")

#### [`RequestInput.method`](https://docs.browserless.io/bql-schema/types/inputs/request-input\#)Â â—Â [`Method`](https://docs.browserless.io/bql-schema/types/enums/method) enum [â€‹](https://docs.browserless.io/bql-schema/types/inputs/request-input\#requestinputmethodmethod- "Direct link to requestinputmethodmethod-")

The HTTP Method of the request

#### [`RequestInput.url`](https://docs.browserless.io/bql-schema/types/inputs/request-input\#)Â â—Â [`String`](https://docs.browserless.io/bql-schema/types/scalars/string) scalar [â€‹](https://docs.browserless.io/bql-schema/types/inputs/request-input\#requestinputurlstring- "Direct link to requestinputurlstring-")

The pattern of the request URL to wait for, using glob-style pattern-matching

### Member Of [â€‹](https://docs.browserless.io/bql-schema/types/inputs/request-input\#member-of "Direct link to Member Of")

[`if`](https://docs.browserless.io/bql-schema/operations/mutations/if) mutationÂ â—Â [`ifnot`](https://docs.browserless.io/bql-schema/operations/mutations/ifnot) mutation

- [Fields](https://docs.browserless.io/bql-schema/types/inputs/request-input#fields)
- [Member Of](https://docs.browserless.io/bql-schema/types/inputs/request-input#member-of)

---

### ResponseInput | Browserless.io
Original URL: https://docs.browserless.io/bql-schema/types/inputs/response-input

[Skip to main content](https://docs.browserless.io/bql-schema/types/inputs/response-input#__docusaurus_skipToContent_fallback)


The specific response to perform a conditional action on

```codeBlockLines_p187
input ResponseInput {
  statuses: [Int]
  codes: [Int] @deprecated
  url: String
}

```

### Fields [â€‹](https://docs.browserless.io/bql-schema/types/inputs/response-input\#fields "Direct link to Fields")

#### [`ResponseInput.statuses`](https://docs.browserless.io/bql-schema/types/inputs/response-input\#)Â â—Â [`[Int]`](https://docs.browserless.io/bql-schema/types/scalars/int) listscalar [â€‹](https://docs.browserless.io/bql-schema/types/inputs/response-input\#responseinputstatusesint-- "Direct link to responseinputstatusesint--")

The HTTP Response code(s) of the URL to wait for. Can be a single HTTP code or a list of desired codes

#### [`ResponseInput.codes`](https://docs.browserless.io/bql-schema/types/inputs/response-input\#)Â â—Â [`[Int]`](https://docs.browserless.io/bql-schema/types/scalars/int) deprecatedlistscalar [â€‹](https://docs.browserless.io/bql-schema/types/inputs/response-input\#responseinputcodesint--- "Direct link to responseinputcodesint---")

DEPRECATED

Use `statuses` field instead as it is more consistent in BrowserQL.

The HTTP Response code(s) of the URL to wait for. Can be a single HTTP code or a list of desired codes

#### [`ResponseInput.url`](https://docs.browserless.io/bql-schema/types/inputs/response-input\#)Â â—Â [`String`](https://docs.browserless.io/bql-schema/types/scalars/string) scalar [â€‹](https://docs.browserless.io/bql-schema/types/inputs/response-input\#responseinputurlstring- "Direct link to responseinputurlstring-")

The pattern of the response URL to wait for, using glob-style pattern-matching

### Member Of [â€‹](https://docs.browserless.io/bql-schema/types/inputs/response-input\#member-of "Direct link to Member Of")

[`if`](https://docs.browserless.io/bql-schema/operations/mutations/if) mutationÂ â—Â [`ifnot`](https://docs.browserless.io/bql-schema/operations/mutations/ifnot) mutation

- [Fields](https://docs.browserless.io/bql-schema/types/inputs/response-input#fields)
- [Member Of](https://docs.browserless.io/bql-schema/types/inputs/response-input#member-of)

---

### ScreenshotClip | Browserless.io
Original URL: https://docs.browserless.io/bql-schema/types/inputs/screenshot-clip

[Skip to main content](https://docs.browserless.io/bql-schema/types/inputs/screenshot-clip#__docusaurus_skipToContent_fallback)


The clipping to be applied to the screenshot

```codeBlockLines_p187
input ScreenshotClip {
  height: Float
  scale: Float
  width: Float
  x: Float
  y: Float
}

```

### Fields [â€‹](https://docs.browserless.io/bql-schema/types/inputs/screenshot-clip\#fields "Direct link to Fields")

#### [`ScreenshotClip.height`](https://docs.browserless.io/bql-schema/types/inputs/screenshot-clip\#)Â â—Â [`Float`](https://docs.browserless.io/bql-schema/types/scalars/float) scalar [â€‹](https://docs.browserless.io/bql-schema/types/inputs/screenshot-clip\#screenshotclipheightfloat- "Direct link to screenshotclipheightfloat-")

The height of the clip, in pixels

#### [`ScreenshotClip.scale`](https://docs.browserless.io/bql-schema/types/inputs/screenshot-clip\#)Â â—Â [`Float`](https://docs.browserless.io/bql-schema/types/scalars/float) scalar [â€‹](https://docs.browserless.io/bql-schema/types/inputs/screenshot-clip\#screenshotclipscalefloat- "Direct link to screenshotclipscalefloat-")

The scale factor of the clip

#### [`ScreenshotClip.width`](https://docs.browserless.io/bql-schema/types/inputs/screenshot-clip\#)Â â—Â [`Float`](https://docs.browserless.io/bql-schema/types/scalars/float) scalar [â€‹](https://docs.browserless.io/bql-schema/types/inputs/screenshot-clip\#screenshotclipwidthfloat- "Direct link to screenshotclipwidthfloat-")

The width of the clip, in pixels

#### [`ScreenshotClip.x`](https://docs.browserless.io/bql-schema/types/inputs/screenshot-clip\#)Â â—Â [`Float`](https://docs.browserless.io/bql-schema/types/scalars/float) scalar [â€‹](https://docs.browserless.io/bql-schema/types/inputs/screenshot-clip\#screenshotclipxfloat- "Direct link to screenshotclipxfloat-")

The x coordinate to start clipping, in pixels

#### [`ScreenshotClip.y`](https://docs.browserless.io/bql-schema/types/inputs/screenshot-clip\#)Â â—Â [`Float`](https://docs.browserless.io/bql-schema/types/scalars/float) scalar [â€‹](https://docs.browserless.io/bql-schema/types/inputs/screenshot-clip\#screenshotclipyfloat- "Direct link to screenshotclipyfloat-")

The y coordinate to start clipping, in pixels

### Member Of [â€‹](https://docs.browserless.io/bql-schema/types/inputs/screenshot-clip\#member-of "Direct link to Member Of")

[`screenshot`](https://docs.browserless.io/bql-schema/operations/mutations/screenshot) mutation

- [Fields](https://docs.browserless.io/bql-schema/types/inputs/screenshot-clip#fields)
- [Member Of](https://docs.browserless.io/bql-schema/types/inputs/screenshot-clip#member-of)

---

### Attribute | Browserless.io
Original URL: https://docs.browserless.io/bql-schema/types/objects/attribute

[Skip to main content](https://docs.browserless.io/bql-schema/types/objects/attribute#__docusaurus_skipToContent_fallback)


No description

```codeBlockLines_p187
type Attribute {
  name: String
  value: String
}

```

### Fields [â€‹](https://docs.browserless.io/bql-schema/types/objects/attribute\#fields "Direct link to Fields")

#### [`Attribute.name`](https://docs.browserless.io/bql-schema/types/objects/attribute\#)Â â—Â [`String`](https://docs.browserless.io/bql-schema/types/scalars/string) scalar [â€‹](https://docs.browserless.io/bql-schema/types/objects/attribute\#attributenamestring- "Direct link to attributenamestring-")

#### [`Attribute.value`](https://docs.browserless.io/bql-schema/types/objects/attribute\#)Â â—Â [`String`](https://docs.browserless.io/bql-schema/types/scalars/string) scalar [â€‹](https://docs.browserless.io/bql-schema/types/objects/attribute\#attributevaluestring- "Direct link to attributevaluestring-")

### Member Of [â€‹](https://docs.browserless.io/bql-schema/types/objects/attribute\#member-of "Direct link to Member Of")

[`MapSelectorResponse`](https://docs.browserless.io/bql-schema/types/objects/map-selector-response) object

- [Fields](https://docs.browserless.io/bql-schema/types/objects/attribute#fields)
- [Member Of](https://docs.browserless.io/bql-schema/types/objects/attribute#member-of)

---

### CaptchaResponse | Browserless.io
Original URL: https://docs.browserless.io/bql-schema/types/objects/captcha-response

[Skip to main content](https://docs.browserless.io/bql-schema/types/objects/captcha-response#__docusaurus_skipToContent_fallback)


Response returned after a captcha has been solved

```codeBlockLines_p187
type CaptchaResponse {
  found: Boolean
  solved: Boolean
  time: Float
  token: String
}

```

### Fields [â€‹](https://docs.browserless.io/bql-schema/types/objects/captcha-response\#fields "Direct link to Fields")

#### [`CaptchaResponse.found`](https://docs.browserless.io/bql-schema/types/objects/captcha-response\#)Â â—Â [`Boolean`](https://docs.browserless.io/bql-schema/types/scalars/boolean) scalar [â€‹](https://docs.browserless.io/bql-schema/types/objects/captcha-response\#captcharesponsefoundboolean- "Direct link to captcharesponsefoundboolean-")

If a captcha was found or not

#### [`CaptchaResponse.solved`](https://docs.browserless.io/bql-schema/types/objects/captcha-response\#)Â â—Â [`Boolean`](https://docs.browserless.io/bql-schema/types/scalars/boolean) scalar [â€‹](https://docs.browserless.io/bql-schema/types/objects/captcha-response\#captcharesponsesolvedboolean- "Direct link to captcharesponsesolvedboolean-")

If a captcha was found, whether or not it was solved

#### [`CaptchaResponse.time`](https://docs.browserless.io/bql-schema/types/objects/captcha-response\#)Â â—Â [`Float`](https://docs.browserless.io/bql-schema/types/scalars/float) scalar [â€‹](https://docs.browserless.io/bql-schema/types/objects/captcha-response\#captcharesponsetimefloat- "Direct link to captcharesponsetimefloat-")

The total time it took to find, and solve, the captcha

#### [`CaptchaResponse.token`](https://docs.browserless.io/bql-schema/types/objects/captcha-response\#)Â â—Â [`String`](https://docs.browserless.io/bql-schema/types/scalars/string) scalar [â€‹](https://docs.browserless.io/bql-schema/types/objects/captcha-response\#captcharesponsetokenstring- "Direct link to captcharesponsetokenstring-")

The solved token of the response, if any is provided

### Returned By [â€‹](https://docs.browserless.io/bql-schema/types/objects/captcha-response\#returned-by "Direct link to Returned By")

[`solve`](https://docs.browserless.io/bql-schema/operations/mutations/solve) mutationÂ â—Â [`verify`](https://docs.browserless.io/bql-schema/operations/mutations/verify) mutation

- [Fields](https://docs.browserless.io/bql-schema/types/objects/captcha-response#fields)
- [Returned By](https://docs.browserless.io/bql-schema/types/objects/captcha-response#returned-by)

---

### ClickResponse | Browserless.io
Original URL: https://docs.browserless.io/bql-schema/types/objects/click-response

[Skip to main content](https://docs.browserless.io/bql-schema/types/objects/click-response#__docusaurus_skipToContent_fallback)


Response returned after having clicked on an element

```codeBlockLines_p187
type ClickResponse {
  selector: String
  time: Float
  x: Float
  y: Float
}

```

### Fields [â€‹](https://docs.browserless.io/bql-schema/types/objects/click-response\#fields "Direct link to Fields")

#### [`ClickResponse.selector`](https://docs.browserless.io/bql-schema/types/objects/click-response\#)Â â—Â [`String`](https://docs.browserless.io/bql-schema/types/scalars/string) scalar [â€‹](https://docs.browserless.io/bql-schema/types/objects/click-response\#clickresponseselectorstring- "Direct link to clickresponseselectorstring-")

The selector text if specified

#### [`ClickResponse.time`](https://docs.browserless.io/bql-schema/types/objects/click-response\#)Â â—Â [`Float`](https://docs.browserless.io/bql-schema/types/scalars/float) scalar [â€‹](https://docs.browserless.io/bql-schema/types/objects/click-response\#clickresponsetimefloat- "Direct link to clickresponsetimefloat-")

The amount of time, in milliseconds, elapsed since the start of clicking to completion

#### [`ClickResponse.x`](https://docs.browserless.io/bql-schema/types/objects/click-response\#)Â â—Â [`Float`](https://docs.browserless.io/bql-schema/types/scalars/float) scalar [â€‹](https://docs.browserless.io/bql-schema/types/objects/click-response\#clickresponsexfloat- "Direct link to clickresponsexfloat-")

The X coordinate of the click, in pixels, on the page

#### [`ClickResponse.y`](https://docs.browserless.io/bql-schema/types/objects/click-response\#)Â â—Â [`Float`](https://docs.browserless.io/bql-schema/types/scalars/float) scalar [â€‹](https://docs.browserless.io/bql-schema/types/objects/click-response\#clickresponseyfloat- "Direct link to clickresponseyfloat-")

The Y coordinate of the click, in pixels, on the page

### Returned By [â€‹](https://docs.browserless.io/bql-schema/types/objects/click-response\#returned-by "Direct link to Returned By")

[`checkbox`](https://docs.browserless.io/bql-schema/operations/mutations/checkbox) mutationÂ â—Â [`click`](https://docs.browserless.io/bql-schema/operations/mutations/click) mutation

- [Fields](https://docs.browserless.io/bql-schema/types/objects/click-response#fields)
- [Returned By](https://docs.browserless.io/bql-schema/types/objects/click-response#returned-by)

---

### CookieResponse | Browserless.io
Original URL: https://docs.browserless.io/bql-schema/types/objects/cookie-response

[Skip to main content](https://docs.browserless.io/bql-schema/types/objects/cookie-response#__docusaurus_skipToContent_fallback)


The response returned after setting or getting cookies

```codeBlockLines_p187
type CookieResponse {
  cookies: [StandardCookie]
  time: Float
}

```

### Fields [â€‹](https://docs.browserless.io/bql-schema/types/objects/cookie-response\#fields "Direct link to Fields")

#### [`CookieResponse.cookies`](https://docs.browserless.io/bql-schema/types/objects/cookie-response\#)Â â—Â [`[StandardCookie]`](https://docs.browserless.io/bql-schema/types/objects/standard-cookie) listobject [â€‹](https://docs.browserless.io/bql-schema/types/objects/cookie-response\#cookieresponsecookiesstandardcookie-- "Direct link to cookieresponsecookiesstandardcookie--")

A standard cookie object with the values of the set cookies

#### [`CookieResponse.time`](https://docs.browserless.io/bql-schema/types/objects/cookie-response\#)Â â—Â [`Float`](https://docs.browserless.io/bql-schema/types/scalars/float) scalar [â€‹](https://docs.browserless.io/bql-schema/types/objects/cookie-response\#cookieresponsetimefloat- "Direct link to cookieresponsetimefloat-")

The time it took to set and return the cookies

### Returned By [â€‹](https://docs.browserless.io/bql-schema/types/objects/cookie-response\#returned-by "Direct link to Returned By")

[`cookies`](https://docs.browserless.io/bql-schema/operations/mutations/cookies) mutation

- [Fields](https://docs.browserless.io/bql-schema/types/objects/cookie-response#fields)
- [Returned By](https://docs.browserless.io/bql-schema/types/objects/cookie-response#returned-by)

---

### DefaultResponse | Browserless.io
Original URL: https://docs.browserless.io/bql-schema/types/objects/default-response

[Skip to main content](https://docs.browserless.io/bql-schema/types/objects/default-response#__docusaurus_skipToContent_fallback)


Default response for all methods

```codeBlockLines_p187
type DefaultResponse {
  timeout: Float
}

```

### Fields [â€‹](https://docs.browserless.io/bql-schema/types/objects/default-response\#fields "Direct link to Fields")

#### [`DefaultResponse.timeout`](https://docs.browserless.io/bql-schema/types/objects/default-response\#)Â â—Â [`Float`](https://docs.browserless.io/bql-schema/types/scalars/float) scalar [â€‹](https://docs.browserless.io/bql-schema/types/objects/default-response\#defaultresponsetimeoutfloat- "Direct link to defaultresponsetimeoutfloat-")

The default timeout for all methods. Default timeout is 30 seconds, or 30000.

### Returned By [â€‹](https://docs.browserless.io/bql-schema/types/objects/default-response\#returned-by "Direct link to Returned By")

[`preferences`](https://docs.browserless.io/bql-schema/operations/mutations/preferences) mutation

- [Fields](https://docs.browserless.io/bql-schema/types/objects/default-response#fields)
- [Returned By](https://docs.browserless.io/bql-schema/types/objects/default-response#returned-by)

---

### EvaluateResponse | Browserless.io
Original URL: https://docs.browserless.io/bql-schema/types/objects/evaluate-response

[Skip to main content](https://docs.browserless.io/bql-schema/types/objects/evaluate-response#__docusaurus_skipToContent_fallback)


Response returned after evaluating a script

```codeBlockLines_p187
type EvaluateResponse {
  time: Float
  value: String
}

```

### Fields [â€‹](https://docs.browserless.io/bql-schema/types/objects/evaluate-response\#fields "Direct link to Fields")

#### [`EvaluateResponse.time`](https://docs.browserless.io/bql-schema/types/objects/evaluate-response\#)Â â—Â [`Float`](https://docs.browserless.io/bql-schema/types/scalars/float) scalar [â€‹](https://docs.browserless.io/bql-schema/types/objects/evaluate-response\#evaluateresponsetimefloat- "Direct link to evaluateresponsetimefloat-")

The time it took for the evaluate call to happen

#### [`EvaluateResponse.value`](https://docs.browserless.io/bql-schema/types/objects/evaluate-response\#)Â â—Â [`String`](https://docs.browserless.io/bql-schema/types/scalars/string) scalar [â€‹](https://docs.browserless.io/bql-schema/types/objects/evaluate-response\#evaluateresponsevaluestring- "Direct link to evaluateresponsevaluestring-")

The returned value of the script, if any

### Returned By [â€‹](https://docs.browserless.io/bql-schema/types/objects/evaluate-response\#returned-by "Direct link to Returned By")

[`evaluate`](https://docs.browserless.io/bql-schema/operations/mutations/evaluate) mutation

- [Fields](https://docs.browserless.io/bql-schema/types/objects/evaluate-response#fields)
- [Returned By](https://docs.browserless.io/bql-schema/types/objects/evaluate-response#returned-by)

---

### Headers | Browserless.io
Original URL: https://docs.browserless.io/bql-schema/types/objects/headers

[Skip to main content](https://docs.browserless.io/bql-schema/types/objects/headers#__docusaurus_skipToContent_fallback)


An object representing the header's name and underlying value

```codeBlockLines_p187
type Headers {
  name: String
  value: String
}

```

### Fields [â€‹](https://docs.browserless.io/bql-schema/types/objects/headers\#fields "Direct link to Fields")

#### [`Headers.name`](https://docs.browserless.io/bql-schema/types/objects/headers\#)Â â—Â [`String`](https://docs.browserless.io/bql-schema/types/scalars/string) scalar [â€‹](https://docs.browserless.io/bql-schema/types/objects/headers\#headersnamestring- "Direct link to headersnamestring-")

#### [`Headers.value`](https://docs.browserless.io/bql-schema/types/objects/headers\#)Â â—Â [`String`](https://docs.browserless.io/bql-schema/types/scalars/string) scalar [â€‹](https://docs.browserless.io/bql-schema/types/objects/headers\#headersvaluestring- "Direct link to headersvaluestring-")

### Member Of [â€‹](https://docs.browserless.io/bql-schema/types/objects/headers\#member-of "Direct link to Member Of")

[`RequestResponse`](https://docs.browserless.io/bql-schema/types/objects/request-response) objectÂ â—Â [`ResponseResponse`](https://docs.browserless.io/bql-schema/types/objects/response-response) object

- [Fields](https://docs.browserless.io/bql-schema/types/objects/headers#fields)
- [Member Of](https://docs.browserless.io/bql-schema/types/objects/headers#member-of)

---

### HoverResponse | Browserless.io
Original URL: https://docs.browserless.io/bql-schema/types/objects/hover-response

[Skip to main content](https://docs.browserless.io/bql-schema/types/objects/hover-response#__docusaurus_skipToContent_fallback)


Response returned after having hovered over an element

```codeBlockLines_p187
type HoverResponse {
  selector: String
  time: Float
  x: Float
  y: Float
}

```

### Fields [â€‹](https://docs.browserless.io/bql-schema/types/objects/hover-response\#fields "Direct link to Fields")

#### [`HoverResponse.selector`](https://docs.browserless.io/bql-schema/types/objects/hover-response\#)Â â—Â [`String`](https://docs.browserless.io/bql-schema/types/scalars/string) scalar [â€‹](https://docs.browserless.io/bql-schema/types/objects/hover-response\#hoverresponseselectorstring- "Direct link to hoverresponseselectorstring-")

The selector text

#### [`HoverResponse.time`](https://docs.browserless.io/bql-schema/types/objects/hover-response\#)Â â—Â [`Float`](https://docs.browserless.io/bql-schema/types/scalars/float) scalar [â€‹](https://docs.browserless.io/bql-schema/types/objects/hover-response\#hoverresponsetimefloat- "Direct link to hoverresponsetimefloat-")

The amount of time, in milliseconds, elapsed since the start to completion

#### [`HoverResponse.x`](https://docs.browserless.io/bql-schema/types/objects/hover-response\#)Â â—Â [`Float`](https://docs.browserless.io/bql-schema/types/scalars/float) scalar [â€‹](https://docs.browserless.io/bql-schema/types/objects/hover-response\#hoverresponsexfloat- "Direct link to hoverresponsexfloat-")

The X coordinate in pixels, on the page

#### [`HoverResponse.y`](https://docs.browserless.io/bql-schema/types/objects/hover-response\#)Â â—Â [`Float`](https://docs.browserless.io/bql-schema/types/scalars/float) scalar [â€‹](https://docs.browserless.io/bql-schema/types/objects/hover-response\#hoverresponseyfloat- "Direct link to hoverresponseyfloat-")

The Y coordinate in pixels, on the page

### Returned By [â€‹](https://docs.browserless.io/bql-schema/types/objects/hover-response\#returned-by "Direct link to Returned By")

[`hover`](https://docs.browserless.io/bql-schema/operations/mutations/hover) mutation

- [Fields](https://docs.browserless.io/bql-schema/types/objects/hover-response#fields)
- [Returned By](https://docs.browserless.io/bql-schema/types/objects/hover-response#returned-by)

---

### HTMLResponse | Browserless.io
Original URL: https://docs.browserless.io/bql-schema/types/objects/htmlresponse

[Skip to main content](https://docs.browserless.io/bql-schema/types/objects/htmlresponse#__docusaurus_skipToContent_fallback)


HTML content of a page

```codeBlockLines_p187
type HTMLResponse {
  html: String
  time: Float
}

```

### Fields [â€‹](https://docs.browserless.io/bql-schema/types/objects/htmlresponse\#fields "Direct link to Fields")

#### [`HTMLResponse.html`](https://docs.browserless.io/bql-schema/types/objects/htmlresponse\#)Â â—Â [`String`](https://docs.browserless.io/bql-schema/types/scalars/string) scalar [â€‹](https://docs.browserless.io/bql-schema/types/objects/htmlresponse\#htmlresponsehtmlstring- "Direct link to htmlresponsehtmlstring-")

The content of the page's HTML

#### [`HTMLResponse.time`](https://docs.browserless.io/bql-schema/types/objects/htmlresponse\#)Â â—Â [`Float`](https://docs.browserless.io/bql-schema/types/scalars/float) scalar [â€‹](https://docs.browserless.io/bql-schema/types/objects/htmlresponse\#htmlresponsetimefloat- "Direct link to htmlresponsetimefloat-")

The amount of time, in milliseconds, elapsed since the start of content retrieval to completion

### Returned By [â€‹](https://docs.browserless.io/bql-schema/types/objects/htmlresponse\#returned-by "Direct link to Returned By")

[`html`](https://docs.browserless.io/bql-schema/operations/mutations/html) mutation

- [Fields](https://docs.browserless.io/bql-schema/types/objects/htmlresponse#fields)
- [Returned By](https://docs.browserless.io/bql-schema/types/objects/htmlresponse#returned-by)

---

### HTTPResponse | Browserless.io
Original URL: https://docs.browserless.io/bql-schema/types/objects/httpresponse

[Skip to main content](https://docs.browserless.io/bql-schema/types/objects/httpresponse#__docusaurus_skipToContent_fallback)


Response returned after a navigation event

```codeBlockLines_p187
type HTTPResponse {
  status: Int
  time: Float
  text: String
  url: String
}

```

### Fields [â€‹](https://docs.browserless.io/bql-schema/types/objects/httpresponse\#fields "Direct link to Fields")

#### [`HTTPResponse.status`](https://docs.browserless.io/bql-schema/types/objects/httpresponse\#)Â â—Â [`Int`](https://docs.browserless.io/bql-schema/types/scalars/int) scalar [â€‹](https://docs.browserless.io/bql-schema/types/objects/httpresponse\#httpresponsestatusint- "Direct link to httpresponsestatusint-")

The status code response of the initial page-load

#### [`HTTPResponse.time`](https://docs.browserless.io/bql-schema/types/objects/httpresponse\#)Â â—Â [`Float`](https://docs.browserless.io/bql-schema/types/scalars/float) scalar [â€‹](https://docs.browserless.io/bql-schema/types/objects/httpresponse\#httpresponsetimefloat- "Direct link to httpresponsetimefloat-")

The amount of time, in milliseconds, elapsed since the start of navigation to completion

#### [`HTTPResponse.text`](https://docs.browserless.io/bql-schema/types/objects/httpresponse\#)Â â—Â [`String`](https://docs.browserless.io/bql-schema/types/scalars/string) scalar [â€‹](https://docs.browserless.io/bql-schema/types/objects/httpresponse\#httpresponsetextstring- "Direct link to httpresponsetextstring-")

The status text of the response from the initial page-load. Generally 'ok'

#### [`HTTPResponse.url`](https://docs.browserless.io/bql-schema/types/objects/httpresponse\#)Â â—Â [`String`](https://docs.browserless.io/bql-schema/types/scalars/string) scalar [â€‹](https://docs.browserless.io/bql-schema/types/objects/httpresponse\#httpresponseurlstring- "Direct link to httpresponseurlstring-")

The final URL of the page after any potential redirects or URL rewrites

### Returned By [â€‹](https://docs.browserless.io/bql-schema/types/objects/httpresponse\#returned-by "Direct link to Returned By")

[`back`](https://docs.browserless.io/bql-schema/operations/mutations/back) mutationÂ â—Â [`content`](https://docs.browserless.io/bql-schema/operations/mutations/content) mutationÂ â—Â [`forward`](https://docs.browserless.io/bql-schema/operations/mutations/forward) mutationÂ â—Â [`goto`](https://docs.browserless.io/bql-schema/operations/mutations/goto) mutationÂ â—Â [`reload`](https://docs.browserless.io/bql-schema/operations/mutations/reload) mutationÂ â—Â [`waitForNavigation`](https://docs.browserless.io/bql-schema/operations/mutations/wait-for-navigation) mutation

- [Fields](https://docs.browserless.io/bql-schema/types/objects/httpresponse#fields)
- [Returned By](https://docs.browserless.io/bql-schema/types/objects/httpresponse#returned-by)

---

### JavaScriptResponse | Browserless.io
Original URL: https://docs.browserless.io/bql-schema/types/objects/java-script-response

[Skip to main content](https://docs.browserless.io/bql-schema/types/objects/java-script-response#__docusaurus_skipToContent_fallback)


The response returned after enabling or disabling JavaScript on the page

```codeBlockLines_p187
type JavaScriptResponse {
  enabled: Boolean
  time: Float
}

```

### Fields [â€‹](https://docs.browserless.io/bql-schema/types/objects/java-script-response\#fields "Direct link to Fields")

#### [`JavaScriptResponse.enabled`](https://docs.browserless.io/bql-schema/types/objects/java-script-response\#)Â â—Â [`Boolean`](https://docs.browserless.io/bql-schema/types/scalars/boolean) scalar [â€‹](https://docs.browserless.io/bql-schema/types/objects/java-script-response\#javascriptresponseenabledboolean- "Direct link to javascriptresponseenabledboolean-")

Whether or not JavaScript is enabled on the page

#### [`JavaScriptResponse.time`](https://docs.browserless.io/bql-schema/types/objects/java-script-response\#)Â â—Â [`Float`](https://docs.browserless.io/bql-schema/types/scalars/float) scalar [â€‹](https://docs.browserless.io/bql-schema/types/objects/java-script-response\#javascriptresponsetimefloat- "Direct link to javascriptresponsetimefloat-")

The time it took to perform this action

### Returned By [â€‹](https://docs.browserless.io/bql-schema/types/objects/java-script-response\#returned-by "Direct link to Returned By")

[`javaScriptEnabled`](https://docs.browserless.io/bql-schema/operations/mutations/java-script-enabled) mutation

- [Fields](https://docs.browserless.io/bql-schema/types/objects/java-script-response#fields)
- [Returned By](https://docs.browserless.io/bql-schema/types/objects/java-script-response#returned-by)

---

### LiveURLResponse | Browserless.io
Original URL: https://docs.browserless.io/bql-schema/types/objects/live-urlresponse

[Skip to main content](https://docs.browserless.io/bql-schema/types/objects/live-urlresponse#__docusaurus_skipToContent_fallback)


The response from the Live-URL query

```codeBlockLines_p187
type LiveURLResponse {
  liveURLId: String
  liveURL: String
}

```

### Fields [â€‹](https://docs.browserless.io/bql-schema/types/objects/live-urlresponse\#fields "Direct link to Fields")

#### [`LiveURLResponse.liveURLId`](https://docs.browserless.io/bql-schema/types/objects/live-urlresponse\#)Â â—Â [`String`](https://docs.browserless.io/bql-schema/types/scalars/string) scalar [â€‹](https://docs.browserless.io/bql-schema/types/objects/live-urlresponse\#liveurlresponseliveurlidstring- "Direct link to liveurlresponseliveurlidstring-")

A unique ID representing the session. Useful for storing and associations in other APIs

#### [`LiveURLResponse.liveURL`](https://docs.browserless.io/bql-schema/types/objects/live-urlresponse\#)Â â—Â [`String`](https://docs.browserless.io/bql-schema/types/scalars/string) scalar [â€‹](https://docs.browserless.io/bql-schema/types/objects/live-urlresponse\#liveurlresponseliveurlstring- "Direct link to liveurlresponseliveurlstring-")

The fully-qualified URL to share with the end-user to allow them to live-stream the browser

### Returned By [â€‹](https://docs.browserless.io/bql-schema/types/objects/live-urlresponse\#returned-by "Direct link to Returned By")

[`liveURL`](https://docs.browserless.io/bql-schema/operations/mutations/live-url) mutation

- [Fields](https://docs.browserless.io/bql-schema/types/objects/live-urlresponse#fields)
- [Returned By](https://docs.browserless.io/bql-schema/types/objects/live-urlresponse#returned-by)

---

### MapSelectorResponse | Browserless.io
Original URL: https://docs.browserless.io/bql-schema/types/objects/map-selector-response

[Skip to main content](https://docs.browserless.io/bql-schema/types/objects/map-selector-response#__docusaurus_skipToContent_fallback)


Response returned from a Map Selector

```codeBlockLines_p187
type MapSelectorResponse {
  innerHTML: String
  innerText: String
  id: String
  class: [String]
  attribute(
    name: String
  ): Attribute
  mapSelector(
    selector: String!
    timeout: Float
    wait: Boolean = true
  ): [MapSelectorResponse]
}

```

### Fields [â€‹](https://docs.browserless.io/bql-schema/types/objects/map-selector-response\#fields "Direct link to Fields")

#### [`MapSelectorResponse.innerHTML`](https://docs.browserless.io/bql-schema/types/objects/map-selector-response\#)Â â—Â [`String`](https://docs.browserless.io/bql-schema/types/scalars/string) scalar [â€‹](https://docs.browserless.io/bql-schema/types/objects/map-selector-response\#mapselectorresponseinnerhtmlstring- "Direct link to mapselectorresponseinnerhtmlstring-")

The innerHTML of the selected DOM Node

#### [`MapSelectorResponse.innerText`](https://docs.browserless.io/bql-schema/types/objects/map-selector-response\#)Â â—Â [`String`](https://docs.browserless.io/bql-schema/types/scalars/string) scalar [â€‹](https://docs.browserless.io/bql-schema/types/objects/map-selector-response\#mapselectorresponseinnertextstring- "Direct link to mapselectorresponseinnertextstring-")

The innerText of the selected DOM Node, eg, the raw textual content

#### [`MapSelectorResponse.id`](https://docs.browserless.io/bql-schema/types/objects/map-selector-response\#)Â â—Â [`String`](https://docs.browserless.io/bql-schema/types/scalars/string) scalar [â€‹](https://docs.browserless.io/bql-schema/types/objects/map-selector-response\#mapselectorresponseidstring- "Direct link to mapselectorresponseidstring-")

The ID attribute's value, if any, of the node

#### [`MapSelectorResponse.class`](https://docs.browserless.io/bql-schema/types/objects/map-selector-response\#)Â â—Â [`[String]`](https://docs.browserless.io/bql-schema/types/scalars/string) listscalar [â€‹](https://docs.browserless.io/bql-schema/types/objects/map-selector-response\#mapselectorresponseclassstring-- "Direct link to mapselectorresponseclassstring--")

The class attribute's value, if any, of the node represented as an array of strings

#### [`MapSelectorResponse.attribute`](https://docs.browserless.io/bql-schema/types/objects/map-selector-response\#)Â â—Â [`Attribute`](https://docs.browserless.io/bql-schema/types/objects/attribute) object [â€‹](https://docs.browserless.io/bql-schema/types/objects/map-selector-response\#mapselectorresponseattributeattribute- "Direct link to mapselectorresponseattributeattribute-")

Retrieve an attribute by the name of the attribute itself, eg, "data-test-id"

##### [`MapSelectorResponse.attribute.name`](https://docs.browserless.io/bql-schema/types/objects/map-selector-response\#)Â â—Â [`String`](https://docs.browserless.io/bql-schema/types/scalars/string) scalar [â€‹](https://docs.browserless.io/bql-schema/types/objects/map-selector-response\#mapselectorresponseattributenamestring- "Direct link to mapselectorresponseattributenamestring-")

#### [`MapSelectorResponse.mapSelector`](https://docs.browserless.io/bql-schema/types/objects/map-selector-response\#)Â â—Â [`[MapSelectorResponse]`](https://docs.browserless.io/bql-schema/types/objects/map-selector-response) listobject [â€‹](https://docs.browserless.io/bql-schema/types/objects/map-selector-response\#mapselectorresponsemapselectormapselectorresponse-- "Direct link to mapselectorresponsemapselectormapselectorresponse--")

You can further map nested DOM nodes as well. For instance, given a parent ".product" node, you can map further nodes like ".price" or ".shipping" as examples. This will give you items appropriately nested by their parent node for better hierarchical representation of data

##### [`MapSelectorResponse.mapSelector.selector`](https://docs.browserless.io/bql-schema/types/objects/map-selector-response\#)Â â—Â [`String!`](https://docs.browserless.io/bql-schema/types/scalars/string) non-nullscalar [â€‹](https://docs.browserless.io/bql-schema/types/objects/map-selector-response\#mapselectorresponsemapselectorselectorstring-- "Direct link to mapselectorresponsemapselectorselectorstring--")

A query-selector-al compatible string, or JavaScript code that returns an DOM NodeList. Examples include:

- All `<button />` Elements:
`selector: "button"`

- A JavaScript snippet that returns a button element
`selector: "document.querySelectorAll('button')"`


##### [`MapSelectorResponse.mapSelector.timeout`](https://docs.browserless.io/bql-schema/types/objects/map-selector-response\#)Â â—Â [`Float`](https://docs.browserless.io/bql-schema/types/scalars/float) scalar [â€‹](https://docs.browserless.io/bql-schema/types/objects/map-selector-response\#mapselectorresponsemapselectortimeoutfloat- "Direct link to mapselectorresponsemapselectortimeoutfloat-")

How long to wait for the element to appear before timing out, overriding any defaults. Default timeout is 30 seconds, or 30000.

##### [`MapSelectorResponse.mapSelector.wait`](https://docs.browserless.io/bql-schema/types/objects/map-selector-response\#)Â â—Â [`Boolean`](https://docs.browserless.io/bql-schema/types/scalars/boolean) scalar [â€‹](https://docs.browserless.io/bql-schema/types/objects/map-selector-response\#mapselectorresponsemapselectorwaitboolean- "Direct link to mapselectorresponsemapselectorwaitboolean-")

Whether or not to wait for the selectors to present in the DOM

### Returned By [â€‹](https://docs.browserless.io/bql-schema/types/objects/map-selector-response\#returned-by "Direct link to Returned By")

[`mapSelector`](https://docs.browserless.io/bql-schema/operations/mutations/map-selector) mutation

### Member Of [â€‹](https://docs.browserless.io/bql-schema/types/objects/map-selector-response\#member-of "Direct link to Member Of")

[`MapSelectorResponse`](https://docs.browserless.io/bql-schema/types/objects/map-selector-response) object

- [Fields](https://docs.browserless.io/bql-schema/types/objects/map-selector-response#fields)
- [Returned By](https://docs.browserless.io/bql-schema/types/objects/map-selector-response#returned-by)
- [Member Of](https://docs.browserless.io/bql-schema/types/objects/map-selector-response#member-of)

---

### Mutation | Browserless.io
Original URL: https://docs.browserless.io/bql-schema/types/objects/mutation

[Skip to main content](https://docs.browserless.io/bql-schema/types/objects/mutation#__docusaurus_skipToContent_fallback)

This document is a complete technical specification of every mutation in the BrowserQL API. To get you started, the ones you'll use most will probably include:

- [goto](https://docs.browserless.io/bql-schema/operations/mutations/goto)
- [reject](https://docs.browserless.io/bql-schema/operations/mutations/reject)
- [proxy](https://docs.browserless.io/bql-schema/operations/mutations/proxy)
- [click](https://docs.browserless.io/bql-schema/operations/mutations/click)
- [type](https://docs.browserless.io/bql-schema/operations/mutations/type)
- [html](https://docs.browserless.io/bql-schema/operations/mutations/html)
- [reconnect](https://docs.browserless.io/bql-schema/operations/mutations/reconnect)

---

### PDFResponse | Browserless.io
Original URL: https://docs.browserless.io/bql-schema/types/objects/pdfresponse

[Skip to main content](https://docs.browserless.io/bql-schema/types/objects/pdfresponse#__docusaurus_skipToContent_fallback)


The response returned after generating a PDF

```codeBlockLines_p187
type PDFResponse {
  base64: String
  size: Float
  time: Float
}

```

### Fields [â€‹](https://docs.browserless.io/bql-schema/types/objects/pdfresponse\#fields "Direct link to Fields")

#### [`PDFResponse.base64`](https://docs.browserless.io/bql-schema/types/objects/pdfresponse\#)Â â—Â [`String`](https://docs.browserless.io/bql-schema/types/scalars/string) scalar [â€‹](https://docs.browserless.io/bql-schema/types/objects/pdfresponse\#pdfresponsebase64string- "Direct link to pdfresponsebase64string-")

Base64 encoded PDF content

#### [`PDFResponse.size`](https://docs.browserless.io/bql-schema/types/objects/pdfresponse\#)Â â—Â [`Float`](https://docs.browserless.io/bql-schema/types/scalars/float) scalar [â€‹](https://docs.browserless.io/bql-schema/types/objects/pdfresponse\#pdfresponsesizefloat- "Direct link to pdfresponsesizefloat-")

The size of the resulting PDF in bytes

#### [`PDFResponse.time`](https://docs.browserless.io/bql-schema/types/objects/pdfresponse\#)Â â—Â [`Float`](https://docs.browserless.io/bql-schema/types/scalars/float) scalar [â€‹](https://docs.browserless.io/bql-schema/types/objects/pdfresponse\#pdfresponsetimefloat- "Direct link to pdfresponsetimefloat-")

The time it took to generate the PDF

### Returned By [â€‹](https://docs.browserless.io/bql-schema/types/objects/pdfresponse\#returned-by "Direct link to Returned By")

[`pdf`](https://docs.browserless.io/bql-schema/operations/mutations/pdf) mutation

- [Fields](https://docs.browserless.io/bql-schema/types/objects/pdfresponse#fields)
- [Returned By](https://docs.browserless.io/bql-schema/types/objects/pdfresponse#returned-by)

---

### ProxyResponse | Browserless.io
Original URL: https://docs.browserless.io/bql-schema/types/objects/proxy-response

[Skip to main content](https://docs.browserless.io/bql-schema/types/objects/proxy-response#__docusaurus_skipToContent_fallback)


Response returned after setting up the proxy patterns

```codeBlockLines_p187
type ProxyResponse {
  time: Float
}

```

### Fields [â€‹](https://docs.browserless.io/bql-schema/types/objects/proxy-response\#fields "Direct link to Fields")

#### [`ProxyResponse.time`](https://docs.browserless.io/bql-schema/types/objects/proxy-response\#)Â â—Â [`Float`](https://docs.browserless.io/bql-schema/types/scalars/float) scalar [â€‹](https://docs.browserless.io/bql-schema/types/objects/proxy-response\#proxyresponsetimefloat- "Direct link to proxyresponsetimefloat-")

### Returned By [â€‹](https://docs.browserless.io/bql-schema/types/objects/proxy-response\#returned-by "Direct link to Returned By")

[`proxy`](https://docs.browserless.io/bql-schema/operations/mutations/proxy) mutation

- [Fields](https://docs.browserless.io/bql-schema/types/objects/proxy-response#fields)
- [Returned By](https://docs.browserless.io/bql-schema/types/objects/proxy-response#returned-by)

---

### QuerySelectorResponse | Browserless.io
Original URL: https://docs.browserless.io/bql-schema/types/objects/query-selector-response

[Skip to main content](https://docs.browserless.io/bql-schema/types/objects/query-selector-response#__docusaurus_skipToContent_fallback)


The response returned after querying the page for a selector

```codeBlockLines_p187
type QuerySelectorResponse {
  childElementCount: Float
  className: String
  id: String
  innerHTML: String
  innerText: String
  localName: String
  outerHTML: String
}

```

### Fields [â€‹](https://docs.browserless.io/bql-schema/types/objects/query-selector-response\#fields "Direct link to Fields")

#### [`QuerySelectorResponse.childElementCount`](https://docs.browserless.io/bql-schema/types/objects/query-selector-response\#)Â â—Â [`Float`](https://docs.browserless.io/bql-schema/types/scalars/float) scalar [â€‹](https://docs.browserless.io/bql-schema/types/objects/query-selector-response\#queryselectorresponsechildelementcountfloat- "Direct link to queryselectorresponsechildelementcountfloat-")

The Element.childElementCount read-only property returns the number of child elements of this element

#### [`QuerySelectorResponse.className`](https://docs.browserless.io/bql-schema/types/objects/query-selector-response\#)Â â—Â [`String`](https://docs.browserless.io/bql-schema/types/scalars/string) scalar [â€‹](https://docs.browserless.io/bql-schema/types/objects/query-selector-response\#queryselectorresponseclassnamestring- "Direct link to queryselectorresponseclassnamestring-")

The className property of the Element interface gets and sets the value of the class attribute of the specified element

#### [`QuerySelectorResponse.id`](https://docs.browserless.io/bql-schema/types/objects/query-selector-response\#)Â â—Â [`String`](https://docs.browserless.io/bql-schema/types/scalars/string) scalar [â€‹](https://docs.browserless.io/bql-schema/types/objects/query-selector-response\#queryselectorresponseidstring- "Direct link to queryselectorresponseidstring-")

The id property of the Element interface represents the element's identifier, reflecting the id global attribute

#### [`QuerySelectorResponse.innerHTML`](https://docs.browserless.io/bql-schema/types/objects/query-selector-response\#)Â â—Â [`String`](https://docs.browserless.io/bql-schema/types/scalars/string) scalar [â€‹](https://docs.browserless.io/bql-schema/types/objects/query-selector-response\#queryselectorresponseinnerhtmlstring- "Direct link to queryselectorresponseinnerhtmlstring-")

The Element property innerHTML gets the HTML or XML markup contained within the element

#### [`QuerySelectorResponse.innerText`](https://docs.browserless.io/bql-schema/types/objects/query-selector-response\#)Â â—Â [`String`](https://docs.browserless.io/bql-schema/types/scalars/string) scalar [â€‹](https://docs.browserless.io/bql-schema/types/objects/query-selector-response\#queryselectorresponseinnertextstring- "Direct link to queryselectorresponseinnertextstring-")

The Element property innerText gets the text contained within the element

#### [`QuerySelectorResponse.localName`](https://docs.browserless.io/bql-schema/types/objects/query-selector-response\#)Â â—Â [`String`](https://docs.browserless.io/bql-schema/types/scalars/string) scalar [â€‹](https://docs.browserless.io/bql-schema/types/objects/query-selector-response\#queryselectorresponselocalnamestring- "Direct link to queryselectorresponselocalnamestring-")

The Element.localName read-only property returns the local part of the qualified name of an element

#### [`QuerySelectorResponse.outerHTML`](https://docs.browserless.io/bql-schema/types/objects/query-selector-response\#)Â â—Â [`String`](https://docs.browserless.io/bql-schema/types/scalars/string) scalar [â€‹](https://docs.browserless.io/bql-schema/types/objects/query-selector-response\#queryselectorresponseouterhtmlstring- "Direct link to queryselectorresponseouterhtmlstring-")

The outerHTML attribute of the Element DOM interface gets the serialized HTML fragment describing the element including its descendants. It can also be set to replace the element with nodes parsed from the given string

### Returned By [â€‹](https://docs.browserless.io/bql-schema/types/objects/query-selector-response\#returned-by "Direct link to Returned By")

[`querySelector`](https://docs.browserless.io/bql-schema/operations/mutations/query-selector) mutationÂ â—Â [`querySelectorAll`](https://docs.browserless.io/bql-schema/operations/mutations/query-selector-all) mutation

- [Fields](https://docs.browserless.io/bql-schema/types/objects/query-selector-response#fields)
- [Returned By](https://docs.browserless.io/bql-schema/types/objects/query-selector-response#returned-by)

---

### ReconnectionResponse | Browserless.io
Original URL: https://docs.browserless.io/bql-schema/types/objects/reconnection-response

[Skip to main content](https://docs.browserless.io/bql-schema/types/objects/reconnection-response#__docusaurus_skipToContent_fallback)


The response received after attempting to reconnect a BrowserQL session

```codeBlockLines_p187
type ReconnectionResponse {
  browserQLEndpoint: String
  browserWSEndpoint: String
  devtoolsFrontendUrl: String
  webSocketDebuggerUrl: String
}

```

### Fields [â€‹](https://docs.browserless.io/bql-schema/types/objects/reconnection-response\#fields "Direct link to Fields")

#### [`ReconnectionResponse.browserQLEndpoint`](https://docs.browserless.io/bql-schema/types/objects/reconnection-response\#)Â â—Â [`String`](https://docs.browserless.io/bql-schema/types/scalars/string) scalar [â€‹](https://docs.browserless.io/bql-schema/types/objects/reconnection-response\#reconnectionresponsebrowserqlendpointstring- "Direct link to reconnectionresponsebrowserqlendpointstring-")

The fully-qualified URL to reconnect future BrowserQL sessions, eg: [https://chrome.browserless.io/bql/$id](https://chrome.browserless.io/bql/$id). Please note that token information is not returned by this API and might be required

#### [`ReconnectionResponse.browserWSEndpoint`](https://docs.browserless.io/bql-schema/types/objects/reconnection-response\#)Â â—Â [`String`](https://docs.browserless.io/bql-schema/types/scalars/string) scalar [â€‹](https://docs.browserless.io/bql-schema/types/objects/reconnection-response\#reconnectionresponsebrowserwsendpointstring- "Direct link to reconnectionresponsebrowserwsendpointstring-")

The fully-qualified URL of the browserWSEndpoint which can be used with other libraries like playwright or puppeteer. Please note that token information is not returned by this API and might be required

#### [`ReconnectionResponse.devtoolsFrontendUrl`](https://docs.browserless.io/bql-schema/types/objects/reconnection-response\#)Â â—Â [`String`](https://docs.browserless.io/bql-schema/types/scalars/string) scalar [â€‹](https://docs.browserless.io/bql-schema/types/objects/reconnection-response\#reconnectionresponsedevtoolsfrontendurlstring- "Direct link to reconnectionresponsedevtoolsfrontendurlstring-")

The fully-qualified URL of the devtools resources for loading Chrome's developer tools remotely

#### [`ReconnectionResponse.webSocketDebuggerUrl`](https://docs.browserless.io/bql-schema/types/objects/reconnection-response\#)Â â—Â [`String`](https://docs.browserless.io/bql-schema/types/scalars/string) scalar [â€‹](https://docs.browserless.io/bql-schema/types/objects/reconnection-response\#reconnectionresponsewebsocketdebuggerurlstring- "Direct link to reconnectionresponsewebsocketdebuggerurlstring-")

The underlying page's webSocketDebuggerUrl, useful for hooking libraries that operate on a page and not a browser object

### Returned By [â€‹](https://docs.browserless.io/bql-schema/types/objects/reconnection-response\#returned-by "Direct link to Returned By")

[`reconnect`](https://docs.browserless.io/bql-schema/operations/mutations/reconnect) mutation

- [Fields](https://docs.browserless.io/bql-schema/types/objects/reconnection-response#fields)
- [Returned By](https://docs.browserless.io/bql-schema/types/objects/reconnection-response#returned-by)

---

### RejectResponse | Browserless.io
Original URL: https://docs.browserless.io/bql-schema/types/objects/reject-response

[Skip to main content](https://docs.browserless.io/bql-schema/types/objects/reject-response#__docusaurus_skipToContent_fallback)


The response parameters for the reject mutation

```codeBlockLines_p187
type RejectResponse {
  time: Float
  enabled: Boolean
}

```

### Fields [â€‹](https://docs.browserless.io/bql-schema/types/objects/reject-response\#fields "Direct link to Fields")

#### [`RejectResponse.time`](https://docs.browserless.io/bql-schema/types/objects/reject-response\#)Â â—Â [`Float`](https://docs.browserless.io/bql-schema/types/scalars/float) scalar [â€‹](https://docs.browserless.io/bql-schema/types/objects/reject-response\#rejectresponsetimefloat- "Direct link to rejectresponsetimefloat-")

#### [`RejectResponse.enabled`](https://docs.browserless.io/bql-schema/types/objects/reject-response\#)Â â—Â [`Boolean`](https://docs.browserless.io/bql-schema/types/scalars/boolean) scalar [â€‹](https://docs.browserless.io/bql-schema/types/objects/reject-response\#rejectresponseenabledboolean- "Direct link to rejectresponseenabledboolean-")

### Returned By [â€‹](https://docs.browserless.io/bql-schema/types/objects/reject-response\#returned-by "Direct link to Returned By")

[`reject`](https://docs.browserless.io/bql-schema/operations/mutations/reject) mutation

- [Fields](https://docs.browserless.io/bql-schema/types/objects/reject-response#fields)
- [Returned By](https://docs.browserless.io/bql-schema/types/objects/reject-response#returned-by)

---

### RequestResponse | Browserless.io
Original URL: https://docs.browserless.io/bql-schema/types/objects/request-response

[Skip to main content](https://docs.browserless.io/bql-schema/types/objects/request-response#__docusaurus_skipToContent_fallback)


Response returned from the request API

```codeBlockLines_p187
type RequestResponse {
  url: String
  method: Method
  type: ResourceType
  headers: [Headers]
}

```

### Fields [â€‹](https://docs.browserless.io/bql-schema/types/objects/request-response\#fields "Direct link to Fields")

#### [`RequestResponse.url`](https://docs.browserless.io/bql-schema/types/objects/request-response\#)Â â—Â [`String`](https://docs.browserless.io/bql-schema/types/scalars/string) scalar [â€‹](https://docs.browserless.io/bql-schema/types/objects/request-response\#requestresponseurlstring- "Direct link to requestresponseurlstring-")

The final URL of the request

#### [`RequestResponse.method`](https://docs.browserless.io/bql-schema/types/objects/request-response\#)Â â—Â [`Method`](https://docs.browserless.io/bql-schema/types/enums/method) enum [â€‹](https://docs.browserless.io/bql-schema/types/objects/request-response\#requestresponsemethodmethod- "Direct link to requestresponsemethodmethod-")

The HTTP method of the request

#### [`RequestResponse.type`](https://docs.browserless.io/bql-schema/types/objects/request-response\#)Â â—Â [`ResourceType`](https://docs.browserless.io/bql-schema/types/enums/resource-type) enum [â€‹](https://docs.browserless.io/bql-schema/types/objects/request-response\#requestresponsetyperesourcetype- "Direct link to requestresponsetyperesourcetype-")

The type of request that was made

#### [`RequestResponse.headers`](https://docs.browserless.io/bql-schema/types/objects/request-response\#)Â â—Â [`[Headers]`](https://docs.browserless.io/bql-schema/types/objects/headers) listobject [â€‹](https://docs.browserless.io/bql-schema/types/objects/request-response\#requestresponseheadersheaders-- "Direct link to requestresponseheadersheaders--")

The headers of the request

### Returned By [â€‹](https://docs.browserless.io/bql-schema/types/objects/request-response\#returned-by "Direct link to Returned By")

[`request`](https://docs.browserless.io/bql-schema/operations/mutations/request) mutation

- [Fields](https://docs.browserless.io/bql-schema/types/objects/request-response#fields)
- [Returned By](https://docs.browserless.io/bql-schema/types/objects/request-response#returned-by)

---

### ResponseResponse | Browserless.io
Original URL: https://docs.browserless.io/bql-schema/types/objects/response-response

[Skip to main content](https://docs.browserless.io/bql-schema/types/objects/response-response#__docusaurus_skipToContent_fallback)


Response returned from the response API

```codeBlockLines_p187
type ResponseResponse {
  status: Int
  url: String
  method: Method
  type: ResourceType
  headers: [Headers]
  body: String
}

```

### Fields [â€‹](https://docs.browserless.io/bql-schema/types/objects/response-response\#fields "Direct link to Fields")

#### [`ResponseResponse.status`](https://docs.browserless.io/bql-schema/types/objects/response-response\#)Â â—Â [`Int`](https://docs.browserless.io/bql-schema/types/scalars/int) scalar [â€‹](https://docs.browserless.io/bql-schema/types/objects/response-response\#responseresponsestatusint- "Direct link to responseresponsestatusint-")

The HTTP status code of the response

#### [`ResponseResponse.url`](https://docs.browserless.io/bql-schema/types/objects/response-response\#)Â â—Â [`String`](https://docs.browserless.io/bql-schema/types/scalars/string) scalar [â€‹](https://docs.browserless.io/bql-schema/types/objects/response-response\#responseresponseurlstring- "Direct link to responseresponseurlstring-")

The final URL of the response

#### [`ResponseResponse.method`](https://docs.browserless.io/bql-schema/types/objects/response-response\#)Â â—Â [`Method`](https://docs.browserless.io/bql-schema/types/enums/method) enum [â€‹](https://docs.browserless.io/bql-schema/types/objects/response-response\#responseresponsemethodmethod- "Direct link to responseresponsemethodmethod-")

The HTTP method of the request that facilitated the response

#### [`ResponseResponse.type`](https://docs.browserless.io/bql-schema/types/objects/response-response\#)Â â—Â [`ResourceType`](https://docs.browserless.io/bql-schema/types/enums/resource-type) enum [â€‹](https://docs.browserless.io/bql-schema/types/objects/response-response\#responseresponsetyperesourcetype- "Direct link to responseresponsetyperesourcetype-")

The type of response that was received

#### [`ResponseResponse.headers`](https://docs.browserless.io/bql-schema/types/objects/response-response\#)Â â—Â [`[Headers]`](https://docs.browserless.io/bql-schema/types/objects/headers) listobject [â€‹](https://docs.browserless.io/bql-schema/types/objects/response-response\#responseresponseheadersheaders-- "Direct link to responseresponseheadersheaders--")

The response headers returned

#### [`ResponseResponse.body`](https://docs.browserless.io/bql-schema/types/objects/response-response\#)Â â—Â [`String`](https://docs.browserless.io/bql-schema/types/scalars/string) scalar [â€‹](https://docs.browserless.io/bql-schema/types/objects/response-response\#responseresponsebodystring- "Direct link to responseresponsebodystring-")

The body of the response, represented as a string when possible or base64 for binary-type requests like images

### Returned By [â€‹](https://docs.browserless.io/bql-schema/types/objects/response-response\#returned-by "Direct link to Returned By")

[`response`](https://docs.browserless.io/bql-schema/operations/mutations/response) mutation

- [Fields](https://docs.browserless.io/bql-schema/types/objects/response-response#fields)
- [Returned By](https://docs.browserless.io/bql-schema/types/objects/response-response#returned-by)

---

### ScreenshotResponse | Browserless.io
Original URL: https://docs.browserless.io/bql-schema/types/objects/screenshot-response

[Skip to main content](https://docs.browserless.io/bql-schema/types/objects/screenshot-response#__docusaurus_skipToContent_fallback)


The response returned after generating a Screenshot

```codeBlockLines_p187
type ScreenshotResponse {
  base64: String
  format: String
  time: Float
}

```

### Fields [â€‹](https://docs.browserless.io/bql-schema/types/objects/screenshot-response\#fields "Direct link to Fields")

#### [`ScreenshotResponse.base64`](https://docs.browserless.io/bql-schema/types/objects/screenshot-response\#)Â â—Â [`String`](https://docs.browserless.io/bql-schema/types/scalars/string) scalar [â€‹](https://docs.browserless.io/bql-schema/types/objects/screenshot-response\#screenshotresponsebase64string- "Direct link to screenshotresponsebase64string-")

The base64 encoded image of the screenshot

#### [`ScreenshotResponse.format`](https://docs.browserless.io/bql-schema/types/objects/screenshot-response\#)Â â—Â [`String`](https://docs.browserless.io/bql-schema/types/scalars/string) scalar [â€‹](https://docs.browserless.io/bql-schema/types/objects/screenshot-response\#screenshotresponseformatstring- "Direct link to screenshotresponseformatstring-")

The format of the screenshot

#### [`ScreenshotResponse.time`](https://docs.browserless.io/bql-schema/types/objects/screenshot-response\#)Â â—Â [`Float`](https://docs.browserless.io/bql-schema/types/scalars/float) scalar [â€‹](https://docs.browserless.io/bql-schema/types/objects/screenshot-response\#screenshotresponsetimefloat- "Direct link to screenshotresponsetimefloat-")

The time it took to take the screenshot

### Returned By [â€‹](https://docs.browserless.io/bql-schema/types/objects/screenshot-response\#returned-by "Direct link to Returned By")

[`screenshot`](https://docs.browserless.io/bql-schema/operations/mutations/screenshot) mutation

- [Fields](https://docs.browserless.io/bql-schema/types/objects/screenshot-response#fields)
- [Returned By](https://docs.browserless.io/bql-schema/types/objects/screenshot-response#returned-by)

---

### ScrollResponse | Browserless.io
Original URL: https://docs.browserless.io/bql-schema/types/objects/scroll-response

[Skip to main content](https://docs.browserless.io/bql-schema/types/objects/scroll-response#__docusaurus_skipToContent_fallback)


Response returned after having scrolling inside the page

```codeBlockLines_p187
type ScrollResponse {
  selector: String
  time: Float
  x: Float
  y: Float
}

```

### Fields [â€‹](https://docs.browserless.io/bql-schema/types/objects/scroll-response\#fields "Direct link to Fields")

#### [`ScrollResponse.selector`](https://docs.browserless.io/bql-schema/types/objects/scroll-response\#)Â â—Â [`String`](https://docs.browserless.io/bql-schema/types/scalars/string) scalar [â€‹](https://docs.browserless.io/bql-schema/types/objects/scroll-response\#scrollresponseselectorstring- "Direct link to scrollresponseselectorstring-")

The CSS selector of the element on the page you want to scroll to

#### [`ScrollResponse.time`](https://docs.browserless.io/bql-schema/types/objects/scroll-response\#)Â â—Â [`Float`](https://docs.browserless.io/bql-schema/types/scalars/float) scalar [â€‹](https://docs.browserless.io/bql-schema/types/objects/scroll-response\#scrollresponsetimefloat- "Direct link to scrollresponsetimefloat-")

The amount of time, in milliseconds, elapsed since the start of scrolling to completion

#### [`ScrollResponse.x`](https://docs.browserless.io/bql-schema/types/objects/scroll-response\#)Â â—Â [`Float`](https://docs.browserless.io/bql-schema/types/scalars/float) scalar [â€‹](https://docs.browserless.io/bql-schema/types/objects/scroll-response\#scrollresponsexfloat- "Direct link to scrollresponsexfloat-")

The X coordinate, in pixels, to scroll to

#### [`ScrollResponse.y`](https://docs.browserless.io/bql-schema/types/objects/scroll-response\#)Â â—Â [`Float`](https://docs.browserless.io/bql-schema/types/scalars/float) scalar [â€‹](https://docs.browserless.io/bql-schema/types/objects/scroll-response\#scrollresponseyfloat- "Direct link to scrollresponseyfloat-")

The Y coordinate, in pixels, to scroll to

### Returned By [â€‹](https://docs.browserless.io/bql-schema/types/objects/scroll-response\#returned-by "Direct link to Returned By")

[`scroll`](https://docs.browserless.io/bql-schema/operations/mutations/scroll) mutation

- [Fields](https://docs.browserless.io/bql-schema/types/objects/scroll-response#fields)
- [Returned By](https://docs.browserless.io/bql-schema/types/objects/scroll-response#returned-by)

---

### SelectResponse | Browserless.io
Original URL: https://docs.browserless.io/bql-schema/types/objects/select-response

[Skip to main content](https://docs.browserless.io/bql-schema/types/objects/select-response#__docusaurus_skipToContent_fallback)


The response returned after selecting a value from a dropdown or multiple select element

```codeBlockLines_p187
type SelectResponse {
  selector: String
  time: Float
  value: StringOrArray
}

```

### Fields [â€‹](https://docs.browserless.io/bql-schema/types/objects/select-response\#fields "Direct link to Fields")

#### [`SelectResponse.selector`](https://docs.browserless.io/bql-schema/types/objects/select-response\#)Â â—Â [`String`](https://docs.browserless.io/bql-schema/types/scalars/string) scalar [â€‹](https://docs.browserless.io/bql-schema/types/objects/select-response\#selectresponseselectorstring- "Direct link to selectresponseselectorstring-")

The selector of the element you selected from

#### [`SelectResponse.time`](https://docs.browserless.io/bql-schema/types/objects/select-response\#)Â â—Â [`Float`](https://docs.browserless.io/bql-schema/types/scalars/float) scalar [â€‹](https://docs.browserless.io/bql-schema/types/objects/select-response\#selectresponsetimefloat- "Direct link to selectresponsetimefloat-")

The amount of time, in milliseconds, elapsed since the start of selecting to completion

#### [`SelectResponse.value`](https://docs.browserless.io/bql-schema/types/objects/select-response\#)Â â—Â [`StringOrArray`](https://docs.browserless.io/bql-schema/types/scalars/string-or-array) scalar [â€‹](https://docs.browserless.io/bql-schema/types/objects/select-response\#selectresponsevaluestringorarray- "Direct link to selectresponsevaluestringorarray-")

The value or values you selected from the select element

### Returned By [â€‹](https://docs.browserless.io/bql-schema/types/objects/select-response\#returned-by "Direct link to Returned By")

[`select`](https://docs.browserless.io/bql-schema/operations/mutations/select) mutation

- [Fields](https://docs.browserless.io/bql-schema/types/objects/select-response#fields)
- [Returned By](https://docs.browserless.io/bql-schema/types/objects/select-response#returned-by)

---

### StandardCookie | Browserless.io
Original URL: https://docs.browserless.io/bql-schema/types/objects/standard-cookie

[Skip to main content](https://docs.browserless.io/bql-schema/types/objects/standard-cookie#__docusaurus_skipToContent_fallback)


A standard cookie

```codeBlockLines_p187
type StandardCookie {
  domain: String
  expires: Float
  httpOnly: Boolean
  name: String!
  path: String
  sameSite: CookieSameSite
  secure: Boolean
  value: String!
  url: String
}

```

### Fields [â€‹](https://docs.browserless.io/bql-schema/types/objects/standard-cookie\#fields "Direct link to Fields")

#### [`StandardCookie.domain`](https://docs.browserless.io/bql-schema/types/objects/standard-cookie\#)Â â—Â [`String`](https://docs.browserless.io/bql-schema/types/scalars/string) scalar [â€‹](https://docs.browserless.io/bql-schema/types/objects/standard-cookie\#standardcookiedomainstring- "Direct link to standardcookiedomainstring-")

Cookie domain

#### [`StandardCookie.expires`](https://docs.browserless.io/bql-schema/types/objects/standard-cookie\#)Â â—Â [`Float`](https://docs.browserless.io/bql-schema/types/scalars/float) scalar [â€‹](https://docs.browserless.io/bql-schema/types/objects/standard-cookie\#standardcookieexpiresfloat- "Direct link to standardcookieexpiresfloat-")

Cookie expiration date, session cookie if not set

#### [`StandardCookie.httpOnly`](https://docs.browserless.io/bql-schema/types/objects/standard-cookie\#)Â â—Â [`Boolean`](https://docs.browserless.io/bql-schema/types/scalars/boolean) scalar [â€‹](https://docs.browserless.io/bql-schema/types/objects/standard-cookie\#standardcookiehttponlyboolean- "Direct link to standardcookiehttponlyboolean-")

True if cookie is http-only

#### [`StandardCookie.name`](https://docs.browserless.io/bql-schema/types/objects/standard-cookie\#)Â â—Â [`String!`](https://docs.browserless.io/bql-schema/types/scalars/string) non-nullscalar [â€‹](https://docs.browserless.io/bql-schema/types/objects/standard-cookie\#standardcookienamestring-- "Direct link to standardcookienamestring--")

Cookie name

#### [`StandardCookie.path`](https://docs.browserless.io/bql-schema/types/objects/standard-cookie\#)Â â—Â [`String`](https://docs.browserless.io/bql-schema/types/scalars/string) scalar [â€‹](https://docs.browserless.io/bql-schema/types/objects/standard-cookie\#standardcookiepathstring- "Direct link to standardcookiepathstring-")

Cookie path

#### [`StandardCookie.sameSite`](https://docs.browserless.io/bql-schema/types/objects/standard-cookie\#)Â â—Â [`CookieSameSite`](https://docs.browserless.io/bql-schema/types/enums/cookie-same-site) enum [â€‹](https://docs.browserless.io/bql-schema/types/objects/standard-cookie\#standardcookiesamesitecookiesamesite- "Direct link to standardcookiesamesitecookiesamesite-")

Cookie SameSite type

#### [`StandardCookie.secure`](https://docs.browserless.io/bql-schema/types/objects/standard-cookie\#)Â â—Â [`Boolean`](https://docs.browserless.io/bql-schema/types/scalars/boolean) scalar [â€‹](https://docs.browserless.io/bql-schema/types/objects/standard-cookie\#standardcookiesecureboolean- "Direct link to standardcookiesecureboolean-")

True if cookie is secure

#### [`StandardCookie.value`](https://docs.browserless.io/bql-schema/types/objects/standard-cookie\#)Â â—Â [`String!`](https://docs.browserless.io/bql-schema/types/scalars/string) non-nullscalar [â€‹](https://docs.browserless.io/bql-schema/types/objects/standard-cookie\#standardcookievaluestring-- "Direct link to standardcookievaluestring--")

Cookie value

#### [`StandardCookie.url`](https://docs.browserless.io/bql-schema/types/objects/standard-cookie\#)Â â—Â [`String`](https://docs.browserless.io/bql-schema/types/scalars/string) scalar [â€‹](https://docs.browserless.io/bql-schema/types/objects/standard-cookie\#standardcookieurlstring- "Direct link to standardcookieurlstring-")

The request-URI to associate with the setting of the cookie. This value can affect the default domain, path, source port, and source scheme values of the created cookie

### Member Of [â€‹](https://docs.browserless.io/bql-schema/types/objects/standard-cookie\#member-of "Direct link to Member Of")

[`CookieResponse`](https://docs.browserless.io/bql-schema/types/objects/cookie-response) object

- [Fields](https://docs.browserless.io/bql-schema/types/objects/standard-cookie#fields)
- [Member Of](https://docs.browserless.io/bql-schema/types/objects/standard-cookie#member-of)

---

### TextResponse | Browserless.io
Original URL: https://docs.browserless.io/bql-schema/types/objects/text-response

[Skip to main content](https://docs.browserless.io/bql-schema/types/objects/text-response#__docusaurus_skipToContent_fallback)


Text content of a page

```codeBlockLines_p187
type TextResponse {
  text: String
  time: Float
}

```

### Fields [â€‹](https://docs.browserless.io/bql-schema/types/objects/text-response\#fields "Direct link to Fields")

#### [`TextResponse.text`](https://docs.browserless.io/bql-schema/types/objects/text-response\#)Â â—Â [`String`](https://docs.browserless.io/bql-schema/types/scalars/string) scalar [â€‹](https://docs.browserless.io/bql-schema/types/objects/text-response\#textresponsetextstring- "Direct link to textresponsetextstring-")

The textual content of the page

#### [`TextResponse.time`](https://docs.browserless.io/bql-schema/types/objects/text-response\#)Â â—Â [`Float`](https://docs.browserless.io/bql-schema/types/scalars/float) scalar [â€‹](https://docs.browserless.io/bql-schema/types/objects/text-response\#textresponsetimefloat- "Direct link to textresponsetimefloat-")

The amount of time, in milliseconds, elapsed since the start of text retrieval to completion

### Returned By [â€‹](https://docs.browserless.io/bql-schema/types/objects/text-response\#returned-by "Direct link to Returned By")

[`text`](https://docs.browserless.io/bql-schema/operations/mutations/text) mutation

- [Fields](https://docs.browserless.io/bql-schema/types/objects/text-response#fields)
- [Returned By](https://docs.browserless.io/bql-schema/types/objects/text-response#returned-by)

---

### TitleResponse | Browserless.io
Original URL: https://docs.browserless.io/bql-schema/types/objects/title-response

[Skip to main content](https://docs.browserless.io/bql-schema/types/objects/title-response#__docusaurus_skipToContent_fallback)


Response returned after the page's title has been set or get

```codeBlockLines_p187
type TitleResponse {
  title: String
}

```

### Fields [â€‹](https://docs.browserless.io/bql-schema/types/objects/title-response\#fields "Direct link to Fields")

#### [`TitleResponse.title`](https://docs.browserless.io/bql-schema/types/objects/title-response\#)Â â—Â [`String`](https://docs.browserless.io/bql-schema/types/scalars/string) scalar [â€‹](https://docs.browserless.io/bql-schema/types/objects/title-response\#titleresponsetitlestring- "Direct link to titleresponsetitlestring-")

The title of the current page

### Returned By [â€‹](https://docs.browserless.io/bql-schema/types/objects/title-response\#returned-by "Direct link to Returned By")

[`title`](https://docs.browserless.io/bql-schema/operations/mutations/title) mutation

- [Fields](https://docs.browserless.io/bql-schema/types/objects/title-response#fields)
- [Returned By](https://docs.browserless.io/bql-schema/types/objects/title-response#returned-by)

---

### TypeResponse | Browserless.io
Original URL: https://docs.browserless.io/bql-schema/types/objects/type-response

[Skip to main content](https://docs.browserless.io/bql-schema/types/objects/type-response#__docusaurus_skipToContent_fallback)


Response returned after having typed into an element

```codeBlockLines_p187
type TypeResponse {
  selector: String
  text: String
  time: Float
  x: Float
  y: Float
}

```

### Fields [â€‹](https://docs.browserless.io/bql-schema/types/objects/type-response\#fields "Direct link to Fields")

#### [`TypeResponse.selector`](https://docs.browserless.io/bql-schema/types/objects/type-response\#)Â â—Â [`String`](https://docs.browserless.io/bql-schema/types/scalars/string) scalar [â€‹](https://docs.browserless.io/bql-schema/types/objects/type-response\#typeresponseselectorstring- "Direct link to typeresponseselectorstring-")

The selector of the element you typed into

#### [`TypeResponse.text`](https://docs.browserless.io/bql-schema/types/objects/type-response\#)Â â—Â [`String`](https://docs.browserless.io/bql-schema/types/scalars/string) scalar [â€‹](https://docs.browserless.io/bql-schema/types/objects/type-response\#typeresponsetextstring- "Direct link to typeresponsetextstring-")

The textual content that was typed

#### [`TypeResponse.time`](https://docs.browserless.io/bql-schema/types/objects/type-response\#)Â â—Â [`Float`](https://docs.browserless.io/bql-schema/types/scalars/float) scalar [â€‹](https://docs.browserless.io/bql-schema/types/objects/type-response\#typeresponsetimefloat- "Direct link to typeresponsetimefloat-")

The amount of time, in milliseconds, elapsed since the start of typing to completion

#### [`TypeResponse.x`](https://docs.browserless.io/bql-schema/types/objects/type-response\#)Â â—Â [`Float`](https://docs.browserless.io/bql-schema/types/scalars/float) scalar [â€‹](https://docs.browserless.io/bql-schema/types/objects/type-response\#typeresponsexfloat- "Direct link to typeresponsexfloat-")

The X coordinate of the element, in pixels, on the page

#### [`TypeResponse.y`](https://docs.browserless.io/bql-schema/types/objects/type-response\#)Â â—Â [`Float`](https://docs.browserless.io/bql-schema/types/scalars/float) scalar [â€‹](https://docs.browserless.io/bql-schema/types/objects/type-response\#typeresponseyfloat- "Direct link to typeresponseyfloat-")

The Y coordinate of the element, in pixels, on the page

### Returned By [â€‹](https://docs.browserless.io/bql-schema/types/objects/type-response\#returned-by "Direct link to Returned By")

[`type`](https://docs.browserless.io/bql-schema/operations/mutations/type) mutation

- [Fields](https://docs.browserless.io/bql-schema/types/objects/type-response#fields)
- [Returned By](https://docs.browserless.io/bql-schema/types/objects/type-response#returned-by)

---

### URLResponse | Browserless.io
Original URL: https://docs.browserless.io/bql-schema/types/objects/urlresponse

[Skip to main content](https://docs.browserless.io/bql-schema/types/objects/urlresponse#__docusaurus_skipToContent_fallback)


Response returned after the URL of the page has been set or get

```codeBlockLines_p187
type URLResponse {
  url: String
}

```

### Fields [â€‹](https://docs.browserless.io/bql-schema/types/objects/urlresponse\#fields "Direct link to Fields")

#### [`URLResponse.url`](https://docs.browserless.io/bql-schema/types/objects/urlresponse\#)Â â—Â [`String`](https://docs.browserless.io/bql-schema/types/scalars/string) scalar [â€‹](https://docs.browserless.io/bql-schema/types/objects/urlresponse\#urlresponseurlstring- "Direct link to urlresponseurlstring-")

The URL of the current page

### Returned By [â€‹](https://docs.browserless.io/bql-schema/types/objects/urlresponse\#returned-by "Direct link to Returned By")

[`url`](https://docs.browserless.io/bql-schema/operations/mutations/url) mutation

- [Fields](https://docs.browserless.io/bql-schema/types/objects/urlresponse#fields)
- [Returned By](https://docs.browserless.io/bql-schema/types/objects/urlresponse#returned-by)

---

### VerifyResponse | Browserless.io
Original URL: https://docs.browserless.io/bql-schema/types/objects/verify-response

[Skip to main content](https://docs.browserless.io/bql-schema/types/objects/verify-response#__docusaurus_skipToContent_fallback)


Response returned after a verification method has been bypassed

```codeBlockLines_p187
type VerifyResponse {
  found: Boolean
  solved: Boolean
  time: Float
}

```

### Fields [â€‹](https://docs.browserless.io/bql-schema/types/objects/verify-response\#fields "Direct link to Fields")

#### [`VerifyResponse.found`](https://docs.browserless.io/bql-schema/types/objects/verify-response\#)Â â—Â [`Boolean`](https://docs.browserless.io/bql-schema/types/scalars/boolean) scalar [â€‹](https://docs.browserless.io/bql-schema/types/objects/verify-response\#verifyresponsefoundboolean- "Direct link to verifyresponsefoundboolean-")

If a verification was found or not

#### [`VerifyResponse.solved`](https://docs.browserless.io/bql-schema/types/objects/verify-response\#)Â â—Â [`Boolean`](https://docs.browserless.io/bql-schema/types/scalars/boolean) scalar [â€‹](https://docs.browserless.io/bql-schema/types/objects/verify-response\#verifyresponsesolvedboolean- "Direct link to verifyresponsesolvedboolean-")

If a verification was found, whether or not it was clicked

#### [`VerifyResponse.time`](https://docs.browserless.io/bql-schema/types/objects/verify-response\#)Â â—Â [`Float`](https://docs.browserless.io/bql-schema/types/scalars/float) scalar [â€‹](https://docs.browserless.io/bql-schema/types/objects/verify-response\#verifyresponsetimefloat- "Direct link to verifyresponsetimefloat-")

The total time it took to find, and click, the verification

- [Fields](https://docs.browserless.io/bql-schema/types/objects/verify-response#fields)

---

### Boolean | Browserless.io
Original URL: https://docs.browserless.io/bql-schema/types/scalars/boolean

[Skip to main content](https://docs.browserless.io/bql-schema/types/scalars/boolean#__docusaurus_skipToContent_fallback)


The `Boolean` scalar type represents `true` or `false`.

```codeBlockLines_p187
scalar Boolean

```

### Member Of [â€‹](https://docs.browserless.io/bql-schema/types/scalars/boolean\#member-of "Direct link to Member Of")

[`CaptchaResponse`](https://docs.browserless.io/bql-schema/types/objects/captcha-response) objectÂ â—Â [`checkbox`](https://docs.browserless.io/bql-schema/operations/mutations/checkbox) mutationÂ â—Â [`CleanInput`](https://docs.browserless.io/bql-schema/types/inputs/clean-input) inputÂ â—Â [`click`](https://docs.browserless.io/bql-schema/operations/mutations/click) mutationÂ â—Â [`CookieInput`](https://docs.browserless.io/bql-schema/types/inputs/cookie-input) inputÂ â—Â [`hover`](https://docs.browserless.io/bql-schema/operations/mutations/hover) mutationÂ â—Â [`html`](https://docs.browserless.io/bql-schema/operations/mutations/html) mutationÂ â—Â [`if`](https://docs.browserless.io/bql-schema/operations/mutations/if) mutationÂ â—Â [`include`](https://docs.browserless.io/bql-schema/operations/directives/include) directiveÂ â—Â [`javaScriptEnabled`](https://docs.browserless.io/bql-schema/operations/mutations/java-script-enabled) mutationÂ â—Â [`JavaScriptResponse`](https://docs.browserless.io/bql-schema/types/objects/java-script-response) objectÂ â—Â [`liveURL`](https://docs.browserless.io/bql-schema/operations/mutations/live-url) mutationÂ â—Â [`mapSelector`](https://docs.browserless.io/bql-schema/operations/mutations/map-selector) mutationÂ â—Â [`pdf`](https://docs.browserless.io/bql-schema/operations/mutations/pdf) mutationÂ â—Â [`proxy`](https://docs.browserless.io/bql-schema/operations/mutations/proxy) mutationÂ â—Â [`querySelector`](https://docs.browserless.io/bql-schema/operations/mutations/query-selector) mutationÂ â—Â [`querySelectorAll`](https://docs.browserless.io/bql-schema/operations/mutations/query-selector-all) mutationÂ â—Â [`reject`](https://docs.browserless.io/bql-schema/operations/mutations/reject) mutationÂ â—Â [`RejectResponse`](https://docs.browserless.io/bql-schema/types/objects/reject-response) objectÂ â—Â [`request`](https://docs.browserless.io/bql-schema/operations/mutations/request) mutationÂ â—Â [`response`](https://docs.browserless.io/bql-schema/operations/mutations/response) mutationÂ â—Â [`screenshot`](https://docs.browserless.io/bql-schema/operations/mutations/screenshot) mutationÂ â—Â [`scroll`](https://docs.browserless.io/bql-schema/operations/mutations/scroll) mutationÂ â—Â [`select`](https://docs.browserless.io/bql-schema/operations/mutations/select) mutationÂ â—Â [`skip`](https://docs.browserless.io/bql-schema/operations/directives/skip) directiveÂ â—Â [`solve`](https://docs.browserless.io/bql-schema/operations/mutations/solve) mutationÂ â—Â [`StandardCookie`](https://docs.browserless.io/bql-schema/types/objects/standard-cookie) objectÂ â—Â [`text`](https://docs.browserless.io/bql-schema/operations/mutations/text) mutationÂ â—Â [`type`](https://docs.browserless.io/bql-schema/operations/mutations/type) mutationÂ â—Â [`verify`](https://docs.browserless.io/bql-schema/operations/mutations/verify) mutationÂ â—Â [`VerifyResponse`](https://docs.browserless.io/bql-schema/types/objects/verify-response) objectÂ â—Â [`waitForSelector`](https://docs.browserless.io/bql-schema/operations/mutations/wait-for-selector) mutation

- [Member Of](https://docs.browserless.io/bql-schema/types/scalars/boolean#member-of)

---

### Float | Browserless.io
Original URL: https://docs.browserless.io/bql-schema/types/scalars/float

[Skip to main content](https://docs.browserless.io/bql-schema/types/scalars/float#__docusaurus_skipToContent_fallback)


The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](https://en.wikipedia.org/wiki/IEEE_floating_point).

```codeBlockLines_p187
scalar Float

```

### Member Of [â€‹](https://docs.browserless.io/bql-schema/types/scalars/float\#member-of "Direct link to Member Of")

[`back`](https://docs.browserless.io/bql-schema/operations/mutations/back) mutationÂ â—Â [`CaptchaResponse`](https://docs.browserless.io/bql-schema/types/objects/captcha-response) objectÂ â—Â [`checkbox`](https://docs.browserless.io/bql-schema/operations/mutations/checkbox) mutationÂ â—Â [`click`](https://docs.browserless.io/bql-schema/operations/mutations/click) mutationÂ â—Â [`ClickResponse`](https://docs.browserless.io/bql-schema/types/objects/click-response) objectÂ â—Â [`CookieInput`](https://docs.browserless.io/bql-schema/types/inputs/cookie-input) inputÂ â—Â [`CookieResponse`](https://docs.browserless.io/bql-schema/types/objects/cookie-response) objectÂ â—Â [`DefaultResponse`](https://docs.browserless.io/bql-schema/types/objects/default-response) objectÂ â—Â [`evaluate`](https://docs.browserless.io/bql-schema/operations/mutations/evaluate) mutationÂ â—Â [`EvaluateResponse`](https://docs.browserless.io/bql-schema/types/objects/evaluate-response) objectÂ â—Â [`forward`](https://docs.browserless.io/bql-schema/operations/mutations/forward) mutationÂ â—Â [`goto`](https://docs.browserless.io/bql-schema/operations/mutations/goto) mutationÂ â—Â [`hover`](https://docs.browserless.io/bql-schema/operations/mutations/hover) mutationÂ â—Â [`HoverResponse`](https://docs.browserless.io/bql-schema/types/objects/hover-response) objectÂ â—Â [`html`](https://docs.browserless.io/bql-schema/operations/mutations/html) mutationÂ â—Â [`HTMLResponse`](https://docs.browserless.io/bql-schema/types/objects/htmlresponse) objectÂ â—Â [`HTTPResponse`](https://docs.browserless.io/bql-schema/types/objects/httpresponse) objectÂ â—Â [`JavaScriptResponse`](https://docs.browserless.io/bql-schema/types/objects/java-script-response) objectÂ â—Â [`liveURL`](https://docs.browserless.io/bql-schema/operations/mutations/live-url) mutationÂ â—Â [`mapSelector`](https://docs.browserless.io/bql-schema/operations/mutations/map-selector) mutationÂ â—Â [`pdf`](https://docs.browserless.io/bql-schema/operations/mutations/pdf) mutationÂ â—Â [`PDFResponse`](https://docs.browserless.io/bql-schema/types/objects/pdfresponse) objectÂ â—Â [`preferences`](https://docs.browserless.io/bql-schema/operations/mutations/preferences) mutationÂ â—Â [`ProxyResponse`](https://docs.browserless.io/bql-schema/types/objects/proxy-response) objectÂ â—Â [`querySelector`](https://docs.browserless.io/bql-schema/operations/mutations/query-selector) mutationÂ â—Â [`querySelectorAll`](https://docs.browserless.io/bql-schema/operations/mutations/query-selector-all) mutationÂ â—Â [`QuerySelectorResponse`](https://docs.browserless.io/bql-schema/types/objects/query-selector-response) objectÂ â—Â [`reconnect`](https://docs.browserless.io/bql-schema/operations/mutations/reconnect) mutationÂ â—Â [`RejectResponse`](https://docs.browserless.io/bql-schema/types/objects/reject-response) objectÂ â—Â [`reload`](https://docs.browserless.io/bql-schema/operations/mutations/reload) mutationÂ â—Â [`request`](https://docs.browserless.io/bql-schema/operations/mutations/request) mutationÂ â—Â [`response`](https://docs.browserless.io/bql-schema/operations/mutations/response) mutationÂ â—Â [`screenshot`](https://docs.browserless.io/bql-schema/operations/mutations/screenshot) mutationÂ â—Â [`ScreenshotClip`](https://docs.browserless.io/bql-schema/types/inputs/screenshot-clip) inputÂ â—Â [`ScreenshotResponse`](https://docs.browserless.io/bql-schema/types/objects/screenshot-response) objectÂ â—Â [`scroll`](https://docs.browserless.io/bql-schema/operations/mutations/scroll) mutationÂ â—Â [`ScrollResponse`](https://docs.browserless.io/bql-schema/types/objects/scroll-response) objectÂ â—Â [`select`](https://docs.browserless.io/bql-schema/operations/mutations/select) mutationÂ â—Â [`SelectResponse`](https://docs.browserless.io/bql-schema/types/objects/select-response) objectÂ â—Â [`solve`](https://docs.browserless.io/bql-schema/operations/mutations/solve) mutationÂ â—Â [`StandardCookie`](https://docs.browserless.io/bql-schema/types/objects/standard-cookie) objectÂ â—Â [`text`](https://docs.browserless.io/bql-schema/operations/mutations/text) mutationÂ â—Â [`TextResponse`](https://docs.browserless.io/bql-schema/types/objects/text-response) objectÂ â—Â [`type`](https://docs.browserless.io/bql-schema/operations/mutations/type) mutationÂ â—Â [`TypeResponse`](https://docs.browserless.io/bql-schema/types/objects/type-response) objectÂ â—Â [`verify`](https://docs.browserless.io/bql-schema/operations/mutations/verify) mutationÂ â—Â [`VerifyResponse`](https://docs.browserless.io/bql-schema/types/objects/verify-response) objectÂ â—Â [`waitForNavigation`](https://docs.browserless.io/bql-schema/operations/mutations/wait-for-navigation) mutationÂ â—Â [`waitForRequest`](https://docs.browserless.io/bql-schema/operations/mutations/wait-for-request) mutationÂ â—Â [`WaitForRequest`](https://docs.browserless.io/bql-schema/types/objects/wait-for-request) objectÂ â—Â [`WaitForResponse`](https://docs.browserless.io/bql-schema/types/objects/wait-for-response) objectÂ â—Â [`waitForSelector`](https://docs.browserless.io/bql-schema/operations/mutations/wait-for-selector) mutationÂ â—Â [`WaitForSelector`](https://docs.browserless.io/bql-schema/types/objects/wait-for-selector) objectÂ â—Â [`waitForTimeout`](https://docs.browserless.io/bql-schema/operations/mutations/wait-for-timeout) mutationÂ â—Â [`WaitForTimeout`](https://docs.browserless.io/bql-schema/types/objects/wait-for-timeout) object

- [Member Of](https://docs.browserless.io/bql-schema/types/scalars/float#member-of)

---

### FloatOrString | Browserless.io
Original URL: https://docs.browserless.io/bql-schema/types/scalars/float-or-string

[Skip to main content](https://docs.browserless.io/bql-schema/types/scalars/float-or-string#__docusaurus_skipToContent_fallback)


Holds the value of a either a float or a string

```codeBlockLines_p187
scalar FloatOrString

```

### Member Of [â€‹](https://docs.browserless.io/bql-schema/types/scalars/float-or-string\#member-of "Direct link to Member Of")

[`pdf`](https://docs.browserless.io/bql-schema/operations/mutations/pdf) mutation

- [Member Of](https://docs.browserless.io/bql-schema/types/scalars/float-or-string#member-of)

---

### Int | Browserless.io
Original URL: https://docs.browserless.io/bql-schema/types/scalars/int

[Skip to main content](https://docs.browserless.io/bql-schema/types/scalars/int#__docusaurus_skipToContent_fallback)


The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.

```codeBlockLines_p187
scalar Int

```

### Member Of [â€‹](https://docs.browserless.io/bql-schema/types/scalars/int\#member-of "Direct link to Member Of")

[`HTTPResponse`](https://docs.browserless.io/bql-schema/types/objects/httpresponse) objectÂ â—Â [`liveURL`](https://docs.browserless.io/bql-schema/operations/mutations/live-url) mutationÂ â—Â [`response`](https://docs.browserless.io/bql-schema/operations/mutations/response) mutationÂ â—Â [`ResponseInput`](https://docs.browserless.io/bql-schema/types/inputs/response-input) inputÂ â—Â [`ResponseResponse`](https://docs.browserless.io/bql-schema/types/objects/response-response) objectÂ â—Â [`type`](https://docs.browserless.io/bql-schema/operations/mutations/type) mutationÂ â—Â [`waitForResponse`](https://docs.browserless.io/bql-schema/operations/mutations/wait-for-response) mutationÂ â—Â [`WaitForResponse`](https://docs.browserless.io/bql-schema/types/objects/wait-for-response) object

- [Member Of](https://docs.browserless.io/bql-schema/types/scalars/int#member-of)

---

### String | Browserless.io
Original URL: https://docs.browserless.io/bql-schema/types/scalars/string

[Skip to main content](https://docs.browserless.io/bql-schema/types/scalars/string#__docusaurus_skipToContent_fallback)


The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.

```codeBlockLines_p187
scalar String

```

### Returned By [â€‹](https://docs.browserless.io/bql-schema/types/scalars/string\#returned-by "Direct link to Returned By")

[`browser`](https://docs.browserless.io/bql-schema/operations/queries/browser) queryÂ â—Â [`version`](https://docs.browserless.io/bql-schema/operations/queries/version) query

### Member Of [â€‹](https://docs.browserless.io/bql-schema/types/scalars/string\#member-of "Direct link to Member Of")

[`Attribute`](https://docs.browserless.io/bql-schema/types/objects/attribute) objectÂ â—Â [`CaptchaResponse`](https://docs.browserless.io/bql-schema/types/objects/captcha-response) objectÂ â—Â [`checkbox`](https://docs.browserless.io/bql-schema/operations/mutations/checkbox) mutationÂ â—Â [`CleanInput`](https://docs.browserless.io/bql-schema/types/inputs/clean-input) inputÂ â—Â [`click`](https://docs.browserless.io/bql-schema/operations/mutations/click) mutationÂ â—Â [`ClickResponse`](https://docs.browserless.io/bql-schema/types/objects/click-response) objectÂ â—Â [`content`](https://docs.browserless.io/bql-schema/operations/mutations/content) mutationÂ â—Â [`CookieInput`](https://docs.browserless.io/bql-schema/types/inputs/cookie-input) inputÂ â—Â [`deprecated`](https://docs.browserless.io/bql-schema/types/directives/deprecated) directiveÂ â—Â [`evaluate`](https://docs.browserless.io/bql-schema/operations/mutations/evaluate) mutationÂ â—Â [`EvaluateResponse`](https://docs.browserless.io/bql-schema/types/objects/evaluate-response) objectÂ â—Â [`goto`](https://docs.browserless.io/bql-schema/operations/mutations/goto) mutationÂ â—Â [`Headers`](https://docs.browserless.io/bql-schema/types/objects/headers) objectÂ â—Â [`hover`](https://docs.browserless.io/bql-schema/operations/mutations/hover) mutationÂ â—Â [`HoverResponse`](https://docs.browserless.io/bql-schema/types/objects/hover-response) objectÂ â—Â [`html`](https://docs.browserless.io/bql-schema/operations/mutations/html) mutationÂ â—Â [`HTMLResponse`](https://docs.browserless.io/bql-schema/types/objects/htmlresponse) objectÂ â—Â [`HTTPResponse`](https://docs.browserless.io/bql-schema/types/objects/httpresponse) objectÂ â—Â [`if`](https://docs.browserless.io/bql-schema/operations/mutations/if) mutationÂ â—Â [`ifnot`](https://docs.browserless.io/bql-schema/operations/mutations/ifnot) mutationÂ â—Â [`LiveURLResponse`](https://docs.browserless.io/bql-schema/types/objects/live-urlresponse) objectÂ â—Â [`mapSelector`](https://docs.browserless.io/bql-schema/operations/mutations/map-selector) mutationÂ â—Â [`MapSelectorResponse`](https://docs.browserless.io/bql-schema/types/objects/map-selector-response) objectÂ â—Â [`pdf`](https://docs.browserless.io/bql-schema/operations/mutations/pdf) mutationÂ â—Â [`PDFResponse`](https://docs.browserless.io/bql-schema/types/objects/pdfresponse) objectÂ â—Â [`proxy`](https://docs.browserless.io/bql-schema/operations/mutations/proxy) mutationÂ â—Â [`querySelector`](https://docs.browserless.io/bql-schema/operations/mutations/query-selector) mutationÂ â—Â [`querySelectorAll`](https://docs.browserless.io/bql-schema/operations/mutations/query-selector-all) mutationÂ â—Â [`QuerySelectorResponse`](https://docs.browserless.io/bql-schema/types/objects/query-selector-response) objectÂ â—Â [`ReconnectionResponse`](https://docs.browserless.io/bql-schema/types/objects/reconnection-response) objectÂ â—Â [`reject`](https://docs.browserless.io/bql-schema/operations/mutations/reject) mutationÂ â—Â [`request`](https://docs.browserless.io/bql-schema/operations/mutations/request) mutationÂ â—Â [`RequestInput`](https://docs.browserless.io/bql-schema/types/inputs/request-input) inputÂ â—Â [`RequestResponse`](https://docs.browserless.io/bql-schema/types/objects/request-response) objectÂ â—Â [`response`](https://docs.browserless.io/bql-schema/operations/mutations/response) mutationÂ â—Â [`ResponseInput`](https://docs.browserless.io/bql-schema/types/inputs/response-input) inputÂ â—Â [`ResponseResponse`](https://docs.browserless.io/bql-schema/types/objects/response-response) objectÂ â—Â [`screenshot`](https://docs.browserless.io/bql-schema/operations/mutations/screenshot) mutationÂ â—Â [`ScreenshotResponse`](https://docs.browserless.io/bql-schema/types/objects/screenshot-response) objectÂ â—Â [`scroll`](https://docs.browserless.io/bql-schema/operations/mutations/scroll) mutationÂ â—Â [`ScrollResponse`](https://docs.browserless.io/bql-schema/types/objects/scroll-response) objectÂ â—Â [`select`](https://docs.browserless.io/bql-schema/operations/mutations/select) mutationÂ â—Â [`SelectResponse`](https://docs.browserless.io/bql-schema/types/objects/select-response) objectÂ â—Â [`specifiedBy`](https://docs.browserless.io/bql-schema/types/directives/specified-by) directiveÂ â—Â [`StandardCookie`](https://docs.browserless.io/bql-schema/types/objects/standard-cookie) objectÂ â—Â [`text`](https://docs.browserless.io/bql-schema/operations/mutations/text) mutationÂ â—Â [`TextResponse`](https://docs.browserless.io/bql-schema/types/objects/text-response) objectÂ â—Â [`TitleResponse`](https://docs.browserless.io/bql-schema/types/objects/title-response) objectÂ â—Â [`type`](https://docs.browserless.io/bql-schema/operations/mutations/type) mutationÂ â—Â [`TypeResponse`](https://docs.browserless.io/bql-schema/types/objects/type-response) objectÂ â—Â [`URLResponse`](https://docs.browserless.io/bql-schema/types/objects/urlresponse) objectÂ â—Â [`waitForRequest`](https://docs.browserless.io/bql-schema/operations/mutations/wait-for-request) mutationÂ â—Â [`WaitForRequest`](https://docs.browserless.io/bql-schema/types/objects/wait-for-request) objectÂ â—Â [`waitForResponse`](https://docs.browserless.io/bql-schema/operations/mutations/wait-for-response) mutationÂ â—Â [`WaitForResponse`](https://docs.browserless.io/bql-schema/types/objects/wait-for-response) objectÂ â—Â [`waitForSelector`](https://docs.browserless.io/bql-schema/operations/mutations/wait-for-selector) mutationÂ â—Â [`WaitForSelector`](https://docs.browserless.io/bql-schema/types/objects/wait-for-selector) object

- [Returned By](https://docs.browserless.io/bql-schema/types/scalars/string#returned-by)
- [Member Of](https://docs.browserless.io/bql-schema/types/scalars/string#member-of)

---

### StringOrArray | Browserless.io
Original URL: https://docs.browserless.io/bql-schema/types/scalars/string-or-array

[Skip to main content](https://docs.browserless.io/bql-schema/types/scalars/string-or-array#__docusaurus_skipToContent_fallback)


Holds the value of a either a string or an array of strings

```codeBlockLines_p187
scalar StringOrArray

```

### Member Of [â€‹](https://docs.browserless.io/bql-schema/types/scalars/string-or-array\#member-of "Direct link to Member Of")

[`select`](https://docs.browserless.io/bql-schema/operations/mutations/select) mutationÂ â—Â [`SelectResponse`](https://docs.browserless.io/bql-schema/types/objects/select-response) object

- [Member Of](https://docs.browserless.io/bql-schema/types/scalars/string-or-array#member-of)

---

### Browserless.io
Original URL: https://docs.browserless.io/browserql/avoid-bot-detection/bypass-tough-bot-detection

[Skip to main content](https://docs.browserless.io/browserql/avoid-bot-detection/bypass-tough-bot-detection#__docusaurus_skipToContent_fallback)

# Page Not Found

We could not find what you were looking for.

Please contact the owner of the site that linked you to the original URL and let them know their link is broken.

---

### handling-2fas | Browserless.io
Original URL: https://docs.browserless.io/browserql/bot%20detection/handling-2fas

[Skip to main content](https://docs.browserless.io/browserql/bot%20detection/handling-2fas#__docusaurus_skipToContent_fallback)

---

### Accessing Pages | Browserless.io
Original URL: https://docs.browserless.io/browserql/bot-detection/accessing-pages

[Skip to main content](https://docs.browserless.io/browserql/bot-detection/accessing-pages#__docusaurus_skipToContent_fallback)


BrowserQL was built from the ground up to handle common challenges when accessing e-commerce or heavily monitored pages. The Bot Detection section helps you understand and overcome anti-bot measures employed by modern websites. These pages cover accessing protected pages, submitting forms without triggering bot flags, solving various types of CAPTCHAs, handling two-factor authentication, reusing sessions through cookies, and utilizing proxies for enhanced anonymity.

- **Passive Detection Evasion**: Handles bot-detection methods used on e-commerce platforms.
- **Stealth General Settings**: Configurable options to fine-tune stealth settings for your use case.
- **Proxy Integration**: Utilize proxies for enhanced anonymity, including settings for residential proxies.

Enterprise

For enterprise users, BQL supports M1 systems, providing high-performance browser automation on macOS devices.

## Hiding Fingerprints [â€‹](https://docs.browserless.io/browserql/bot-detection/accessing-pages\#hiding-fingerprints "Direct link to Hiding Fingerprints")

BrowserQL automatically handles all fingerprint-hiding techniques, so you don't have to worry about configuring them manually. BQL ensures your browser sessions are indistinguishable from genuine user activity.

This built-in feature saves time and effort while providing top-notch stealth for your automation needs.

## What's Next? [â€‹](https://docs.browserless.io/browserql/bot-detection/accessing-pages\#whats-next "Direct link to What's Next?")

BrowserQL simplifies web automation and can help you with the following features:

- [Submitting Forms](https://docs.browserless.io/browserql/bot-detection/submitting-forms)
- [Solving CAPTCHAs](https://docs.browserless.io/browserql/bot-detection/solving-captchas)
- [UI Automation](https://docs.browserless.io/browserql/bot-detection/ui-automation)
- [Proxies](https://docs.browserless.io/browserql/bot-detection/proxies)
- [Bypassing Tough Bot Detection](https://docs.browserless.io/browserql/bot-detection/bypass-tough-bot-detection)

Support

If you're having trouble accessing a specific site, [contact us](https://www.browserless.io/contact/) for assistance.

- [Hiding Fingerprints](https://docs.browserless.io/browserql/bot-detection/accessing-pages#hiding-fingerprints)
- [What's Next?](https://docs.browserless.io/browserql/bot-detection/accessing-pages#whats-next)

---

### Bypassing Tough Bot Detection - The Right Way | Browserless.io
Original URL: https://docs.browserless.io/browserql/bot-detection/bypass-tough-bot-detection

[Skip to main content](https://docs.browserless.io/browserql/bot-detection/bypass-tough-bot-detection#__docusaurus_skipToContent_fallback)


Some sites are just tougher to bypass, and that's the nature of the game. Most sites are easily tricked to thinking you're a human, but some are just a little more clever. Some site use different bot-detection mecahnisms and require to be fooled just a little bit different than others. BQL has several buttons and switches to turn on and off to get it just right. So if you haven't been able to access your website, don't give up just yet, there's still hope!

## Fingerprints [â€‹](https://docs.browserless.io/browserql/bot-detection/bypass-tough-bot-detection\#fingerprints "Direct link to Fingerprints")

There are a few things you can do to change your fingerprint when navigating to sites with BQL. The different combination of your bql session's basic settings makes up your fingerprint, so you'll want to test different combination of them. You can find them under settings in our [BrowserQL tool](https://account.browserless.io/bql), in the icon showing 3 vertical lines.

### Residential Proxying [â€‹](https://docs.browserless.io/browserql/bot-detection/bypass-tough-bot-detection\#residential-proxying "Direct link to Residential Proxying")

One of the most important factors at play is what IP address you're navigating to a site from. Sites that have a high interest in not being visited by bots will subscribe to a range of IPs that come from datacenters such as AWS, GCP, DO, etc. and those coming from residential range of IPs. Using a residential proxy will greatly help generate a convincing fingerprint for your session.

The best thing you can do is also geo-locate your proxy in the same country that your target country is in, if you know this information. Some sites will only service browsers requesting from a specific country, so this feature will be useful.

Lastly, declaring if the proxy is sticky or not can make a slight difference. Disclaimer: A common misunderstanding is that a sticky proxy, means it will persist the IP address from one request to another, this is incorrect. Actually, using a sticky proxy means that every request made from that browser will come form the same IP address, which is normally how it works on real human's machines. Having sticky proxy off means that every request may travel through a different IP address, which isn't necessarily a bad thing, so you can try iterating between ON and OFF to see if that makes a difference.

### Browser binaries [â€‹](https://docs.browserless.io/browserql/bot-detection/bypass-tough-bot-detection\#browser-binaries "Direct link to Browser binaries")

You can select which browser you want to use, either Chromium or Chrome.
Which is the best? Well, the one that works for you!
Keep in mind that Chrome comes with codecs to render things like streamed videos, or other type of multimedia, so it is typically regarded as a more human-like browsers, however it's not a guarantee, and sometimes Chromium is the way to go!

### Adblock [â€‹](https://docs.browserless.io/browserql/bot-detection/bypass-tough-bot-detection\#adblock "Direct link to Adblock")

Everyone hates ads, especially humans. Using this feature basically means you're running an extension that blocks ads, meaning the target site will recognize that you actually have an adblocking extension installed, and this itself will change the fingerprint of your session.

### Human-like behavior [â€‹](https://docs.browserless.io/browserql/bot-detection/bypass-tough-bot-detection\#human-like-behavior "Direct link to Human-like behavior")

This will help with sites that track interactions with the website. Using this turned on will make smooth mouse behavior and human-like typing patterns, i.e. it'll make mistakes while typing, vary in speed and the mouse movements will be more erratic and human-like.

## Cloudflare [â€‹](https://docs.browserless.io/browserql/bot-detection/bypass-tough-bot-detection\#cloudflare "Direct link to Cloudflare")

Getting past cloudflare is quite a common obstacle, it's also quite easily bypassed with the [Verify](https://docs.browserless.io/browserql/bot-detection/solving-captchas#verify) mutation.

If it's not working properly, take these 3 things into consideration:

- Make sure that you have our residential proxying turned on, as it's a requirement for it to work.
- In rare cases, you'll have to tweak your fingerprint for it to work properly, so go over the aforementioned recommendations to find successful bypassing.
- Even though you're navigating to a site that might have cloudflare with something like waitUntil set to NetworkIdle, in a few cases, probably if there's redirection, it seems like the it's not working properly and you'll have to add a waitForNavigation mutation before the verify mutation, such as the below script:

```codeBlockLines_p187
mutation VerifyCloudflare {
  goto(url: "YOURSITE", waitUntil: networkIdle) {
    status
  }
  waitForNavigation(waitUntil:networkIdle){
    time
  }
  verify(type:cloudflare){
    found
    solved
    time
  }
}

```

## Tough Captchas [â€‹](https://docs.browserless.io/browserql/bot-detection/bypass-tough-bot-detection\#tough-captchas "Direct link to Tough Captchas")

[Solving captchas](https://docs.browserless.io/browserql/bot-detection/solving-captchas#solve) is supported in BQL, however it's important to note the current limitations.

Currently, we support recaptchas, hCaptcha and cloudflare turnstiles. If they require interaction such as sliding images, clicking on images, they aren't supported just yet.

There is also passive recaptchas, which pop up on certain sites like a small square with the recaptcha icon. Those are not solved by the solve mutation, rather those are bypassed strictly based on fingerprinting, so using the Solve mutation isn't necessary here.

## Advanced browser fingerprints [â€‹](https://docs.browserless.io/browserql/bot-detection/bypass-tough-bot-detection\#advanced-browser-fingerprints "Direct link to Advanced browser fingerprints")

Some sites can detect the underlying operating system that the browser is running on so sometimes, no amount of efforts to enhance your fingerprint may bypass the most complex bot-detecting systems. For these cases, we have a way to have browsers run directly on special hardware, this infrastructure setup is only available on Enterprise plans, so please [contact us](https://www.browserless.io/contact) to discuss this option further.

- [Fingerprints](https://docs.browserless.io/browserql/bot-detection/bypass-tough-bot-detection#fingerprints)
  - [Residential Proxying](https://docs.browserless.io/browserql/bot-detection/bypass-tough-bot-detection#residential-proxying)
  - [Browser binaries](https://docs.browserless.io/browserql/bot-detection/bypass-tough-bot-detection#browser-binaries)
  - [Adblock](https://docs.browserless.io/browserql/bot-detection/bypass-tough-bot-detection#adblock)
  - [Human-like behavior](https://docs.browserless.io/browserql/bot-detection/bypass-tough-bot-detection#human-like-behavior)
- [Cloudflare](https://docs.browserless.io/browserql/bot-detection/bypass-tough-bot-detection#cloudflare)
- [Tough Captchas](https://docs.browserless.io/browserql/bot-detection/bypass-tough-bot-detection#tough-captchas)
- [Advanced browser fingerprints](https://docs.browserless.io/browserql/bot-detection/bypass-tough-bot-detection#advanced-browser-fingerprints)

---

### Proxies | Browserless.io
Original URL: https://docs.browserless.io/browserql/bot-detection/proxies

[Skip to main content](https://docs.browserless.io/browserql/bot-detection/proxies#__docusaurus_skipToContent_fallback)


Proxies act as intermediaries between your device and the internet, enhancing privacy, security, and geographic flexibility by masking your IP address. This page covers the built-in proxy features in BrowserQL, tips for optimizing bandwidth usage with the reject API, and support for third-party proxies for more advanced configurations.

- [Built-in Proxies](https://docs.browserless.io/browserql/bot-detection/proxies#built-in-proxies)
- [External Proxies](https://docs.browserless.io/browserql/bot-detection/proxies#external-proxies)

## Built-In Proxies [â€‹](https://docs.browserless.io/browserql/bot-detection/proxies\#built-in-proxies "Direct link to Built-In Proxies")

BrowserQL supports **residential proxies** to enhance privacy, security, and geographic flexibility in browser automation. These proxies help bypass location-specific restrictions, improve stealth, and avoid IP-based detection mechanisms. With built-in proxying, you can configure:

- **Proxy Country**: Route requests through a specific country.
- **Sticky Proxying**: Reuse the same proxy for multiple requests.

### How to Enable Built-In Proxies [â€‹](https://docs.browserless.io/browserql/bot-detection/proxies\#how-to-enable-built-in-proxies "Direct link to How to Enable Built-In Proxies")

1. Open the **Session Settings Panel**.
2. Toggle **Residential Proxying** to `On`.
3. Configure your settings:
   - **Sticky Proxying**: Use the same IP for consecutive requests.
   - **Proxy Country**: Select the desired country for proxy routing.

warning

Using a proxy consumes **6 units per MB**.

Watch the video below to learn how to turn on proxy:

Your browser does not support the video tag.

### Optimizing Proxy Usage with the Reject Mutation [â€‹](https://docs.browserless.io/browserql/bot-detection/proxies\#optimizing-proxy-usage-with-the-reject-mutation "Direct link to Optimizing Proxy Usage with the Reject Mutation")

The **reject mutation** optimizes your proxy usage by filtering unnecessary requests. This can help reduce bandwidth consumption and improve efficiency when using proxies. The reject mutation allows you to block requests based on:

- **URL patterns**: Use glob-style patterns to match specific domains or paths.
- **HTTP methods**: Reject specific request methods (e.g., GET, POST).
- **Resource types**: Filter by resource types, such as images, media, or scripts.
- **Operators**: Define whether conditions should be combined using "and" (all must match) or "or" (any match).

Behavior

The reject mutation only takes effect during query execution. For instance, scripts that return quickly might still see assets loading in the editor since rejections occur only while mutations are actively running.

The following example rejects image and media requests, helping save bandwidth:

- Rejecting Images and Media
- Rejecting Media from a Specific Domain

```codeBlockLines_p187
mutation RejectImages {
  reject(type: [image, media]) {
    enabled
    time
  }
  goto(url: "https://cnn.com", waitUntil: firstContentfulPaint) {
    status
    time
  }
}

```

To reject media requests originating from the `google.com` domain, use the `and` operator:

```codeBlockLines_p187
mutation Reject {
  reject(
    operator: and
    type: image
    url: "*google.com*"
  ) {
    enabled
    time
  }
  goto(url: "https://cnn.com", waitUntil: firstContentfulPaint) {
    status
    time
  }
}

```

## External Proxies [â€‹](https://docs.browserless.io/browserql/bot-detection/proxies\#external-proxies "Direct link to External Proxies")

Alongside the Browserless residential proxy, you can also use an external proxy as well. This is done via the `proxy` mutation, which takes several options with regards to how and when to proxy.

The first requirement is to specify the server's URI to proxy through. This takes the format of `${protocol}://${username}:${password}@${host}:${port}`. For instance, if you have a username of `john` and a password of `1337code` and a URL of `myproxy.com` and a port of `1234`, the server argument would look like: `http://john:1337@myproxy.com:1234`. If you don't have a username or password you can simply omit those fields in the URI. Most proxy servers will also have simple generation widgets that can help build these URI's out for you.

Here's the full snippet in BrowserQL:

```codeBlockLines_p187
mutation ExternalProxy {
  # Proxy to this server for all requests
  proxy(server: "http://john:1337@myproxy.com:1234" url: "*") {
    time
  }
  goto(url: "https://nordvpn.com/what-is-my-ip/", waitUntil: load) {
    status
  }
  waitForTimeout(time: 5000) {
    time
  }
}

```

The second important part of the `proxy` mutation is deciding which requests need to be proxied. BrowserQL supports this by allowing you make patterns of the type of requests you'd like to proxy. You can proxy based upon URL pattern, request methods, and even request types. To proxy _all_ requests, simply use `url: "*"` which will match all requests being sent by BrowserQL.

If you want to proxy only the Document requests (typically what most pages are), then you'd set the `type: document` for this. Here's an example of proxying for Document and XHR requests:

```codeBlockLines_p187
mutation ProxyDocumentAndXHR {
  proxy(server: "http://john:1337@myproxy.com:1234" type: [document, xhr]) {
    time
  }
  goto(url: "https://nordvpn.com/what-is-my-ip/", waitUntil: load) {
    status
  }
  waitForTimeout(time: 5000) {
    time
  }
}

```

Finally, you can mix and match proxies as well with this API. The first proxy that matches the request will be the chosen proxy for that request, so ordering can be important if you want to mix and match proxies for various types of requests.

For instance, you can proxy `document` and `xhr` requests through a residential proxy querying that first, and all other requests through a data-center proxy. Here's how that'd look by specifying the residential proxy _first_, then matching all others via the greedy `url: "*"` pattern:

```codeBlockLines_p187
mutation ProxyDocumentAndXHR {
  # Proxy document and xhr through residential
  residential: proxy(server: "http://john:1337@residential.proxy.com:1234" type: [document, xhr]) {
    time
  }
  # Proxy all else through datacenter
  datacenter: proxy(server: "http://john:1337@datacenter.proxy.com:1234" url: "*") {
    time
  }
  goto(url: "https://nordvpn.com/what-is-my-ip/", waitUntil: load) {
    status
  }
  waitForTimeout(time: 5000) {
    time
  }
}

```

- [Built-In Proxies](https://docs.browserless.io/browserql/bot-detection/proxies#built-in-proxies)
  - [How to Enable Built-In Proxies](https://docs.browserless.io/browserql/bot-detection/proxies#how-to-enable-built-in-proxies)
  - [Optimizing Proxy Usage with the Reject Mutation](https://docs.browserless.io/browserql/bot-detection/proxies#optimizing-proxy-usage-with-the-reject-mutation)
- [External Proxies](https://docs.browserless.io/browserql/bot-detection/proxies#external-proxies)

---

### Solving CAPTCHAs | Browserless.io
Original URL: https://docs.browserless.io/browserql/bot-detection/solving-captchas

[Skip to main content](https://docs.browserless.io/browserql/bot-detection/solving-captchas#__docusaurus_skipToContent_fallback)


CAPTCHAs are a common roadblock in automation. BrowserQL includes built-in support for CAPTCHA challenges. BQL will automatically detect and interacts with CAPTCHAs, even those embedded in iframes or shadow DOMs. You can use the following mutations:

- [Verify](https://docs.browserless.io/browserql/bot-detection/solving-captchas#verify)
- [Solve](https://docs.browserless.io/browserql/bot-detection/solving-captchas#solve)

## Verify [â€‹](https://docs.browserless.io/browserql/bot-detection/solving-captchas\#verify "Direct link to Verify")

The [`Verify`](https://docs.browserless.io/bql-schema/operations/mutations/verify) mutation clicks a verification button to assert human-like interaction. This mutation can be used to surpass cloudflare's human verification step.

If you're not sure whether a site has Cloudflare protection, you can use the `if` mutation with a `waitForSelector` to conditionally run the verification. Since the `if` mutation doesn't wait for a selector to be present, adding a `waitForSelector` before it ensures the Cloudflare turnstile is available before attempting verification.

```codeBlockLines_p187
    mutation Verify {
      goto(url: "https://protected.domain") {
        status
      }

      verify(type: cloudflare) {
        found
        solved
        time
      }
    }

```

### Conditional Cloudflare Verification [â€‹](https://docs.browserless.io/browserql/bot-detection/solving-captchas\#conditional-cloudflare-verification "Direct link to Conditional Cloudflare Verification")

Here's an example of using conditional verification with the `if` mutation:

```codeBlockLines_p187
    goto(url: "https://www.browserless.io/practice-form") {
      status
    }
    waitForSelector(selector:".cf-turnstile",timeout:1000){
      time
    }
    if(selector:".cf-turnstile"){
      verify(type:cloudflare,timeout:30000){
        found
        solved
        time
      }
    }
    html{
      html
    }

```

Note that `.cf-turnstile` is specific to our sample website. For your own implementation, you should look for a selector that works for your target website. Some alternatives that might work on other sites include `a[href*="cloudflare.com"]` or other Cloudflare-specific elements.

## Solve [â€‹](https://docs.browserless.io/browserql/bot-detection/solving-captchas\#solve "Direct link to Solve")

The [`Solve`](https://docs.browserless.io/bql-schema/operations/mutations/solve) mutation solves a captcha, specified by the "type" of captcha to solve. Currently, BQL can solve **turnstile reCAPTCHAs** and **hCAPTCHAs** only. Image-based CAPTCHAs are not supported yet.

info

When solving reCAPTCHAs, it's normal if there isn't a visual confirmation that the CAPTCHA has been solved (i.e., the checkbox may not appear ticked). This is expected behavior. After solving, you should proceed and click on the form's submit button.

- hCaptcha
- reCAPTCHA

```codeBlockLines_p187
mutation SolveCaptcha {
  goto(url: "https://protected.domain") {
    status
  }

  solve(type: hcaptcha) {
    found
    solved
    time
  }
}

```

```codeBlockLines_p187
mutation SolveCaptcha {
  goto(url: "https://protected.domain") {
    status
  }

  solve(type: recaptcha) {
    found
    solved
    time
  }
}

```

### Form Submission After Solving [â€‹](https://docs.browserless.io/browserql/bot-detection/solving-captchas\#form-submission-after-solving "Direct link to Form Submission After Solving")

After solving a CAPTCHA, you should proceed with form submission by clicking the submit button:

```codeBlockLines_p187
mutation SolveAndSubmit {
  goto(url: "https://protected.domain") {
    status
  }

  solve(type: recaptcha) {
    found
    solved
    time
  }

  click(selector: "button[type='submit']") {
    time
  }
}

```

If there isn't a submit button available, you can trigger form submission manually using the `evaluate` mutation:

```codeBlockLines_p187
mutation SolveAndTriggerSubmit {
  goto(url: "https://protected.domain") {
    status
  }

  solve(type: recaptcha) {
    found
    solved
    time
  }

  evaluate(content: "window.onSubmit()") {
    time
  }
}

```

Replace `window.onSubmit()` with the appropriate JavaScript function that submits the form on your target website.

- [Verify](https://docs.browserless.io/browserql/bot-detection/solving-captchas#verify)
  - [Conditional Cloudflare Verification](https://docs.browserless.io/browserql/bot-detection/solving-captchas#conditional-cloudflare-verification)
- [Solve](https://docs.browserless.io/browserql/bot-detection/solving-captchas#solve)
  - [Form Submission After Solving](https://docs.browserless.io/browserql/bot-detection/solving-captchas#form-submission-after-solving)

---

### Submitting Forms | Browserless.io
Original URL: https://docs.browserless.io/browserql/bot-detection/submitting-forms

[Skip to main content](https://docs.browserless.io/browserql/bot-detection/submitting-forms#__docusaurus_skipToContent_fallback)


Modern websites often employ sophisticated techniques such as CAPTCHAs, iframes, and closed-shadow DOM trees to block automated tools. **BrowserQL** presents you with tools to automate challenging scenarios such as handling CAPTCHAs, submitting forms, and navigating deeply nested elements. The combination of **deep selectors** and **humanized actions** ensures that your automation scripts are both effective and resilient.

## Submitting Forms [â€‹](https://docs.browserless.io/browserql/bot-detection/submitting-forms\#submitting-forms "Direct link to Submitting Forms")

BrowserQL simplifies form submission by automating the process in a human-like manner. It handles tasks like filling input fields, selecting dropdowns, and clicking buttons with minimal configuration. Hereâ€™s how you can fill out a form and submit it:

Solving CAPTCHAs

BQL can solve CAPTCHAs with the `solve` and `verify` mutations. Refer to the [Solving CAPTCHAs](https://docs.browserless.io/browserql/bot-detection/solving-captchas) page for more details.

```codeBlockLines_p187
mutation SubmitForm {
  goto(url: "https://example.com/form", waitUntil: firstContentfulPaint) {
    status
  }

  fillName: type(
    selector: "input#name"
    text: "John Doe"
  ) {
    time
  }

  fillEmail: type(
    selector: "input#email"
    text: "johndoe@example.com"
  ) {
    time
  }

  submitForm: click(
    selector: "button#submit"
  ) {
    time
  }
}

```

Humanized Behavior

BrowserQL ensures that the input values are typed with randomized delays, mimicking human behavior to avoid detection. Refer to the following pages for more details:

- **[Session Settings](https://docs.browserless.io/browserql/using-the-ide/session-settings#configuring-session-settings)**: Learn to activate human-like behavior on your queries.
- **[Writing BrowserQL](https://docs.browserless.io/browserql/writing-bql/language-basics#performing-actions)**: Understand how to change delay time in your mutations.

## Clicking within Iframes [â€‹](https://docs.browserless.io/browserql/bot-detection/submitting-forms\#clicking-within-iframes "Direct link to Clicking within Iframes")

Deep selectors lets you target elements nested inside iframes or hidden within shadow DOMs. These selectors extend the standard query syntax, allowing precise targeting even on complex web pages.

### How to Click within Iframes [â€‹](https://docs.browserless.io/browserql/bot-detection/submitting-forms\#how-to-click-within-iframes "Direct link to How to Click within Iframes")

To target an element inside an iframe, you need to specify the iframe URL pattern and the DOM selector, following the format shown below:

```codeBlockLines_p187
selector: "< [optional URL pattern] selector"

```

1. **`<` Character**: Indicates that youâ€™re using a deep selector.
2. **Optional URL Pattern**: Matches iframe URLs using glob-style patterns.
3. **DOM Selector**: Identifies the target element within the matched iframe.

Below you can see multiple deep selector examples:

- Example 1
- Example 2
- Example 3
- Example 4

Target an iframe of cnn.com and look for a button with an ID of "submit"

```codeBlockLines_p187
selector: "< *cnn.com* button#submit"

```

Target an iframe of google.com/api/verify and click an anchor element with a classname that includes "now":

```codeBlockLines_p187
selector: "< *google.com/api/verify* a[class*='now']"

```

Find any element on any iframe (or top-level page) with an attribute of price:

```codeBlockLines_p187
selector: "< [price]"

```

Find an iframe with an exact URL of " [https://amazon.com/](https://amazon.com/) and a span with classname of "submit" and "order":

```codeBlockLines_p187
selector: "< https://amazon.com/ span.submit.order"

```

Restrictions

- **Parent-child relationships** are not supported (e.g., `div > span`).
- Each selector must refer to a **single node**.

- [Submitting Forms](https://docs.browserless.io/browserql/bot-detection/submitting-forms#submitting-forms)
- [Clicking within Iframes](https://docs.browserless.io/browserql/bot-detection/submitting-forms#clicking-within-iframes)
  - [How to Click within Iframes](https://docs.browserless.io/browserql/bot-detection/submitting-forms#how-to-click-within-iframes)

---

### How to Automate UIs | Browserless.io
Original URL: https://docs.browserless.io/browserql/bot-detection/ui-automation

[Skip to main content](https://docs.browserless.io/browserql/bot-detection/ui-automation#__docusaurus_skipToContent_fallback)


For activities such as submitting forms or inputting data, Browseless recommends using **BrowserQL**, our most advanced option. BQL is our own custom library that avoids the fingerprints left by other automation tools.

## How BrowserQL Works [â€‹](https://docs.browserless.io/browserql/bot-detection/ui-automation\#how-browserql-works "Direct link to How BrowserQL Works")

**BrowserQL** is our own browser automation language, built on GraphQL. Weâ€™ve tried to keep it simple, as just a set of queries and responses.

Itâ€™s optimized for web automation and scraping, designed to minimize complexity by making intelligent assumptions. Hereâ€™s what it does for you:

- Waits for selectors before interacting with elements.
- Handles mouse movements and clicks automatically.
- Ensures elements are visible by scrolling if needed.
- Manages page-load events, like waiting for `firstContentfulPaint`.

Instead of worrying about these technical details, you focus on queries and actions. You will:

1. Navigate to pages.
2. Perform actions (e.g., click, type).
3. Solve or verify CAPTCHAs.
4. Connect to a library if needed.

Each query follows the format of `function (arguments) {responses}` with an optional `name:` beforehand. For example, going to a site and start filling a form by typing your email, would look like:

```codeBlockLines_p187
mutation form_example {
  goto(url: "https://example.com", waitUntil: networkIdle) {
    status
  }
  typeEmail: type(text: "john@email.com", selector: "#Email"
  ) {
    time
  }
}

```

We then run this query with the browsers hosted in our cloud, which you can see run in the editor.

BrowserQL API

Find out how to export your queries and integrate it in your code by [calling the BrowserQL API](https://docs.browserless.io/browserql/using-the-ide/using-api-calls).

![](https://docs.browserless.io/img/doc/02-ui-automation/automation-01.png)

Browsers

You can run **Chrome or Chromium browsers**, which you can change in the **session settings**. Chrome is more resource-intensive but recommended for getting past CAPTCHAs.

## Humanized Interactions [â€‹](https://docs.browserless.io/browserql/bot-detection/ui-automation\#humanized-interactions "Direct link to Humanized Interactions")

BrowserQL can **humanize** your page interactions. When `humanized` is selected in the **session settings**, it will:

- Wait until the previous action's finished.
- Scroll if needed until the field is visible.
- Mouse over to somewhere within the form field.
- Click into the field.
- Type at a realistic speed.
- Make and correct typos.

Enabling User Input

**Hybrid automations** with `liveURL` allow users to interact with automated workflows.

- [How BrowserQL Works](https://docs.browserless.io/browserql/bot-detection/ui-automation#how-browserql-works)
- [Humanized Interactions](https://docs.browserless.io/browserql/bot-detection/ui-automation#humanized-interactions)

---

### Browserless.io
Original URL: https://docs.browserless.io/browserql/connecting-libraries/playwright

[Skip to main content](https://docs.browserless.io/browserql/connecting-libraries/playwright#__docusaurus_skipToContent_fallback)

# Page Not Found

We could not find what you were looking for.

Please contact the owner of the site that linked you to the original URL and let them know their link is broken.

---

### Browserless.io
Original URL: https://docs.browserless.io/browserql/connecting-libraries/puppeteer

[Skip to main content](https://docs.browserless.io/browserql/connecting-libraries/puppeteer#__docusaurus_skipToContent_fallback)

# Page Not Found

We could not find what you were looking for.

Please contact the owner of the site that linked you to the original URL and let them know their link is broken.

---

### Connection URLs and Endpoints | Browserless.io
Original URL: https://docs.browserless.io/browserql/connection-urls

[Skip to main content](https://docs.browserless.io/browserql/connection-urls#__docusaurus_skipToContent_fallback)


This page explains all the connection URLs and endpoints available for **BrowserQL**, including how to authenticate with your API token, choose the right regional base URL, and interact with the BQL service. Whether you're using the BQL IDE or making direct API calls, this guide covers everything you need to connect and start automating.

## Base URL and Regions [â€‹](https://docs.browserless.io/browserql/connection-urls\#base-url-and-regions "Direct link to Base URL and Regions")

Browserless has multiple regional base URLs:

- `https://production-sfo.browserless.io` (US West)
- `https://production-lon.browserless.io` (Europe UK)
- `https://production-ams.browserless.io` (Europe Amsterdam)

Choose the region closest to you to reduce latency (see [Load Balancers](https://docs.browserless.io/baas/load-balancers)). All require the token query parameter.

## Using Your API Token in URLs [â€‹](https://docs.browserless.io/browserql/connection-urls\#using-your-api-token-in-urls "Direct link to Using Your API Token in URLs")

Add your API token to the URL query string as `?token=YOUR_TOKEN`. Required for authentication (see see [BQL Connection URL Builder](https://docs.browserless.io/browserql/connection-urls)). Invalid tokens result in HTTP 401/403 errors. Keep this URL secure and never expose it in client-side code or logs.

Example:
`https://production-sfo.browserless.io/chromium/bql?token=094632bb-e326-4c63-b953-82b55700b14c` is a basic connection string for a new Chromium session on the SFO cluster using the given token.

Below you can select your preferences of region and browser to define your URL:

### BQL Connection URL Builder

Service Type:

BrowserQL

Browser:

ChromiumChrome

Region:

US WestEurope UKEurope Amsterdam

API Token:

#### Connection URL:

Copy

```
https://production-sfo.browserless.io/chromium/bql?token=YOUR_TOKEN
```

#### Code Snippet:

Copy

```
const response = await fetch('https://production-sfo.browserless.io/chromium/bql?token=YOUR_TOKEN', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json',
  },
  body: JSON.stringify({
    query: `mutation MyQuery($url: String!) {
      goto(url: $url) {
        status
      }
      # Add more BQL operations here
    }`,
    variables: { url: 'https://example.com' }
  }),
});
```

## BrowserQL Connection [â€‹](https://docs.browserless.io/browserql/connection-urls\#browserql-connection "Direct link to BrowserQL Connection")

If you are using the BQL IDE, the connection is handled for you (the IDE lets you select a region
and enters your token). However, advanced users can also call the BQL service directly via a
GraphQL HTTP request or WebSocket:

- **GraphQL HTTP Endpoint**: You can send a GraphQL HTTP POST to the base URL with
`/graphql`. For example: `POST https://production-sfo.browserless.io/graphql?token=YOUR_TOKEN`.
The body of the request should be a JSON with your GraphQL query or mutation. The
response will be JSON with your results. (This is usually used for the management
GraphQL API for checking session pressure, etc., not commonly for running BQL
browser sessions, which are handled by the dedicated BQL endpoint.)

- **Dedicated BQL Endpoint**: When running browser sessions with BQL, Browserless
uses a special endpoint internally (often shown as `/bql`). For instance, when a BQL
session is created, it may run at a URL like
`https://production-sfo.browserless.io/bql/SESSION_ID?token=YOUR_TOKEN`. This is typically abstracted away by the IDE or the initial request. In practice, you
will start a BQL session via the IDE or a GraphQL call, and if you need to reconnect to it
for a hybrid scenario, you'll use the reconnect URL provided in the response (which
looks like the above). In summary, for pure BQL usage, you normally don't manually
construct these URLs.


- [Base URL and Regions](https://docs.browserless.io/browserql/connection-urls#base-url-and-regions)
- [Using Your API Token in URLs](https://docs.browserless.io/browserql/connection-urls#using-your-api-token-in-urls)
- [BrowserQL Connection](https://docs.browserless.io/browserql/connection-urls#browserql-connection)

---

### Launch Parameters and Options | Browserless.io
Original URL: https://docs.browserless.io/browserql/launch-parameters

[Skip to main content](https://docs.browserless.io/browserql/launch-parameters#__docusaurus_skipToContent_fallback)


Browserless allows extensive configuration of how browsers are launched and behave during
your sessions. These launch parameters can be provided either via query parameters in the
URL or through a special JSON launch payload. Whether you're using BQL, BaaS v2, or REST, these
options let you tweak the browser environment to fit your needs.

## Passing Launch Options [â€‹](https://docs.browserless.io/browserql/launch-parameters\#passing-launch-options "Direct link to Passing Launch Options")

Two ways to specify launch options:

1. **Individual Query Parameters**: Add options directly to URLs (e.g., `&headless=false`, `&proxy=residential`). Best for simple boolean options.

2. **Combined `launch` Parameter (JSON)**: For complex configurations, use a single query param `launch` with a JSON string as its value. This JSON can include any Chrome flags or Browserless-specific settings in a structured way. It's essentially the equivalent of Puppeteer's `launch({ options })` but provided to the cloud service:







```codeBlockLines_p187
&launch={"headless":false,"stealth":true,"args":["--window-size=1920,1080"]}

```











(URL-encoded) would configure a headful, stealth-enabled browser with a specific window size.


Browserless merges both methods if used together, with individual parameters taking precedence. Use query params for simple toggles and the launch parameter for multiple settings.

## Launch Options (Query Parameters) [â€‹](https://docs.browserless.io/browserql/launch-parameters\#launch-options-query-parameters "Direct link to Launch Options (Query Parameters)")

Below is a list of available launch options you can use in query strings. BrowserQL
internally uses some of these, but BQL users typically set these via the IDE session settings
rather than manually in a URL.

| Parameter | Description | Default |
| --- | --- | --- |
| headless | Runs the browser in headless mode. Set to false to enable headful mode (with a GUI). While the GUI isn't visible in cloud environments, headful mode may help bypass bot detection. Note: it uses more resources. | `true` |
| stealth | Enables stealth mode to reduce automation signals (similar to puppeteer-extraâ€™s stealth plugin). In BQL, stealth is always on by design and controlled via the humanlike option. In BaaS/REST, set to true to enable stealth techniques. | - `false` (for BaaS/REST)<br>- `true` (for BQL) |
| humanlike | Simulates human-like behavior such as natural mouse movement, typing, and random delays. In the BQL IDE, this can be toggled in session settings. For direct BQL GraphQL calls, use humanlike: true in the launch payload. Recommended for strict bot detection scenarios. | `false` |
| blockAds | Enables the built-in ad blocker (powered by uBlock Origin). Helps speed up scripts and reduce noise by blocking ads and trackers. Especially useful for scraping to avoid popups and clutter. | `false` |
| blockConsentModals | Automatically blocks or dismisses cookie/GDPR consent banners. Available in BQL sessions and the /screenshot and /pdf REST APIs. In BQL, toggle it via the IDE or launch JSON. Useful for cleaner scraping by removing overlays. | `false` |
| proxy | Routes browser traffic through a proxy. Options: proxy=residential for Browserlessâ€™s residential proxy pool; proxy=\`<your proxy URL>\` for your own proxy. Omit to use a direct connection. | none |
| proxyCountry | Used with proxy=residential to specify the exit nodeâ€™s country. Accepts ISO 3166 country codes (e.g., us, gb, de). If omitted, a random location is chosen. | none |
| proxySticky | Used with proxy=residential to maintain the same proxy IP across a session (when possible). Useful for sites that expect consistent IP usage. | `false` |
| timeout | Maximum session duration in milliseconds. The session will automatically close after this time to prevent overuse. | 60000 |

### Headless [â€‹](https://docs.browserless.io/browserql/launch-parameters\#headless "Direct link to Headless")

- cURL
- Javascript
- Python
- Java
- C#

```codeBlockLines_p187
curl --request POST \
  --url 'https://production-sfo.browserless.io/chromium/bql?token=YOUR_API_TOKEN_HERE&headless=false' \
  --header 'Content-Type: application/json' \
  --data '{"query":"mutation PDF {\n  goto(\n    url: \"https://example.com\"\n  ) {\n    status\n  }\n  simple: pdf {\n    base64\n  }\n}","variables":{},"operationName":"PDF"}'

```

```codeBlockLines_p187
const endpoint = "https://production-sfo.browserless.io/chromium/bql?token=YOUR_API_TOKEN_HERE&headless=false";
const token = "YOUR_API_TOKEN_HERE";

const options = {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json',
  },
  body: JSON.stringify({"query":"mutation PDF {\n  goto(url: \"https://example.com\") {\n    status\n  }\n\n  pdf {\n    base64\n  }\n}","variables":"","operationName":"PDF"})
};

const url = `${endpoint}?token=${token}`;
const response = await fetch(url, options);
const data = await response.json();

console.log(data);

```

```codeBlockLines_p187
import requests

endpoint = "https://production-sfo.browserless.io/chromium/bql?token=YOUR_API_TOKEN_HERE&headless=false"
query_string = {
    "token": "YOUR_API_TOKEN_HERE",
}
headers = {
    "Content-Type": "application/json",
}
payload = {
    "query": "mutation PDF {\n  goto(url: \"https://example.com\") {\n    status\n  }\n\n  pdf {\n    base64\n  }\n}",
    "variables": None,
    "operationName": "PDF",
}

response = requests.post(endpoint, params=query_string, headers=headers, json=payload)
print(response.json())

```

```codeBlockLines_p187
String url = "https://production-sfo.browserless.io/chromium/bql?token=YOUR_API_TOKEN_HERE&headless=false";
String token = "YOUR_API_TOKEN_HERE";
String endpoint = String.format("%s?token=%s%s%s", url, token);

HttpResponse<String> response = Unirest.post(endpoint)
    .header("Content-Type", "application/json")
    .body({"query":"mutation PDF {\n  goto(url: \"https://example.com\") {\n    status\n  }\n\n  pdf {\n    base64\n  }\n}","variables":"","operationName":"PDF"})
    .asString();

```

```codeBlockLines_p187
string url = "https://production-sfo.browserless.io/chromium/bql?token=YOUR_API_TOKEN_HERE&headless=false";
string token = "YOUR_API_TOKEN_HERE";
string endpoint = $"{url}?token={token}";

var payload = new
{
    query = @"mutation PDF {
  goto(url: ""https://example.com"") {
    status
  }

  pdf {
    base64
  }
}",
    variables = "",
    operationName = "PDF"
};

using (var client = new HttpClient())
{
    var jsonPayload = System.Text.Json.JsonSerializer.Serialize(payload);
    var content = new StringContent(jsonPayload, Encoding.UTF8, "application/json");

    var response = await client.PostAsync(endpoint, content);
    string responseBody = await response.Content.ReadAsStringAsync();

    Console.WriteLine(responseBody);
}

```

### Stealth [â€‹](https://docs.browserless.io/browserql/launch-parameters\#stealth "Direct link to Stealth")

- cURL
- Javascript
- Python
- Java
- C#

```codeBlockLines_p187
curl --request POST \
  --url 'https://production-sfo.browserless.io/chromium/bql?token=YOUR_API_TOKEN_HERE&stealth=false' \
  --header 'Content-Type: application/json' \
  --data '{"query":"mutation PDF {\n  goto(\n    url: \"https://example.com\"\n  ) {\n    status\n  }\n  simple: pdf {\n    base64\n  }\n}","variables":{},"operationName":"PDF"}'

```

```codeBlockLines_p187
const endpoint = "https://production-sfo.browserless.io/chromium/bql?token=YOUR_API_TOKEN_HERE&stealth=false";
const token = "YOUR_API_TOKEN_HERE";

const options = {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json',
  },
  body: JSON.stringify({"query":"mutation PDF {\n  goto(url: \"https://example.com\") {\n    status\n  }\n\n  pdf {\n    base64\n  }\n}","variables":"","operationName":"PDF"})
};

const url = `${endpoint}?token=${token}`;
const response = await fetch(url, options);
const data = await response.json();

console.log(data);

```

```codeBlockLines_p187
import requests

endpoint = "https://production-sfo.browserless.io/chromium/bql?token=YOUR_API_TOKEN_HERE&stealth=false"
query_string = {
    "token": "YOUR_API_TOKEN_HERE",
}
headers = {
    "Content-Type": "application/json",
}
payload = {
    "query": "mutation PDF {\n  goto(url: \"https://example.com\") {\n    status\n  }\n\n  pdf {\n    base64\n  }\n}",
    "variables": None,
    "operationName": "PDF",
}

response = requests.post(endpoint, params=query_string, headers=headers, json=payload)
print(response.json())

```

```codeBlockLines_p187
String url = "https://production-sfo.browserless.io/chromium/bql?token=YOUR_API_TOKEN_HERE&stealth=false";
String token = "YOUR_API_TOKEN_HERE";
String endpoint = String.format("%s?token=%s%s%s", url, token);

HttpResponse<String> response = Unirest.post(endpoint)
    .header("Content-Type", "application/json")
    .body({"query":"mutation PDF {\n  goto(url: \"https://example.com\") {\n    status\n  }\n\n  pdf {\n    base64\n  }\n}","variables":"","operationName":"PDF"})
    .asString();

```

```codeBlockLines_p187
string url = "https://production-sfo.browserless.io/chromium/bql?token=YOUR_API_TOKEN_HERE&stealth=false";
string token = "YOUR_API_TOKEN_HERE";
string endpoint = $"{url}?token={token}";

var payload = new
{
    query = @"mutation PDF {
  goto(url: ""https://example.com"") {
    status
  }

  pdf {
    base64
  }
}",
    variables = "",
    operationName = "PDF"
};

using (var client = new HttpClient())
{
    var jsonPayload = System.Text.Json.JsonSerializer.Serialize(payload);
    var content = new StringContent(jsonPayload, Encoding.UTF8, "application/json");

    var response = await client.PostAsync(endpoint, content);
    string responseBody = await response.Content.ReadAsStringAsync();

    Console.WriteLine(responseBody);
}

```

### Human Like behavior [â€‹](https://docs.browserless.io/browserql/launch-parameters\#human-like-behavior "Direct link to Human Like behavior")

- cURL
- Javascript
- Python
- Java
- C#

```codeBlockLines_p187
curl --request POST \
  --url 'https://production-sfo.browserless.io/chromium/bql?token=YOUR_API_TOKEN_HERE&humanlike=true' \
  --header 'Content-Type: application/json' \
  --data '{"query":"mutation PDF {\n  goto(\n    url: \"https://example.com\"\n  ) {\n    status\n  }\n  simple: pdf {\n    base64\n  }\n}","variables":{},"operationName":"PDF"}'

```

```codeBlockLines_p187
const endpoint = "https://production-sfo.browserless.io/chromium/bql?token=YOUR_API_TOKEN_HERE&humanlike=true";
const token = "YOUR_API_TOKEN_HERE";

const options = {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json',
  },
  body: JSON.stringify({"query":"mutation PDF {\n  goto(url: \"https://example.com\") {\n    status\n  }\n\n  pdf {\n    base64\n  }\n}","variables":"","operationName":"PDF"})
};

const url = `${endpoint}?token=${token}`;
const response = await fetch(url, options);
const data = await response.json();

console.log(data);

```

```codeBlockLines_p187
import requests

endpoint = "https://production-sfo.browserless.io/chromium/bql?token=YOUR_API_TOKEN_HERE&humanlike=true"
query_string = {
    "token": "YOUR_API_TOKEN_HERE",
}
headers = {
    "Content-Type": "application/json",
}
payload = {
    "query": "mutation PDF {\n  goto(url: \"https://example.com\") {\n    status\n  }\n\n  pdf {\n    base64\n  }\n}",
    "variables": None,
    "operationName": "PDF",
}

response = requests.post(endpoint, params=query_string, headers=headers, json=payload)
print(response.json())

```

```codeBlockLines_p187
String url = "https://production-sfo.browserless.io/chromium/bql?token=YOUR_API_TOKEN_HERE&humanlike=true";
String token = "YOUR_API_TOKEN_HERE";
String endpoint = String.format("%s?token=%s%s%s", url, token);

HttpResponse<String> response = Unirest.post(endpoint)
    .header("Content-Type", "application/json")
    .body({"query":"mutation PDF {\n  goto(url: \"https://example.com\") {\n    status\n  }\n\n  pdf {\n    base64\n  }\n}","variables":"","operationName":"PDF"})
    .asString();

```

```codeBlockLines_p187
string url = "https://production-sfo.browserless.io/chromium/bql?token=YOUR_API_TOKEN_HERE&humanlike=true";
string token = "YOUR_API_TOKEN_HERE";
string endpoint = $"{url}?token={token}";

var payload = new
{
    query = @"mutation PDF {
  goto(url: ""https://example.com"") {
    status
  }

  pdf {
    base64
  }
}",
    variables = "",
    operationName = "PDF"
};

using (var client = new HttpClient())
{
    var jsonPayload = System.Text.Json.JsonSerializer.Serialize(payload);
    var content = new StringContent(jsonPayload, Encoding.UTF8, "application/json");

    var response = await client.PostAsync(endpoint, content);
    string responseBody = await response.Content.ReadAsStringAsync();

    Console.WriteLine(responseBody);
}

```

### Block Ads [â€‹](https://docs.browserless.io/browserql/launch-parameters\#block-ads "Direct link to Block Ads")

- cURL
- Javascript
- Python
- Java
- C#

```codeBlockLines_p187
curl --request POST \
  --url 'https://production-sfo.browserless.io/chromium/bql?token=YOUR_API_TOKEN_HERE&adBlock=true' \
  --header 'Content-Type: application/json' \
  --data '{"query":"mutation PDF {\n  goto(\n    url: \"https://example.com\"\n  ) {\n    status\n  }\n  simple: pdf {\n    base64\n  }\n}","variables":{},"operationName":"PDF"}'

```

```codeBlockLines_p187
const endpoint = "https://production-sfo.browserless.io/chromium/bql?token=YOUR_API_TOKEN_HERE&adBlock=true";
const token = "YOUR_API_TOKEN_HERE";

const options = {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json',
  },
  body: JSON.stringify({"query":"mutation PDF {\n  goto(url: \"https://example.com\") {\n    status\n  }\n\n  pdf {\n    base64\n  }\n}","variables":"","operationName":"PDF"})
};

const url = `${endpoint}?token=${token}`;
const response = await fetch(url, options);
const data = await response.json();

console.log(data);

```

```codeBlockLines_p187
import requests

endpoint = "https://production-sfo.browserless.io/chromium/bql?token=YOUR_API_TOKEN_HERE&adBlock=true"
query_string = {
    "token": "YOUR_API_TOKEN_HERE",
}
headers = {
    "Content-Type": "application/json",
}
payload = {
    "query": "mutation PDF {\n  goto(url: \"https://example.com\") {\n    status\n  }\n\n  pdf {\n    base64\n  }\n}",
    "variables": None,
    "operationName": "PDF",
}

response = requests.post(endpoint, params=query_string, headers=headers, json=payload)
print(response.json())

```

```codeBlockLines_p187
String url = "https://production-sfo.browserless.io/chromium/bql?token=YOUR_API_TOKEN_HERE&adBlock=true";
String token = "YOUR_API_TOKEN_HERE";
String endpoint = String.format("%s?token=%s%s%s", url, token);

HttpResponse<String> response = Unirest.post(endpoint)
    .header("Content-Type", "application/json")
    .body({"query":"mutation PDF {\n  goto(url: \"https://example.com\") {\n    status\n  }\n\n  pdf {\n    base64\n  }\n}","variables":"","operationName":"PDF"})
    .asString();

```

```codeBlockLines_p187
string url = "https://production-sfo.browserless.io/chromium/bql?token=YOUR_API_TOKEN_HERE&adBlock=true";
string token = "YOUR_API_TOKEN_HERE";
string endpoint = $"{url}?token={token}";

var payload = new
{
    query = @"mutation PDF {
  goto(url: ""https://example.com"") {
    status
  }

  pdf {
    base64
  }
}",
    variables = "",
    operationName = "PDF"
};

using (var client = new HttpClient())
{
    var jsonPayload = System.Text.Json.JsonSerializer.Serialize(payload);
    var content = new StringContent(jsonPayload, Encoding.UTF8, "application/json");

    var response = await client.PostAsync(endpoint, content);
    string responseBody = await response.Content.ReadAsStringAsync();

    Console.WriteLine(responseBody);
}

```

### Block Consent Modals [â€‹](https://docs.browserless.io/browserql/launch-parameters\#block-consent-modals "Direct link to Block Consent Modals")

- cURL
- Javascript
- Python
- Java
- C#

```codeBlockLines_p187
curl --request POST \
  --url 'https://production-sfo.browserless.io/chromium/bql?token=YOUR_API_TOKEN_HERE&blockConsentModals=true' \
  --header 'Content-Type: application/json' \
  --data '{"query":"mutation PDF {\n  goto(\n    url: \"https://example.com\"\n  ) {\n    status\n  }\n  simple: pdf {\n    base64\n  }\n}","variables":{},"operationName":"PDF"}'

```

```codeBlockLines_p187
const endpoint = "https://production-sfo.browserless.io/chromium/bql?token=YOUR_API_TOKEN_HERE&blockConsentModals=true";
const token = "YOUR_API_TOKEN_HERE";

const options = {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json',
  },
  body: JSON.stringify({"query":"mutation PDF {\n  goto(url: \"https://example.com\") {\n    status\n  }\n\n  pdf {\n    base64\n  }\n}","variables":"","operationName":"PDF"})
};

const url = `${endpoint}?token=${token}`;
const response = await fetch(url, options);
const data = await response.json();

console.log(data);

```

```codeBlockLines_p187
import requests

endpoint = "https://production-sfo.browserless.io/chromium/bql?token=YOUR_API_TOKEN_HERE&blockConsentModals=true"
query_string = {
    "token": "YOUR_API_TOKEN_HERE",
}
headers = {
    "Content-Type": "application/json",
}
payload = {
    "query": "mutation PDF {\n  goto(url: \"https://example.com\") {\n    status\n  }\n\n  pdf {\n    base64\n  }\n}",
    "variables": None,
    "operationName": "PDF",
}

response = requests.post(endpoint, params=query_string, headers=headers, json=payload)
print(response.json())

```

```codeBlockLines_p187
String url = "https://production-sfo.browserless.io/chromium/bql?token=YOUR_API_TOKEN_HERE&blockConsentModals=true";
String token = "YOUR_API_TOKEN_HERE";
String endpoint = String.format("%s?token=%s%s%s", url, token);

HttpResponse<String> response = Unirest.post(endpoint)
    .header("Content-Type", "application/json")
    .body({"query":"mutation PDF {\n  goto(url: \"https://example.com\") {\n    status\n  }\n\n  pdf {\n    base64\n  }\n}","variables":"","operationName":"PDF"})
    .asString();

```

```codeBlockLines_p187
string url = "https://production-sfo.browserless.io/chromium/bql?token=YOUR_API_TOKEN_HERE&blockConsentModals=true";
string token = "YOUR_API_TOKEN_HERE";
string endpoint = $"{url}?token={token}";

var payload = new
{
    query = @"mutation PDF {
  goto(url: ""https://example.com"") {
    status
  }

  pdf {
    base64
  }
}",
    variables = "",
    operationName = "PDF"
};

using (var client = new HttpClient())
{
    var jsonPayload = System.Text.Json.JsonSerializer.Serialize(payload);
    var content = new StringContent(jsonPayload, Encoding.UTF8, "application/json");

    var response = await client.PostAsync(endpoint, content);
    string responseBody = await response.Content.ReadAsStringAsync();

    Console.WriteLine(responseBody);
}

```

### Proxy [â€‹](https://docs.browserless.io/browserql/launch-parameters\#proxy "Direct link to Proxy")

- cURL
- Javascript
- Python
- Java
- C#

```codeBlockLines_p187
curl --request POST \
  --url 'https://production-sfo.browserless.io/chromium/bql?token=YOUR_API_TOKEN_HERE&proxy=residential' \
  --header 'Content-Type: application/json' \
  --data '{"query":"mutation PDF {\n  goto(\n    url: \"https://example.com\"\n  ) {\n    status\n  }\n  simple: pdf {\n    base64\n  }\n}","variables":{},"operationName":"PDF"}'

```

```codeBlockLines_p187
const endpoint = "https://production-sfo.browserless.io/chromium/bql?token=YOUR_API_TOKEN_HERE&proxy=residential";
const token = "YOUR_API_TOKEN_HERE";

const options = {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json',
  },
  body: JSON.stringify({"query":"mutation PDF {\n  goto(url: \"https://example.com\") {\n    status\n  }\n\n  pdf {\n    base64\n  }\n}","variables":"","operationName":"PDF"})
};

const url = `${endpoint}?token=${token}`;
const response = await fetch(url, options);
const data = await response.json();

console.log(data);

```

```codeBlockLines_p187
import requests

endpoint = "https://production-sfo.browserless.io/chromium/bql?token=YOUR_API_TOKEN_HERE&proxy=residential"
query_string = {
    "token": "YOUR_API_TOKEN_HERE",
}
headers = {
    "Content-Type": "application/json",
}
payload = {
    "query": "mutation PDF {\n  goto(url: \"https://example.com\") {\n    status\n  }\n\n  pdf {\n    base64\n  }\n}",
    "variables": None,
    "operationName": "PDF",
}

response = requests.post(endpoint, params=query_string, headers=headers, json=payload)
print(response.json())

```

```codeBlockLines_p187
String url = "https://production-sfo.browserless.io/chromium/bql?token=YOUR_API_TOKEN_HERE&proxy=residential";
String token = "YOUR_API_TOKEN_HERE";
String endpoint = String.format("%s?token=%s%s%s", url, token);

HttpResponse<String> response = Unirest.post(endpoint)
    .header("Content-Type", "application/json")
    .body({"query":"mutation PDF {\n  goto(url: \"https://example.com\") {\n    status\n  }\n\n  pdf {\n    base64\n  }\n}","variables":"","operationName":"PDF"})
    .asString();

```

```codeBlockLines_p187
string url = "https://production-sfo.browserless.io/chromium/bql?token=YOUR_API_TOKEN_HERE&proxy=residential";
string token = "YOUR_API_TOKEN_HERE";
string endpoint = $"{url}?token={token}";

var payload = new
{
    query = @"mutation PDF {
  goto(url: ""https://example.com"") {
    status
  }

  pdf {
    base64
  }
}",
    variables = "",
    operationName = "PDF"
};

using (var client = new HttpClient())
{
    var jsonPayload = System.Text.Json.JsonSerializer.Serialize(payload);
    var content = new StringContent(jsonPayload, Encoding.UTF8, "application/json");

    var response = await client.PostAsync(endpoint, content);
    string responseBody = await response.Content.ReadAsStringAsync();

    Console.WriteLine(responseBody);
}

```

### Proxy Country [â€‹](https://docs.browserless.io/browserql/launch-parameters\#proxy-country "Direct link to Proxy Country")

- cURL
- Javascript
- Python
- Java
- C#

```codeBlockLines_p187
curl --request POST \
  --url 'https://production-sfo.browserless.io/chromium/bql?token=YOUR_API_TOKEN_HERE&proxy=residential&proxyCountry=br' \
  --header 'Content-Type: application/json' \
  --data '{"query":"mutation PDF {\n  goto(\n    url: \"https://example.com\"\n  ) {\n    status\n  }\n  simple: pdf {\n    base64\n  }\n}","variables":{},"operationName":"PDF"}'

```

```codeBlockLines_p187
const endpoint = "https://production-sfo.browserless.io/chromium/bql?token=YOUR_API_TOKEN_HERE&proxy=residential&proxyCountry=br";
const token = "YOUR_API_TOKEN_HERE";

const options = {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json',
  },
  body: JSON.stringify({"query":"mutation PDF {\n  goto(url: \"https://example.com\") {\n    status\n  }\n\n  pdf {\n    base64\n  }\n}","variables":"","operationName":"PDF"})
};

const url = `${endpoint}?token=${token}`;
const response = await fetch(url, options);
const data = await response.json();

console.log(data);

```

```codeBlockLines_p187
import requests

endpoint = "https://production-sfo.browserless.io/chromium/bql?token=YOUR_API_TOKEN_HERE&proxy=residential&proxyCountry=br"
query_string = {
    "token": "YOUR_API_TOKEN_HERE",
}
headers = {
    "Content-Type": "application/json",
}
payload = {
    "query": "mutation PDF {\n  goto(url: \"https://example.com\") {\n    status\n  }\n\n  pdf {\n    base64\n  }\n}",
    "variables": None,
    "operationName": "PDF",
}

response = requests.post(endpoint, params=query_string, headers=headers, json=payload)
print(response.json())

```

```codeBlockLines_p187
String url = "https://production-sfo.browserless.io/chromium/bql?token=YOUR_API_TOKEN_HERE&proxy=residential&proxyCountry=br";
String token = "YOUR_API_TOKEN_HERE";
String endpoint = String.format("%s?token=%s%s%s", url, token);

HttpResponse<String> response = Unirest.post(endpoint)
    .header("Content-Type", "application/json")
    .body({"query":"mutation PDF {\n  goto(url: \"https://example.com\") {\n    status\n  }\n\n  pdf {\n    base64\n  }\n}","variables":"","operationName":"PDF"})
    .asString();

```

```codeBlockLines_p187
string url = "https://production-sfo.browserless.io/chromium/bql?token=YOUR_API_TOKEN_HERE&proxy=residential&proxyCountry=br";
string token = "YOUR_API_TOKEN_HERE";
string endpoint = $"{url}?token={token}";

var payload = new
{
    query = @"mutation PDF {
  goto(url: ""https://example.com"") {
    status
  }

  pdf {
    base64
  }
}",
    variables = "",
    operationName = "PDF"
};

using (var client = new HttpClient())
{
    var jsonPayload = System.Text.Json.JsonSerializer.Serialize(payload);
    var content = new StringContent(jsonPayload, Encoding.UTF8, "application/json");

    var response = await client.PostAsync(endpoint, content);
    string responseBody = await response.Content.ReadAsStringAsync();

    Console.WriteLine(responseBody);
}

```

### Proxy Sticky [â€‹](https://docs.browserless.io/browserql/launch-parameters\#proxy-sticky "Direct link to Proxy Sticky")

- cURL
- Javascript
- Python
- Java
- C#

```codeBlockLines_p187
curl --request POST \
  --url 'https://production-sfo.browserless.io/chromium/bql?token=YOUR_API_TOKEN_HERE&proxy=residential&proxySticky=true' \
  --header 'Content-Type: application/json' \
  --data '{"query":"mutation PDF {\n  goto(\n    url: \"https://example.com\"\n  ) {\n    status\n  }\n  simple: pdf {\n    base64\n  }\n}","variables":{},"operationName":"PDF"}'

```

```codeBlockLines_p187
const endpoint = "https://production-sfo.browserless.io/chromium/bql?token=YOUR_API_TOKEN_HERE&proxy=residential&proxySticky=true";
const token = "YOUR_API_TOKEN_HERE";

const options = {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json',
  },
  body: JSON.stringify({"query":"mutation PDF {\n  goto(url: \"https://example.com\") {\n    status\n  }\n\n  pdf {\n    base64\n  }\n}","variables":"","operationName":"PDF"})
};

const url = `${endpoint}?token=${token}`;
const response = await fetch(url, options);
const data = await response.json();

console.log(data);

```

```codeBlockLines_p187
import requests

endpoint = "https://production-sfo.browserless.io/chromium/bql?token=YOUR_API_TOKEN_HERE&proxy=residential&proxySticky=true"
query_string = {
    "token": "YOUR_API_TOKEN_HERE",
}
headers = {
    "Content-Type": "application/json",
}
payload = {
    "query": "mutation PDF {\n  goto(url: \"https://example.com\") {\n    status\n  }\n\n  pdf {\n    base64\n  }\n}",
    "variables": None,
    "operationName": "PDF",
}

response = requests.post(endpoint, params=query_string, headers=headers, json=payload)
print(response.json())

```

```codeBlockLines_p187
String url = "https://production-sfo.browserless.io/chromium/bql?token=YOUR_API_TOKEN_HERE&proxy=residential&proxySticky=true";
String token = "YOUR_API_TOKEN_HERE";
String endpoint = String.format("%s?token=%s%s%s", url, token);

HttpResponse<String> response = Unirest.post(endpoint)
    .header("Content-Type", "application/json")
    .body({"query":"mutation PDF {\n  goto(url: \"https://example.com\") {\n    status\n  }\n\n  pdf {\n    base64\n  }\n}","variables":"","operationName":"PDF"})
    .asString();

```

```codeBlockLines_p187
string url = "https://production-sfo.browserless.io/chromium/bql?token=YOUR_API_TOKEN_HERE&proxy=residential&proxySticky=true";
string token = "YOUR_API_TOKEN_HERE";
string endpoint = $"{url}?token={token}";

var payload = new
{
    query = @"mutation PDF {
  goto(url: ""https://example.com"") {
    status
  }

  pdf {
    base64
  }
}",
    variables = "",
    operationName = "PDF"
};

using (var client = new HttpClient())
{
    var jsonPayload = System.Text.Json.JsonSerializer.Serialize(payload);
    var content = new StringContent(jsonPayload, Encoding.UTF8, "application/json");

    var response = await client.PostAsync(endpoint, content);
    string responseBody = await response.Content.ReadAsStringAsync();

    Console.WriteLine(responseBody);
}

```

### Timeout [â€‹](https://docs.browserless.io/browserql/launch-parameters\#timeout "Direct link to Timeout")

- cURL
- Javascript
- Python
- Java
- C#

```codeBlockLines_p187
curl --request POST \
  --url 'https://production-sfo.browserless.io/chromium/bql?token=YOUR_API_TOKEN_HERE&timeout=25000' \
  --header 'Content-Type: application/json' \
  --data '{"query":"mutation PDF {\n  goto(\n    url: \"https://example.com\"\n  ) {\n    status\n  }\n  simple: pdf {\n    base64\n  }\n}","variables":{},"operationName":"PDF"}'

```

```codeBlockLines_p187
const endpoint = "https://production-sfo.browserless.io/chromium/bql?token=YOUR_API_TOKEN_HERE&timeout=25000";
const token = "YOUR_API_TOKEN_HERE";

const options = {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json',
  },
  body: JSON.stringify({"query":"mutation PDF {\n  goto(url: \"https://example.com\") {\n    status\n  }\n\n  pdf {\n    base64\n  }\n}","variables":"","operationName":"PDF"})
};

const url = `${endpoint}?token=${token}`;
const response = await fetch(url, options);
const data = await response.json();

console.log(data);

```

```codeBlockLines_p187
import requests

endpoint = "https://production-sfo.browserless.io/chromium/bql?token=YOUR_API_TOKEN_HERE&timeout=25000"
query_string = {
    "token": "YOUR_API_TOKEN_HERE",
}
headers = {
    "Content-Type": "application/json",
}
payload = {
    "query": "mutation PDF {\n  goto(url: \"https://example.com\") {\n    status\n  }\n\n  pdf {\n    base64\n  }\n}",
    "variables": None,
    "operationName": "PDF",
}

response = requests.post(endpoint, params=query_string, headers=headers, json=payload)
print(response.json())

```

```codeBlockLines_p187
String url = "https://production-sfo.browserless.io/chromium/bql?token=YOUR_API_TOKEN_HERE&timeout=25000";
String token = "YOUR_API_TOKEN_HERE";
String endpoint = String.format("%s?token=%s%s%s", url, token);

HttpResponse<String> response = Unirest.post(endpoint)
    .header("Content-Type", "application/json")
    .body({"query":"mutation PDF {\n  goto(url: \"https://example.com\") {\n    status\n  }\n\n  pdf {\n    base64\n  }\n}","variables":"","operationName":"PDF"})
    .asString();

```

```codeBlockLines_p187
string url = "https://production-sfo.browserless.io/chromium/bql?token=YOUR_API_TOKEN_HERE&timeout=25000";
string token = "YOUR_API_TOKEN_HERE";
string endpoint = $"{url}?token={token}";

var payload = new
{
    query = @"mutation PDF {
  goto(url: ""https://example.com"") {
    status
  }

  pdf {
    base64
  }
}",
    variables = "",
    operationName = "PDF"
};

using (var client = new HttpClient())
{
    var jsonPayload = System.Text.Json.JsonSerializer.Serialize(payload);
    var content = new StringContent(jsonPayload, Encoding.UTF8, "application/json");

    var response = await client.PostAsync(endpoint, content);
    string responseBody = await response.Content.ReadAsStringAsync();

    Console.WriteLine(responseBody);
}

```

- [Passing Launch Options](https://docs.browserless.io/browserql/launch-parameters#passing-launch-options)
- [Launch Options (Query Parameters)](https://docs.browserless.io/browserql/launch-parameters#launch-options-query-parameters)
  - [Headless](https://docs.browserless.io/browserql/launch-parameters#headless)
  - [Stealth](https://docs.browserless.io/browserql/launch-parameters#stealth)
  - [Human Like behavior](https://docs.browserless.io/browserql/launch-parameters#human-like-behavior)
  - [Block Ads](https://docs.browserless.io/browserql/launch-parameters#block-ads)
  - [Block Consent Modals](https://docs.browserless.io/browserql/launch-parameters#block-consent-modals)
  - [Proxy](https://docs.browserless.io/browserql/launch-parameters#proxy)
  - [Proxy Country](https://docs.browserless.io/browserql/launch-parameters#proxy-country)
  - [Proxy Sticky](https://docs.browserless.io/browserql/launch-parameters#proxy-sticky)
  - [Timeout](https://docs.browserless.io/browserql/launch-parameters#timeout)

---

### A guide to use Hybrid with BQL | Browserless.io
Original URL: https://docs.browserless.io/browserql/recipes/hybrid-bql-playwright

[Skip to main content](https://docs.browserless.io/browserql/recipes/hybrid-bql-playwright#__docusaurus_skipToContent_fallback)


This guide demonstrates how to use BrowserQL with our Hybrid feature, which allows you to connect Playwright to an existing BrowserQL session. This is particularly useful when you need to:

- Use BQL-specific features
- Use Playwright's rich API alongside BQL
- Monitor browser activity through a LiveURL
- Unblock sites and perform other browser actions by using Playwright
- Need to provide a LiveURL and listen to when it's being closed.

## LiveURL directly from BQL [â€‹](https://docs.browserless.io/browserql/recipes/hybrid-bql-playwright\#liveurl-directly-from-bql "Direct link to LiveURL directly from BQL")

A LiveURL can also be generated directly from BQL, but you won't be able to listen to when it's been closed and then continue using that browser.
The benefit of using a library such as playwright in conjunction with BQL is that you'll be able to wait for the end-user to finish using the LiveURL and then continue your automation after that, amongst other workflows.
You can generate a LiveURL from BQL directly and then use the reconnect api as well, however there's a max time to how long the reconnect URL can be alive before it dies off, so using a BQL + LiveURL + Reconnect is best done with a Library such as Playwright or Puppeteer.

## Prerequisites [â€‹](https://docs.browserless.io/browserql/recipes/hybrid-bql-playwright\#prerequisites "Direct link to Prerequisites")

Before running this script, make sure you have:

1. Node.js installed on your system
2. A browserless API key
3. The required npm packages, make sure the playwright version is [supported by Browserless](https://docs.browserless.io/baas/private-deployment/versions)






```codeBlockLines_p187
npm install playwright-core@1.50.1

```


## Complete Example [â€‹](https://docs.browserless.io/browserql/recipes/hybrid-bql-playwright\#complete-example "Direct link to Complete Example")

Here's a complete example that shows how to:

1. Initialize a BrowserQL session
2. Connect Playwright to the session
3. Monitor the session through a LiveURL
4. Perform browser actions
5. Capture screenshots

```codeBlockLines_p187
// Import required dependencies
import { chromium } from 'playwright-core';
const token = "YOUR-API-KEY";
const timeout = 5 * 60 * 1000; // 5 minutes timeout
const url = 'https://www.example.com';

// Configure query parameters for BrowserQL
const queryParams = new URLSearchParams({
  token,
  timeout,
  proxy: "residential", // Use residential proxy for better bot detection bypassing
  proxyCountry: "us"   // Set proxy country to US or whichever country the target site is for
}).toString();

// Define the BQL mutation to initialize the session
const query = `
  mutation ReconnectToPlaywright($url: String!) {
    goto(url: $url, waitUntil: networkIdle) {
      status
    }
    #The mutation below is an example of a bql-specific mutations you could need before connecting to playwright
    #verify(type: cloudflare) {
      #found
      #solved
      #time
    #}
    reconnect(timeout: 30000) {
      browserWSEndpoint
    }
  }
`;

const variables = { url };

// Construct the BrowserQL endpoint URL
const endpoint = `https://production-sfo.browserless.io/chromium/bql?${queryParams}`;

// Configure the fetch request options
const options = {
  method: 'POST',
  headers: {
    'content-type': 'application/json',
  },
  body: JSON.stringify({
    query,
    variables,
  }),
};

// Main execution function
(async () => {
  try {
    console.log(`Initializing BrowserQL session for URL: ${url}`);

    // Send the initial BQL query
    const response = await fetch(endpoint, options);

    if (!response.ok) {
      throw new Error(`Failed to initialize session:\n${await response.text()}`);
    }

    // Extract the WebSocket endpoint for Playwright connection
    const { data } = await response.json();
    const browserWSEndpoint = data.reconnect.browserWSEndpoint;
    const endpointReconnect = `${browserWSEndpoint}?${queryParams}`;

    console.log(`Session initialized! Connecting Playwright to ${endpointReconnect}`);

    // Connect Playwright to the BrowserQL session
    const browser = await chromium.connectOverCDP(endpointReconnect);

    // Get the existing context and page
    const [context] = await browser.contexts();
    const page = await context.pages()[0];

    // Create a CDP session for advanced browser control
    const cdpSession = await context.newCDPSession(page);

    // Get the LiveURL for monitoring the session
    const { liveURL } = await cdpSession.send('Browserless.liveURL');
    console.log('Monitor or interact with your session at:', liveURL); //You can open this in a new tab or place it inside an iFrame

    // Example: Perform some browser actions
    // await page.click('.some-button');
    // await page.type('.some-input', 'Hello World');
    /*await page.evaluate(() => {
      document.getElementById("myElement")?.remove();
    });*/

    // Wait for the live session to complete
    await new Promise((resolve) => {
      cdpSession.on('Browserless.liveComplete', resolve);
    });

    console.log(`Session completed. URL the session ended on: ${page.url()}`);

    // Capture a screenshot of the final state
    await page.screenshot({
      fullPage: false,
      path: 'session-screenshot.png'
    });

    // Clean up: close the browser connection
    await browser.close();
    console.log('Browser session closed successfully.');
  } catch (error) {
    console.error('Session error:', error);
  }
})();

```

## Understanding the Code [â€‹](https://docs.browserless.io/browserql/recipes/hybrid-bql-playwright\#understanding-the-code "Direct link to Understanding the Code")

### 1\. Initial Setup [â€‹](https://docs.browserless.io/browserql/recipes/hybrid-bql-playwright\#1-initial-setup "Direct link to 1. Initial Setup")

- The script requires a browserless API key to work, [sign up here](https://www.browserless.io/pricing)
- It configures a 5-minute timeout and sets up residential proxy settings
- The `queryParams` object contains all necessary parameters for the BrowserQL session

### 2\. BQL Query [â€‹](https://docs.browserless.io/browserql/recipes/hybrid-bql-playwright\#2-bql-query "Direct link to 2. BQL Query")

- The `ReconnectToPlaywright` mutation is used to:

1. Navigate to the specified URL
2. Wait for network activity to settle
3. Use BQL-specific features such as verifying cloudflare
4. Get a WebSocket endpoint for Playwright connection

### 3\. Playwright Integration [â€‹](https://docs.browserless.io/browserql/recipes/hybrid-bql-playwright\#3-playwright-integration "Direct link to 3. Playwright Integration")

- After getting the WebSocket endpoint, Playwright connects to the BrowserQL session
- The script retrieves the existing browser context and page
- You can further manipulate the website with Playwright, such as removing unwanted HTML elements before sharing the LiveURL to your end-user.
- A CDP (Chrome DevTools Protocol) session is created for advanced browser control

### 4\. Live Monitoring [â€‹](https://docs.browserless.io/browserql/recipes/hybrid-bql-playwright\#4-live-monitoring "Direct link to 4. Live Monitoring")

- The script obtains a LiveURL through the CDP session
- This URL allows you to monitor and interact with the browser session in real-time
- The session continues until the `Browserless.liveComplete` event is received

### 5\. Cleanup [â€‹](https://docs.browserless.io/browserql/recipes/hybrid-bql-playwright\#5-cleanup "Direct link to 5. Cleanup")

- The script captures a screenshot of the final state
- Finally, it properly closes the browser connection

## Best Practices [â€‹](https://docs.browserless.io/browserql/recipes/hybrid-bql-playwright\#best-practices "Direct link to Best Practices")

1. **Error Handling**
   - Always wrap the main execution in a try-catch block
   - Log errors with meaningful messages
   - Clean up resources in case of errors
2. **Session Management**
   - Set appropriate timeouts for your use case
   - Use residential proxies when needed
   - Monitor the LiveURL for debugging
3. **Resource Cleanup**
   - Always close browser connections
   - Save important data (screenshots, logs) before cleanup

## Common Use Cases [â€‹](https://docs.browserless.io/browserql/recipes/hybrid-bql-playwright\#common-use-cases "Direct link to Common Use Cases")

1. **Debugging BQL Queries**
   - Use the LiveURL to monitor query execution
   - Watch network requests and responses
   - Debug JavaScript errors in real-time
2. **Complex Browser Automation**
   - Combine BQL's simplicity and unblocking features with Playwright's power
   - Use CDP for advanced browser control
   - Capture screenshots and network data
3. **Testing and Monitoring**
   - Monitor browser sessions in real-time
   - Observe the actual flow of an automation
   - Debug issues with live browser inspection

- [LiveURL directly from BQL](https://docs.browserless.io/browserql/recipes/hybrid-bql-playwright#liveurl-directly-from-bql)
- [Prerequisites](https://docs.browserless.io/browserql/recipes/hybrid-bql-playwright#prerequisites)
- [Complete Example](https://docs.browserless.io/browserql/recipes/hybrid-bql-playwright#complete-example)
- [Understanding the Code](https://docs.browserless.io/browserql/recipes/hybrid-bql-playwright#understanding-the-code)
  - [1\. Initial Setup](https://docs.browserless.io/browserql/recipes/hybrid-bql-playwright#1-initial-setup)
  - [2\. BQL Query](https://docs.browserless.io/browserql/recipes/hybrid-bql-playwright#2-bql-query)
  - [3\. Playwright Integration](https://docs.browserless.io/browserql/recipes/hybrid-bql-playwright#3-playwright-integration)
  - [4\. Live Monitoring](https://docs.browserless.io/browserql/recipes/hybrid-bql-playwright#4-live-monitoring)
  - [5\. Cleanup](https://docs.browserless.io/browserql/recipes/hybrid-bql-playwright#5-cleanup)
- [Best Practices](https://docs.browserless.io/browserql/recipes/hybrid-bql-playwright#best-practices)
- [Common Use Cases](https://docs.browserless.io/browserql/recipes/hybrid-bql-playwright#common-use-cases)

---

### Mapping | Browserless.io
Original URL: https://docs.browserless.io/browserql/recipes/mapping

[Skip to main content](https://docs.browserless.io/browserql/recipes/mapping#__docusaurus_skipToContent_fallback)


The mapping feature provides a flexible way to extract structured data from web pages by specifying DOM selectors or JavaScript snippets. This guide covers advanced tips, best practices, and sneaky strategies to help you leverage this feature fully.

The mapping feature allows you to:

- Select multiple DOM nodes simultaneously.
- Retrieve structured data (text, HTML, or attributes).
- Map nested selectors to capture hierarchical DOM structures.
- Assign aliases to make your returned JSON more meaningful.

tip

Use specific CSS selectors to avoid unnecessary data.

## Creating JSON with `mapSelector` [â€‹](https://docs.browserless.io/browserql/recipes/mapping\#creating-json-with-mapselector "Direct link to creating-json-with-mapselector")

The `mapSelector` function offers an intuitive alternative to typical parsing, working similarly to the `map` function in functional programming, with NodeLists or `document.querySelectorAll`.

You can easily extract DOM attributes using the `attribute(name: "data-custom-attribute")` property. It returns an object with `name` and `value` properties.

The query below demonstrates how to:

1. Navigate to `https://news.ycombinator.com`.
2. Create a map named `posts` to extract all `.submission .titleline > a` elements.
3. Return an array of objects, each containing the `href` attribute as a structured JSON.

- Mutation
- Example response

```codeBlockLines_p187
mutation scraping_example {
  goto(
    url: "https://news.ycombinator.com",
    waitUntil: firstContentfulPaint
  ) {
    status
  }

  posts: mapSelector(selector: ".submission .titleline > a", wait: true) {
    link: attribute(name: "href") {
      value
    }
  }
}

```

```codeBlockLines_p187
{
  "data": {
    "goto": {
      "status": 200
    },
    "posts": [\
      {\
        "link": {\
          "value": "https://churchofturing.github.io/landscapeoflisp.html"\
        }\
      },\
      {\
        "link": {\
          "value": "https://www.jjj.de/fxt/fxtbook.pdf"\
        }\
      },\
      ...\
      {\
        "link": {\
          "value": "https://ereader-swedish.fly.dev/"\
        }\
      }\
    ]
  }
}

```

## Smart Use of Aliases [â€‹](https://docs.browserless.io/browserql/recipes/mapping\#smart-use-of-aliases "Direct link to Smart Use of Aliases")

Aliases enhance readability and clarity of your mapped data.

**Example:**

```codeBlockLines_p187
mutation ProductDetails {
  goto(url: "https://example.com/products") {
    status
  }

  products: mapSelector(selector: ".product-item") {
    title: mapSelector(selector: ".product-title") { innerText }
    price: mapSelector(selector: ".product-price") { innerText }
  }
}

```

## Handling Arbitrary DOM Attributes [â€‹](https://docs.browserless.io/browserql/recipes/mapping\#handling-arbitrary-dom-attributes "Direct link to Handling Arbitrary DOM Attributes")

Retrieve any `custom` or `data-*` attributes seamlessly:

**Example:**

```codeBlockLines_p187
mutation CustomAttributes {
  goto(url: "https://example.com") {
    status
  }

  items: mapSelector(selector: "[data-item-id]") {
    id: attribute(name: "data-item-id") {
      name
      value
    }
  }
}

```

## Nested Mapping for Hierarchical Data [â€‹](https://docs.browserless.io/browserql/recipes/mapping\#nested-mapping-for-hierarchical-data "Direct link to Nested Mapping for Hierarchical Data")

Use nested mappings for deeply structured data. The hierarchy is preserved, making your structured JSON easier to handle:

**Example:**

```codeBlockLines_p187
mutation NestedMappingExample {
  goto(url: "https://example.com/categories") {
    status
  }

  categories: mapSelector(selector: ".category") {
    categoryName: innerText
    subcategories: mapSelector(selector: ".subcategory") {
      subcategoryName: innerText
    }
  }
}

```

### Advanced Nested Example [â€‹](https://docs.browserless.io/browserql/recipes/mapping\#advanced-nested-example "Direct link to Advanced Nested Example")

Further illustrating nested mapping, this example retrieves metadata such as author and score:

```codeBlockLines_p187
mutation map_selector_example_with_metadata {
  goto(url: "https://news.ycombinator.com") {
    status
  }

  posts: mapSelector(selector: ".subtext .subline") {
    author: mapSelector(selector: ".hnuser") {
      authorName: innerText
    }

    score: mapSelector(selector: ".score") {
      score: innerText
    }
  }
}

```

## Conditional Wait and Timeout Adjustments [â€‹](https://docs.browserless.io/browserql/recipes/mapping\#conditional-wait-and-timeout-adjustments "Direct link to Conditional Wait and Timeout Adjustments")

Customize wait times for dynamic content:

**Example:**

```codeBlockLines_p187
mutation TimeoutExample {
  goto(url: "https://example.com") {
    status
  }

  delayedItems: mapSelector(selector: ".async-loaded-item", timeout: 60000, wait: true) {
    content: innerText
  }
}

```

- [Creating JSON with `mapSelector`](https://docs.browserless.io/browserql/recipes/mapping#creating-json-with-mapselector)
- [Smart Use of Aliases](https://docs.browserless.io/browserql/recipes/mapping#smart-use-of-aliases)
- [Handling Arbitrary DOM Attributes](https://docs.browserless.io/browserql/recipes/mapping#handling-arbitrary-dom-attributes)
- [Nested Mapping for Hierarchical Data](https://docs.browserless.io/browserql/recipes/mapping#nested-mapping-for-hierarchical-data)
  - [Advanced Nested Example](https://docs.browserless.io/browserql/recipes/mapping#advanced-nested-example)
- [Conditional Wait and Timeout Adjustments](https://docs.browserless.io/browserql/recipes/mapping#conditional-wait-and-timeout-adjustments)

---

### Working with multi-line evaluate in BrowserQL | Browserless.io
Original URL: https://docs.browserless.io/browserql/recipes/multi-line-evaluate

[Skip to main content](https://docs.browserless.io/browserql/recipes/multi-line-evaluate#__docusaurus_skipToContent_fallback)


BrowserQL's `evaluate` mutation allows you to execute JavaScript in the browser's page environment. When working with more complex scripts, especially multi-line code, you need to understand how to properly format your code for BrowserQL.

## How evaluate works in BrowserQL [â€‹](https://docs.browserless.io/browserql/recipes/multi-line-evaluate\#how-evaluate-works-in-browserql "Direct link to How evaluate works in BrowserQL")

When you use the `evaluate` mutation, BrowserQL automatically wraps your code in an async function like this:

```codeBlockLines_p187
(async() => {return YOUR_CODE_HERE})();

```

However, for multi-line code, you currently need to wrap your code in an IIFE (Immediately Invoked Function Expression) to ensure proper execution:

```codeBlockLines_p187
(()=>{
  // Your multi-line code here
  return result;
})()

```

This approach allows you to:

- Structure complex logic across multiple lines
- Use modern JavaScript features (like arrow functions, destructuring, etc.)
- Return values from your code execution
- Handle scoping properly within your evaluate blocks

## Single vs. Multi-line evaluation [â€‹](https://docs.browserless.io/browserql/recipes/multi-line-evaluate\#single-vs-multi-line-evaluation "Direct link to Single vs. Multi-line evaluation")

- Single-line
- Multi-line (with IIFE)

For simple expressions, you can use single-line evaluation:

```codeBlockLines_p187
mutation SimpleEvaluate {
  goto(url:"https://www.example.com"){
    time
  }
  evaluate(content: "document.title") {
    value
  }
}

```

For multi-line scripts, use triple quotes ( `"""`) and wrap your code in an IIFE:

```codeBlockLines_p187
mutation MultiLineEvaluate {
  goto(url:"https://www.example.com"){
    time
  }
  evaluate(content: """
  (()=>{
    const title = document.title;
    const url = window.location.href;
    return { title, url };
  })()
  """) {
    value
  }
}

```

## Important syntax requirement [â€‹](https://docs.browserless.io/browserql/recipes/multi-line-evaluate\#important-syntax-requirement "Direct link to Important syntax requirement")

When writing multi-line evaluate code in BrowserQL, you must wrap your code in an IIFE (Immediately Invoked Function Expression):

- Correct IIFE syntax (required)
- Incorrect approach (will not work - missing IIFE wrap)

```codeBlockLines_p187
mutation CorrectIIFE {
  goto(url:"https://www.example.com"){
    time
  }
  evaluate(content: """
  (()=>{
    const text = document.body.innerText;
    return text;
  })()
  """) {
    value
  }
}

```

```codeBlockLines_p187
mutation IncorrectApproach {
  goto(url:"https://www.example.com"){
    time
  }
  evaluate(content: """
    // ERROR: This code is missing the required IIFE wrapper
    // Correct version would be: (()=>{ ... code ... })()
    const text = document.body.innerText;
    return text;
  """) {
    value
  }
}

```

## Working with async operations [â€‹](https://docs.browserless.io/browserql/recipes/multi-line-evaluate\#working-with-async-operations "Direct link to Working with async operations")

BrowserQL's evaluate implementation can handle promises when properly wrapped in an IIFE:

- Using async/await
- Using promises

```codeBlockLines_p187
mutation AsyncEvaluate {
  goto(url: "https://www.example.com") {
    time
  }
	evaluateData: evaluate(content: """
    (async () => {
      const response = await fetch('/api/data');
      const contentType = response.headers.get('content-type') || '';
      if (!contentType.includes('application/json')) {
        const text = await response.text();
        return JSON.stringify({ error: 'Unexpected response type', content: text.slice(0, 200) });
      }
      return await response.json();
    })();
  """) {
    value
  }
}

```

```codeBlockLines_p187
mutation PromiseEvaluate {
  goto(url: "https://www.example.com") {
  	time
  }
  evaluate(content: """
  (()=>{
    return new Promise(resolve => {
      setTimeout(() => {
        resolve('Operation completed after delay');
      }, 1500);
    });
  })()
  """) {
    value
    time
  }
}

```

## Common use cases [â€‹](https://docs.browserless.io/browserql/recipes/multi-line-evaluate\#common-use-cases "Direct link to Common use cases")

### Extracting data from the DOM [â€‹](https://docs.browserless.io/browserql/recipes/multi-line-evaluate\#extracting-data-from-the-dom "Direct link to Extracting data from the DOM")

Note that this is a sample to demonstrate evaluate's abilities, however if you'd like to extract data from the DOM in JSON format, you can also look into our MapSelector mutation.

```codeBlockLines_p187
mutation ExtractData {
  goto(url: "https://example.com", waitUntil: networkIdle) {
    status
  }

  evaluate(content: """
  (()=>{
    const links = Array.from(document.querySelectorAll('a')).map(a => ({
      text: a.innerText,
      href: a.href
    }));

    const title = document.title;
    const metaDescription = document.querySelector('meta[name="description"]')?.content || '';

    return JSON.stringify({
      title,
      metaDescription,
      links,
      totalLinks: links.length
    });
  })()
  """) {
    value
  }
}

```

### Manipulating the page [â€‹](https://docs.browserless.io/browserql/recipes/multi-line-evaluate\#manipulating-the-page "Direct link to Manipulating the page")

```codeBlockLines_p187
mutation ManipulatePage {
  goto(url: "https://example.com", waitUntil: networkIdle) {
    status
  }

  evaluate(content: """
  (() => {
    // Remove <p> elements
    const popups = document.querySelectorAll('.popup','.modal','p');
    popups.forEach(p => p.remove());

    // Inject an input if it doesn't exist
    let searchInput = document.querySelector('input[type="search"]');
    if (!searchInput) {
      searchInput = document.createElement('input');
      searchInput.type = 'search';
      searchInput.placeholder = 'Search...';
      document.body.appendChild(searchInput);
    }

    // Click and focus the input
    searchInput.click();
    searchInput.focus();

    //Return that the DOM was modified and indicate whether the searchInput is the active element.
    const result = {
      modified: true,
      focused: document.activeElement === searchInput
    };

    return JSON.stringify(result);
  })()
  """) {
    value
    time
  }
}

```

### Working with multiple evaluate calls [â€‹](https://docs.browserless.io/browserql/recipes/multi-line-evaluate\#working-with-multiple-evaluate-calls "Direct link to Working with multiple evaluate calls")

```codeBlockLines_p187
mutation MultipleEvaluates {
  goto(url: "https://example.com", waitUntil: networkIdle) {
    status
  }

  prepare: evaluate(content: """
  (() => {
    // Set up the page
    window.__browserless_data = {
      startTime: Date.now()
    };

    // Return success
    return true;
  })()
  """) {
    value
  }

  performAction: evaluate(content: """
  (() => {
    // Simulate some user action
    const button = document.querySelector('.action-button');
    if (button) {
      button.click();
      return true;
    }
    return false;
  })()
  """) {
    value
  }

  collectResults: evaluate(content: """
  (() => {
    const endTime = Date.now();
    const startTime = window.__browserless_data?.startTime || 0;
    const result = {
      executionTime: endTime - startTime,
      success: document.querySelector('.success-message') !== null
    };
    return JSON.stringify(result);
  })()
  """) {
    value
  }
}

```

## Using the timeout parameter and exception handling [â€‹](https://docs.browserless.io/browserql/recipes/multi-line-evaluate\#using-the-timeout-parameter-and-exception-handling "Direct link to Using the timeout parameter and exception handling")

For long-running scripts, you can specify a custom timeout (in milliseconds) and add try/catch blocks in case there's an exception inside your function:

```codeBlockLines_p187
mutation LongRunningScript {
  goto(url: "https://www.example.com") {
    time
  }

  evaluate(
    content: """
    (() => {
      return new Promise(resolve => {
        try {
          setTimeout(() => {
            try {
              const result = JSON.stringify({
                success: true,
                data: 'Completed after delay'
              });
              resolve(result);
            } catch (innerErr) {
              resolve(JSON.stringify({
                success: false,
                error: 'Error inside timeout: ' + (innerErr.message || 'Unknown')
              }));
            }
          }, 1000); // 1 second delay
        } catch (outerErr) {
          resolve(JSON.stringify({
            success: false,
            error: 'Outer error: ' + (outerErr.message || 'Unknown')
          }));
        }
      });
    })()
    """,
    timeout: 5000
  ) {
    value
    time
  }
}

```

By default, the timeout is 30 seconds (30000ms).

- [How evaluate works in BrowserQL](https://docs.browserless.io/browserql/recipes/multi-line-evaluate#how-evaluate-works-in-browserql)
- [Single vs. Multi-line evaluation](https://docs.browserless.io/browserql/recipes/multi-line-evaluate#single-vs-multi-line-evaluation)
- [Important syntax requirement](https://docs.browserless.io/browserql/recipes/multi-line-evaluate#important-syntax-requirement)
- [Working with async operations](https://docs.browserless.io/browserql/recipes/multi-line-evaluate#working-with-async-operations)
- [Common use cases](https://docs.browserless.io/browserql/recipes/multi-line-evaluate#common-use-cases)
  - [Extracting data from the DOM](https://docs.browserless.io/browserql/recipes/multi-line-evaluate#extracting-data-from-the-dom)
  - [Manipulating the page](https://docs.browserless.io/browserql/recipes/multi-line-evaluate#manipulating-the-page)
  - [Working with multiple evaluate calls](https://docs.browserless.io/browserql/recipes/multi-line-evaluate#working-with-multiple-evaluate-calls)
- [Using the timeout parameter and exception handling](https://docs.browserless.io/browserql/recipes/multi-line-evaluate#using-the-timeout-parameter-and-exception-handling)

---

### How to scrape websites | Browserless.io
Original URL: https://docs.browserless.io/browserql/scraping

[Skip to main content](https://docs.browserless.io/browserql/scraping#__docusaurus_skipToContent_fallback)


For web scraping, Browseless recommends using **BrowserQL**, our most advanced option. BQL is our own custom library that avoids the fingerprints left by other automation tools.

In this section you'll go through the following:

- [How BrowserQL works](https://docs.browserless.io/browserql/scraping#how-browserql-works)
- [Bypassing bot detectors](https://docs.browserless.io/scraping/bot-detectors)
- [Performing searches](https://docs.browserless.io/scraping/performing-searches)
- [Extracting HTML or a JSON](https://docs.browserless.io/scraping/extracting-data)
- [Scraping responses](https://docs.browserless.io/scraping/scraping-responses)

## How BrowserQL works [â€‹](https://docs.browserless.io/browserql/scraping\#how-browserql-works "Direct link to How BrowserQL works")

BrowserQL is our own browser automation language, built on GraphQL. Weâ€™ve kept it simple, as a set of queries and responses.

BQL is optimized for web automation and scraping, designed to minimize complexity by making intelligent assumptions. Hereâ€™s what it does for you:

- Loads a browser with human-like fingerprints.
- Manages page-load events, like `firstContentfulPaint`.
- Handles proxies and request filtering.
- Waits for any mentioned selectors.

Instead of worrying about these technical details, you can focus on queries and actions. You will:

1. Navigate to pages.
2. Perform actions (e.g., click, type).
3. Extract data (e.g., text, HTML).

Each query follows the format of `function (arguments) {responses}` with an optional `name:` beforehand For example, going to a site and grabbing a product name would be:

```codeBlockLines_p187
mutation scrape_example {
  goto(url: "https://example.com", waitUntil: networkIdle) {
    status
  }
 productName: text(
    selector: "span#productTitle"
    visible: true
  ) {
    text
  }
}

```

We then run this query with the browsers hosted in our cloud, which you can see run in the [editor](https://bql.browserless.io/).

BrowserQL API

Find out how to export your queries and integrate it in your code by [calling the BrowserQL API](https://docs.browserless.io/browserql/using-the-ide/using-api-calls).

![](https://docs.browserless.io/img/doc/01-scraping/scraping-1.png)

- [How BrowserQL works](https://docs.browserless.io/browserql/scraping#how-browserql-works)

---

### Bypassing bot detectors | Browserless.io
Original URL: https://docs.browserless.io/browserql/scraping/bot-detectors

[Skip to main content](https://docs.browserless.io/browserql/scraping/bot-detectors#__docusaurus_skipToContent_fallback)


If you're scraping, you're probably coming up against bot detectors. BrowserQL hides most fingerprints, but there's still some settings to be aware.

Note

This information is for bypassing passive bot detectors. For log ins and compulsory CAPTCHAs, check out the [UI Automation](https://docs.browserless.io/ui-automation) section.

## Built-In Proxies [â€‹](https://docs.browserless.io/browserql/scraping/bot-detectors\#built-in-proxies "Direct link to Built-In Proxies")

Use the `proxy` mutation to connect through the Browserless residential proxy to avoid IP-based detection mechanisms.

The example below shows how to use the proxy mutation with browserless's proxy for all requests and proxy through Brazil:

```codeBlockLines_p187
mutation residential_proxy_example{
  proxy(
    url: "*"
    country: BR
  ) {
    time
  }
}

```

Proxy Mutation

You can see detailed information on the proxy mutation [here](https://docs.browserless.io/bql-schema/operations/mutations/proxy).

## External Proxies [â€‹](https://docs.browserless.io/browserql/scraping/bot-detectors\#external-proxies "Direct link to External Proxies")

You can use the `proxy` mutation to connect your own proxies. This mutation can proxy requests by a specified set of conditions, through your external proxy. Only requests that match these conditions are proxies and the rest are sent from the instance's own IP address.

To use your own proxy for all requests, you will use the following query:

```codeBlockLines_p187
mutation external_proxy_example{
  proxy(
    url: "*"
    server: "http://username:password@my-proxy.com:12321"
  ) {
    time
  }
}

```

Where the server parameter takes the following format:

```codeBlockLines_p187
${protocol}://${username}:${password}@${host}:${port}

```

For example, if you have:

- Username: `john`
- Password: `1337code`
- URL: `myproxy.com`
- Port: `1234`

The server argument would look like:

```codeBlockLines_p187
http://john:1337@myproxy.com:1234

```

If you don't have a username or password, you can simply omit those fields in the URI.

## Rejecting Requests [â€‹](https://docs.browserless.io/browserql/scraping/bot-detectors\#rejecting-requests "Direct link to Rejecting Requests")

You can reject unnecessary requests to reduce proxy consumption and improve efficiency. The reject mutation allows you to block requests based on:

- **URL patterns**: Use glob-style patterns to match specific domains or paths.
- **HTTP methods**: Reject specific request methods (e.g., GET, POST).
- **Resource types**: Filter by resource types, such as images, media, or scripts.
- **Operators**: Define whether conditions should be combined using "and" (all must match) or "or" (any match).

For example, you can reject images, media, font and styles as follows:

```codeBlockLines_p187
mutation reject_images{
  reject(type: [image, media, font, stylesheet]) {
    enabled
    time
  }
  goto(url: "https://cnn.com", waitUntil: firstContentfulPaint) {
    status
    time
  }
}

```

## Filtering requests [â€‹](https://docs.browserless.io/browserql/scraping/bot-detectors\#filtering-requests "Direct link to Filtering requests")

You can define which requests need to be proxied, based on URL pattern, request method and request type. To proxy all requests, simply use `url: "*"` to match everything. To proxy only the document requests, set `type: document` as follows:

```codeBlockLines_p187
mutation proxy_filtering{
  proxy(server: "http://john:1337@myproxy.com:1234" type: [document, xhr]) {
    time
  }

  goto(url: "https://nordvpn.com/what-is-my-ip/", waitUntil: load) {
    status
  }
}

```

You can even mix and match proxies, such as a residential proxy for the document and xhr, then the rest through a datacenter proxy.

## Chrome/Chromium Browsers [â€‹](https://docs.browserless.io/browserql/scraping/bot-detectors\#chromechromium-browsers "Direct link to Chrome/Chromium Browsers")

You have a choice of running Chrome or Chromium browsers, which you can change in the session settings. Some detectors will block Chromium, but it's more efficient to run.

- [Built-In Proxies](https://docs.browserless.io/browserql/scraping/bot-detectors#built-in-proxies)
- [External Proxies](https://docs.browserless.io/browserql/scraping/bot-detectors#external-proxies)
- [Rejecting Requests](https://docs.browserless.io/browserql/scraping/bot-detectors#rejecting-requests)
- [Filtering requests](https://docs.browserless.io/browserql/scraping/bot-detectors#filtering-requests)
- [Chrome/Chromium Browsers](https://docs.browserless.io/browserql/scraping/bot-detectors#chromechromium-browsers)

---

### Extracting Data | Browserless.io
Original URL: https://docs.browserless.io/browserql/scraping/extracting-data

[Skip to main content](https://docs.browserless.io/browserql/scraping/extracting-data#__docusaurus_skipToContent_fallback)


You have three main options for extracting data:

- Grab the full or cleaned HTML to parse externally
- Use the mapping function to generate a JSON
- Use requests to grab an API response

## Responding with HTML [â€‹](https://docs.browserless.io/browserql/scraping/extracting-data\#responding-with-html "Direct link to Responding with HTML")

If you already have a parser set up, then you can grab the HTML. You can include selectors such as `body` or use our cleaning options. For example:

- Cleaned HTML
- HTML of a selector

```codeBlockLines_p187
mutation clean_example {
  goto(url: "https://www.browserless.io/") {
    status
  }
html(clean: {
    removeAttributes: true,
    removeNonTextNodes: true
  }) {
    html
  }
}

```

```codeBlockLines_p187
mutation clean_example {
  goto(url: "https://www.browserless.io/") {
    status
  }
html(
  selector: ".navbar_container"
  clean: {
    removeAttributes: true,
    removeNonTextNodes: true
  }) {
    html
  }
}

```

Clean Features

Features of the "clean" argument include removal of non-text nodes, removal of DOM attributes, as well as removal of excessive whitespace and newlines. Using "clean" can save nearly 1,000 times the payload size.

## Creating a JSON with `mapSelector` [â€‹](https://docs.browserless.io/browserql/scraping/extracting-data\#creating-a-json-with-mapselector "Direct link to creating-a-json-with-mapselector")

We have created an alternative to typical parsing, with our `mapSelector` mutation. It is similar to how â€œmapâ€ works in most functional programming languages, where you might use a NodeList or `document.querySelectorAll`.

For getting arbitrary DOM attributes back you can specify them via the `attribute(name: "data-custom-attribute")` property. This will return an object with `name` and `value` properties.

To exemplify this feature, the query below does the following:

1. Navigates to `https://news.ycombinator.com`.
2. Creates a map called `posts`, finding all elements with the `.submission .titleline > a` selector.
3. Returns an array of objects, with an object for each element found. This object will present the name given to the attribute searched as key ( `link`), and inside it, a `value` key with the actual value searched, in the example below, the `href` of each element.

- Mutation
- Example response

```codeBlockLines_p187
mutation scraping_example {
  goto(
    url: "https://news.ycombinator.com",
    waitUntil: firstContentfulPaint
  ) {
    status
  }

  posts: mapSelector(selector: ".submission .titleline > a", wait: true) {
    link: attribute(name: "href") {
      value
    }
  }
}

```

```codeBlockLines_p187
{
  "data": {
    "goto": {
      "status": 200
    },
    "posts": [\
      {\
        "link": {\
          "value": "https://churchofturing.github.io/landscapeoflisp.html"\
        }\
      },\
      {\
        "link": {\
          "value": "https://www.jjj.de/fxt/fxtbook.pdf"\
        }\
      },\
      ...\
      {\
        "link": {\
          "value": "https://ereader-swedish.fly.dev/"\
        }\
      }\
    ]
  }
}

```

You may also continuously map further nested items, for instance this query might get all posts on a page, and then a nested `mapSelector` call might list each author, and post score. Hierarchy of data is preserved to pass through the hierarchical data modeled inside the DOM.

```codeBlockLines_p187
mutation map_selector_example_with_metadata {
  goto(url: "https://news.ycombinator.com") {
    status
  }

  # Get all textual content
  posts: mapSelector(selector: ".subtext .subline") {
    # Get the author(s)
    author: mapSelector(selector: ".hnuser") {
      authorName: innerText
    }

    # Get the post score
    score: mapSelector(selector: ".score") {
      score: innerText
    }
  }
}

```

This API will always return a list of results back regardless if one or more items are found, or null if none are found.

For more details, check out the [advanced mapping guide](https://docs.browserless.io/browserql/recipes/mapping).

- [Responding with HTML](https://docs.browserless.io/browserql/scraping/extracting-data#responding-with-html)
- [Creating a JSON with `mapSelector`](https://docs.browserless.io/browserql/scraping/extracting-data#creating-a-json-with-mapselector)

---

### Performing searches | Browserless.io
Original URL: https://docs.browserless.io/browserql/scraping/performing-searches

[Skip to main content](https://docs.browserless.io/browserql/scraping/performing-searches#__docusaurus_skipToContent_fallback)

If you need to interact with popups or search bars then use the `click` and `type` requests. They use level 4 CSS for the selectors while handling wait conditions automatically.

```codeBlockLines_p187
mutation searching_booking_com{
  goto(url: "https://www.booking.com", waitUntil: networkIdle) {
    status
  }

  closeModal: click(
    selector: "button[aria-label='Dismiss sign-in info.']",
    visible: true,
    timeout: 5000
  ) {
    time
  }

  type(
    text: "New York",
    selector: "input[name='ss'][placeholder='Where are you going?']",
  ) {
    selector
  }

  submitSearch: click(
    selector: "button[type='submit'][class*='a83ed08757']",
    visible: true
  ) {
    selector
    time
  }
}

```

---

### Scraping Responses | Browserless.io
Original URL: https://docs.browserless.io/browserql/scraping/scraping-responses

[Skip to main content](https://docs.browserless.io/browserql/scraping/scraping-responses#__docusaurus_skipToContent_fallback)

BrowserQL can record responses made by the browser, filtered by the URL-pattern, method or type. BQL automatically waits for the response, which you can disable with the wait option.

- Getting all Document responses
- Loading all GET AJAX Response

```codeBlockLines_p187
mutation DocumentResponses{
  goto(url: "https://example.com/", waitUntil: load) {
    status
  }
  response(type:document) {
    url
    body
    headers {
      name
      value
    }
  }
}

```

```codeBlockLines_p187
mutation AJAXGetCalls {
  goto(url: "https://msn.com/", waitUntil: load) {
    status
  }
  response(type: xhr, method: GET, operator: and) {
    url
    type
    method
    body
    headers {
      name
      value
    }
  }
}

```

---

### Parsing Libraries | Browserless.io
Original URL: https://docs.browserless.io/browserql/session-management/parsing-libraries

[Skip to main content](https://docs.browserless.io/browserql/session-management/parsing-libraries#__docusaurus_skipToContent_fallback)


You can use BrowserQL to retrieve HTML content from any website, and use this content with any parsing libraries, such as Scrapy, Beaultiful Soup, or Cheerio.

With BQL, you'll navigate to the desired page, do the actions you require, like verifying or solving a captcha, and finally, retrieve the HTML you need to parse.

tip

Use [BQL Editor](https://account.browserless.io/bql) to create and test your queries before integrating it to your code.

## Example [â€‹](https://docs.browserless.io/browserql/session-management/parsing-libraries\#example "Direct link to Example")

As an example, the code below accesses [https://browserless.io/](https://browserless.io/), clicks on the **Try it Free** button, and retrieves the HTML content from the pricing page.

```codeBlockLines_p187
mutation RetrieveHTML {
  goto(url: "https://browserless.io/") {
    status
  }

  click(selector: ".button-group a.button.w-button") {
    time
  }

  html {
    html
  }
}

```

Now, you can integrate this query into your code, using BQL to retrieve the HTML, and integrating it with your preffered library to parse this content:

- Beautiful Soup
- Scrapy
- Cheerio

```codeBlockLines_p187
import requests
from bs4 import BeautifulSoup

url = 'https://browserless.io/'
token = 'YOUR_API_TOKEN_HERE'
timeout = 5 * 60 * 1000

query = '''
mutation RetrieveHTML($url: String!) {
    goto(url: $url) {
        status
    }
    click(selector: ".button-group a.button.w-button") {
        time
    }
    html {
        html
    }
}
'''

variables = {"url": url}
endpoint = f'https://production-sfo.browserless.io/chromium/bql?timeout={timeout}&token={token}'

headers = {'content-type': 'application/json'}
payload = {"query": query, "variables": variables}

response = requests.post(endpoint, json=payload)
response_data = response.json()

# Extract HTML content
html_content = response_data['data']['html']['html']

# Parse HTML with BeautifulSoup
soup = BeautifulSoup(html_content, 'html.parser')
plans = [tag.text.strip() for tag in soup.find_all('div', class_='tag_price margin-bottom margin-large')]

print(plans)

```

```codeBlockLines_p187
import requests
from scrapy.selector import Selector

url = 'https://browserless.io/'
token = 'YOUR_API_TOKEN_HERE'
timeout = 5 * 60 * 1000

query = '''
mutation RetrieveHTML($url: String!) {
    goto(url: $url) {
        status
    }
    click(selector: ".button-group a.button.w-button") {
        time
    }
    html {
        html
    }
}
'''

variables = {"url": url}
endpoint = f'https://production-sfo.browserless.io/chromium/bql?timeout={timeout}&token={token}'

headers = {'content-type': 'application/json'}
payload = {"query": query, "variables": variables}

response = requests.post(endpoint, json=payload)
response_data = response.json()

# Extract HTML content
html_content = response_data['data']['html']['html']

# Parse HTML with Scrapy
selector = Selector(text=html_content)
plans = selector.css('.tag_price.margin-bottom.margin-large::text').getall()

print(plans)

```

```codeBlockLines_p187
const fetch = require('node-fetch');
const cheerio = require('cheerio');

const url = 'https://browserless.io/';
const token = 'YOUR_API_TOKEN_HERE';
const timeout = 5 * 60 * 1000;

const queryParams = new URLSearchParams({
  timeout,
  token,
}).toString();

const query = `
  mutation RetrieveHTML($url: String!) {
    goto(url: $url) {
      status
    }
    click(selector: ".button-group a.button.w-button") {
      time
    }
    html {
      html
    }
  }
`;

const variables = { url };
const endpoint = `https://production-sfo.browserless.io/chromium/bql?${queryParams}`;

const options = {
  method: 'POST',
  headers: {
    'content-type': 'application/json',
  },
  body: JSON.stringify({
    query,
    variables,
  }),
};

(async () => {
  try {
    const response = await fetch(endpoint, options);
    const { data } = await response.json();

    // Extract HTML content
    const htmlContent = data.html.html;

    // Parse HTML with Cheerio
    const $ = cheerio.load(htmlContent);
    const plans = [];
    $('.tag_price.margin-bottom.margin-large').each((_, element) => {
      plans.push($(element).text().trim());
    });

    console.log(plans);
  } catch (error) {
    console.error('Error fetching or parsing HTML:', error);
  }
})();

```

- [Example](https://docs.browserless.io/browserql/session-management/parsing-libraries#example)

---

### Persisting Sessions | Browserless.io
Original URL: https://docs.browserless.io/browserql/session-management/persisting-sessions

[Skip to main content](https://docs.browserless.io/browserql/session-management/persisting-sessions#__docusaurus_skipToContent_fallback)


## Persisting Browser Sessions with User Data Directory [â€‹](https://docs.browserless.io/browserql/session-management/persisting-sessions\#persisting-browser-sessions-with-user-data-directory "Direct link to Persisting Browser Sessions with User Data Directory")

The `--user-data-dir` flag in browserless allows you to persist browser data such as cookies, localStorage, cache, and login sessions across multiple browser sessions. This is particularly useful for maintaining authenticated states and user preferences without having to re-authenticate or reconfigure settings each time.

note

The `--user-data-dir` feature is only available for Enterprise plans with dedicated fleets. It cannot be used with shared plans.

## Important details when implementing User Data Directories [â€‹](https://docs.browserless.io/browserql/session-management/persisting-sessions\#important-details-when-implementing-user-data-directories "Direct link to Important details when implementing User Data Directories")

The directory will be created if it doesn't exist. When using `--user-data-dir`, make sure to use a unique directory path for each different browser profile you want to maintain. You can only instantiate one browser per userdatadir at a time, meaning it's 1-1 and you can't use the same path in the flag for multiple concurrent browsers.

### Pointing to a specific dedicated worker on Enterprise plans [â€‹](https://docs.browserless.io/browserql/session-management/persisting-sessions\#pointing-to-a-specific-dedicated-worker-on-enterprise-plans "Direct link to Pointing to a specific dedicated worker on Enterprise plans")

User data directories are stored locally on each worker's file system and do not sync across your fleet. For example, a browser instance using `--user-data-dir=~/u/1` on Worker #1 will not be accessible from Worker #2. No need to worry! Browserless allows you to point at a specific worker by using the endpoint provided on your account page under "Production" Clusters. Click on the cell under the Address column to copy the endpoint for the worker you need. You'll want to keep track of which browser session was persisted initially on which worker to ensure consistent access.

- Your BQL endpoints would change from `https://chrome.browserless.io/bql` to something like `https://chrome.browserless.io/p/53616c7465645f5ff8cc738d5eecb3032823d67e37578fe4531b0f9a83dc80856c66d0fe36aba4d2f4bc5f01c18bdfab/bql?token=YOUR_API_TOKEN_HERE&--user-data-dir=~/custompath/123`

## Example: Persisting Dark Mode Preference with BrowserQL [â€‹](https://docs.browserless.io/browserql/session-management/persisting-sessions\#example-persisting-dark-mode-preference-with-browserql "Direct link to Example: Persisting Dark Mode Preference with BrowserQL")

The following example demonstrates how to use the `--user-data-dir` flag with BrowserQL to persist browser state. This example shows how to toggle dark mode on w3schools.com - each time you run it, the initial state will be different since it's persisting the toggle state from previous runs.

```codeBlockLines_p187
const url = 'https://www.browserless.io/';
const token = 'YOUR_API_TOKEN_HERE'; //this script using userdatadir only works for dedicated machines
const timeout = 5 * 60 * 1000;
const launchArgs = {
  args: ['--user-data-dir=~/id-togle-test-123']
};
const queryParams = new URLSearchParams({
  timeout,
  token,
  launch: JSON.stringify(launchArgs)
}).toString();

const query = `
  mutation DarkModeToggle {
    goto(url: "https://www.w3schools.com/", waitUntil: domContentLoaded) {
      status
    }
    DarkModeClassBefore:evaluate(content: "document.body.className") {
      value
    }
    click(selector:"#tnb-dark-mode-toggle-btn"){
      time
    }
    DarkModeClassAfter:evaluate(content: "document.body.className") {
      value
    }
  }
`;

const variables = { url };

const endpoint =
  `https://chrome.browserless.io/chromium/bql?${queryParams}`;

const options = {
  method: 'POST',
  headers: {
    'content-type': 'application/json'
  },
  body: JSON.stringify({
    query,
  }),
};

try {
  console.log(`Running BQL Query: ${url}`);

  const response = await fetch(endpoint, options);

  if (!response.ok) {
    throw new Error(`Got non-ok response:\n` + (await response.text()));
  }

  const { data } = await response.json();

  console.log("Full response data:", JSON.stringify(data, null, 2));

  if (data && data.DarkModeClassBefore && data.DarkModeClassAfter) {
    console.log("Dark mode toggle results:");
    console.log("Before:", data.DarkModeClassBefore.value);
    console.log("After:", data.DarkModeClassAfter.value);
    console.log("Click time:", data.click.time, "ms");
  } else {
    console.log("Unexpected response structure:", data);
  }
} catch (error) {
  console.error(error);
}

```

This example demonstrates how to:

1. Configure a user data directory with the `--user-data-dir` flag
2. Navigate to a website
3. Check the current state (dark mode on/off)
4. Toggle the state
5. Verify the change

When you run this script multiple times, you'll notice that the initial state persists between runs, demonstrating that the browser session is being maintained.

- [Persisting Browser Sessions with User Data Directory](https://docs.browserless.io/browserql/session-management/persisting-sessions#persisting-browser-sessions-with-user-data-directory)
- [Important details when implementing User Data Directories](https://docs.browserless.io/browserql/session-management/persisting-sessions#important-details-when-implementing-user-data-directories)
  - [Pointing to a specific dedicated worker on Enterprise plans](https://docs.browserless.io/browserql/session-management/persisting-sessions#pointing-to-a-specific-dedicated-worker-on-enterprise-plans)
- [Example: Persisting Dark Mode Preference with BrowserQL](https://docs.browserless.io/browserql/session-management/persisting-sessions#example-persisting-dark-mode-preference-with-browserql)

---

### Playwright | Browserless.io
Original URL: https://docs.browserless.io/browserql/session-management/playwright

[Skip to main content](https://docs.browserless.io/browserql/session-management/playwright#__docusaurus_skipToContent_fallback)


If you're already using Playwright working with WebSockets, you can still mix-and-match BrowserQL in your scripts. This is perfect for getting past a nasty bot blockage and then connecting your existing scripts back.

Reconnecting with More BQL

You can also run _more_ BrowserQL at a later time by doing the same process this guide will teach you. Refer to the [Reconnecting with More BQL](https://docs.browserless.io/browserql/writing-bql/reconnecting-bql) guide for more details.

## Using Reconnect [â€‹](https://docs.browserless.io/browserql/session-management/playwright\#using-reconnect "Direct link to Using Reconnect")

With BQL, you'll navigate to the desired page, do the actions you require, like verifying or solving a captcha, and finally, use the [`reconnect`](https://docs.browserless.io/bql-schema/operations/mutations/reconnect) mutation to retrieve a websocket endpoint. This endpoint will be your entry point when starting your Playwright connection.

Using the [https://example.com/](https://example.com/) page, you can run the following BrowserQL query then ask for a connection back:

Reconnect Timeout

The `reconnect` mutation has a `timeout` argument, which is a limit (in milliseconds) for how long the browser should be available before it gets shutdown when nothing connects to it. If a connection were to happen after this time, a semantic `404` is returned back. When a connection happens, this will clear the timer and the session can continue past this limit.

```codeBlockLines_p187
mutation Reconnect {
  goto(url: "https://example.com/", waitUntil: networkIdle) {
    status
  }

  reconnect (timeout: 30000) {
    browserWSEndpoint
  }
}

```

## Connecting with Playwright [â€‹](https://docs.browserless.io/browserql/session-management/playwright\#connecting-with-playwright "Direct link to Connecting with Playwright")

Now, you need to integrate the BQL query above into your Playwright code. You can use BQL Editor's Export Query as Code to translate any query into multiple code languages, like Javascript.

- Learn how to [Export Query as Code](https://docs.browserless.io/browserql/writing-bql/exporting-scripts).
- See the [Available programming languages](https://docs.browserless.io/browserql/using-the-ide/ide-features#query-as-code).

With the query turned into your preffered code language, you can integrate the code into your script. The example below uses the `browserWSEndpoint` to make a connection with Playwright, and takes a screenshot of the webpage:

- Javascript
- Python
- Java
- C#

```codeBlockLines_p187
import playwright from 'playwright-core';

const url = 'https://example.com';
const token = 'YOUR_API_TOKEN_HERE';
const timeout = 5 * 60 * 1000;

const queryParams = new URLSearchParams({
  timeout,
  token,
}).toString();

const query = `
  mutation Reconnect($url: String!) {
    goto(url: $url, waitUntil: networkIdle) {
      status
    }
    reconnect(timeout: 30000) {
      browserWSEndpoint
    }
  }
`;

const variables = { url };

const endpoint =
  `https://production-sfo.browserless.io/playwright./bql?${queryParams}`;

const options = {
  method: 'POST',
  headers: {
    'content-type': 'application/json',
  },
  body: JSON.stringify({
    query,
    variables,
  }),
};

(async () => {
  try {
    console.log(`Running BQL Query: ${url}`);

    const response = await fetch(endpoint, options);

    if (!response.ok) {
      throw new Error(`Got non-ok response:\n` + (await response.text()));
    }

    const { data } = await response.json();
    const browserWSEndpoint = data.reconnect.browserWSEndpoint;

    console.log(`Got OK response! Connecting Playwright to ${browserWSEndpoint}`);

    const browser = await playwright.chromium.connectOverCDP(browserWSEndpoint);
    const context = browser.contexts()[0];
    const page = context.pages().find((p) => p.url().includes(url));

    if (!page) {
      throw new Error(`Could not find a page matching ${url}`);
    }

    await page.screenshot({ fullPage: true, path: 'temp.png' });

    await browser.close();
  } catch (error) {
    console.error(error);
  }
})();

```

```codeBlockLines_p187
import requests
from playwright.sync_api import sync_playwright

url = "https://example.com"
token = "YOUR_API_TOKEN_HERE"
timeout = 5 * 60 * 1000

query_params = f"token={token}&timeout={timeout}"
endpoint = f"https://production-sfo.browserless.io/chromium/bql?{query_params}"

query = """
  mutation Reconnect($url: String!) {
    goto(url: $url, waitUntil: networkIdle) {
      status
    }
    reconnect(timeout: 30000) {
      browserWSEndpoint
    }
  }
"""

variables = {"url": url}

headers = {"content-type": "application/json"}

body = {"query": query, "variables": variables}

try:
    print(f"Running BQL Query: {url}")
    response = requests.post(endpoint, json=body, headers=headers)

    if response.status_code != 200:
        raise Exception(f"Got non-ok response:\n{response.text}")

    data = response.json().get("data")
    browser_ws_endpoint = data["reconnect"]["browserWSEndpoint"]
    print(f"Got OK response! Connecting Playwright to {browser_ws_endpoint}")

    with sync_playwright() as playwright:
        browser = playwright.chromium.connect_over_cdp(browser_ws_endpoint)
        context = browser.contexts[0]
        page = next((p for p in context.pages if url in p.url), None)

        if not page:
            raise Exception(f"Could not find a page matching {url}")

        page.screenshot(path="temp.png", full_page=True)

        browser.close()

except Exception as e:
    print(f"Error: {e}")

```

```codeBlockLines_p187
package com.example;

import com.microsoft.playwright.*;
import com.google.gson.*;
import java.net.http.*;
import java.net.URI;
import java.util.*;

public class PlaywrightBQL {
    public static void main(String[] args) {
        String url = "https://example.com";
        String token = "YOUR_API_TOKEN_HERE";
        int timeout = 5 * 60 * 1000;

        String queryParams = String.format("token=%s&timeout=%d", token, timeout);
        String endpoint = String.format("https://production-sfo.browserless.io/chromium/bql?%s", queryParams);

        String query = """
                mutation Reconnect($url: String!) {
                  goto(url: $url, waitUntil: networkIdle) {
                    status
                  }
                  reconnect(timeout: 30000) {
                    browserWSEndpoint
                  }
                }
                """;

        JsonObject variables = new JsonObject();
        variables.addProperty("url", url);

        JsonObject body = new JsonObject();
        body.addProperty("query", query);
        body.add("variables", variables);

        try {
            // Send GraphQL request
            HttpClient client = HttpClient.newHttpClient();
            HttpRequest request = HttpRequest.newBuilder()
                    .uri(URI.create(endpoint))
                    .header("Content-Type", "application/json")
                    .POST(HttpRequest.BodyPublishers.ofString(body.toString()))
                    .build();

            HttpResponse<String> response = client.send(request, HttpResponse.BodyHandlers.ofString());
            if (response.statusCode() != 200) {
                throw new RuntimeException("Failed request: " + response.body());
            }

            // Parse response
            JsonObject data = JsonParser.parseString(response.body()).getAsJsonObject().getAsJsonObject("data");
            String browserWSEndpoint = data.getAsJsonObject("reconnect").get("browserWSEndpoint").getAsString();

            System.out.println("Connecting Playwright to " + browserWSEndpoint);

            try (Playwright playwright = Playwright.create()) {
                Browser browser = playwright.chromium().connectOverCDP(browserWSEndpoint);
                BrowserContext context = browser.contexts().get(0);
                Page page = context.pages().stream()
                        .filter(p -> p.url().contains(url))
                        .findFirst()
                        .orElseThrow(() -> new RuntimeException("Page not found"));

                page.screenshot(new Page.ScreenshotOptions().setPath("temp.png").setFullPage(true));
                browser.close();
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

```

```codeBlockLines_p187
using System;
using System.Net.Http;
using System.Text;
using System.Text.Json;
using System.Text.Json.Nodes;
using Microsoft.Playwright;

class Program
{
    static async System.Threading.Tasks.Task Main(string[] args)
    {
        string url = "https://example.com";
        string token = "YOUR_API_TOKEN_HERE";
        int timeout = 5 * 60 * 1000;

        string queryParams = $"token={token}&timeout={timeout}";
        string endpoint = $"https://production-sfo.browserless.io/chromium/bql?{queryParams}";

        string query = @"
        mutation Reconnect($url: String!) {
          goto(url: $url, waitUntil: networkIdle) {
            status
          }
          reconnect(timeout: 30000) {
            browserWSEndpoint
          }
        }";

        var body = new
        {
            query = query,
            variables = new { url }
        };

        try
        {
            // Send GraphQL request
            using var client = new HttpClient();
            var requestContent = new StringContent(JsonSerializer.Serialize(body), Encoding.UTF8, "application/json");
            var response = await client.PostAsync(endpoint, requestContent);

            if (!response.IsSuccessStatusCode)
            {
                throw new Exception($"Request failed: {await response.Content.ReadAsStringAsync()}");
            }

            var jsonResponse = JsonNode.Parse(await response.Content.ReadAsStringAsync());
            string browserWSEndpoint = jsonResponse["data"]["reconnect"]["browserWSEndpoint"].ToString();

            Console.WriteLine($"Connecting Playwright to {browserWSEndpoint}");

            // Connect to Playwright
            using var playwright = await Playwright.CreateAsync();
            var browser = await playwright.Chromium.ConnectOverCDPAsync(browserWSEndpoint);
            var context = browser.Contexts[0];
            var page = context.Pages.Find(p => p.Url.Contains(url)) ?? throw new Exception("Page not found");

            // Take screenshot
            await page.ScreenshotAsync(new PageScreenshotOptions { Path = "temp.png", FullPage = true });

            await browser.CloseAsync();
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error: {ex.Message}");
        }
    }
}

```

- [Using Reconnect](https://docs.browserless.io/browserql/session-management/playwright#using-reconnect)
- [Connecting with Playwright](https://docs.browserless.io/browserql/session-management/playwright#connecting-with-playwright)

---

### Puppeteer | Browserless.io
Original URL: https://docs.browserless.io/browserql/session-management/puppeteer

[Skip to main content](https://docs.browserless.io/browserql/session-management/puppeteer#__docusaurus_skipToContent_fallback)


If you're already using Puppeteer working with WebSockets, you can still mix-and-match BrowserQL in your scripts. This is perfect for getting past a nasty bot blockage and then connecting your existing scripts back.

Reconnecting with More BQL

You can also run _more_ BrowserQL at a later time by doing the same process this guide will teach you. Refer to the [Reconnecting with More BQL](https://docs.browserless.io/browserql/writing-bql/reconnecting-bql) guide for more details.

## Using Reconnect [â€‹](https://docs.browserless.io/browserql/session-management/puppeteer\#using-reconnect "Direct link to Using Reconnect")

With BQL, you'll navigate to the desired page, do the actions you require, like verifying or solving a captcha, and finally, use the [`reconnect`](https://docs.browserless.io/bql-schema/operations/mutations/reconnect) mutation to retrieve a websocket endpoint. This endpoint will be your entry point when starting your Puppeteer connection.

Using the [https://example.com/](https://example.com/) page, you can run the following BrowserQL query then ask for a connection back:

Reconnect Timeout

The `reconnect` mutation has a `timeout` argument, which is a limit (in milliseconds) for how long the browser should be available before it gets shutdown when nothing connects to it. If a connection were to happen after this time, a semantic `404` is returned back. When a connection happens, this will clear the timer and the session can continue past this limit.

```codeBlockLines_p187
mutation Reconnect {
  goto(url: "https://example.com/", waitUntil: networkIdle) {
    status
  }

  reconnect (timeout: 30000) {
    browserWSEndpoint
  }
}

```

## Connecting with Puppeteer [â€‹](https://docs.browserless.io/browserql/session-management/puppeteer\#connecting-with-puppeteer "Direct link to Connecting with Puppeteer")

Now, you need to integrate the BQL query above into your Puppeteer code. You can use BrowserQL Editor's Export Query as Code to translate any query into multiple code languages, like Javascript.

- Learn how to [Export Query as Code](https://docs.browserless.io/browserql/writing-bql/exporting-scripts).
- See the [Available programming languages](https://docs.browserless.io/browserql/using-the-ide/ide-features#query-as-code).

With the query turned into JS code, you can integrate the code into your script. The example below uses the `browserWSEndpoint` to make a connection with Puppeteer, and takes a screenshot of the webpage:

```codeBlockLines_p187
import puppeteer from 'puppeteer-core';

const url = 'https://example.com';
const token = 'YOUR_API_TOKEN_HERE';
const timeout = 5 * 60 * 1000;

const queryParams = new URLSearchParams({
  timeout,
  token,
}).toString();

const query = `
  mutation Reconnect($url: String!) {
    goto(url: $url, waitUntil: networkIdle) {
      status
    }
    reconnect(timeout: 30000) {
      browserWSEndpoint
    }
  }
`;

const variables = { url };

const endpoint = `https://production-sfo.browserless.io/chromium/bql?${queryParams}`;

const options = {
  method: 'POST',
  headers: {
    'content-type': 'application/json'
  },
  body: JSON.stringify({
    query,
    variables,
  }),
};

try {
  console.log(`Running BQL Query: ${url}`);

  const response = await fetch(endpoint, options);

  if (!response.ok) {
    throw new Error(`Got non-ok response:\n` + (await response.text()));
  }

  const { data } = await response.json();
  const browserWSEndpoint = data.reconnect.browserWSEndpoint
  console.log(`Got OK response! Connecting puppeteer to ${browserWSEndpoint}`);
  const browser = await puppeteer.connect({
    browserWSEndpoint,
  });
  console.log(`Connected to ${await browser.version()}`);
  const pages = await browser.pages();
  const page = pages.find((p) => p.url().includes(url));
  await page.screenshot({ fullPage: true, path: 'temp.png' });
  await browser.close();
} catch (error) {
  console.error(error);
}

```

- [Using Reconnect](https://docs.browserless.io/browserql/session-management/puppeteer#using-reconnect)
- [Connecting with Puppeteer](https://docs.browserless.io/browserql/session-management/puppeteer#connecting-with-puppeteer)

---

### Maintaining Sessions with Reconnects | Browserless.io
Original URL: https://docs.browserless.io/browserql/session-management/reconnect-to-browserless

[Skip to main content](https://docs.browserless.io/browserql/session-management/reconnect-to-browserless#__docusaurus_skipToContent_fallback)


The Session-Reconnect features allow you to maintain continuity across multiple browser sessions or integrate with other automation tools. This section covers how to reconnect to an existing browser session, pass control between BrowserQL and external libraries, and create persistent workflows that can be accessed and controlled across different sessions or systems.

Similar to connecting a 3rd-party library, you can also reconnect back and execute more BrowserQL as well. BQL does this by generating a new unique URL to use for running more queries. You can take this URL, append your API-token to it, and run more query language.

Scraping websites with traditional tools like Puppeteer or Playwright can be inefficient due to repeated session restarts and unnecessary proxy usage. Reconnects maintains browser sessions, preserving cookies, cache, and session data across multiple requests, bringing the following benefits:

- **Reduced proxy usage:** Save up to 90% of proxy bandwidth.
- **Improved efficiency:** Avoid repetitive loading of static content.
- **Lower detection risk:** Maintain consistent session states to avoid bot detection mechanisms like CAPTCHAs.

## Implementing Reconnects with BrowserQL [â€‹](https://docs.browserless.io/browserql/session-management/reconnect-to-browserless\#implementing-reconnects-with-browserql "Direct link to Implementing Reconnects with BrowserQL")

This guide will go through the following steps to maintain a sessions using Reconnects:

1. [Initiate a session](https://docs.browserless.io/browserql/session-management/reconnect-to-browserless#step-1-initial-setup).
2. [Scrape data using the reconnect URL](https://docs.browserless.io/browserql/session-management/reconnect-to-browserless#step-2-using-the-reconnect-url).
3. [Refresh your session URL regularly to maintain stability](https://docs.browserless.io/browserql/session-management/reconnect-to-browserless#step-3-refreshing-your-session).

### Step 1: Initial Setup [â€‹](https://docs.browserless.io/browserql/session-management/reconnect-to-browserless\#step-1-initial-setup "Direct link to Step 1: Initial Setup")

Start by initiating a session with BrowserQL. This first query opens the browser, navigates to your target URL, and provides a reconnect URL to reuse the same session.

- Javascript
- Python
- Java
- C#

```codeBlockLines_p187
import fetch from 'node-fetch';

const API_KEY = "YOUR_API_TOKEN_HERE";
const BQL_ENDPOINT = "https://production-sfo.browserless.io/chromium/bql";

const sessionQuery = `
mutation StartSession {
  goto(url: "https://example.com", waitUntil: networkIdle) {
    status
  }
  reconnect(timeout: 60000) { # Keeps session open for 60 seconds
    BrowserQLEndpoint
  }
}`;

async function startSession() {
  const response = await fetch(BQL_ENDPOINT, {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      Authorization: `Bearer ${API_KEY}`,
    },
    body: JSON.stringify({ query: sessionQuery }),
  });

  const data = await response.json();
  console.log("Reconnect URL:", data.data.reconnect.BrowserQLEndpoint);
  return data.data.reconnect.BrowserQLEndpoint;
}

startSession();

```

```codeBlockLines_p187
import requests

API_KEY = "YOUR_API_TOKEN_HERE"
BQL_ENDPOINT = "https://production-sfo.browserless.io/chromium/bql"

session_query = """
mutation StartSession {
  goto(url: "https://example.com", waitUntil: networkIdle) {
    status
  }
  reconnect(timeout: 60000) {
    BrowserQLEndpoint
  }
}
"""

def start_session():
    headers = {
        "Content-Type": "application/json",
        "Authorization": f"Bearer {API_KEY}"
    }
    payload = {"query": session_query}
    response = requests.post(BQL_ENDPOINT, json=payload, headers=headers)
    response.raise_for_status()
    data = response.json()
    endpoint = data['data']['reconnect']['BrowserQLEndpoint']
    print("Reconnect URL:", endpoint)
    return endpoint

start_session()

```

```codeBlockLines_p187
import java.io.IOException;
import java.net.URI;
import java.net.http.HttpClient;
import java.net.http.HttpRequest;
import java.net.http.HttpResponse;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;

public class BrowserlessSession {

    private static final String API_KEY = "YOUR_API_TOKEN_HERE";
    private static final String BQL_ENDPOINT = "https://production-sfo.browserless.io/chromium/bql";

    private static final String SESSION_QUERY = """
        mutation StartSession {
          goto(url: "https://example.com", waitUntil: networkIdle) {
            status
          }
          reconnect(timeout: 60000) {
            BrowserQLEndpoint
          }
        }
        """;

    public static void main(String[] args) throws IOException, InterruptedException {
        HttpClient client = HttpClient.newHttpClient();

        String jsonPayload = "{\"query\": " + new ObjectMapper().writeValueAsString(SESSION_QUERY) + "}";

        HttpRequest request = HttpRequest.newBuilder()
            .uri(URI.create(BQL_ENDPOINT))
            .header("Content-Type", "application/json")
            .header("Authorization", "Bearer " + API_KEY)
            .POST(HttpRequest.BodyPublishers.ofString(jsonPayload))
            .build();

        HttpResponse<String> response = client.send(request, HttpResponse.BodyHandlers.ofString());

        ObjectMapper mapper = new ObjectMapper();
        JsonNode root = mapper.readTree(response.body());

        String endpoint = root.path("data")
                              .path("reconnect")
                              .path("BrowserQLEndpoint")
                              .asText();

        System.out.println("Reconnect URL: " + endpoint);
    }
}

```

```codeBlockLines_p187
using System;
using System.Net.Http;
using System.Text;
using System.Text.Json;
using System.Threading.Tasks;

class Program
{
    private const string ApiKey = "YOUR_API_TOKEN_HERE";
    private const string BqlEndpoint = "https://production-sfo.browserless.io/chromium/bql";

    private const string sessionQuery = @"
    mutation StartSession {
      goto(url: ""https://example.com"", waitUntil: networkIdle) {
        status
      }
      reconnect(timeout: 60000) {
        BrowserQLEndpoint
      }
    }";

    static async Task Main()
    {
        using var client = new HttpClient();

        client.DefaultRequestHeaders.Add("Authorization", $"Bearer {ApiKey}");

        var payload = new
        {
            query = sessionQuery
        };

        var content = new StringContent(JsonSerializer.Serialize(payload), Encoding.UTF8, "application/json");

        var response = await client.PostAsync(BqlEndpoint, content);
        response.EnsureSuccessStatusCode();

        var responseBody = await response.Content.ReadAsStringAsync();
        using var doc = JsonDocument.Parse(responseBody);
        var endpoint = doc.RootElement.GetProperty("data")
                                    .GetProperty("reconnect")
                                    .GetProperty("BrowserQLEndpoint")
                                    .GetString();

        Console.WriteLine("Reconnect URL: " + endpoint);
    }
}

```

### Step 2: Using the Reconnect URL [â€‹](https://docs.browserless.io/browserql/session-management/reconnect-to-browserless\#step-2-using-the-reconnect-url "Direct link to Step 2: Using the Reconnect URL")

Use the reconnect URL provided by the initial session setup to make subsequent queries without starting a new browser instance.

- Javascript
- Python
- Java
- C#

```codeBlockLines_p187
const RECONNECT_BQL_ENDPOINT = "YOUR_RECONNECT_BQL_ENDPOINT";

const scrapeQuery = `
mutation FetchData {
  text(selector: ".product-title") {
    text
  }
}`;

async function fetchData() {
  const response = await fetch(RECONNECT_BQL_ENDPOINT, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ query: scrapeQuery }),
  });

  const data = await response.json();
  console.log("Fetched Data:", data.data.text.text);
}

fetchData();

```

```codeBlockLines_p187
import requests

RECONNECT_BQL_ENDPOINT = "YOUR_RECONNECT_BQL_ENDPOINT"

scrape_query = """
mutation FetchData {
  text(selector: ".product-title") {
    text
  }
}
"""

def fetch_data():
    headers = {"Content-Type": "application/json"}
    response = requests.post(
        RECONNECT_BQL_ENDPOINT,
        json={"query": scrape_query},
        headers=headers
    )
    response.raise_for_status()
    data = response.json()
    print("Fetched Data:", data['data']['text']['text'])

fetch_data()

```

```codeBlockLines_p187
import java.io.IOException;
import java.net.URI;
import java.net.http.HttpClient;
import java.net.http.HttpRequest;
import java.net.http.HttpResponse;

import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;

public class FetchData {

    private static final String RECONNECT_BQL_ENDPOINT = "YOUR_RECONNECT_BQL_ENDPOINT";

    private static final String SCRAPE_QUERY = """
        mutation FetchData {
          text(selector: ".product-title") {
            text
          }
        }
        """;

    public static void main(String[] args) throws IOException, InterruptedException {
        HttpClient client = HttpClient.newHttpClient();

        String jsonPayload = "{\"query\": " + new ObjectMapper().writeValueAsString(SCRAPE_QUERY) + "}";

        HttpRequest request = HttpRequest.newBuilder()
            .uri(URI.create(RECONNECT_BQL_ENDPOINT))
            .header("Content-Type", "application/json")
            .POST(HttpRequest.BodyPublishers.ofString(jsonPayload))
            .build();

        HttpResponse<String> response = client.send(request, HttpResponse.BodyHandlers.ofString());

        ObjectMapper mapper = new ObjectMapper();
        JsonNode root = mapper.readTree(response.body());

        String fetchedText = root.path("data").path("text").path("text").asText();

        System.out.println("Fetched Data: " + fetchedText);
    }
}

```

```codeBlockLines_p187
using System;
using System.Net.Http;
using System.Text;
using System.Text.Json;
using System.Threading.Tasks;

class Program
{
    private const string ReconnectBqlEndpoint = "YOUR_RECONNECT_BQL_ENDPOINT";

    private const string scrapeQuery = @"
    mutation FetchData {
      text(selector: "".product-title"") {
        text
      }
    }";

    static async Task Main()
    {
        using var client = new HttpClient();

        var payload = new
        {
            query = scrapeQuery
        };

        var content = new StringContent(JsonSerializer.Serialize(payload), Encoding.UTF8, "application/json");

        var response = await client.PostAsync(ReconnectBqlEndpoint, content);
        response.EnsureSuccessStatusCode();

        var responseBody = await response.Content.ReadAsStringAsync();
        using var doc = JsonDocument.Parse(responseBody);

        var fetchedText = doc.RootElement.GetProperty("data")
                                        .GetProperty("text")
                                        .GetProperty("text")
                                        .GetString();

        Console.WriteLine("Fetched Data: " + fetchedText);
    }
}

```

### Step 3: Refreshing Your Session [â€‹](https://docs.browserless.io/browserql/session-management/reconnect-to-browserless\#step-3-refreshing-your-session "Direct link to Step 3: Refreshing Your Session")

To avoid instability, refresh the reconnect endpoint periodically.

- Javascript
- Python
- Java
- C#

```codeBlockLines_p187
const refreshQuery = `
mutation RefreshSession {
  reconnect(timeout: 60000) { # Extends session timeout
    BrowserQLEndpoint
  }
}`;

async function refreshSession() {
  const response = await fetch(BQL_ENDPOINT, {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      Authorization: `Bearer ${API_KEY}`,
    },
    body: JSON.stringify({ query: refreshQuery }),
  });

  const data = await response.json();
  console.log("New Reconnect URL:", data.data.reconnect.BrowserQLEndpoint);
  return data.data.reconnect.BrowserQLEndpoint;
}

```

```codeBlockLines_p187
import requests

API_KEY = "YOUR_API_TOKEN_HERE"
BQL_ENDPOINT = "https://production-sfo.browserless.io/chromium/bql"

refresh_query = """
mutation RefreshSession {
  reconnect(timeout: 60000) {
    BrowserQLEndpoint
  }
}
"""

def refresh_session():
    headers = {
        "Content-Type": "application/json",
        "Authorization": f"Bearer {API_KEY}"
    }
    response = requests.post(
        BQL_ENDPOINT,
        json={"query": refresh_query},
        headers=headers
    )
    response.raise_for_status()
    data = response.json()
    endpoint = data['data']['reconnect']['BrowserQLEndpoint']
    print("New Reconnect URL:", endpoint)
    return endpoint

refresh_session()

```

```codeBlockLines_p187
import java.io.IOException;
import java.net.URI;
import java.net.http.HttpClient;
import java.net.http.HttpRequest;
import java.net.http.HttpResponse;

import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;

public class RefreshSession {

    private static final String API_KEY = "YOUR_API_TOKEN_HERE";
    private static final String BQL_ENDPOINT = "https://production-sfo.browserless.io/chromium/bql";

    private static final String REFRESH_QUERY = """
        mutation RefreshSession {
          reconnect(timeout: 60000) {
            BrowserQLEndpoint
          }
        }
        """;

    public static void main(String[] args) throws IOException, InterruptedException {
        HttpClient client = HttpClient.newHttpClient();

        String jsonPayload = "{\"query\": " + new ObjectMapper().writeValueAsString(REFRESH_QUERY) + "}";

        HttpRequest request = HttpRequest.newBuilder()
            .uri(URI.create(BQL_ENDPOINT))
            .header("Content-Type", "application/json")
            .header("Authorization", "Bearer " + API_KEY)
            .POST(HttpRequest.BodyPublishers.ofString(jsonPayload))
            .build();

        HttpResponse<String> response = client.send(request, HttpResponse.BodyHandlers.ofString());

        ObjectMapper mapper = new ObjectMapper();
        JsonNode root = mapper.readTree(response.body());

        String endpoint = root.path("data").path("reconnect").path("BrowserQLEndpoint").asText();

        System.out.println("New Reconnect URL: " + endpoint);
    }
}

```

```codeBlockLines_p187
using System;
using System.Net.Http;
using System.Text;
using System.Text.Json;
using System.Threading.Tasks;

class Program
{
    private const string ApiKey = "YOUR_API_TOKEN_HERE";
    private const string BqlEndpoint = "https://production-sfo.browserless.io/chromium/bql";

    private const string refreshQuery = @"
    mutation RefreshSession {
      reconnect(timeout: 60000) {
        BrowserQLEndpoint
      }
    }";

    static async Task Main()
    {
        using var client = new HttpClient();
        client.DefaultRequestHeaders.Add("Authorization", $"Bearer {ApiKey}");

        var payload = new
        {
            query = refreshQuery
        };

        var content = new StringContent(JsonSerializer.Serialize(payload), Encoding.UTF8, "application/json");

        var response = await client.PostAsync(BqlEndpoint, content);
        response.EnsureSuccessStatusCode();

        var responseBody = await response.Content.ReadAsStringAsync();
        using var doc = JsonDocument.Parse(responseBody);

        var endpoint = doc.RootElement.GetProperty("data")
                                      .GetProperty("reconnect")
                                      .GetProperty("BrowserQLEndpoint")
                                      .GetString();

        Console.WriteLine("New Reconnect URL: " + endpoint);
    }
}

```

### Full Example Code [â€‹](https://docs.browserless.io/browserql/session-management/reconnect-to-browserless\#full-example-code "Direct link to Full Example Code")

Here's a complete example demonstrating all steps together:

- Javascript
- Python
- Java
- C#

```codeBlockLines_p187
import fetch from 'node-fetch';

const API_KEY = "YOUR_API_TOKEN_HERE";
const BQL_ENDPOINT = "https://production-sfo.browserless.io/chromium/bql";

const sessionQuery = `
mutation StartSession {
  goto(url: "https://example.com", waitUntil: networkIdle) {
    status
  }
  reconnect(timeout: 60000) { # Keeps session open for 60 seconds
    BrowserQLEndpoint
  }
}`;

async function startSession() {
  const response = await fetch(BQL_ENDPOINT, {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      Authorization: `Bearer ${API_KEY}`,
    },
    body: JSON.stringify({ query: sessionQuery }),
  });

  const data = await response.json();
  console.log("Reconnect URL:", data.data.reconnect.BrowserQLEndpoint);
  return data.data.reconnect.BrowserQLEndpoint;
}

async function fetchData(reconnectUrl) {
  const scrapeQuery = `
mutation FetchData {
  text(selector: ".product-title") {
    text
  }
}`;

  const response = await fetch(reconnectUrl, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ query: scrapeQuery }),
  });

  const data = await response.json();
  console.log("Fetched Data:", data.data.text.text);
}

async function refreshSession() {
  const refreshQuery = `
mutation RefreshSession {
  reconnect(timeout: 60000) { # Extends session timeout
    BrowserQLEndpoint
  }
}`;
  const response = await fetch(BQL_ENDPOINT, {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      Authorization: `Bearer ${API_KEY}`,
    },
    body: JSON.stringify({ query: refreshQuery }),
  });

  const data = await response.json();
  console.log("New Reconnect URL:", data.data.reconnect.BrowserQLEndpoint);
  return data.data.reconnect.BrowserQLEndpoint;
}

(async () => {
  let reconnectUrl = await startSession();
  let pagesScraped = 0;
  const PAGE_LIMIT = 20;

  for (let i = 0; i < 100; i++) {
    if (pagesScraped >= PAGE_LIMIT) {
      reconnectUrl = await refreshSession();
      pagesScraped = 0;
    }

    const data = await fetchData(reconnectUrl);
    console.log(`Scraped Page ${i + 1}:`, data);
    pagesScraped++;
  }
})();

```

```codeBlockLines_p187
import requests

API_KEY = "YOUR_API_TOKEN_HERE"
BQL_ENDPOINT = "https://production-sfo.browserless.io/chromium/bql"

session_query = """
mutation StartSession {
  goto(url: "https://example.com", waitUntil: networkIdle) {
    status
  }
  reconnect(timeout: 60000) {
    BrowserQLEndpoint
  }
}
"""

refresh_query = """
mutation RefreshSession {
  reconnect(timeout: 60000) {
    BrowserQLEndpoint
  }
}
"""

scrape_query = """
mutation FetchData {
  text(selector: ".product-title") {
    text
  }
}
"""

def start_session():
    headers = {
        "Content-Type": "application/json",
        "Authorization": f"Bearer {API_KEY}"
    }
    response = requests.post(BQL_ENDPOINT, json={"query": session_query}, headers=headers)
    response.raise_for_status()
    endpoint = response.json()['data']['reconnect']['BrowserQLEndpoint']
    print("Reconnect URL:", endpoint)
    return endpoint

def refresh_session():
    headers = {
        "Content-Type": "application/json",
        "Authorization": f"Bearer {API_KEY}"
    }
    response = requests.post(BQL_ENDPOINT, json={"query": refresh_query}, headers=headers)
    response.raise_for_status()
    endpoint = response.json()['data']['reconnect']['BrowserQLEndpoint']
    print("New Reconnect URL:", endpoint)
    return endpoint

def fetch_data(reconnect_url):
    headers = {"Content-Type": "application/json"}
    response = requests.post(reconnect_url, json={"query": scrape_query}, headers=headers)
    response.raise_for_status()
    data = response.json()['data']['text']['text']
    print("Fetched Data:", data)
    return data

def main():
    reconnect_url = start_session()
    pages_scraped = 0
    PAGE_LIMIT = 20

    for i in range(100):
        if pages_scraped >= PAGE_LIMIT:
            reconnect_url = refresh_session()
            pages_scraped = 0

        data = fetch_data(reconnect_url)
        print(f"Scraped Page {i + 1}:", data)
        pages_scraped += 1

if __name__ == "__main__":
    main()

```

```codeBlockLines_p187
import java.net.URI;
import java.net.http.HttpClient;
import java.net.http.HttpRequest;
import java.net.http.HttpResponse;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;

public class BrowserlessScraper {

    static final String API_KEY = "YOUR_API_TOKEN_HERE";
    static final String BQL_ENDPOINT = "https://production-sfo.browserless.io/chromium/bql";
    static final ObjectMapper mapper = new ObjectMapper();
    static final HttpClient client = HttpClient.newHttpClient();

    static String executeQuery(String url, String query, boolean auth) throws Exception {
        String payload = mapper.writeValueAsString(new Query(query));
        var requestBuilder = HttpRequest.newBuilder()
            .uri(URI.create(url))
            .header("Content-Type", "application/json")
            .POST(HttpRequest.BodyPublishers.ofString(payload));

        if (auth) requestBuilder.header("Authorization", "Bearer " + API_KEY);

        var response = client.send(requestBuilder.build(), HttpResponse.BodyHandlers.ofString());
        return response.body();
    }

    static String startSession() throws Exception {
        String sessionQuery = """
        mutation StartSession {
          goto(url: "https://example.com", waitUntil: networkIdle) { status }
          reconnect(timeout: 60000) { BrowserQLEndpoint }
        }""";
        String json = executeQuery(BQL_ENDPOINT, sessionQuery, true);
        return mapper.readTree(json).path("data").path("reconnect").path("BrowserQLEndpoint").asText();
    }

    static String refreshSession() throws Exception {
        String refreshQuery = """
        mutation RefreshSession {
          reconnect(timeout: 60000) { BrowserQLEndpoint }
        }""";
        String json = executeQuery(BQL_ENDPOINT, refreshQuery, true);
        return mapper.readTree(json).path("data").path("reconnect").path("BrowserQLEndpoint").asText();
    }

    static String fetchData(String reconnectUrl) throws Exception {
        String scrapeQuery = """
        mutation FetchData {
          text(selector: ".product-title") { text }
        }""";
        String json = executeQuery(reconnectUrl, scrapeQuery, false);
        return mapper.readTree(json).path("data").path("text").path("text").asText();
    }

    public static void main(String[] args) throws Exception {
        String reconnectUrl = startSession();
        System.out.println("Reconnect URL: " + reconnectUrl);
        int pagesScraped = 0, PAGE_LIMIT = 20;

        for (int i = 0; i < 100; i++) {
            if (pagesScraped >= PAGE_LIMIT) {
                reconnectUrl = refreshSession();
                System.out.println("New Reconnect URL: " + reconnectUrl);
                pagesScraped = 0;
            }

            String data = fetchData(reconnectUrl);
            System.out.printf("Scraped Page %d: %s%n", i + 1, data);
            pagesScraped++;
        }
    }

    static class Query {
        public String query;
        Query(String q) { this.query = q; }
    }
}

```

```codeBlockLines_p187
using System;
using System.Net.Http;
using System.Text;
using System.Text.Json;
using System.Threading.Tasks;

class Program
{
    const string ApiKey = "YOUR_API_TOKEN_HERE";
    const string BqlEndpoint = "https://production-sfo.browserless.io/chromium/bql";

    const string sessionQuery = @"
    mutation StartSession {
      goto(url: ""https://example.com"", waitUntil: networkIdle) { status }
      reconnect(timeout: 60000) { BrowserQLEndpoint }
    }";

    const string refreshQuery = @"
    mutation RefreshSession {
      reconnect(timeout: 60000) { BrowserQLEndpoint }
    }";

    const string scrapeQuery = @"
    mutation FetchData {
      text(selector: "".product-title"") { text }
    }";

    static async Task<string> ExecuteQuery(string url, string query, bool auth)
    {
        using var client = new HttpClient();
        if (auth) client.DefaultRequestHeaders.Add("Authorization", $"Bearer {ApiKey}");

        var content = new StringContent(JsonSerializer.Serialize(new { query }), Encoding.UTF8, "application/json");
        var response = await client.PostAsync(url, content);
        response.EnsureSuccessStatusCode();

        var json = await response.Content.ReadAsStringAsync();
        return json;
    }

    static async Task Main()
    {
        var jsonDoc = JsonDocument.Parse(await ExecuteQuery(BqlEndpoint, sessionQuery, true));
        var reconnectUrl = jsonDoc.RootElement.GetProperty("data").GetProperty("reconnect").GetProperty("BrowserQLEndpoint").GetString();
        Console.WriteLine("Reconnect URL: " + reconnectUrl);

        int pagesScraped = 0, PAGE_LIMIT = 20;

        for (int i = 0; i < 100; i++)
        {
            if (pagesScraped >= PAGE_LIMIT)
            {
                jsonDoc = JsonDocument.Parse(await ExecuteQuery(BqlEndpoint, refreshQuery, true));
                reconnectUrl = jsonDoc.RootElement.GetProperty("data").GetProperty("reconnect").GetProperty("BrowserQLEndpoint").GetString();
                Console.WriteLine("New Reconnect URL: " + reconnectUrl);
                pagesScraped = 0;
            }

            jsonDoc = JsonDocument.Parse(await ExecuteQuery(reconnectUrl, scrapeQuery, false));
            var data = jsonDoc.RootElement.GetProperty("data").GetProperty("text").GetProperty("text").GetString();
            Console.WriteLine($"Scraped Page {i + 1}: {data}");
            pagesScraped++;
        }
    }
}

```

## Improving Efficiency with BrowserQL's Reject API [â€‹](https://docs.browserless.io/browserql/session-management/reconnect-to-browserless\#improving-efficiency-with-browserqls-reject-api "Direct link to Improving Efficiency with BrowserQL's Reject API")

BrowserQL also lets you reject unnecessary requests (e.g., images, media) to optimize resource usage:

```codeBlockLines_p187
mutation OptimizeSession {
  setRequestInterception(enabled: true)
  reject(patterns: ["*.png", "*.jpg", "*.mp4"])
}

```

Use this to further streamline your scraping tasks.

## Common Issues [â€‹](https://docs.browserless.io/browserql/session-management/reconnect-to-browserless\#common-issues "Direct link to Common Issues")

### CAPTCHA Challenges [â€‹](https://docs.browserless.io/browserql/session-management/reconnect-to-browserless\#captcha-challenges "Direct link to CAPTCHA Challenges")

If you encounter CAPTCHAs, ensure your session maintains human-like interaction patterns by reducing request rates and maintaining stable sessions.

### Session Timeouts [â€‹](https://docs.browserless.io/browserql/session-management/reconnect-to-browserless\#session-timeouts "Direct link to Session Timeouts")

Set appropriate timeout values to ensure sessions remain active without resource leaks:

```codeBlockLines_p187
reconnect(timeout: 120000)

```

- [Implementing Reconnects with BrowserQL](https://docs.browserless.io/browserql/session-management/reconnect-to-browserless#implementing-reconnects-with-browserql)
  - [Step 1: Initial Setup](https://docs.browserless.io/browserql/session-management/reconnect-to-browserless#step-1-initial-setup)
  - [Step 2: Using the Reconnect URL](https://docs.browserless.io/browserql/session-management/reconnect-to-browserless#step-2-using-the-reconnect-url)
  - [Step 3: Refreshing Your Session](https://docs.browserless.io/browserql/session-management/reconnect-to-browserless#step-3-refreshing-your-session)
  - [Full Example Code](https://docs.browserless.io/browserql/session-management/reconnect-to-browserless#full-example-code)
- [Improving Efficiency with BrowserQL's Reject API](https://docs.browserless.io/browserql/session-management/reconnect-to-browserless#improving-efficiency-with-browserqls-reject-api)
- [Common Issues](https://docs.browserless.io/browserql/session-management/reconnect-to-browserless#common-issues)
  - [CAPTCHA Challenges](https://docs.browserless.io/browserql/session-management/reconnect-to-browserless#captcha-challenges)
  - [Session Timeouts](https://docs.browserless.io/browserql/session-management/reconnect-to-browserless#session-timeouts)

---

### BrowserQL | Browserless.io
Original URL: https://docs.browserless.io/browserql/start

[Skip to main content](https://docs.browserless.io/browserql/start#__docusaurus_skipToContent_fallback)


Browserless is a cloud-based service for running headless browsers at scale, and **BrowserQL** is our first-class browser automation API, and includes powerful options like human-like, reconnecting and proxying. It's a full rethink of how to do browser automation with a minimalistic stealth-first approach. It combines many decades of development and research, and includes a fully-featured editor, with a live view of the session, and built-in docs. No more context switching!

## What is BrowserQL? [â€‹](https://docs.browserless.io/browserql/start\#what-is-browserql "Direct link to What is BrowserQL?")

**BrowserQL** (BQL) is a GraphQL-based API for browser automation. BQL is a first-class, stealth-focused solution ideal for bypassing CAPTCHAs and bot detectors. It comes with a fully-featured web IDE and uses a minimalistic, scriptable query language instead of traditional code.

BQL redefines how browser automation is done. Instead of traditional code, BQL uses a minimal, scriptable query language thatâ€™s purpose-built for human-like automation. Itâ€™s tightly integrated with a powerful web-based IDE that includes:

- A live session preview.
- Built-in documentation.
- No installation or CLI required.
- Zero context switching.

This makes it ideal for developers and automation engineers who want to move fast without sacrificing control or stealth.

## Why Use BrowserQL? [â€‹](https://docs.browserless.io/browserql/start\#why-use-browserql "Direct link to Why Use BrowserQL?")

BrowserQL is the **best solution** when you need to:

- Bypass **advanced bot detection systems**.
- Automate **CAPTCHA-solving flows**.
- Mimic **human-like interactions** reliably.
- Build **stealth-first automations** at scale.

With decades of research and development behind it, BrowserQL is a production-grade solution designed to succeed where traditional browser automation fails.

## Getting Started [â€‹](https://docs.browserless.io/browserql/start\#getting-started "Direct link to Getting Started")

To begin using BQL:

1. [Sign up for a Browserless account](https://account.browserless.io/signup/email?plan=free) (free plan available).
2. Get your **API Key**.
3. Access the BQL web editor: [https://account.browserless.io/bql](https://account.browserless.io/bql).

Everything is accessible via your account dashboardâ€”no installations required.

Requirements

BrowserQL does not require any CLI tools, local runtime, or libraries. All you need is a Browserless account to access the cloud editor and generate your API key.

## Global Endpoints [â€‹](https://docs.browserless.io/browserql/start\#global-endpoints "Direct link to Global Endpoints")

Browserless operates multiple regional endpoints for low-latency access. The primary shared clusters are in US West (SFO), EU West (London), and EU Central (Amsterdam) ( [Load Balancers](https://docs.browserless.io/baas/load-balancers)). For example:

- `https://production-sfo.browserless.io` â€“ San Francisco, USA (default US endpoint)
- `https://production-lon.browserless.io` â€“ London, UK (European endpoint)
- `https://production-ams.browserless.io` â€“ Amsterdam, NL (another EU endpoint)

You can use the endpoint closest to your servers or users. All endpoints offer the same API and require your token.

## Next Steps [â€‹](https://docs.browserless.io/browserql/start\#next-steps "Direct link to Next Steps")

Before exploring all BQL has to offer, learn more about connecting and building an URL for your needs, and all launch parameters available:

- [Connection URLs and Endpoints](https://docs.browserless.io/browserql/connection-urls)
- [Launch Parameters and Options](https://docs.browserless.io/browserql/launch-parameters)

Want to explore more?

If you already have an automation library that works over WebSockets, you can mix-and-match BrowserQL with the library of your choice. To learn how to integrate BQL, check the guides below:

- [Connecting with Puppeteer](https://docs.browserless.io/browserql/connecting-libraries/puppeteer)
- [Connecting with Playwright](https://docs.browserless.io/browserql/connecting-libraries/playwright)

There's a lot more to BQL than just this. Our Editor comes with built-in documentation, a live Viewer and Devtools to get you started. Refer to the following pages to learn more about BQL:

- [Acessing Pages with Bot Detection](https://docs.browserless.io/browserql/bot-detection/accessing-pages)
- [Writing BQL Queries](https://docs.browserless.io/browserql/writing-bql/language-basics)
- [Mutation Reference](https://docs.browserless.io/bql-schema/schema)
- [Using the IDE](https://docs.browserless.io/browserql/using-the-ide/ide-features)

- [What is BrowserQL?](https://docs.browserless.io/browserql/start#what-is-browserql)
- [Why Use BrowserQL?](https://docs.browserless.io/browserql/start#why-use-browserql)
- [Getting Started](https://docs.browserless.io/browserql/start#getting-started)
- [Global Endpoints](https://docs.browserless.io/browserql/start#global-endpoints)
- [Next Steps](https://docs.browserless.io/browserql/start#next-steps)

---

### troubleshooting-scripts | Browserless.io
Original URL: https://docs.browserless.io/browserql/using%20the%20ide/troubleshooting-scripts

[Skip to main content](https://docs.browserless.io/browserql/using%20the%20ide/troubleshooting-scripts#__docusaurus_skipToContent_fallback)

---

### IDE Features | Browserless.io
Original URL: https://docs.browserless.io/browserql/using-the-ide/ide-features

[Skip to main content](https://docs.browserless.io/browserql/using-the-ide/ide-features#__docusaurus_skipToContent_fallback)


BrowserQL Editor has a few features to help you throughout your work. From built-in documentation and history tracker, to exporting your queries into a number of coding languages.

## Global Settings [â€‹](https://docs.browserless.io/browserql/using-the-ide/ide-features\#global-settings "Direct link to Global Settings")

In the Global Settings tab, you can define the following settings:

- **BrowserQL Endpoint**: Choose between one of the available BQL Endpoints.
- **API Token**: Your API token goes here. This value is required to successfully execute your queries.
- **Persist Headers**: Choose whether to save headers upon reloading. _We recommend only to enable this option if you trust the device_.
- **Show Results**: Choose between automatically show the results after executing a query or not.
- **Theme**: Adjust how the interface looks like, between light or darkmode.
- **Wait before close**: Define the amount of time to wait before closing the connection. This can help when waiting for interactions is necessary for example. Choose between waiting `10s`, `30s`, `60s` or `5m`.
- **Clear storage**: Remove all locally stored data and start fresh.

## Built-in Documentation [â€‹](https://docs.browserless.io/browserql/using-the-ide/ide-features\#built-in-documentation "Direct link to Built-in Documentation")

BrowserQL Editor comes with a complete documentation of all available mutations, responses and schemas you can use when creating your queries. You can access it in the top-left corner of the IDE window.Navigate through mutations and schemas by clicking in each one, and use the search input at the top to find the desired information.

Your browser does not support the video tag.

Example code

Each mutation in the Built-in Documentation presents a working example code to show you how the mutation works. Copy it, and try the query out to see what each BQL mutation can do.

## Query as Code [â€‹](https://docs.browserless.io/browserql/using-the-ide/ide-features\#query-as-code "Direct link to Query as Code")

The **Export Query as Code** feature helps you to turn any of your queries into a number of available coding languages. You can open this option in the sidebar to the side of the code tab, as presented below, or with the `Shift+Ctrl+E` shortcut.

![](https://docs.browserless.io/img/browserql/ide-query-code.png)

The list below shows the available languages you can export your queries:

![cURL logo](https://curl.se/logo/curl-symbol.svg)cURL

![JS (fetch) logo](https://upload.wikimedia.org/wikipedia/commons/6/6a/JavaScript-logo.png)JS (fetch)

![JS (axios) logo](https://upload.wikimedia.org/wikipedia/commons/6/6a/JavaScript-logo.png)JS (axios)

![Python logo](https://upload.wikimedia.org/wikipedia/commons/c/c3/Python-logo-notext.svg)Python

![Go logo](https://upload.wikimedia.org/wikipedia/commons/0/05/Go_Logo_Blue.svg)Go

![Java logo](https://upload.wikimedia.org/wikipedia/en/3/30/Java_programming_language_logo.svg)Java

![PHP logo](https://upload.wikimedia.org/wikipedia/commons/2/27/PHP-logo.svg)PHP

![Ruby logo](https://upload.wikimedia.org/wikipedia/commons/7/73/Ruby_logo.svg)Ruby

BrowserQL API

Find more about exporting your query and [calling the BrowserQL API](https://docs.browserless.io/browserql/using-the-ide/using-api-calls).

## History [â€‹](https://docs.browserless.io/browserql/using-the-ide/ide-features\#history "Direct link to History")

Right below the documentation, there is a history of every query you executed. Open it by clicking it, and you can retrieve any query you created. You can also save as favorite, and rename a query in the history tab.

![](https://docs.browserless.io/img/browserql/ide-history.png)

## Short Keys [â€‹](https://docs.browserless.io/browserql/using-the-ide/ide-features\#short-keys "Direct link to Short Keys")

The Editor also has a list of short keys to make your life easier when creating queries. You can see the available short keys by opening the Short Keys tab. The image below also shows them:

![](https://docs.browserless.io/img/browserql/short-keys.png)

- [Global Settings](https://docs.browserless.io/browserql/using-the-ide/ide-features#global-settings)
- [Built-in Documentation](https://docs.browserless.io/browserql/using-the-ide/ide-features#built-in-documentation)
- [Query as Code](https://docs.browserless.io/browserql/using-the-ide/ide-features#query-as-code)
- [History](https://docs.browserless.io/browserql/using-the-ide/ide-features#history)
- [Short Keys](https://docs.browserless.io/browserql/using-the-ide/ide-features#short-keys)

---

### Session Settings | Browserless.io
Original URL: https://docs.browserless.io/browserql/using-the-ide/session-settings

[Skip to main content](https://docs.browserless.io/browserql/using-the-ide/session-settings#__docusaurus_skipToContent_fallback)


BrowserQL Editor allows you to have multiple sessions, each with their own particular configurations. For example, you can have a first section running on chrome, with human-like behavior active, while the second one runs on chromium, without human-like behavior, and with a proxy.

## Configuring Session Settings [â€‹](https://docs.browserless.io/browserql/using-the-ide/session-settings\#configuring-session-settings "Direct link to Configuring Session Settings")

Session Settings allows you to configure the following for each individual tab in the editor:

- **Browser**: Choose which browser the session will use. Either Chromium or Chrome.
- **Human-like Behavior**: Select whether the automation should imitate human behavior, including smooth mouse movements and typing patterns that resemble those of a person.
- **Adblock**: Toggle adblock on/off in the session. Useful for accessing websites cluttered with intrusive ads, improving page readability, reducing distractions, and speeding up data scraping workflows.
- **Residential Proxy**: Route the browser's requests through a residential proxy network. This enhances anonymity and mimics real user traffic, making it ideal for accessing geographically restricted content or bypassing anti-bot measures. _Note that this will significantly increase unit consumption_. Refer to the [Using a Proxy](https://docs.browserless.io/browserql/bot-detection/proxies) guide for more details.

Below shows how to configure different session settings, where:

### First Session

- **Browser**: `Chrome`
- **Human-like Behavior**: `On`
- **Adblock**: `On`
- **Residential Proxy**: `Off`

### Second Session

- **Browser**: `Chromium`
- **Human-like Behavior**: `Off`
- **Adblock**: `Off`
- **Residential Proxy**: `On`

Your browser does not support the video tag.

- [Configuring Session Settings](https://docs.browserless.io/browserql/using-the-ide/session-settings#configuring-session-settings)

---

### Calling the BrowserQL API | Browserless.io
Original URL: https://docs.browserless.io/browserql/using-the-ide/using-api-calls

[Skip to main content](https://docs.browserless.io/browserql/using-the-ide/using-api-calls#__docusaurus_skipToContent_fallback)

Once you have set up your query, you can **export it** to be called via an API.

1. Click the **Export as Code** button.
2. Choose your preferred **language**.

The export will include the **endpoint, token, headers, and payload**.

![](https://docs.browserless.io/img/doc/01-scraping/scraping-2.png)

Of course, you might need multiple API calls for a scraping session, such as one to crawl the search results then a second to grab the details from each page.

- Javascript
- Python
- Java

```codeBlockLines_p187
const { JSDOM } = require("jsdom");

async function ExtractJobsHTML() {
    const url = "https://production-sfo.browserless.io/chromium/bql?token=YOUR_API_TOKEN_HERE";
    const options = {
      method: 'POST',
      body: '{"query":"mutation ExtractJobsHTML {\n  goto(url: \"https://news.ycombinator.com\", waitUntil: firstMeaningfulPaint) {\n    status\n  }\n  \n  click(selector: \"span.pagetop > a[href=\'jobs\']\") {\n    x\n    y\n  }\n  \n  html {\n    html\n  }\n}","variables":null,"operationName":"ExtractJobsHTML"}'
    };

    let response;

    try {
      response = await fetch(url, options);
    } catch (error) {
      console.error(error);
    }

    const json = await response.json();
    const html = json.data.html.html;

    const dom = new JSDOM(html);
    const document = dom.window.document;
    const rows = document.querySelectorAll("tr.athing");

    const titlesAndLinks = [];
    rows.forEach((row) => {
        const anchor = row.querySelector("a");
        if (anchor) {
            titlesAndLinks.push({
                title: anchor.textContent.trim(),
                link: anchor.href.trim(),
            });
        }
    });

    console.log(titlesAndLinks);
}

ExtractJobsHTML();

```

```codeBlockLines_p187
import http.client
from bs4 import BeautifulSoup
import json

conn = http.client.HTTPSConnection("production-sfo.browserless.io")

payload = '{"query":"mutation ExtractJobsHTML {\\n  goto(url: \\"https://news.ycombinator.com\\", waitUntil: firstMeaningfulPaint) {\\n    status\\n  }\\n  \\n  click(selector: \\"span.pagetop > a[href=\'jobs\']\\") {\\n    x\\n    y\\n  }\\n  \\n  html {\\n    html\\n  }\\n}","variables":null,"operationName":"ExtractJobsHTML"}'

headers = {"Content-Type": "application/json"}

conn.request(
    "POST",
    "/chromium/bql?token=YOUR_API_TOKEN_HERE",
    payload,
    headers,
)

res = conn.getresponse()
response = res.read()

response_json = json.loads(response.decode("utf-8"))

html = response_json["data"]["html"]["html"]

soup = BeautifulSoup(html, "html.parser")

titles_and_links = []

for job in soup.find_all("tr", class_="athing"):
    title_tag = job.find("a")
    if title_tag:
        titles_and_links.append(
            {"title": title_tag.text.strip(), "link": title_tag["href"].strip()}
        )

print(titles_and_links)

```

```codeBlockLines_p187
import com.mashape.unirest.http.HttpResponse;
import com.mashape.unirest.http.Unirest;
import org.jsoup.Jsoup;
import org.jsoup.nodes.Document;
import org.jsoup.nodes.Element;
import org.jsoup.select.Elements;
import com.google.gson.JsonObject;
import com.google.gson.JsonParser;

public class ExtractJobsHTML {
    public static void main(String[] args) throws Exception {
        HttpResponse<String> response = Unirest.post("https://production-sfo.browserless.io/chromium/bql?token=YOUR_API_TOKEN_HERE")
            .body("{\"query\":\"mutation ExtractJobsHTML {\\n  goto(url: \\\"https://news.ycombinator.com\\\", waitUntil: firstMeaningfulPaint) {\\n    status\\n  }\\n  \\n  click(selector: \\\"span.pagetop > a[href='jobs']\\\") {\\n    x\\n    y\\n  }\\n  \\n  html {\\n    html\\n  }\\n}\",\"variables\":null,\"operationName\":\"ExtractJobsHTML\"}")
            .asString();

        // Parse JSON response
        JsonObject jsonResponse = JsonParser.parseString(response.getBody()).getAsJsonObject();
        String html = jsonResponse.getAsJsonObject("data").getAsJsonObject("html").get("html").getAsString();

        // Parse HTML with Jsoup
        Document doc = Jsoup.parse(html);
        Elements jobs = doc.select("tr.athing");

        for (Element job : jobs) {
            Element titleTag = job.selectFirst("a");
            if (titleTag != null) {
                System.out.println("Title: " + titleTag.text());
                System.out.println("Link: " + titleTag.attr("href"));
            }
        }
    }
}

```

---

### Your First Query | Browserless.io
Original URL: https://docs.browserless.io/browserql/writing-bql

[Skip to main content](https://docs.browserless.io/browserql/writing-bql#__docusaurus_skipToContent_fallback)


BrowserQL is purely a _GraphQL_ server under the hood. This means that all of the same concepts apply to BQL that typically apply to GraphQL. Since BQL uses GraphQL as a protocol, all of the things you wish to control the browser are called _Mutations_. Here's an example first query with that in mind:

```codeBlockLines_p187
mutation ScrapeHN {
  goto(url: "https://news.ycombinator.com", waitUntil: firstMeaningfulPaint) {
    status
    time
  }
  firstHeadline: text(selector: ".titleline") {
    text
  }
}

```

Breaking this down, we're:

- Defining we want to run a `mutation` and naming our script as ScrapeHN.
- Instructing a browser to `goto` the Hacker News site, and wait for the `firstMeaningfulPaint` event to fire.
- Asking to return both the time it took and the HTTP-code's `status` once the `waitUntil` has fired.
- Giving our action an alias, in this case firstHeadline.
- Extracting the text of a specified selector.

**Click Run in the [IDE](https://account.browserless.io/bql/) to execute this mutation.**

The result will return be a JSON response that matches our query, a core part of how GraphQL works:

```codeBlockLines_p187
{
  "data": {
    "goto": {
      "status": 200,
      "time": 222
    },
    "text": {
      "text": "Hacker News new | past | comments | ask | show | jobs | submitlogin..."
    }
  }
}

```

## Exporting Your Query [â€‹](https://docs.browserless.io/browserql/writing-bql\#exporting-your-query "Direct link to Exporting Your Query")

BrowserQL can be exported and run programmatically just like with any other kind of GraphQL server. You can export queries via two means:

**1\. Clicking the Export Query as Code button**: This option will open a tab with multiple available code languages you can select and copy the code. For more details on this feature, refer to the [Query as Code](https://docs.browserless.io/browserql/using-the-ide/ide-features#query-as-code) section of the documentation.

Keep your Token Safe

The codes copied with the Export Query as Code feature will include headers, variables and API tokens in it.
Be careful not to share your private information in public places like Github, Bitbucket, etc. This opens space for malicious API calls.

**2\. Selecting and copying the query**: Similar to other IDEs, you can select an entire query and copy it to paste wherever necessary. This is helpful if you want to store queries in a `.gql` file for further processing or fetching. Be sure to consult your library's documentation when using this approach.

note

This method does _**not**_ copy any associated variables, headers, or API tokens, so make sure to apply those correctly before executing your query.

- [Exporting Your Query](https://docs.browserless.io/browserql/writing-bql#exporting-your-query)

---

### Exporting Scripts | Browserless.io
Original URL: https://docs.browserless.io/browserql/writing-bql/exporting-scripts

[Skip to main content](https://docs.browserless.io/browserql/writing-bql/exporting-scripts#__docusaurus_skipToContent_fallback)


BrowserQL IDE allows you to export any of your queries into different languages. This feature makes your life easier when integrating our functionalities into your scraping application. This allows you to try and test your queries in our IDE, and quickly move a working one into your code.

## Example [â€‹](https://docs.browserless.io/browserql/writing-bql/exporting-scripts\#example "Direct link to Example")

In this example, the BQL query will navigate to [https://news.ycombinator.com/](https://news.ycombinator.com/), click on the Jobs tab, and extract the HTML from the page:

- BQL Query
- Export Query as Code

```codeBlockLines_p187
mutation ExtractJobsHTML {
  goto(url: "https://news.ycombinator.com", waitUntil: firstMeaningfulPaint) {
    status
  }

  click(selector: "span.pagetop > a[href='jobs']") {
    x
    y
  }

  html {
    html
  }
}

```

- Javascript
- Python
- Java

```codeBlockLines_p187
const url = 'https://production-sfo.browserless.io/chromium/bql?token=YOUR_API_TOKEN_HERE';
const options = {
  method: 'POST',
  body: '{"query":"mutation ExtractJobsHTML {\n  goto(url: \"https://news.ycombinator.com\", waitUntil: firstMeaningfulPaint) {\n    status\n  }\n  \n  click(selector: \"span.pagetop > a[href=\'jobs\']\") {\n    x\n    y\n  }\n  \n  html {\n    html\n  }\n}","variables":null,"operationName":"ExtractJobsHTML"}'
};

try {
  const response = await fetch(url, options);
  const data = await response.json();
  console.log(data);
} catch (error) {
  console.error(error);
}

```

```codeBlockLines_p187
import http.client

conn = http.client.HTTPSConnection("production-sfo.browserless.io")

payload = "{\"query\":\"mutation ExtractJobsHTML {\\n  goto(url: \\\"https://news.ycombinator.com\\\", waitUntil: firstMeaningfulPaint) {\\n    status\\n  }\\n  \\n  click(selector: \\\"span.pagetop > a[href='jobs']\\\") {\\n    x\\n    y\\n  }\\n  \\n  html {\\n    html\\n  }\\n}\",\"variables\":null,\"operationName\":\"ExtractJobsHTML\"}"

conn.request("POST", "/chromium/bql?token=YOUR_API_TOKEN_HERE", payload)

res = conn.getresponse()
data = res.read()

print(data.decode("utf-8"))

```

```codeBlockLines_p187
HttpResponse<String> response = Unirest.post("https://production-sfo.browserless.io/chromium/bql?token=YOUR_API_TOKEN_HERE")
.body("{\"query\":\"mutation ExtractJobsHTML {\\n  goto(url: \\\"https://news.ycombinator.com\\\", waitUntil: firstMeaningfulPaint) {\\n    status\\n  }\\n  \\n  click(selector: \\\"span.pagetop > a[href='jobs']\\\") {\\n    x\\n    y\\n  }\\n  \\n  html {\\n    html\\n  }\\n}\",\"variables\":null,\"operationName\":\"ExtractJobsHTML\"}")
.asString();

```

Now, using BrowserQL Editor to export this script in your preferred coding language to integrate it with a application that reads the HTML and extracts the title and link from it, creating an array with this information.

BrowserQL API

Find out how to export your queries and integrate it in your code by [calling the BrowserQL API](https://docs.browserless.io/browserql/using-the-ide/using-api-calls).

- Javascript
- Python
- Java

```codeBlockLines_p187
const { JSDOM } = require("jsdom");

async function ExtractJobsHTML() {
    const url = "https://production-sfo.browserless.io/chromium/bql?token=YOUR_API_TOKEN_HERE";
    const options = {
      method: 'POST',
      body: '{"query":"mutation ExtractJobsHTML {\n  goto(url: \"https://news.ycombinator.com\", waitUntil: firstMeaningfulPaint) {\n    status\n  }\n  \n  click(selector: \"span.pagetop > a[href=\'jobs\']\") {\n    x\n    y\n  }\n  \n  html {\n    html\n  }\n}","variables":null,"operationName":"ExtractJobsHTML"}'
    };

    let response;

    try {
      response = await fetch(url, options);
    } catch (error) {
      console.error(error);
    }

    const json = await response.json();
    const html = json.data.html.html;

    const dom = new JSDOM(html);
    const document = dom.window.document;
    const rows = document.querySelectorAll("tr.athing");

    const titlesAndLinks = [];
    rows.forEach((row) => {
        const anchor = row.querySelector("a");
        if (anchor) {
            titlesAndLinks.push({
                title: anchor.textContent.trim(),
                link: anchor.href.trim(),
            });
        }
    });

    console.log(titlesAndLinks);
}

ExtractJobsHTML();

```

```codeBlockLines_p187
import http.client
from bs4 import BeautifulSoup
import json

conn = http.client.HTTPSConnection("production-sfo.browserless.io")

payload = '{"query":"mutation ExtractJobsHTML {\\n  goto(url: \\"https://news.ycombinator.com\\", waitUntil: firstMeaningfulPaint) {\\n    status\\n  }\\n  \\n  click(selector: \\"span.pagetop > a[href=\'jobs\']\\") {\\n    x\\n    y\\n  }\\n  \\n  html {\\n    html\\n  }\\n}","variables":null,"operationName":"ExtractJobsHTML"}'

headers = {"Content-Type": "application/json"}

conn.request(
    "POST",
    "/chromium/bql?token=YOUR_API_TOKEN_HERE",
    payload,
    headers,
)

res = conn.getresponse()
response = res.read()

response_json = json.loads(response.decode("utf-8"))

html = response_json["data"]["html"]["html"]

soup = BeautifulSoup(html, "html.parser")

titles_and_links = []

for job in soup.find_all("tr", class_="athing"):
    title_tag = job.find("a")
    if title_tag:
        titles_and_links.append(
            {"title": title_tag.text.strip(), "link": title_tag["href"].strip()}
        )

print(titles_and_links)

```

```codeBlockLines_p187
import com.mashape.unirest.http.HttpResponse;
import com.mashape.unirest.http.Unirest;
import org.jsoup.Jsoup;
import org.jsoup.nodes.Document;
import org.jsoup.nodes.Element;
import org.jsoup.select.Elements;
import com.google.gson.JsonObject;
import com.google.gson.JsonParser;

public class ExtractJobsHTML {
    public static void main(String[] args) throws Exception {
        HttpResponse<String> response = Unirest.post("https://production-sfo.browserless.io/chromium/bql?token=YOUR_API_TOKEN_HERE")
            .body("{\"query\":\"mutation ExtractJobsHTML {\\n  goto(url: \\\"https://news.ycombinator.com\\\", waitUntil: firstMeaningfulPaint) {\\n    status\\n  }\\n  \\n  click(selector: \\\"span.pagetop > a[href='jobs']\\\") {\\n    x\\n    y\\n  }\\n  \\n  html {\\n    html\\n  }\\n}\",\"variables\":null,\"operationName\":\"ExtractJobsHTML\"}")
            .asString();

        // Parse JSON response
        JsonObject jsonResponse = JsonParser.parseString(response.getBody()).getAsJsonObject();
        String html = jsonResponse.getAsJsonObject("data").getAsJsonObject("html").get("html").getAsString();

        // Parse HTML with Jsoup
        Document doc = Jsoup.parse(html);
        Elements jobs = doc.select("tr.athing");

        for (Element job : jobs) {
            Element titleTag = job.selectFirst("a");
            if (titleTag != null) {
                System.out.println("Title: " + titleTag.text());
                System.out.println("Link: " + titleTag.attr("href"));
            }
        }
    }
}

```

- [Example](https://docs.browserless.io/browserql/writing-bql/exporting-scripts#example)

---

### Language Basics | Browserless.io
Original URL: https://docs.browserless.io/browserql/writing-bql/language-basics

[Skip to main content](https://docs.browserless.io/browserql/writing-bql/language-basics#__docusaurus_skipToContent_fallback)


Learning a new language can be intimidating, but mastering BQL doesn't have to be difficult. This guide provides a straightforward overview of how to write BQL with a clear.

## What You Won't Write [â€‹](https://docs.browserless.io/browserql/writing-bql/language-basics\#what-you-wont-write "Direct link to What You Won't Write")

BrowserQL is optimized for web automation and scraping, designed to minimize complexity by making intelligent assumptions. Hereâ€™s what it does **for you**:

- **Waits for selectors** before interacting with elements.
- Handles **mouse movements** and clicks automatically.
- Ensures **elements are visible** by scrolling as needed.
- Manages **page-load events**, like waiting for `firstContentfulPaint`.

Instead of worrying about these technical details, you focus on **queries and actions**.

## What Youâ€™ll Write [â€‹](https://docs.browserless.io/browserql/writing-bql/language-basics\#what-youll-write "Direct link to What Youâ€™ll Write")

BQL is a query language where you:

1. Navigate to pages.
2. Perform actions (e.g., click, type).
3. Extract data (e.g., text, HTML).

With just a handful of commands ( [`goto`](https://docs.browserless.io/bql-schema/operations/mutations/goto), [`text`](https://docs.browserless.io/bql-schema/operations/mutations/text), [`html`](https://docs.browserless.io/bql-schema/operations/mutations/html), [`click`](https://docs.browserless.io/bql-schema/operations/mutations/click), [`type`](https://docs.browserless.io/bql-schema/operations/mutations/type) and [more](https://docs.browserless.io/bql-schema/operations/mutations)), you can achieve complex automation in a fraction of the usual code.

For example, the script below demonstrates how easy it is to automate a logging into Cloudflare in 30 lines:

```codeBlockLines_p187
mutation Cloudflare {
  goto(
    url: "https://dash.cloudflare.com/login?lang=en-gb"
    waitUntil: firstContentfulPaint
  ) {
    status
  }

  acceptCookies: click(
    selector: "#onetrust-accept-btn-handler"
  ) {
    time
  }

  typeEmail: type(
    selector: "form [data-testid='login-input-email']"
    text: "test@browserless.io"
  ) {
    selector
  }

  typePassword: type(
    selector: "form [data-testid='login-input-password']"
    text: "super-cool-password"
  ) {
    selector
  }

  clickCaptcha: verify(
    type: cloudflare
  ) {
    solved
  }
}

```

## Creating a BQL Script [â€‹](https://docs.browserless.io/browserql/writing-bql/language-basics\#creating-a-bql-script "Direct link to Creating a BQL Script")

Below are steps into creating a BQL script, guiding you into navigating to a page, retrieving data, performing actions, and, finally, generating an endpoint to connect to external libraries.

### Navigating to a Page [â€‹](https://docs.browserless.io/browserql/writing-bql/language-basics\#navigating-to-a-page "Direct link to Navigating to a Page")

Every script starts with a **mutation**, specifying actions and the responses you expect:

```codeBlockLines_p187
mutation ExampleName {
  goto(
    url: "https://example.com"
    waitUntil: firstMeaningfulPaint
  ) {
    status
    time
  }
}

```

This standard format is composed of the following:

1. **Action**: `goto` specifies the page to navigate to.
2. **Arguments**: Provide the `url` and a `waitUntil` condition.
3. **Response**: Request useful outputs, like `status` or `time`.

Mutations

You can find detailed information on all mutations, their arguments, and responses in the [Mutations Reference page](https://docs.browserless.io/bql-schema/schema) and also in the [Built-in Documentation](https://docs.browserless.io/browserql/using-the-ide/ide-features#built-in-documentation) in our IDE.

### Retrieving Data [â€‹](https://docs.browserless.io/browserql/writing-bql/language-basics\#retrieving-data "Direct link to Retrieving Data")

Extracting information is just as simple. Use `text` or `html` commands depending on the format you need:

- Text
- HTML

```codeBlockLines_p187
mutation ExampleName {
  ...
  productName: text(
    selector: "span#productTitle"
    visible: true
  ) {
    text
  }
}

```

Where:

- **Alias**: `productName` is the name for this interaction. You can define names for each interaction in the script.
- **Action**: `text` extracts visible text.
- **Arguments**: Include a `selector` and optional conditions like `visible`.
- **Output**: The desired response (e.g., text content).

Example JSON response:

```codeBlockLines_p187
"productName": {
  "text": "Coffee and Espresso Maker"
}

```

Pro Tip

Omit the `selector` to retrieve the entire pageâ€™s content.

```codeBlockLines_p187
mutation ExampleName {
  ...
  elementHTML: html(
    selector: "div"
    visible: true
  ) {
    html
  }
}

```

Where:

- **Alias**: `elementHTML` is the name for this interaction. You can define names for each interaction in the script.
- **Action**: `html` extracts the element's HTML content.
- **Arguments**: Include a `selector` and optional conditions like `visible`.
- **Output**: The desired response (e.g., html content).

Example JSON response:

```codeBlockLines_p187
"productName": {
  "html": "\n    <h1 xmlns=\"http://www.w3.org/1999/xhtml\">Example Domain</h1>\n    <p xmlns=\"http://www.w3.org/1999/xhtml\">This domain is for use in illustrative examples in documents. You may use this\n    domain in literature without prior coordination or asking for permission.</p>\n    <p xmlns=\"http://www.w3.org/1999/xhtml\"><a href=\"https://www.iana.org/domains/example\">More information...</a></p>\n"
}

```

Pro Tip

Omit the `selector` to retrieve the entire pageâ€™s html content.

### Performing Actions [â€‹](https://docs.browserless.io/browserql/writing-bql/language-basics\#performing-actions "Direct link to Performing Actions")

Many cases for gathering data or normalizing data across systems require you click, type and submit forms. All of these are staples of any web automation library and are supported by BrowserQL.

By default, BrowserQL takes care of waiting for these elements to be present in the document, visible to an end user, and scrolls to them in the viewport. You won't have to worry about writing code to handle those small nuanced situations.

- Clicking a Button
- Keyboard Typing
- HTML Content
- Retrieving Text

To click the **Free Trial** link at the Browserless.io website, you need to navigate to the website with the `goto` mutation, and then use the `click` to select the `<a>` element. In the example below, we'll use the element's href to find the correct element on screen. Also, the visible flag specifies that this element must be visible to the user.

- Clicking
- Setting a Timeout

```codeBlockLines_p187
mutation ClickButton {
  goto(url: "https://www.browserless.io/" waitUntil: firstContentfulPaint) {
    status
  }

  click(selector: "a[href=\"https://account.browserless.io/signup/email/?plan=starter\"]", visible: true) {
    x
    y
  }
}

```

By default BrowserQL will automatically wait for elements to be present before interacting with them. You can limit the amount of time it will wait by setting a `timeout` argument. The following will limit the `timeout` to 10 seconds versus the default of 30 seconds:

```codeBlockLines_p187

mutation ClickButton {
  goto(url: "https://www.browserless.io/" waitUntil: firstContentfulPaint) {
    status
  }

  click(
    selector: "a[href=\"https://account.browserless.io/signup/email/?plan=starter\"]",
    visible: true
    timeout: 10000
  ) {
    x
    y
  }
}

```

Typing is also supported, and works similarly to how the `click` query does. After navigating to a website, you need to specify the text you want to be typed, along with the selector, telling the query where it should type the content.

- Typing
- Setting a Delay

```codeBlockLines_p187
mutation TypeInteraction {
  goto(url: "https://www.google.com/" waitUntil: firstContentfulPaint) {
    status
  }

  type(
    text: "I'm a little teapot!"
    selector: "form textarea"
  ) {
    x
    y
  }
}

```

By default, BrowserQL will type a character at a time with a random interval of space between similar to a real user. If you wish to change this delay you can specify a `delay` argument which receives an array with a minimum and maximum delay time ( `[min, max]`) in milliseconds.

```codeBlockLines_p187
mutation TypeInteraction {
  goto(url: "https://www.google.com/" waitUntil: firstContentfulPaint) {
    status
  }

  type(
    text: "I'm a little teapot!"
    selector: "form textarea"
    delay: [10, 50]
  ) {
    x
    y
  }
}

```

This means a delay between `10` and `50` milliseconds is chosen at random between keystrokes.

You can retrieve HTML content from any website with BrowserQL as well. Use the `html` mutation after navigating to the website.

- HTML
- With Selector

```codeBlockLines_p187
mutation HTMLInteraction {
  goto(url: "https://www.browserless.io/" waitUntil: firstContentfulPaint) {
    status
  }

  html(
    visible: true
  ) {
    time
    html
  }
}

```

You can set a selector to the `html` mutation to define what content you want to retrieve from the page. In the case below, we return the content from the `h1` element with `.heading-style-h1.margin-bottom.margin-large` classes.

```codeBlockLines_p187
mutation HTMLInteraction {
  goto(url: "https://www.browserless.io/" waitUntil: firstContentfulPaint) {
    status
  }

  html(
    selector: "h1.heading-style-h1.margin-bottom.margin-large"
    visible: true
  ) {
    time
    html
  }
}

```

To retrieve the text from an element in any website, you can use the `text` mutation, and add a `selector` argument to define which element to search for the text content.

- Text
- Last element of its kind

```codeBlockLines_p187
mutation TextInteraction {
  goto(url: "https://www.example.com/" waitUntil: firstContentfulPaint) {
    status
  }

  text(
    selector: "p"
    visible: true
  ) {
    time
    text
  }
}

```

```codeBlockLines_p187
mutation TextInteraction {
  goto(url: "https://www.example.com/" waitUntil: firstContentfulPaint) {
    status
  }

  text(
    selector: "p:last-of-type"
    visible: true
  ) {
    time
    text
  }
}

```

For actions such as the need to get past a captcha, BQL takes humanized actions, such as moving the mouse to a selector and randomized typing delays. By default, BrowserQL will type a character at a time with a random time between strokes similar to a real user.

Delay Change

If you wish to change this delay you can specify a `min` and `max` delay. Below, typing delays are randomized between 10â€“50 milliseconds, mimicking natural input:

```codeBlockLines_p187
teapotTyping: type(
  text: "I'm a little teapot!"
  selector: "form textarea"
  delay: [10, 50]
) {
  time
}

```

### Handling CAPTCHA [â€‹](https://docs.browserless.io/browserql/writing-bql/language-basics\#handling-captcha "Direct link to Handling CAPTCHA")

If you know that a page is going to have a captcha, such as for a login or form submission, you can use the [verification mutation](https://docs.browserless.io/bql-schema/operations/mutations/verify). This will click on the captcha, even if itâ€™s hidden away in iframe and shadow DOMs. Just specify the CAPTCHA type (e.g., `hcaptcha` or `cloudflare`), and BQL takes care of the rest:

```codeBlockLines_p187
verifyCaptcha: verify(type: hcaptcha) {
  time
  found
  solved
}

```

### Connecting Libraries with Endpoints [â€‹](https://docs.browserless.io/browserql/writing-bql/language-basics\#connecting-libraries-with-endpoints "Direct link to Connecting Libraries with Endpoints")

We also know that you might want to connect other libraries, like Puppeteer or Playwright, to these browsers once theyâ€™ve got past the bot detectors. You can create an endpoint with the `reconnect` action, and use this endpoint to connect to the browser:

```codeBlockLines_p187
reconnect(timeout: 30000) {
  browserWSEndpoint
}

```

## Next Steps [â€‹](https://docs.browserless.io/browserql/writing-bql/language-basics\#next-steps "Direct link to Next Steps")

BrowserQL simplifies web automation with intuitive commands and a structure thatâ€™s easy to learn. Start by focusing on the following:

- [Advanced Options](https://docs.browserless.io/browserql/writing-bql/advanced-options)
- [Extracting Scripts](https://docs.browserless.io/browserql/writing-bql/exporting-scripts)

- [What You Won't Write](https://docs.browserless.io/browserql/writing-bql/language-basics#what-you-wont-write)
- [What Youâ€™ll Write](https://docs.browserless.io/browserql/writing-bql/language-basics#what-youll-write)
- [Creating a BQL Script](https://docs.browserless.io/browserql/writing-bql/language-basics#creating-a-bql-script)
  - [Navigating to a Page](https://docs.browserless.io/browserql/writing-bql/language-basics#navigating-to-a-page)
  - [Retrieving Data](https://docs.browserless.io/browserql/writing-bql/language-basics#retrieving-data)
  - [Performing Actions](https://docs.browserless.io/browserql/writing-bql/language-basics#performing-actions)
  - [Handling CAPTCHA](https://docs.browserless.io/browserql/writing-bql/language-basics#handling-captcha)
  - [Connecting Libraries with Endpoints](https://docs.browserless.io/browserql/writing-bql/language-basics#connecting-libraries-with-endpoints)
- [Next Steps](https://docs.browserless.io/browserql/writing-bql/language-basics#next-steps)

---

### Browserless.io
Original URL: https://docs.browserless.io/browserql/writing-bql/reconnecting-bql

[Skip to main content](https://docs.browserless.io/browserql/writing-bql/reconnecting-bql#__docusaurus_skipToContent_fallback)

# Page Not Found

We could not find what you were looking for.

Please contact the owner of the site that linked you to the original URL and let them know their link is broken.

---

### Docker | Browserless.io
Original URL: https://docs.browserless.io/category/docker

[Skip to main content](https://docs.browserless.io/category/docker#__docusaurus_skipToContent_fallback)

[**ðŸ“„ï¸ Quick Start** \\
The docker image that powers the core of Browserless is available for free for open-source projects. Using it is about as simple as using the Browserless service itself with the only difference being that you'll have to launch and manage the infrastructure.](https://docs.browserless.io/enterprise/docker/quickstart)[**ðŸ“„ï¸ Configuration** \\
The browserless docker container is highly-configurable, and accepts parameters through environment variables when starting. You can set parameters such as port, connection-timeout, queueing and more. Below is a description of each parameter, what they mean, and what they default to.](https://docs.browserless.io/enterprise/docker/config)[**ðŸ“„ï¸ Extending** \\
For hosted accounts, if you want to use a third-party module please get in touch!](https://docs.browserless.io/enterprise/docker/extending)[**ðŸ“„ï¸ Webhooks** \\
When launching the docker image you can configure it to "callback" to a web-based URL when certain events occur. For instance, you can have it call an HTTP URI when sessions are queued or rejected.](https://docs.browserless.io/enterprise/docker/webhooks)

---

### Private Deployment | Browserless.io
Original URL: https://docs.browserless.io/category/private-deployment

[Skip to main content](https://docs.browserless.io/category/private-deployment#__docusaurus_skipToContent_fallback)

[**ðŸ“„ï¸ GraphQL API** \\
Aside from providing the default production-sfo.browserless.io domain for running sessions, Browserless also exposes a GraphQL API for other operations. This document goes over some critical queries, however there's more information and descriptions at the interactive GraphiQL interface located here.](https://docs.browserless.io/enterprise/private-deployment/graphql-api)[**ðŸ“„ï¸ Worker settings** \\
To customize your worker settings, log in to your browserless account and click on the the gear icon in the Production Workers tab.](https://docs.browserless.io/enterprise/private-deployment/worker-settings)

---

### Utility Functions | Browserless.io
Original URL: https://docs.browserless.io/category/utility-functions

[Skip to main content](https://docs.browserless.io/category/utility-functions#__docusaurus_skipToContent_fallback)

[**ðŸ“„ï¸ Overview** \\
Browserless provides specialized utility functions for managing and monitoring your private deployments. These functions are primarily relevant for users with private or self-hosted deployments who need to access usage metrics, session information, and configuration details.](https://docs.browserless.io/enterprise/utility-functions/intro)[**ðŸ“„ï¸ /sessions** \\
The sessions API allows you to gather information about the currently running sessions and is only available for dedicated and self-hosted accounts](https://docs.browserless.io/enterprise/utility-functions/sessions)[**ðŸ“„ï¸ /config** \\
The /config API will give you information about your worker's configuration, and is only available for dedicated and self-hosted accounts](https://docs.browserless.io/enterprise/utility-functions/config)[**ðŸ“„ï¸ /metrics** \\
The metrics API allows you to retrieve an array of session statistics. The data returned will have a maximum date of 1 week.](https://docs.browserless.io/enterprise/utility-functions/metrics)

---

### Page Error
Original URL: https://docs.browserless.io/components/cards

# This page crashed

Try again

Cannot read properties of null (reading 'innerText')

---

### Page Error
Original URL: https://docs.browserless.io/components/header

# This page crashed

Try again

Cannot read properties of null (reading 'innerText')

---

### Docker Configuration | Browserless.io
Original URL: https://docs.browserless.io/enterprise/docker/config

[Skip to main content](https://docs.browserless.io/enterprise/docker/config#__docusaurus_skipToContent_fallback)


The browserless docker container is highly-configurable, and accepts parameters through environment variables when starting. You can set parameters such as port, connection-timeout, queueing and more. Below is a description of each parameter, what they mean, and what they default to.

## Token [â€‹](https://docs.browserless.io/enterprise/docker/config\#token "Direct link to Token")

Browserless is designed to **always** require a token. This means that, if you don't pass a `TOKEN` env variable, **a randomly generated token will be set**. To set a token, you can pass it as env variable this way:

```codeBlockLines_p187
$ docker run -p 3000:3000 -e "TOKEN=6R0W53R135510" ghcr.io/browserless/chromium

```

## Port [â€‹](https://docs.browserless.io/enterprise/docker/config\#port "Direct link to Port")

By default browserless listens on port `3000`. You can configure this in docker by using it's port mapping functionality. As an example, let's say you want to have it listen port `8080`, you would run it like so:

```codeBlockLines_p187
$ docker run -p 8080:3000 ghcr.io/browserless/chromium

```

This should allow you some flexibility in how to run the image.

## Max Concurrent Sessions [â€‹](https://docs.browserless.io/enterprise/docker/config\#max-concurrent-sessions "Direct link to Max Concurrent Sessions")

Since running browsers can be rather resource intensive you'll probably want to limit the number of concurrent sessions. This is, by default, set to 5 when not specified. Once the limit is reached then queueing begins to take place and requests will wait until more workers are ready.

To set this to a different number, say 10, you need to pass the `CONCURRENT` env variable like so:

```codeBlockLines_p187
$ docker run -e "CONCURRENT=10" -p 3000:3000 ghcr.io/browserless/chromium

```

It's best to keep this limit small and grow it over time as it's easy to starve resources when running on restricted hardware.

## Connection Timeout [â€‹](https://docs.browserless.io/enterprise/docker/config\#connection-timeout "Direct link to Connection Timeout")

`TIMEOUT` is a parameter that sets how long any session can run for. This is in place to prevent scripts that don't cleanup properly, or run into errors tha cause them to hang. The value of which can be set in milliseconds, and defaults to `30000`, or 30 seconds.

To allow more time for sessions, simply change it by setting `TIMEOUT` when running.

info

You can opt-out of timers by setting this value to `-1` for _no_ session timer. Be sure to close connections when not in use!

```codeBlockLines_p187
$ docker run -e "TIMEOUT=60000" -p 3000:3000 ghcr.io/browserless/chromium

```

## Max Queue Length [â€‹](https://docs.browserless.io/enterprise/docker/config\#max-queue-length "Direct link to Max Queue Length")

This value determines how many items in the queue are allowed before requests are issued a `429` response code and closed. This mechanism is in place to prevent consumers from accidentally (or purposefully) triggering a denial-of-service. By default the image only allows a queue of 5 requests before beginning to fail more. As an example, if you have a `CONCURRENT` of 5 and a `QUEUED` of 5, then 10 concurrent connections are allowed (5 running then 5 pending).

To adjust this value, simply set it via `QUEUED`.

```codeBlockLines_p187
$ docker run -e "QUEUED=10" -p 3000:3000 ghcr.io/browserless/chromium

```

## Demo Mode [â€‹](https://docs.browserless.io/enterprise/docker/config\#demo-mode "Direct link to Demo Mode")

## Defining a host bind [â€‹](https://docs.browserless.io/enterprise/docker/config\#defining-a-host-bind "Direct link to Defining a host bind")

browserless will, by default, bind to localhost when no host is provided. If you want to bind to another IP, or domain, then pass in a `HOST` variable to do so.

```codeBlockLines_p187
$ docker run -e "HOST=192.168.1.1" -p 3000:3000 ghcr.io/browserless/chromium

```

## Logging [â€‹](https://docs.browserless.io/enterprise/docker/config\#logging "Direct link to Logging")

Browserless uses the [`debug`](https://www.npmjs.com/package/debug) npm package to log output. By default, browserless prints a minimal set of logs regarding sessions and other performance characteristics. To turn it off, simply set the `DEBUG` value to nothing:

```codeBlockLines_p187
$ docker run -e "DEBUG=-*" -p 3000:3000 ghcr.io/browserless/chromium

```

Since most other npm packages use this same module, you can set this flag to a wildcard `*` to see nearly everything that's happening internally:

warning

Be careful running with this command as you'll generate a lot of log output.

```codeBlockLines_p187
$ docker run -e "DEBUG=*" -p 3000:3000 ghcr.io/browserless/chromium

```

## Enable CORS [â€‹](https://docs.browserless.io/enterprise/docker/config\#enable-cors "Direct link to Enable CORS")

You can enable cross-origin-resource-sharing with browserless by setting the `CORS=true` variable. This defaults to `false`:

```codeBlockLines_p187
$ docker run -e "CORS=true" -p 3000:3000 ghcr.io/browserless/chromium

```

## Allow CORS methods [â€‹](https://docs.browserless.io/enterprise/docker/config\#allow-cors-methods "Direct link to Allow CORS methods")

When `CORS=true`, by default, all `OPTIONS`, `POST`, and `GET` requests are allowed. To have more control over the methods, you can configure them using the `CORS_ALLOW_METHODS` env variable:

```codeBlockLines_p187
$ docker run \
  -e "CORS=true" \
  -e "CORS_ALLOW_METHODS=POST, DELETE" \
  -p 3000:3000 \
  ghcr.io/browserless/chromium

```

## Allow CORS origins [â€‹](https://docs.browserless.io/enterprise/docker/config\#allow-cors-origins "Direct link to Allow CORS origins")

When `CORS=true`, by default, requests from **all** origins are allowed. To have more control over the origins, you can configure them using the `CORS_ALLOW_ORIGIN` env variable:

```codeBlockLines_p187
$ docker run \
  -e "CORS=true" \
  -e "CORS_ALLOW_ORIGIN=http://localhost" \
  -p 3000:3000 \
  ghcr.io/browserless/chromium

```

## Set CORS maximum cache age [â€‹](https://docs.browserless.io/enterprise/docker/config\#set-cors-maximum-cache-age "Direct link to Set CORS maximum cache age")

When `CORS=true`, by default, CORS responses will have a maximum cache age of `2592000` s. To change this value, you can configure them using the `CORS_MAX_AGE` env variable:

```codeBlockLines_p187
$ docker run \
  -e "CORS=true" \
  -e "CORS_MAX_AGE=300" \
  -p 3000:3000 \
  ghcr.io/browserless/chromium

```

## Persisting Metrics [â€‹](https://docs.browserless.io/enterprise/docker/config\#persisting-metrics "Direct link to Persisting Metrics")

browserless captures metrics while it's running, and exposes them via the `/metrics` endpoint. These, by default, don't persist anywhere _unless_ you tell browserless where to persist them. When provided, the docker image will also attempt to read the metrics on startup and write to it periodically during execution.

warning

In this run command we're mounting the machines `/root` path so that the docker can access it at `/root`, be sure to change this to fit your use-case

```codeBlockLines_p187
$ docker run -e "METRICS_JSON_PATH=/root/metrics.json" -v /root:/root -p 3000:3000 ghcr.io/browserless/chromium

```

## Default User Data Dir [â€‹](https://docs.browserless.io/enterprise/docker/config\#default-user-data-dir "Direct link to Default User Data Dir")

Sets a default directory to cache user data to (cookies, local-storage and more). This will force all sessions to use the same cache unless sessions themselves specify another path, which will override this behavior.

```codeBlockLines_p187
$ docker run -e "DATA_DIR=/tmp/my-profile" -p 3000:3000 ghcr.io/browserless/chromium

```

## Default Downloads Dir [â€‹](https://docs.browserless.io/enterprise/docker/config\#default-downloads-dir "Direct link to Default Downloads Dir")

Sets a default directory to store downloaded files. By default, downloads are stored inside a `browserless-download-dirs` dir inside the OS' temporary dir. To change this, you can use the `DOWNLOAD_DIR` env variable.

```codeBlockLines_p187
$ docker run -e "DOWNLOAD_DIR=/downloads" -p 3000:3000 ghcr.io/browserless/chromium

```

## Enable `GET` APIs [â€‹](https://docs.browserless.io/enterprise/docker/config\#enable-get-apis "Direct link to enable-get-apis")

Allows for enabling HTTP `GET` operations, as opposed to `POST` ing bodies of code to run on our APIs. When enabled, you'll simply need to set a `body` query-string parameter, with a URL-encoded JSON string of the normal API body.

```codeBlockLines_p187
$ docker run -e 'ALLOW_GET=true' -p 3000:3000 ghcr.io/browserless/chromium

```

## Using a proxy [â€‹](https://docs.browserless.io/enterprise/docker/config\#using-a-proxy "Direct link to Using a proxy")

You'll often want to use a load-balancer, or reverse proxy, in front of Browserless for SSL termination or to load balance across a fleet of Browserless instances. In certain cases, Browserless does generate links (like in the `/sessions` API), in which case this link builder needs to be aware of how it should route sessions.

In order to handle this, you can specify three parameters: `PROXY_HOST`, `PROXY_PORT` and `PROXY_SSL` to Browserless. This will tell certain APIs to generate links with the prior information.

```codeBlockLines_p187
$ docker run -e "PROXY_HOST=browserless.my-domain.com" -e PROXY_PORT=443 -e PROXY_SSL=true -p 3000:3000 ghcr.io/browserless/chromium

```

Then, /sessions API calls will return properly formatted JSON resposnes:

```codeBlockLines_p187
[\
  {\
    "description": "",\
    "devtoolsFrontendUrl": "/devtools/inspector.html?wss=browserless.my-domain.com:443/devtools/page/C6962B3428FC8E42CDA6484AB5B57EAC",\
    "id": "C6962B3428FC8E42CDA6484AB5B57EAC",\
    "title": "Example Domain",\
    "type": "page",\
    "url": "https://www.example.com/",\
    "webSocketDebuggerUrl": "wss://browserless.my-domain.com:443/devtools/page/C6962B3428FC8E42CDA6484AB5B57EAC",\
    "browserId": "b519351a-355e-47d5-82cc-7c240cfa40f3",\
    "browserWSEndpoint": "wss://browserless.my-domain.com:443/devtools/browser/b519351a-355e-47d5-82cc-7c240cfa40f3",\
    "port": "42169",\
    "trackingId": null\
  }\
]

```

## Allow `file://` protocol [â€‹](https://docs.browserless.io/enterprise/docker/config\#allow-file-protocol "Direct link to allow-file-protocol")

By default, requests using the `file://` procotol are denied for security reasons. Set `ALLOW_FILE_PROTOCOL=true` in your env params to allow it:

```codeBlockLines_p187
$ docker run -e "ALLOW_FILE_PROTOCOL=true" -p 3000:3000 ghcr.io/browserless/chromium

```

## Check instance health before a session [â€‹](https://docs.browserless.io/enterprise/docker/config\#check-instance-health-before-a-session "Direct link to Check instance health before a session")

You can use the `HEALTH` env variable to check CPU/Memory prior to running a session. If the instance's CPU/Memory are high on any inbound session (HTTP APIs, Puppeteer or Playwright), Browserless will respond with a `503` status code.

```codeBlockLines_p187
$ docker run -e 'HEALTH=true' -p 3000:3000 ghcr.io/browserless/chromium

```

## Setting the maximum memory for health checks [â€‹](https://docs.browserless.io/enterprise/docker/config\#setting-the-maximum-memory-for-health-checks "Direct link to Setting the maximum memory for health checks")

If `HEALTH=true`, by default, it will allow requests as long memory usage is not over `99`. To set the threshold value, you canuse the `MAX_MEMORY_PERCENT` env variable:

```codeBlockLines_p187
$ docker run \
  -e 'HEALTH=true' \
  -e 'MAX_MEMORY_PERCENT=80' \
  -p 3000:3000 \
  ghcr.io/browserless/chromium

```

## Setting the maximum cpu for health checks [â€‹](https://docs.browserless.io/enterprise/docker/config\#setting-the-maximum-cpu-for-health-checks "Direct link to Setting the maximum cpu for health checks")

If `HEALTH=true`, by default, it will allow requests as long cpu usage is not over `99`. To set the threshold value, you canuse the `MAX_CPU_PERCENT` env variable:

```codeBlockLines_p187
$ docker run \
  -e 'HEALTH=true' \
  -e 'MAX_CPU_PERCENT=80' \
  -p 3000:3000 \
  ghcr.io/browserless/chromium

```

- [Token](https://docs.browserless.io/enterprise/docker/config#token)
- [Port](https://docs.browserless.io/enterprise/docker/config#port)
- [Max Concurrent Sessions](https://docs.browserless.io/enterprise/docker/config#max-concurrent-sessions)
- [Connection Timeout](https://docs.browserless.io/enterprise/docker/config#connection-timeout)
- [Max Queue Length](https://docs.browserless.io/enterprise/docker/config#max-queue-length)
- [Demo Mode](https://docs.browserless.io/enterprise/docker/config#demo-mode)
- [Defining a host bind](https://docs.browserless.io/enterprise/docker/config#defining-a-host-bind)
- [Logging](https://docs.browserless.io/enterprise/docker/config#logging)
- [Enable CORS](https://docs.browserless.io/enterprise/docker/config#enable-cors)
- [Allow CORS methods](https://docs.browserless.io/enterprise/docker/config#allow-cors-methods)
- [Allow CORS origins](https://docs.browserless.io/enterprise/docker/config#allow-cors-origins)
- [Set CORS maximum cache age](https://docs.browserless.io/enterprise/docker/config#set-cors-maximum-cache-age)
- [Persisting Metrics](https://docs.browserless.io/enterprise/docker/config#persisting-metrics)
- [Default User Data Dir](https://docs.browserless.io/enterprise/docker/config#default-user-data-dir)
- [Default Downloads Dir](https://docs.browserless.io/enterprise/docker/config#default-downloads-dir)
- [Enable `GET` APIs](https://docs.browserless.io/enterprise/docker/config#enable-get-apis)
- [Using a proxy](https://docs.browserless.io/enterprise/docker/config#using-a-proxy)
- [Allow `file://` protocol](https://docs.browserless.io/enterprise/docker/config#allow-file-protocol)
- [Check instance health before a session](https://docs.browserless.io/enterprise/docker/config#check-instance-health-before-a-session)
- [Setting the maximum memory for health checks](https://docs.browserless.io/enterprise/docker/config#setting-the-maximum-memory-for-health-checks)
- [Setting the maximum cpu for health checks](https://docs.browserless.io/enterprise/docker/config#setting-the-maximum-cpu-for-health-checks)

---

### Extending the Docker Image | Browserless.io
Original URL: https://docs.browserless.io/enterprise/docker/extending

[Skip to main content](https://docs.browserless.io/enterprise/docker/extending#__docusaurus_skipToContent_fallback)


info

For hosted accounts, if you want to use a third-party module please [get in touch!](https://www.browserless.io/contact)

Browserless includes a few extra packages that make it easy to get going with most of the use-cases we've seen. However if you're using the `/function` API, or other API's wherein you want to load npm modules, then you'll need to extend our image so that you can install these dependencies. The process if fairly easy in docker to do so.

## 1\. Create your own Dockerfile [â€‹](https://docs.browserless.io/enterprise/docker/extending\#1-create-your-own-dockerfile "Direct link to 1. Create your own Dockerfile")

First, you'll want to write your own `Dockerfile`. In the example below, we're going to add the `aws-sdk` module.

```codeBlockLines_p187
FROM ghcr.io/browserless/chromium:latest

# Install the AWS SDK
RUN npm install aws-sdk

```

Feel free to change the `FROM` value here. It's generally a good practice to "pin" this version to value that won't change. For instance, if we want to use version [1.15.0](https://github.com/browserless/browserless/blob/V1/CHANGELOG.md#1150) of Browserless, we'd have done:

```codeBlockLines_p187
FROM ghcr.io/browserless/chromium:2.2.0

# Install the AWS SDK
RUN npm install aws-sdk

```

In either case, save your file and let's proceed.

## 2\. Build the docker image [â€‹](https://docs.browserless.io/enterprise/docker/extending\#2-build-the-docker-image "Direct link to 2. Build the docker image")

Once the you have the file saved, it's as simple as building the image.

```codeBlockLines_p187
$ docker build -t my/browserless:latest .

```

Here, we're using a "dumby" user of `my` and a repo of `browserless`, tagging it as the \`latest. Feel free to change these however you see fit, especially if you want to push this built image into docker's public cloud or your own private image registry.

It'll likely take a few minutes to pull all the dependencies locally and build, however subsequent builds will be much quicker since they'll have a local cache.

## 3\. Run the image [â€‹](https://docs.browserless.io/enterprise/docker/extending\#3-run-the-image "Direct link to 3. Run the image")

Now that you have a custom-built version you can apply all the same arguments to your start command (all environment variables and so on apply), you'll simply change the image you're running when you startup (note that we're whitelisting this new module, allowing browserless to execute it for security purposes).

Here's an example of running the newly built image with the module whitelisted.

```codeBlockLines_p187
$ docker run -p 3000:3000 -e FUNCTION_EXTERNALS='["aws-sdk"]' my/browserless:latest

```

Now your calls to `/function` and others will have access to the `aws-sdk` module:

```codeBlockLines_p187
$ curl -X POST \
  http://localhost:3000/function \
  -H 'Content-Type: application/javascript' \
  -d 'const aws = require('\''aws-sdk'\'');

module.exports = async () => {
  const data = Object.keys(aws);

  return {
    data,
    type: '\''text/plain'\'',
  };
};'

```

That's it! If you need to add more simply install your modules in the `Dockerfile`, build the image, and run it!

- [1\. Create your own Dockerfile](https://docs.browserless.io/enterprise/docker/extending#1-create-your-own-dockerfile)
- [2\. Build the docker image](https://docs.browserless.io/enterprise/docker/extending#2-build-the-docker-image)
- [3\. Run the image](https://docs.browserless.io/enterprise/docker/extending#3-run-the-image)

---

### Docker Quick Start | Browserless.io
Original URL: https://docs.browserless.io/enterprise/docker/quickstart

[Skip to main content](https://docs.browserless.io/enterprise/docker/quickstart#__docusaurus_skipToContent_fallback)


The docker image that powers the core of Browserless is available for free for open-source projects. Using it is about as simple as using the Browserless service itself with the only difference being that you'll have to launch and manage the infrastructure.

At a high-level, we'll do the following:

1. [Run the docker image](https://docs.browserless.io/enterprise/docker/quickstart#1-run-it-with-some-sensible-defaults).
2. [Update our app to connect to this image](https://docs.browserless.io/enterprise/docker/quickstart#2-update-your-app-to-use-browserless).

## 1\. Run it with some sensible defaults [â€‹](https://docs.browserless.io/enterprise/docker/quickstart\#1-run-it-with-some-sensible-defaults "Direct link to 1. Run it with some sensible defaults")

Running the docker image is similar to other `docker run` commands, and all options are passed in via environment variables. In the example below, we're starting with the image with a maximum concurrency of `10`, further requests will remain open and ran when a slot opens up. We're also setting the token to `6R0W53R135510`.

warning

Browserless is designed to **always** require a token. This means that, if you don't pass a `TOKEN` env variable, **a randomly generated token will be set**.

After the image is pulled (one time only), then you'll see the first of our logs, which will print the final configuration.

```codeBlockLines_p187
$ docker run \
  --rm \
  -p 3000:3000 \
  -e "CONCURRENT=10" \
  -e "TOKEN=6R0W53R135510" \
  ghcr.io/browserless/chromium

```

Feel free to visit [http://localhost:3000/docs](http://localhost:3000/docs) to see if the image is running properly. You can also read more about the different variables on our [docker section](https://docs.browserless.io/enterprise/docker/config).

## 2\. Update your app to use Browserless [â€‹](https://docs.browserless.io/enterprise/docker/quickstart\#2-update-your-app-to-use-browserless "Direct link to 2. Update your app to use Browserless")

Once we have Browserless running we can simply use it inside of our application instead of launching it locally. There's more details in our docs about using Puppeteer or Playwright, but here is an example:

- Puppeteer
- Playwright

```codeBlockLines_p187
const express = require("express");
const puppeteer = require("puppeteer-core");

const app = express();

app.get("/image", async (req, res) => {
// This was puppeteer.launch()
const browser = await puppeteer.connect({
  browserWSEndpoint: "ws://localhost:3000?token=6R0W53R135510",
});
const page = await browser.newPage();

await page.goto("http://www.example.com/");
const data = await page.screenshot();
browser.close();

return res.end(data, "binary");
});

app.listen(8080);

```

- Javascript
- Python
- Java
- C#

```codeBlockLines_p187
const express = require('express');
const playwright = require('playwright');

const app = express();

app.get('/image', async (req, res) => {
  const browser = await playwright.chromium.connectOverCDP('ws://localhost:3000?token=6R0W53R135510');

  const context = await browser.newContext();
  const page = await context.newPage();

  await page.goto('http://www.example.com/');
  await new Promise((resolve) => setTimeout(resolve, 5000));
  const data = await page.screenshot({ type: 'png' });

  await browser.close();

  return res.end(data, 'binary');
});

app.listen(8080);

```

```codeBlockLines_p187
from flask import Flask, send_file
from playwright.sync_api import sync_playwright
import io

app = Flask(__name__)

@app.route("/image", methods=["GET"])
def capture_image():
    with sync_playwright() as p:
        browser = p.chromium.connect_over_cdp("ws://localhost:3000?token=6R0W53R135510")
        context = browser.new_context()
        page = context.new_page()

        page.goto("http://www.example.com/")
        page.wait_for_timeout(5000)
        screenshot = page.screenshot(type="png")

        browser.close()

        return send_file(io.BytesIO(screenshot), mimetype="image/png")

if __name__ == "__main__":
    app.run(port=8080)

```

```codeBlockLines_p187
import com.microsoft.playwright.*;
import static spark.Spark.*;
import java.io.OutputStream;

public class PlaywrightImageServer {
    public static void main(String[] args) {
        port(8080);

        get("/image", (req, res) -> {
            try (Playwright playwright = Playwright.create()) {
                Browser browser = playwright.chromium().connectOverCDP("ws://localhost:3000?token=6R0W53R135510");
                BrowserContext context = browser.newContext();
                Page page = context.newPage();

                page.navigate("http://www.example.com/");
                page.waitForTimeout(5000);
                byte[] screenshot = page.screenshot(new Page.ScreenshotOptions().setType("png"));

                browser.close();

                res.type("image/png");
                OutputStream outputStream = res.raw().getOutputStream();
                outputStream.write(screenshot);
                outputStream.flush();

                return res.raw();
            } catch (Exception e) {
                res.status(500);
                return "Error capturing screenshot: " + e.getMessage();
            }
        });
    }
}

```

```codeBlockLines_p187
using System;
using System.IO;
using System.Threading.Tasks;
using Microsoft.AspNetCore.Builder;
using Microsoft.AspNetCore.Hosting;
using Microsoft.AspNetCore.Http;
using Microsoft.Extensions.Hosting;
using Microsoft.Playwright;

var builder = WebApplication.CreateBuilder(args);
var app = builder.Build();

app.MapGet("/image", async context =>
{
    try
    {
        var playwright = await Playwright.CreateAsync();
        var browser = await playwright.Chromium.ConnectOverCDPAsync("ws://localhost:3000?token=6R0W53R135510");

        var page = await (await browser.NewContextAsync()).NewPageAsync();
        await page.GotoAsync("http://www.example.com/");
        await Task.Delay(5000);

        var screenshot = await page.ScreenshotAsync(new PageScreenshotOptions { Type = ScreenshotType.Png });

        context.Response.ContentType = "image/png";
        await context.Response.Body.WriteAsync(screenshot);

        await browser.CloseAsync();
    }
    catch (Exception e)
    {
        context.Response.StatusCode = 500;
        await context.Response.WriteAsync("Error capturing screenshot: " + e.Message);
    }
});

app.Run("http://localhost:8080");

```

## What's next? [â€‹](https://docs.browserless.io/enterprise/docker/quickstart\#whats-next "Direct link to What's next?")

There's a lot more that you can configure and tune in Browserless to handle the needs of your application. Be sure to read about all the options it exposes and how to get the most out of the Browserless image!

We also have docs for extra features for licensed users such as:

- [Watching sessions](https://docs.browserless.io/enterprise/watching-sessions)
- [Live Debugger](https://docs.browserless.io/enterprise/live-debugger)
- [Utility Functions](https://docs.browserless.io/enterprise/utility-functions/intro)
- [Worker settings](https://docs.browserless.io/enterprise/private-deployment/worker-settings)

- [1\. Run it with some sensible defaults](https://docs.browserless.io/enterprise/docker/quickstart#1-run-it-with-some-sensible-defaults)
- [2\. Update your app to use Browserless](https://docs.browserless.io/enterprise/docker/quickstart#2-update-your-app-to-use-browserless)
- [What's next?](https://docs.browserless.io/enterprise/docker/quickstart#whats-next)

---

### Docker Webhooks | Browserless.io
Original URL: https://docs.browserless.io/enterprise/docker/webhooks

[Skip to main content](https://docs.browserless.io/enterprise/docker/webhooks#__docusaurus_skipToContent_fallback)


When launching the docker image you can configure it to "callback" to a web-based URL when certain events occur. For instance, you can have it call an HTTP URI when sessions are queued or rejected.

For each URL, when the associated event happens, browserless will do a `GET` call on the provided URL. It doesn't listen to responses or failures, however it's a good idea to answer it back immediately to close any open connections.

Below is a list of all possible options. Be sure to check back often and see when more are added!

## Queuing [â€‹](https://docs.browserless.io/enterprise/docker/webhooks\#queuing "Direct link to Queuing")

Setting a `QUEUE_ALERT_URL` will trigger the image to call a the specified URL when queuing begins to happen. You can set this to any HTTP URL as seen below:

```codeBlockLines_p187
$ docker run -d \
  --restart always \
  --name browserless \
  -e "QUEUE_ALERT_URL=https://my.website.com/queued" \
  -p 3000:3000
  ghcr.io/browserless/chromium

```

## Rejections [â€‹](https://docs.browserless.io/enterprise/docker/webhooks\#rejections "Direct link to Rejections")

Setting a `REJECT_ALERT_URL` will trigger the image to call a the specified URL when rejections begins to happen. You can set this to any HTTP URL as seen below:

```codeBlockLines_p187
$ docker run -d \
  --restart always \
  --name browserless \
  -e "REJECT_ALERT_URL=https://my.website.com/rejected" \
  -p 3000:3000
  ghcr.io/browserless/chromium

```

## Timeouts [â€‹](https://docs.browserless.io/enterprise/docker/webhooks\#timeouts "Direct link to Timeouts")

Setting a `TIMEOUT_ALERT_URL` will trigger the image to call a the specified URL when time-outs begins to happen. You can set this to any HTTP URL as seen below:

```codeBlockLines_p187
$ docker run -d \
  --restart always \
  --name browserless \
  -e "TIMEOUT_ALERT_URL=https://my.website.com/time-out" \
  -p 3000:3000
  ghcr.io/browserless/chromium

```

## Health Failure [â€‹](https://docs.browserless.io/enterprise/docker/webhooks\#health-failure "Direct link to Health Failure")

Setting a `FAILED_HEALTH_URL` will trigger the image to call a the specified URL when the health of the instance is critical (over 99% on CPU and memory). You can use this event to potentially restart the image or replace it.

```codeBlockLines_p187
$ docker run -d \
  --restart always \
  --name browserless \
  -e "FAILED_HEALTH_URL=https://my.website.com/failed-health" \
  -p 3000:3000
  ghcr.io/browserless/chromium

```

## Need something else? [â€‹](https://docs.browserless.io/enterprise/docker/webhooks\#need-something-else "Direct link to Need something else?")

If you're looking for hooks for other events, please [let us know](https://www.browserless.io/contact).

- [Queuing](https://docs.browserless.io/enterprise/docker/webhooks#queuing)
- [Rejections](https://docs.browserless.io/enterprise/docker/webhooks#rejections)
- [Timeouts](https://docs.browserless.io/enterprise/docker/webhooks#timeouts)
- [Health Failure](https://docs.browserless.io/enterprise/docker/webhooks#health-failure)
- [Need something else?](https://docs.browserless.io/enterprise/docker/webhooks#need-something-else)

---

### Live Debugger | Browserless.io
Original URL: https://docs.browserless.io/enterprise/live-debugger

[Skip to main content](https://docs.browserless.io/enterprise/live-debugger#__docusaurus_skipToContent_fallback)


Local and Hosted Live Debuggers function differently

The Live Debugger described 
Debugging scripts for headless browsers is probably the most frustrating and time-consuming part of the development cycle. Internal IDE and Runtime debugging tools have many limitations for external processes, and taking screenshots at every step is only effective to a certain extent. External debugging libraries are also incovenient to set up and clean up.

At Browserless, we want the headless browser development (and production) experience to be a effortless task, and that's why we ship a Live Debugger with our Chromium docker images. Some key features include:

- An editor with syntax highlighting and auto-completion.
- Typescript support.
- A visual screencast of the browser that you can interact with.
- The ability to interact with the browser's DevTools.
- File downloading for testing PDFs/PNGs.
- Control over browser-specific parameters like headless and stealth.
- A tab-based layout with code-saving capabilities.
- The ability to **save your code to disk as a NodeJS project**.

Inside your Browserless account, you will see an option in the menu linking to the debugger, under the `Resources` section:

![Account Menu](https://docs.browserless.io/assets/images/account-debugger-dde3a5dd9a762246809808ee8f0c9385.png)

And you will se the Live Debugger:

![Account Menu](https://docs.browserless.io/assets/images/debugger-v1-960dbeec56b062ffc3a2be891395a893.png)

There you will be able connect to your worker's websocket enpoints, to set custom launch flags, and set session parameters.

## 1\. Hybrid Feature in v2 [â€‹](https://docs.browserless.io/enterprise/live-debugger\#1-hybrid-feature-in-v2 "Direct link to 1. Hybrid Feature in v2")

For libraries like Puppeteer and Playwright, we recommend using our [Hybrid automation feature](https://docs.browserless.io/enterprise/watching-sessions) which allows you to:

- Stream remote headless browsers to users via a shareable URL
- Detect when captchas are found on the page
- Allow human intervention in automation workflows
- Continue automation after human interaction is complete

## 2\. BrowserQL Editor [â€‹](https://docs.browserless.io/enterprise/live-debugger\#2-browserql-editor "Direct link to 2. BrowserQL Editor")

For real-time session viewing and debugging, we recommend using the [BrowserQL Editor](https://account.browserless.io/bql), which provides:

- A live view of the browser session in the right panel
- Built-in documentation and debugging tools
- The ability to create and test queries before integrating them into your code
- Advanced session settings and configuration options

To access the BrowserQL Editor:

1. Log into your Browserless account at [account.browserless.io](https://account.browserless.io/)
2. Navigate to the BQL section in the sidebar menu
3. Or go directly to [https://account.browserless.io/bql](https://account.browserless.io/bql)

For more information about BrowserQL and its features, see our [BrowserQL documentation](https://docs.browserless.io/browserql/start).

- [1\. Hybrid Feature in v2](https://docs.browserless.io/enterprise/live-debugger#1-hybrid-feature-in-v2)
- [2\. BrowserQL Editor](https://docs.browserless.io/enterprise/live-debugger#2-browserql-editor)

---

### Browserless GraphQL API | Browserless.io
Original URL: https://docs.browserless.io/enterprise/private-deployment/graphql-api

[Skip to main content](https://docs.browserless.io/enterprise/private-deployment/graphql-api#__docusaurus_skipToContent_fallback)


Aside from providing the default `production-sfo.browserless.io` domain for running sessions, Browserless also exposes a GraphQL API for other operations. This document goes over some critical queries, however there's more information and descriptions at the interactive GraphiQL interface [located here](https://api.browserless.io/graphql/).

note

This GraphQL API is specifically for monitoring and managing private Browserless deployments (checking session pressure, metrics, etc). If you are looking for browser automation capabilities, you should use [BrowserQL](https://docs.browserless.io/browserql/start) instead, which is our dedicated browser automation API.

## Pressure [â€‹](https://docs.browserless.io/enterprise/private-deployment/graphql-api\#pressure "Direct link to Pressure")

The `pressure` query shows how much load your instance(s) are under, and whether they can accept more traffic or not. This is real-time, so if you need to check if your instance can take more traffic you can do a request to check prior to running your `puppeteer.connect` call.

warning

The pressure queries are still in BETA and may experience breaking schema changes.

```codeBlockLines_p187
# https://api.browserless.io/graphql
{
  pressure(apiToken: "YOUR_API_TOKEN_HERE") {
    running
    recentlyRejected
    queued
    isAvailable
    date
  }
}

```

This request will return a JSON object with the following payload:

```codeBlockLines_p187
{
  "data": {
    "pressure": {
      "running": 0,
      "recentlyRejected": 0,
      "queued": 0,
      "isAvailable": true,
      "date": 1524762532204
    }
  }
}

```

## Metrics [â€‹](https://docs.browserless.io/enterprise/private-deployment/graphql-api\#metrics "Direct link to Metrics")

The `metrics` query gives you insight to how your worker(s) are performing. It details things like successful, rejected, and timed-out sessions. Eventually this will be expanded to include things like average session-time and other helpful data-points.

Below is an example of a request for `metrics` and the responding payload.

warning

The metrics queries are still in BETA and may experience breaking schema changes.

```codeBlockLines_p187
# https://api.browserless.io/graphql
{
  metrics(apiToken: "YOUR_API_TOKEN_HERE") {
    successful
    rejected
    timedout
    queued
    cpu
    memory
    date
  }
}

```

This request returns an array of object detailing the metrics of your instance(s). If there's more than one instance stats are aggregated together in 5-minute intervals. CPU and Memory are averaged accross instances.

```codeBlockLines_p187
{
  "data": {
    "metrics": [\
      {\
        "successful": 0,\
        "rejected": 0,\
        "timedout": 0,\
        "queued": 0,\
        "cpu": 0.002734375,\
        "memory": 0.9055320561641963,\
        "date": 1524227700000\
      },\
      //...\
    ]
  }
}

```

## Sessions [â€‹](https://docs.browserless.io/enterprise/private-deployment/graphql-api\#sessions "Direct link to Sessions")

The `sessions` query shows what browsers you have instantiated and running. This will only work for customers who have their dedicated fleet, for security purposes.

```codeBlockLines_p187
# https://api.browserless.io/graphql
{
  sessions(apiToken: "YOUR_API_TOKEN_HERE") {
     description
    devtoolsFrontendUrl
    live
    kill
    title
    type
    url
    trackingId
    browserId
    browserWSEndpoint
    browserWSEndpointClient
  }
}

```

warning

For security purposes, we limit the number of failed GraphQL request attempts. If you encounter rate limiting errors, you'll need to wait until the top of the hour before making additional requests.

## Pre-Session Checks [â€‹](https://docs.browserless.io/enterprise/private-deployment/graphql-api\#pre-session-checks "Direct link to Pre-Session Checks")

If you've been getting rejections or queued, be sure to use the GraphQL API to do pre-session checks. This allows your workers to remain up and healthy, allowing sessions to go smoothly.

```codeBlockLines_p187
# https://api.browserless.io/graphql
{
  pressure(apiToken: "YOUR_API_TOKEN_HERE") {
    running
    recentlyRejected
    queued
    isAvailable
    date
  }
}

```

This request will return a JSON object with the following payload:

```codeBlockLines_p187
{
  "data": {
    "pressure": {
      "running": 0,
      "recentlyRejected": 0,
      "queued": 0,
      "isAvailable": true,
      "date": 1524762532204
    }
  }
}

```

You can use the `isAvailable` boolean to check to see if the instance can handle more connections. Otherwise you're free to write any sort of custom check with the provided JSON response.

## See More [â€‹](https://docs.browserless.io/enterprise/private-deployment/graphql-api\#see-more "Direct link to See More")

There's a lot more you can do in the GraphQL API behind browserless, so be sure to [check it out here](https://api.browserless.io/graphql/)!

- [Pressure](https://docs.browserless.io/enterprise/private-deployment/graphql-api#pressure)
- [Metrics](https://docs.browserless.io/enterprise/private-deployment/graphql-api#metrics)
- [Sessions](https://docs.browserless.io/enterprise/private-deployment/graphql-api#sessions)
- [Pre-Session Checks](https://docs.browserless.io/enterprise/private-deployment/graphql-api#pre-session-checks)
- [See More](https://docs.browserless.io/enterprise/private-deployment/graphql-api#see-more)

---

### Worker settings | Browserless.io
Original URL: https://docs.browserless.io/enterprise/private-deployment/worker-settings

[Skip to main content](https://docs.browserless.io/enterprise/private-deployment/worker-settings#__docusaurus_skipToContent_fallback)


To customize your worker settings, log in to your [browserless account](https://account.browserless.io/) and click on the the gear icon in the Production Workers tab.

There are several settings that you can tweak for your dedicated workers in the popup that appears.

## Puppeteer version and global timeout [â€‹](https://docs.browserless.io/enterprise/private-deployment/worker-settings\#puppeteer-version-and-global-timeout "Direct link to Puppeteer version and global timeout")

The first two dropdown fields will allow you to pick the chrome/puppeteer version and the global timeout.

### Supported chrome/puppeteer versions [â€‹](https://docs.browserless.io/enterprise/private-deployment/worker-settings\#supported-chromepuppeteer-versions "Direct link to Supported chrome/puppeteer versions")

By default, you will have the latest version. If a newer version is released, we notify through email and your workers will update automatically the next time your workers are relaunched or restarted. If you want to pin your workers to a specific version, you'll have to select one of these versions from the dropdown.

### Global timeout [â€‹](https://docs.browserless.io/enterprise/private-deployment/worker-settings\#global-timeout "Direct link to Global timeout")

Once the duration of your session reaches the global timeout, it will be terminated.

If your session runs into an exception and your script doesn't handle it properly, your browser process might not exit properly, causing it to hang and remain open, which leads to consuming unnecessary resources, until it reaches the global timeout. It's always a best practice to [implement exception handling in your scripts](https://hackernoon.com/7-tips-to-making-your-puppeteer-scripts-more-bulletproof) to avoid this.

## Concurrency and Queue [â€‹](https://docs.browserless.io/enterprise/private-deployment/worker-settings\#concurrency-and-queue "Direct link to Concurrency and Queue")

The max concurrency and queue can be modified by using the slider.

### Concurrency tips [â€‹](https://docs.browserless.io/enterprise/private-deployment/worker-settings\#concurrency-tips "Direct link to Concurrency tips")

If you experience many timeouts/errors and rarely see queued sessions, your worker may be running out of resources and your worker is getting gridlocked. You can limit the max concurrency so that sessions don't run out of resources and hit the queue faster.

### Queue tips [â€‹](https://docs.browserless.io/enterprise/private-deployment/worker-settings\#queue-tips "Direct link to Queue tips")

If you use an external queueing system, you'll want to set your queue to 0, so that we return an error immediately after your concurrency limit has been reached. Bear in mind this feature may not be 100% flawless, due to the async implementation, a request may slip through the cracks if two requests are being received by the server exactly at the same time, so don't panic if a request gets queued even when set to 0.

## Session health checks [â€‹](https://docs.browserless.io/enterprise/private-deployment/worker-settings\#session-health-checks "Direct link to Session health checks")

If this feature is checked on, your worker will check the health of your worker before a session connects, be it an api call or library call; if the load balancer determines your worker(s) can't handle another request, it will throw a 5xx response code. Disabling this will send the requests to your worker blindly, forcing it to take the request independently of the health of the worker.

## Stealth mode [â€‹](https://docs.browserless.io/enterprise/private-deployment/worker-settings\#stealth-mode "Direct link to Stealth mode")

This feature implements puppeteer-extra-plugin-stealth, which injects user behavior to your page, helping your sessions avoid basic bot detecting techniques.

## Experimental features [â€‹](https://docs.browserless.io/enterprise/private-deployment/worker-settings\#experimental-features "Direct link to Experimental features")

The following features are experimental, which means they are to be used with caution, since they can have caveats you should consider before enabling them.

### Enable GET APIs [â€‹](https://docs.browserless.io/enterprise/private-deployment/worker-settings\#enable-get-apis "Direct link to Enable GET APIs")

This feature allows you to enable special /GET handlers for our APIs. This is handy for cases where you need to directly call our services from a cache-layer like a CDN. Read more information on the [/GET APIs](https://www.browserless.io/docs/api-get).

Please do not call the hosted service from the browser as it will reveal your secret token!

### Automatic health restarts [â€‹](https://docs.browserless.io/enterprise/private-deployment/worker-settings\#automatic-health-restarts "Direct link to Automatic health restarts")

This feature will restart your worker automatically when CPU or Memory usage are above 100% for a period of time (by default 5 minutes). Read more about [exiting on health failure](https://www.browserless.io/docs/docker.html#exit-on-health-failure)

- [Puppeteer version and global timeout](https://docs.browserless.io/enterprise/private-deployment/worker-settings#puppeteer-version-and-global-timeout)
  - [Supported chrome/puppeteer versions](https://docs.browserless.io/enterprise/private-deployment/worker-settings#supported-chromepuppeteer-versions)
  - [Global timeout](https://docs.browserless.io/enterprise/private-deployment/worker-settings#global-timeout)
- [Concurrency and Queue](https://docs.browserless.io/enterprise/private-deployment/worker-settings#concurrency-and-queue)
  - [Concurrency tips](https://docs.browserless.io/enterprise/private-deployment/worker-settings#concurrency-tips)
  - [Queue tips](https://docs.browserless.io/enterprise/private-deployment/worker-settings#queue-tips)
- [Session health checks](https://docs.browserless.io/enterprise/private-deployment/worker-settings#session-health-checks)
- [Stealth mode](https://docs.browserless.io/enterprise/private-deployment/worker-settings#stealth-mode)
- [Experimental features](https://docs.browserless.io/enterprise/private-deployment/worker-settings#experimental-features)
  - [Enable GET APIs](https://docs.browserless.io/enterprise/private-deployment/worker-settings#enable-get-apis)
  - [Automatic health restarts](https://docs.browserless.io/enterprise/private-deployment/worker-settings#automatic-health-restarts)

---

### Enterprise Quick Start | Browserless.io
Original URL: https://docs.browserless.io/enterprise/quick-start

[Skip to main content](https://docs.browserless.io/enterprise/quick-start#__docusaurus_skipToContent_fallback)


Welcome to Browserless Enterprise! This guide will help you quickly get started with our Enterprise offerings and understand the key features available to you.

## What is Browserless Enterprise? [â€‹](https://docs.browserless.io/enterprise/quick-start\#what-is-browserless-enterprise "Direct link to What is Browserless Enterprise?")

Browserless Enterprise provides advanced features and capabilities for organizations that need:

- Self-hosted browser automation infrastructure
- Private deployments with custom configurations
- Advanced monitoring and debugging tools
- High-volume browser automation at scale

## Getting Started [â€‹](https://docs.browserless.io/enterprise/quick-start\#getting-started "Direct link to Getting Started")

### 1\. Choose Your Deployment Option [â€‹](https://docs.browserless.io/enterprise/quick-start\#1-choose-your-deployment-option "Direct link to 1. Choose Your Deployment Option")

Browserless Enterprise can be deployed in several ways:

- **Docker**: Run Browserless in your own infrastructure using our Docker images
- **Private Deployment**: Custom-tailored deployments for your specific needs
- **Cloud Enterprise**: Managed enterprise-grade browser automation in our cloud

### 2\. Set Up Your Environment [â€‹](https://docs.browserless.io/enterprise/quick-start\#2-set-up-your-environment "Direct link to 2. Set Up Your Environment")

#### Docker Quick Start [â€‹](https://docs.browserless.io/enterprise/quick-start\#docker-quick-start "Direct link to Docker Quick Start")

The fastest way to get started with Browserless Enterprise is using our Docker image:

```codeBlockLines_p187
docker run \
  --rm \
  -p 3000:3000 \
  -e "CONCURRENT=10" \
  -e "TOKEN=YOUR_TOKEN" \
  ghcr.io/browserless/chromium

```

Visit [Docker Quick Start](https://docs.browserless.io/enterprise/docker/quickstart) for more detailed instructions.

#### Private Deployment [â€‹](https://docs.browserless.io/enterprise/quick-start\#private-deployment "Direct link to Private Deployment")

For custom deployments, our team will work with you to set up Browserless in your environment according to your specific requirements. [Contact us](https://www.browserless.io/contact) to discuss your needs.

### 3\. Connect Your Application [â€‹](https://docs.browserless.io/enterprise/quick-start\#3-connect-your-application "Direct link to 3. Connect Your Application")

Once your Browserless Enterprise instance is running, connect your application using Puppeteer, Playwright, or other supported libraries:

```codeBlockLines_p187
// Puppeteer example
const browser = await puppeteer.connect({
  browserWSEndpoint: "ws://localhost:3000?token=YOUR_TOKEN",
});

```

## Key Enterprise Features [â€‹](https://docs.browserless.io/enterprise/quick-start\#key-enterprise-features "Direct link to Key Enterprise Features")

### User Data Directory [â€‹](https://docs.browserless.io/enterprise/quick-start\#user-data-directory "Direct link to User Data Directory")

Persist browser sessions and cookies between runs with [User Data Directory](https://docs.browserless.io/enterprise/user-data-directory) support.

### Watching Sessions [â€‹](https://docs.browserless.io/enterprise/quick-start\#watching-sessions "Direct link to Watching Sessions")

Monitor and debug browser sessions in real-time with the [Session Watching](https://docs.browserless.io/enterprise/watching-sessions) feature.

### Live Debugger [â€‹](https://docs.browserless.io/enterprise/quick-start\#live-debugger "Direct link to Live Debugger")

Interactively debug your browser automation scripts with the [Live Debugger](https://docs.browserless.io/enterprise/live-debugger).

### Utility Functions [â€‹](https://docs.browserless.io/enterprise/quick-start\#utility-functions "Direct link to Utility Functions")

Access powerful utility functions for [session management](https://docs.browserless.io/enterprise/utility-functions/sessions), [configuration](https://docs.browserless.io/enterprise/utility-functions/config), and [metrics](https://docs.browserless.io/enterprise/utility-functions/metrics).

## Next Steps [â€‹](https://docs.browserless.io/enterprise/quick-start\#next-steps "Direct link to Next Steps")

- Learn about [Browserless Terminology](https://docs.browserless.io/enterprise/terminology)
- Explore [Docker Configuration](https://docs.browserless.io/enterprise/docker/configuration)
- Set up [Private Deployment](https://docs.browserless.io/enterprise/private-deployment/graphql-api)
- Understand [Worker Settings](https://docs.browserless.io/enterprise/private-deployment/worker-settings)

For any questions or assistance, [contact our support team](https://www.browserless.io/contact).

- [What is Browserless Enterprise?](https://docs.browserless.io/enterprise/quick-start#what-is-browserless-enterprise)
- [Getting Started](https://docs.browserless.io/enterprise/quick-start#getting-started)
  - [1\. Choose Your Deployment Option](https://docs.browserless.io/enterprise/quick-start#1-choose-your-deployment-option)
  - [2\. Set Up Your Environment](https://docs.browserless.io/enterprise/quick-start#2-set-up-your-environment)
  - [3\. Connect Your Application](https://docs.browserless.io/enterprise/quick-start#3-connect-your-application)
- [Key Enterprise Features](https://docs.browserless.io/enterprise/quick-start#key-enterprise-features)
  - [User Data Directory](https://docs.browserless.io/enterprise/quick-start#user-data-directory)
  - [Watching Sessions](https://docs.browserless.io/enterprise/quick-start#watching-sessions)
  - [Live Debugger](https://docs.browserless.io/enterprise/quick-start#live-debugger)
  - [Utility Functions](https://docs.browserless.io/enterprise/quick-start#utility-functions)
- [Next Steps](https://docs.browserless.io/enterprise/quick-start#next-steps)

---

### Terminology | Browserless.io
Original URL: https://docs.browserless.io/enterprise/terminology

[Skip to main content](https://docs.browserless.io/enterprise/terminology#__docusaurus_skipToContent_fallback)


On the main [browserless.io](https://www.browserless.io/) site, and inside this documentation site, you'll notice we use a few terms like "worker" or "session". Below is a list of commonly-used terms and what they mean.

### Worker [â€‹](https://docs.browserless.io/enterprise/terminology\#worker "Direct link to Worker")

A worker is an instance of the Browserless container running on a virtual-machine. Our Cloud-Unit plans utilize a massive fleet of workers to handle the traffic needs of many users, and Enterprise users can engage with us and we'll provide the right size and quantity of workers in order to fulfill their needs.

### Session [â€‹](https://docs.browserless.io/enterprise/terminology\#session "Direct link to Session")

A session is anytime Chrome is actively running and connected to. Browserless, however, automatically queues up to 2X this amount without any changes in your app's code. This allows you to set a baseline of concurrently running traffic, but allows for "bursts" of traffic without having to adjust any of your code (just keep using `puppeteer.connect`).

If more sessions are needed, you can either upgrade your worker's size or launch more instances of them to handle traffic.

### Pressure [â€‹](https://docs.browserless.io/enterprise/terminology\#pressure "Direct link to Pressure")

Pressure indicates how much traffic is going on in your workers at any given time. Using the GraphQL API, you can fetch important details like `isAvailable` to see if your workers can handle another connection. Doing so will ensure your accout doesn't get overloaded and become unresponsive.

```codeBlockLines_p187
# https://api.browserless.io/graphql
{
  pressure(apiToken: "YOUR_API_KEY") {
    running
    recentlyRejected
    queued
    isAvailable
    date
  }
}

```

This request will return a JSON object with the following payload:

```codeBlockLines_p187
// JSON returned
{
  "data": {
    "pressure": {
      "running": 0,
      "recentlyRejected": 0,
      "queued": 0,
      "isAvailable": true,
      "date": 1524762532204
    }
  }
}

```

- [Worker](https://docs.browserless.io/enterprise/terminology#worker)
- [Session](https://docs.browserless.io/enterprise/terminology#session)
- [Pressure](https://docs.browserless.io/enterprise/terminology#pressure)

---

### User Data Directory for persisting sessions | Browserless.io
Original URL: https://docs.browserless.io/enterprise/user-data-directory

[Skip to main content](https://docs.browserless.io/enterprise/user-data-directory#__docusaurus_skipToContent_fallback)


The `--user-data-dir` flag in browserless allows you to persist browser data such as cookies, localStorage, cache, and login sessions across multiple browser sessions. This is particularly useful for maintaining authenticated states and user preferences without having to re-authenticate or reconfigure settings each time.

note

The `--user-data-dir` feature is only available for Enterprise plans with dedicated fleets. It cannot be used with shared plans.

## Important details when implementing User Data Directories [â€‹](https://docs.browserless.io/enterprise/user-data-directory\#important-details-when-implementing-user-data-directories "Direct link to Important details when implementing User Data Directories")

The directory will be created if it doesn't exist. When using `--user-data-dir`, make sure to use a unique directory path for each different browser profile you want to maintain. You can only instantiate one browser per userdatadir at a time, meaning it's 1-1 and you can't use the same path in the flag for multiple concurrent browsers.

### Pointing to a specific dedicated worker on Enterprise plans [â€‹](https://docs.browserless.io/enterprise/user-data-directory\#pointing-to-a-specific-dedicated-worker-on-enterprise-plans "Direct link to Pointing to a specific dedicated worker on Enterprise plans")

User data directories are stored locally on each worker's file system and do not sync across your fleet. For example, a browser instance using `--user-data-dir=~/u/1` on Worker #1 will not be accessible from Worker #2. No need to worry! Browserless allows you to point at a specific worker by using the endpoint provided on your account page under "Production" Clusters. Click on the cell under the Address column to copy the endpoint for the worker you need. You'll want to keep track of which browser session was persisted initially on which worker to ensure consistent access.

- Your BQL endpoints would change from `https://chrome.browserless.io/bql` to something like `https://chrome.browserless.io/p/53616c7465645f5ff8cc738d5eecb3032823d67e37578fe4531b0f9a83dc80856c66d0fe36aba4d2f4bc5f01c18bdfab/bql?token=YOUR_API_TOKEN_HERE&--user-data-dir=~/custompath/123`
- Your websocket connections would change from `wss://chrome.browserless.io/chromium` to something like `wss://chrome.browserless.io/p/53616c7465645f5ff8cc738d5eecb3032823d67e37578fe4531b0f9a83dc80856c66d0fe36aba4d2f4bc5f01c18bdfab/chromium?token=YOUR_API_TOKEN_HERE&--user-data-dir=~/custompath/456`

## Using the userdatadir with Puppeteer and Playwright [â€‹](https://docs.browserless.io/enterprise/user-data-directory\#using-the-userdatadir-with-puppeteer-and-playwright "Direct link to Using the userdatadir with Puppeteer and Playwright")

The following examples demonstrate how to use the `--user-data-dir` flag with both Puppeteer and Playwright. These examples show how to persist a login session to browserless.io - once you log in and close the tab, running the script again will show you already logged in.

- Puppeteer
- Playwright

```codeBlockLines_p187
import puppeteer from 'puppeteer-core';

const launchArgs = {
  headless: false,
  args: ['--user-data-dir=~/u/1']
};

const queryParams = new URLSearchParams({
  token: "YOUR_API_TOKEN_HERE", //this script using userdatadir only works for dedicated machines
  timeout: 300000,
  launch: JSON.stringify(launchArgs)
}).toString();

(async () => {
  let browser;
  try {
    browser = await puppeteer.connect({
      browserWSEndpoint: `wss://chrome.browserless.io/chromium?${queryParams}`,
      defaultViewport: null
    });

    console.log('Connected');

    const page = await browser.newPage();
    await page.goto('https://account.browserless.io/', {
      waitUntil: 'domcontentloaded'
    });

    console.log('Navigated');

    const client = await page.target().createCDPSession();
    const { liveURL } = await client.send('Browserless.liveURL', {
      timeout: 300000
    });

    console.log('Click for live experience:', liveURL);

    await new Promise((resolve) => {
      client.on('Browserless.liveComplete', resolve);
    });

    console.log(`Live URL closed on page: ${page.url()}`);

    await browser.close();
  } catch (error) {
    console.error('An error occurred:', error);
    if (browser) {
      await browser.close().catch(console.error);
    }
    throw error;
  }
})().catch(error => {
  console.error('Fatal error:', error);
});

```

```codeBlockLines_p187
import { chromium } from 'playwright-core';

const launchArgs = {
  headless: false,
  stealth: true,
  args: ['--user-data-dir=~/u/1']
};
const queryParams = new URLSearchParams({
  token: "YOUR_API_TOKEN_HERE", //this script using userdatadir only works for dedicated machines
  timeout: 300000,
  launch: JSON.stringify(launchArgs)
}).toString();

(async () => {
  let browser;
  try {
    browser = await chromium.connectOverCDP(
      `wss://chrome.browserless.io/chromium/stealth?${queryParams}`
    );
    console.log('Connected');
    const [context] = await browser.contexts();
    const page = await context.newPage();
    await page.goto('https://account.browserless.io/', {
      waitUntil: 'domcontentloaded'
    });
    console.log('Navigated');
    const cdpSession = await context.newCDPSession(page);
    const { liveURL } = await cdpSession.send('Browserless.liveURL', {
      timeout: 300000
    });
    console.log('Click for live experience:', liveURL);
    await new Promise((resolve) => {
      cdpSession.on('Browserless.liveComplete', resolve);
    });

    console.log(`Live URL closed on page: ${page.url()}`);

    await browser.close();
  } catch (error) {
    console.error('An error occurred:', error);
    if (browser) {
      await browser.close().catch(console.error);
    }
    throw error;
  }
})().catch(error => {
  console.error('Fatal error:', error);
});

```

## Using with BrowserQL [â€‹](https://docs.browserless.io/enterprise/user-data-directory\#using-with-browserql "Direct link to Using with BrowserQL")

The following example demonstrates how to use the `--user-data-dir` flag with BrowserQL to persist browser state. This example shows how to toggle dark mode on w3schools.com - each time you run it, the initial state will be different since it's persisting the toggle state from previous runs.

```codeBlockLines_p187
import puppeteer from 'puppeteer-core';

const url = 'https://www.browserless.io/';
const token = 'YOUR_API_TOKEN_HERE'; //this script using userdatadir only works for dedicated machines
const timeout = 5 * 60 * 1000;
const launchArgs = {
  args: ['--user-data-dir=~/id-togle-test-123']
};
const queryParams = new URLSearchParams({
  timeout,
  token,
  launch: JSON.stringify(launchArgs)
}).toString();

const query = `
  mutation DarkModeToggle {
    goto(url: "https://www.w3schools.com/", waitUntil: domContentLoaded) {
      status
    }
    DarkModeClassBefore:evaluate(content: "document.body.className") {
      value
    }
    click(selector:"#tnb-dark-mode-toggle-btn"){
      time
    }
    DarkModeClassAfter:evaluate(content: "document.body.className") {
      value
    }
  }
`;

const variables = { url };

const endpoint =
  `https://chrome.browserless.io/chromium/bql?${queryParams}`;

const options = {
  method: 'POST',
  headers: {
    'content-type': 'application/json'
  },
  body: JSON.stringify({
    query,
  }),
};

try {
  console.log(`Running BQL Query: ${url}`);

  const response = await fetch(endpoint, options);

  if (!response.ok) {
    throw new Error(`Got non-ok response:\n` + (await response.text()));
  }

  const { data } = await response.json();

  console.log("Full response data:", JSON.stringify(data, null, 2));

  if (data && data.DarkModeClassBefore && data.DarkModeClassAfter) {
    console.log("Dark mode toggle results:");
    console.log("Before:", data.DarkModeClassBefore.value);
    console.log("After:", data.DarkModeClassAfter.value);
    console.log("Click time:", data.click.time, "ms");
  } else {
    console.log("Unexpected response structure:", data);
  }
} catch (error) {
  console.error(error);
}

```

- [Important details when implementing User Data Directories](https://docs.browserless.io/enterprise/user-data-directory#important-details-when-implementing-user-data-directories)
  - [Pointing to a specific dedicated worker on Enterprise plans](https://docs.browserless.io/enterprise/user-data-directory#pointing-to-a-specific-dedicated-worker-on-enterprise-plans)
- [Using the userdatadir with Puppeteer and Playwright](https://docs.browserless.io/enterprise/user-data-directory#using-the-userdatadir-with-puppeteer-and-playwright)
- [Using with BrowserQL](https://docs.browserless.io/enterprise/user-data-directory#using-with-browserql)

---

### /config API | Browserless.io
Original URL: https://docs.browserless.io/enterprise/utility-functions/config

[Skip to main content](https://docs.browserless.io/enterprise/utility-functions/config#__docusaurus_skipToContent_fallback)


The `/config` API will give you information about your worker's configuration, **and is only available for dedicated and self-hosted accounts**

You can [check the full Open API schema here](https://docs.browserless.io/open-api#tag/Management-REST-APIs/paths/~1config/get).

## Get your worker's configuration [â€‹](https://docs.browserless.io/enterprise/utility-functions/config\#get-your-workers-configuration "Direct link to Get your worker's configuration")

To see your current configuration, simply issue a `GET` request to `/sessions`:

- cURL
- Javascript
- Python
- Java
- C#

```codeBlockLines_p187
curl -X GET \
  https://production-sfo.browserless.io/config?token=YOUR_API_TOKEN_HERE

```

```codeBlockLines_p187
const TOKEN = "YOUR_API_TOKEN_HERE";
const url = `https://production-sfo.browserless.io/config?token=${TOKEN}`;

const fetchConfig = async () => {
  const response = await fetch(url, {
    method: 'GET'
  });

  const result = await response.json();
  console.log(result);
};

fetchConfig();

```

```codeBlockLines_p187
import requests

TOKEN = "YOUR_API_TOKEN_HERE"
url = f"https://production-sfo.browserless.io/config?token={TOKEN}"

response = requests.get(url)
result = response.json()

print(result)

```

```codeBlockLines_p187
import java.io.*;
import java.net.URI;
import java.net.http.*;

public class FetchConfig {
    public static void main(String[] args) {
        String TOKEN = "YOUR_API_TOKEN_HERE";
        String url = "https://production-sfo.browserless.io/config?token=" + TOKEN;

        HttpClient client = HttpClient.newHttpClient();

        HttpRequest request = HttpRequest.newBuilder()
            .uri(URI.create(url))
            .GET()
            .build();

        try {
            HttpResponse<String> response = client.send(request, HttpResponse.BodyHandlers.ofString());
            System.out.println("Response: " + response.body());
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

```

```codeBlockLines_p187
using System;
using System.Net.Http;
using System.Threading.Tasks;

class Program {
    static async Task Main(string[] args) {
        string TOKEN = "YOUR_API_TOKEN_HERE";
        string url = $"https://production-sfo.browserless.io/config?token={TOKEN}";

        using var client = new HttpClient();

        try {
            var response = await client.GetAsync(url);
            response.EnsureSuccessStatusCode();

            var result = await response.Content.ReadAsStringAsync();
            Console.WriteLine("Response: " + result);
        } catch (Exception ex) {
            Console.WriteLine($"Error: {ex.Message}");
        }
    }
}

```

Running this request will result in an JSON output like:

```codeBlockLines_p187
{
  "allowCORS": true,
  "allowFileProtocol": false,
  "allowGetCalls": false,
  "concurrent": 10,
  "data": "/tmp/browserless-data-dirs",
  "debug": "browserless*,-**:verbose",
  "errorAlertURL": null,
  "healthFailureURL": null,
  "host": "localhost",
  "maxCPU": 99,
  "maxMemory": 99,
  "metricsJSONPath": "/tmp/browserless-metrics.json",
  "port": 3001,
  "queued": 10,
  "queuedAlertURL": null,
  "rejectAlertURL": null,
  "retries": 5,
  "timeout": 30000,
  "timeoutAlertURL": null,
  "token": "6R0W53R135510"
}

```

- [Get your worker's configuration](https://docs.browserless.io/enterprise/utility-functions/config#get-your-workers-configuration)

---

### Utility Functions Overview | Browserless.io
Original URL: https://docs.browserless.io/enterprise/utility-functions/intro

[Skip to main content](https://docs.browserless.io/enterprise/utility-functions/intro#__docusaurus_skipToContent_fallback)


Browserless provides specialized utility functions for managing and monitoring your private deployments. These functions are primarily relevant for users with private or self-hosted deployments who need to access usage metrics, session information, and configuration details.

## Available Utility Functions [â€‹](https://docs.browserless.io/enterprise/utility-functions/intro\#available-utility-functions "Direct link to Available Utility Functions")

- [/sessions](https://docs.browserless.io/enterprise/utility-functions/sessions) \- Gather information about currently running browser sessions
- [/metrics](https://docs.browserless.io/enterprise/utility-functions/metrics) \- Retrieve usage metrics and performance data
- [/config](https://docs.browserless.io/enterprise/utility-functions/config) \- Access configuration information about your workers

These utility functions provide valuable insights for monitoring the health and performance of your Browserless deployment, allowing you to optimize resource usage and troubleshoot issues.

note

Utility Functions are primarily intended for dedicated and self-hosted accounts. Some functions may not be available on shared plans.

- [Available Utility Functions](https://docs.browserless.io/enterprise/utility-functions/intro#available-utility-functions)

---

### /metrics API | Browserless.io
Original URL: https://docs.browserless.io/enterprise/utility-functions/metrics

[Skip to main content](https://docs.browserless.io/enterprise/utility-functions/metrics#__docusaurus_skipToContent_fallback)


The metrics API allows you to retrieve an array of session statistics. The data returned will have a maximum date of 1 week.

You can [check the full Open API schema here](https://docs.browserless.io/open-api#tag/Management-REST-APIs/paths/~1metrics/get).

## Gathering metrics from your workers [â€‹](https://docs.browserless.io/enterprise/utility-functions/metrics\#gathering-metrics-from-your-workers "Direct link to Gathering metrics from your workers")

To see statistics regarding your workers, simply issue a `GET` request to `/metrics`:

- cURL
- Javascript
- Python
- Java
- C#

```codeBlockLines_p187
curl -X GET \
  https://production-sfo.browserless.io/metrics?token=YOUR_API_TOKEN_HERE

```

```codeBlockLines_p187
const TOKEN = "YOUR_API_TOKEN_HERE";
const url = `https://production-sfo.browserless.io/metrics?token=${TOKEN}`;

const fetchMetrics = async () => {
  const response = await fetch(url, {
    method: 'GET'
  });

  const result = await response.json();
  console.log(result);
};

fetchMetrics();

```

```codeBlockLines_p187
import requests

TOKEN = "YOUR_API_TOKEN_HERE"
url = f"https://production-sfo.browserless.io/metrics?token={TOKEN}"

response = requests.get(url)
result = response.json()

print(result)

```

```codeBlockLines_p187
import java.io.*;
import java.net.URI;
import java.net.http.*;

public class FetchMetrics {
    public static void main(String[] args) {
        String TOKEN = "YOUR_API_TOKEN_HERE";
        String url = "https://production-sfo.browserless.io/metrics?token=" + TOKEN;

        HttpClient client = HttpClient.newHttpClient();

        HttpRequest request = HttpRequest.newBuilder()
            .uri(URI.create(url))
            .GET()
            .build();

        try {
            HttpResponse<String> response = client.send(request, HttpResponse.BodyHandlers.ofString());
            System.out.println("Response: " + response.body());
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

```

```codeBlockLines_p187
using System;
using System.Net.Http;
using System.Threading.Tasks;

class Program {
    static async Task Main(string[] args) {
        string TOKEN = "YOUR_API_TOKEN_HERE";
        string url = $"https://production-sfo.browserless.io/metrics?token={TOKEN}";

        using var client = new HttpClient();

        try {
            var response = await client.GetAsync(url);
            response.EnsureSuccessStatusCode();

            var result = await response.Content.ReadAsStringAsync();
            Console.WriteLine("Response: " + result);
        } catch (Exception ex) {
            Console.WriteLine($"Error: {ex.Message}");
        }
    }
}

```

warning

Remember that running this in the browser will expose your API key!

Running this request will result in an output like:

```codeBlockLines_p187
[\
  {\
    "error": 3,\
    "maxConcurrent": 4,\
    "queued": 0,\
    "rejected": 0,\
    "running": 3,\
    "sessionTimes": [992, 1041, 802],\
    "successful": 0,\
    "timedout": 0,\
    "unauthorized": 0,\
    "unhealthy": 0,\
    "maxTime": 1041,\
    "meanTime": 945,\
    "minTime": 802,\
    "totalTime": 2835,\
    "units": 3,\
    "date": 1709134233732,\
    "cpu": 0.024877870173220466,\
    "memory": 0.7784158564199399\
  },\
  // ...\
]

```

### /metrics/total [â€‹](https://docs.browserless.io/enterprise/utility-functions/metrics\#metricstotal "Direct link to /metrics/total")

This route will output a similar payload, but with the total stats of all sessions.

- [Gathering metrics from your workers](https://docs.browserless.io/enterprise/utility-functions/metrics#gathering-metrics-from-your-workers)
  - [/metrics/total](https://docs.browserless.io/enterprise/utility-functions/metrics#metricstotal)

---

### /sessions API | Browserless.io
Original URL: https://docs.browserless.io/enterprise/utility-functions/sessions

[Skip to main content](https://docs.browserless.io/enterprise/utility-functions/sessions#__docusaurus_skipToContent_fallback)


The sessions API allows you to gather information about the currently running sessions **and is only available for dedicated and self-hosted accounts**

You can [check the full Open API schema here](https://docs.browserless.io/open-api#tag/Management-REST-APIs/paths/~1sessions/get).

## Gathering information from your running sessions [â€‹](https://docs.browserless.io/enterprise/utility-functions/sessions\#gathering-information-from-your-running-sessions "Direct link to Gathering information from your running sessions")

To see information regarding the running sessions, simply issue a `GET` request to `/sessions`:

- cURL
- Javascript
- Python
- Java
- C#

```codeBlockLines_p187
curl -X GET \
  https://production-sfo.browserless.io/sessions?token=YOUR_API_TOKEN_HERE

```

```codeBlockLines_p187
const TOKEN = "YOUR_API_TOKEN_HERE";
const url = `https://production-sfo.browserless.io/sessions?token=${TOKEN}`;

const fetchSessions = async () => {
  const response = await fetch(url, {
    method: 'GET'
  });

  const result = await response.json();
  console.log(result);
};

fetchSessions();

```

```codeBlockLines_p187
import requests

TOKEN = "YOUR_API_TOKEN_HERE"
url = f"https://production-sfo.browserless.io/sessions?token={TOKEN}"

response = requests.get(url)
result = response.json()

print(result)

```

```codeBlockLines_p187
import java.io.*;
import java.net.URI;
import java.net.http.*;

public class FetchSessions {
    public static void main(String[] args) {
        String TOKEN = "YOUR_API_TOKEN_HERE";
        String url = "https://production-sfo.browserless.io/sessions?token=" + TOKEN;

        HttpClient client = HttpClient.newHttpClient();

        HttpRequest request = HttpRequest.newBuilder()
            .uri(URI.create(url))
            .GET()
            .build();

        try {
            HttpResponse<String> response = client.send(request, HttpResponse.BodyHandlers.ofString());
            System.out.println("Response: " + response.body());
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

```

```codeBlockLines_p187
using System;
using System.Net.Http;
using System.Threading.Tasks;

class Program {
    static async Task Main(string[] args) {
        string TOKEN = "YOUR_API_TOKEN_HERE";
        string url = $"https://production-sfo.browserless.io/sessions?token={TOKEN}";

        using var client = new HttpClient();

        try {
            var response = await client.GetAsync(url);
            response.EnsureSuccessStatusCode();

            var result = await response.Content.ReadAsStringAsync();
            Console.WriteLine("Response: " + result);
        } catch (Exception ex) {
            Console.WriteLine($"Error: {ex.Message}");
        }
    }
}

```

warning

Remember that running this in the browser will expose your API key!

Running this request will result in an output like:

```codeBlockLines_p187
[{\
  "id": null,\
  "initialConnectURL": "wss://production-sfo.browserless.io/firefox/playwright/?token=YOUR_API_TOKEN_HERE",\
  "isTempDataDir": true,\
  "launchOptions": {},\
  "numbConnected": 1,\
  "routePath": ["/firefox/playwright", "/firefox/playwright"],\
  "startedOn": 1709584439748,\
  "ttl": 0,\
  "userDataDir": null,\
  "browser": "FirefoxPlaywright",\
  "browserId": "d9a8570a73666d79d79ac23f07cf8966",\
  "killURL": null,\
  "running": true,\
  "timeAliveMs": 10118,\
  "type": "browser"\
}]

```

- [Gathering information from your running sessions](https://docs.browserless.io/enterprise/utility-functions/sessions#gathering-information-from-your-running-sessions)

---

### Watching your sessions | Browserless.io
Original URL: https://docs.browserless.io/enterprise/watching-sessions

[Skip to main content](https://docs.browserless.io/enterprise/watching-sessions#__docusaurus_skipToContent_fallback)


Both the Browserless docker image, and Dedicated hosted plans, have the ability to watch sessions as they run. As with most of our APIs and features, they're strongly geared towards engineers building on top of Browserless. It's with these engineers in mind that we've written this document on how to watch your sessions as you work, broken up into three different methods.

## Watching sessions on the docker image [â€‹](https://docs.browserless.io/enterprise/watching-sessions\#watching-sessions-on-the-docker-image "Direct link to Watching sessions on the docker image")

To use the session viewer on the docker image, you don't need to do anything special in your code or how you connect to Browserless. The only change you might make is add a `id` to your connect call in order to sort or filter sessions to the one you care about.

In any case, the first step is to start the container as usual:

```codeBlockLines_p187
$ docker run --rm -p 3000:3000 ghcr.io/browserless/chrome

```

Then, in your application or script connect to it.

- Puppeteer
- Playwright

```codeBlockLines_p187
import puppeteer from "puppeteer";

const browser = await puppeteer.connect({
  browserWSEndpoint: `wss://chrome.browserless.io?token=YOUR_API_TOKEN_HERE`,
});
const page = await browser.newPage();
await page.goto("https://example.com/");
await browser.close();

```

- Javascript
- Python
- Java
- C#

```codeBlockLines_p187
import { chromium } from "playwright-core";

(async () => {
  const browser = await chromium.connectOverCDP(
    `wss://chrome.browserless.io?token=YOUR_API_TOKEN_HERE`
  );

  // Create a new context and page
  const context = browser.contexts()[0] || (await browser.newContext());
  const page = await context.newPage();

  // Navigate to the URL
  await page.goto("https://example.com/");
  console.log("Page loaded successfully");

  // Close the browser
  await browser.close();
})();

```

```codeBlockLines_p187
import asyncio
from playwright.async_api import async_playwright

WS_ENDPOINT = "wss://chrome.browserless.io?token=YOUR_API_TOKEN_HERE"

async def main():
    async with async_playwright() as p:
        browser = await p.chromium.connect_over_cdp(WS_ENDPOINT)

        # Use existing context or create a new one
        context = browser.contexts[0] if browser.contexts else await browser.new_context()
        page = await context.new_page()

        await page.goto("https://example.com/")
        print("Page loaded successfully")

        await browser.close()

asyncio.run(main())

```

```codeBlockLines_p187
import com.microsoft.playwright.*;

public class PlaywrightRemoteBrowser {
    public static void main(String[] args) {
        String wsEndpoint = "wss://chrome.browserless.io?token=YOUR_API_TOKEN_HERE";

        try (Playwright playwright = Playwright.create()) {
            Browser browser = playwright.chromium().connectOverCDP(wsEndpoint);

            // Use existing context or create a new one
            BrowserContext context = browser.contexts().isEmpty()
                ? browser.newContext()
                : browser.contexts().get(0);

            Page page = context.newPage();

            page.navigate("https://example.com/");
            System.out.println("Page loaded successfully");

            browser.close();
        }
    }
}

```

```codeBlockLines_p187
using System;
using System.Threading.Tasks;
using Microsoft.Playwright;

class Program
{
    static async Task Main(string[] args)
    {
        string wsEndpoint = "wss://chrome.browserless.io?token=YOUR_API_TOKEN_HERE";

        var playwright = await Playwright.CreateAsync();
        var browser = await playwright.Chromium.ConnectOverCDPAsync(wsEndpoint);

        // Use existing context or create a new one
        var context = browser.Contexts.Count > 0
            ? browser.Contexts[0]
            : await browser.NewContextAsync();

        var page = await context.NewPageAsync();

        await page.GotoAsync("https://example.com/");
        Console.WriteLine("Page loaded successfully");

        await browser.CloseAsync();
    }
}

```

In your browser, you can go to [http://localhost:3000/sessions](http://localhost:3000/sessions) to get a JSON of the running sessions.

info

If your session is immediately closing, then you can keep it open by _not_ calling `browser.close` at the end (just remember to terminate your script with CTRL+C or similar).

## Using the Sessions tab in the Dedicated plans [â€‹](https://docs.browserless.io/enterprise/watching-sessions\#using-the-sessions-tab-in-the-dedicated-plans "Direct link to Using the Sessions tab in the Dedicated plans")

In Dedicated plans, you can see your active sessions at any time by going to the Sessions portion of the account page.

Pressing the "Fetch Running Sessions" button will retrieve actively running sessions across all your workers, and show them here. The "Debugger" Link will then open up the page that you can run and view these sessions.

Anytime you connect, you can immediately see the results here after pushing the "Fetch Running Sessions" button.

## Programmatically watching your sessions on Dedicated plans [â€‹](https://docs.browserless.io/enterprise/watching-sessions\#programmatically-watching-your-sessions-on-dedicated-plans "Direct link to Programmatically watching your sessions on Dedicated plans")

Thanks to our powerful GraphQL API, you can programmatically retrieve your running sessions with a simple GraphQL API call. This simple feature allows you to build powerful integrations against browserless: end-users are able to witness their automation running, engineers can debug live production issues, and you can more easily pinpoint problems in your scripts.

When setting this up, you'll want to ensure that you don't accidentally expose your sessions to other users. It's for this reason that we've create a `id`, which allows you to filter and more easily distinguish between running sessions.

For those that want to see the full example, see below. We'll break it down step-by-step afterwards.

**TL;DR the goods**

- Puppeteer
- Playwright

```codeBlockLines_p187
import puppeteer from "puppeteer";

const apiToken = "YOUR_API_TOKEN_HERE";
const id = "some-unique-id";

const getSessionsById = (id) => {
  return fetch("https://api.browserless.io/graphql", {
    method: "POST",
    headers: {
      "content-type": "application/json",
    },
    body: JSON.stringify({
      query: `
        query getSessions($id: String!, $apiToken: String!) {
          sessions(apiToken: $apiToken, id: $id) {
            description
            devtoolsFrontendUrl
            id
            title
            url
            id
            browserId
            browserWSEndpoint
          }
        }
      `,
      variables: {
        id,
        apiToken,
      },
    }),
  })
    .then((res) => res.json())
    .then((res) => res.data.sessions)
    .catch((error) => {
      console.log(`Error retrieving sessions ${error.message}`);
      return null;
    });
};

const run = async () => {
  const sleep = (ms) => new Promise((res) => setTimeout(res, ms));

  let browser = null;

  try {
    browser = await puppeteer.connect({
      browserWSEndpoint: `wss://chrome.browserless.io?token=${apiToken}&id=${id}`,
    });

    const page = await browser.newPage();
    await page.goto("https://example.com");

    const [session] = await getSessionsById(id);

    if (!session) {
      throw new Error(`Error retrieving session!`);
    }

    console.log(`Open: ${session.devtoolsFrontendUrl} in your browser!`);

    // Let the page stay open for 30 seconds so we can debug!
    await sleep(30000);
  } catch (error) {
    console.error(`Saw error when running: ${error.message}`);
  } finally {
    if (browser) {
      console.log(`Shutting down the browser.`);
      browser.close();
    }
  }
};

run();

```

- Javascript
- Python
- Java
- C#

```codeBlockLines_p187
import { chromium } from "playwright-core";

const apiToken = "YOUR_API_TOKEN_HERE";
const id = "some-unique-id";

const getSessionsById = async (id) => {
  try {
    const response = await fetch("https://api.browserless.io/graphql", {
      method: "POST",
      headers: {
        "content-type": "application/json",
      },
      body: JSON.stringify({
        query: `
          query getSessions($id: String!, $apiToken: String!) {
            sessions(apiToken: $apiToken, id: $id) {
              description
              devtoolsFrontendUrl
              id
              title
              url
              id
              browserId
              browserWSEndpoint
            }
          }
        `,
        variables: {
          id,
          apiToken,
        },
      }),
    });
    const result = await response.json();
    return result.data.sessions;
  } catch (error) {
    console.error(`Error retrieving sessions: ${error.message}`);
    return null;
  }
};

const run = async () => {
  const sleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms));

  let browser = null;

  try {
    browser = await chromium.connectOverCDP(
      `wss://chrome.browserless.io?token=${apiToken}&id=${id}`
    );

    const context = browser.contexts()[0] || (await browser.newContext());
    const page = await context.newPage();
    await page.goto("https://example.com");

    const [session] = await getSessionsById(id);

    if (!session) {
      throw new Error(`Error retrieving session!`);
    }

    console.log(`Open: ${session.devtoolsFrontendUrl} in your browser!`);

    // Let the page stay open for 30 seconds so we can debug!
    await sleep(30000);
  } catch (error) {
    console.error(`Saw error when running: ${error.message}`);
  } finally {
    if (browser) {
      console.log(`Shutting down the browser.`);
      await browser.close();
    }
  }
};

run();

```

```codeBlockLines_p187
import asyncio
import requests
from playwright.async_api import async_playwright

API_TOKEN = "YOUR_API_TOKEN_HERE"
ID = "some-unique-id"

def get_sessions_by_id(session_id):
    try:
        response = requests.post(
            "https://api.browserless.io/graphql",
            json={
                "query": """
                    query getSessions($id: String!, $apiToken: String!) {
                        sessions(apiToken: $apiToken, id: $id) {
                            description
                            devtoolsFrontendUrl
                            id
                            title
                            url
                            browserId
                            browserWSEndpoint
                        }
                    }
                """,
                "variables": {
                    "id": session_id,
                    "apiToken": API_TOKEN,
                },
            },
            headers={"Content-Type": "application/json"},
        )
        response.raise_for_status()
        return response.json()["data"]["sessions"]
    except Exception as e:
        print(f"Error retrieving sessions: {e}")
        return None

async def run():
    async with async_playwright() as p:
        browser = None
        try:
            browser = await p.chromium.connect_over_cdp(
                f"wss://chrome.browserless.io?token={API_TOKEN}&id={ID}"
            )

            context = browser.contexts[0] if browser.contexts else await browser.new_context()
            page = await context.new_page()
            await page.goto("https://example.com")

            sessions = get_sessions_by_id(ID)
            if not sessions:
                raise Exception("Error retrieving session!")

            session = sessions[0]
            print(f"Open: {session['devtoolsFrontendUrl']} in your browser!")

            # Let the page stay open for 30 seconds
            await asyncio.sleep(30)
        except Exception as e:
            print(f"Saw error when running: {e}")
        finally:
            if browser:
                print("Shutting down the browser.")
                await browser.close()

asyncio.run(run())

```

```codeBlockLines_p187
import com.microsoft.playwright.*;
import java.net.http.*;
import java.net.URI;
import java.net.http.HttpClient;
import java.util.*;

import com.google.gson.Gson;

public class PlaywrightRemote {
    private static final String API_TOKEN = "YOUR_API_TOKEN_HERE";
    private static final String ID = "some-unique-id";

    private static List<Map<String, Object>> getSessionsById(String id) throws Exception {
        HttpClient client = HttpClient.newHttpClient();
        String query = """
            query getSessions($id: String!, $apiToken: String!) {
                sessions(apiToken: $apiToken, id: $id) {
                    description
                    devtoolsFrontendUrl
                    id
                    title
                    url
                    browserId
                    browserWSEndpoint
                }
            }
        """;

        Map<String, Object> payload = Map.of(
            "query", query,
            "variables", Map.of("id", id, "apiToken", API_TOKEN)
        );

        HttpRequest request = HttpRequest.newBuilder()
            .uri(URI.create("https://api.browserless.io/graphql"))
            .header("Content-Type", "application/json")
            .POST(HttpRequest.BodyPublishers.ofString(new Gson().toJson(payload)))
            .build();

        HttpResponse<String> response = client.send(request, HttpResponse.BodyHandlers.ofString());
        if (response.statusCode() != 200) {
            throw new Exception("Error retrieving sessions: " + response.body());
        }

        Map<String, Object> responseData = new Gson().fromJson(response.body(), Map.class);
        return (List<Map<String, Object>>) ((Map<String, Object>) responseData.get("data")).get("sessions");
    }

    public static void main(String[] args) {
        try (Playwright playwright = Playwright.create()) {
            Browser browser = playwright.chromium().connectOverCDP(
                "wss://chrome.browserless.io?token=" + API_TOKEN + "&id=" + ID
            );

            BrowserContext context = browser.contexts().isEmpty() ? browser.newContext() : browser.contexts().get(0);
            Page page = context.newPage();
            page.navigate("https://example.com");

            List<Map<String, Object>> sessions = getSessionsById(ID);
            if (sessions.isEmpty()) {
                throw new Exception("Error retrieving session!");
            }

            Map<String, Object> session = sessions.get(0);
            System.out.println("Open: " + session.get("devtoolsFrontendUrl") + " in your browser!");

            Thread.sleep(30000);
            browser.close();
        } catch (Exception e) {
            System.err.println("Saw error when running: " + e.getMessage());
        }
    }
}

```

```codeBlockLines_p187
using System;
using System.Net.Http;
using System.Text;
using System.Text.Json;
using System.Threading.Tasks;
using Microsoft.Playwright;

class Program
{
    private const string ApiToken = "YOUR_API_TOKEN_HERE";
    private const string Id = "some-unique-id";

    static async Task Main(string[] args)
    {
        var httpClient = new HttpClient();
        var playwright = await Playwright.CreateAsync();
        IBrowser browser = null;

        try
        {
            browser = await playwright.Chromium.ConnectOverCDPAsync(
                $"wss://chrome.browserless.io?token={ApiToken}&id={Id}"
            );

            var context = browser.Contexts.Count > 0 ? browser.Contexts[0] : await browser.NewContextAsync();
            var page = await context.NewPageAsync();
            await page.GotoAsync("https://example.com");

            var payload = new
            {
                query = @"
                    query getSessions($id: String!, $apiToken: String!) {
                        sessions(apiToken: $apiToken, id: $id) {
                            description
                            devtoolsFrontendUrl
                            id
                            title
                            url
                            browserId
                            browserWSEndpoint
                        }
                    }
                ",
                variables = new { id = Id, apiToken = ApiToken }
            };

            var response = await httpClient.PostAsync(
                "https://api.browserless.io/graphql",
                new StringContent(JsonSerializer.Serialize(payload), Encoding.UTF8, "application/json")
            );

            response.EnsureSuccessStatusCode();
            var responseData = JsonSerializer.Deserialize<JsonElement>(await response.Content.ReadAsStringAsync());
            var sessions = responseData.GetProperty("data").GetProperty("sessions").EnumerateArray();

            if (!sessions.MoveNext())
            {
                throw new Exception("Error retrieving session!");
            }

            var session = sessions.Current;
            Console.WriteLine($"Open: {session.GetProperty("devtoolsFrontendUrl").GetString()} in your browser!");

            await Task.Delay(30000);
        }
        catch (Exception e)
        {
            Console.WriteLine($"Saw error when running: {e.Message}");
        }
        finally
        {
            if (browser != null)
            {
                Console.WriteLine("Shutting down the browser.");
                await browser.CloseAsync();
            }
        }
    }
}

```

### Selecting the modules to use [â€‹](https://docs.browserless.io/enterprise/watching-sessions\#selecting-the-modules-to-use "Direct link to Selecting the modules to use")

For this automated example, we're using the `puppeteer` or `playwright`. These are used for running the browser.

You're free to use whatever modules you like, including Selenium, however we've found that puppeteer and playwright are the most common across the web.

Once done, let's setup the function to get sessions from the GraphQL endpoint!

### Fetching sessions [â€‹](https://docs.browserless.io/enterprise/watching-sessions\#fetching-sessions "Direct link to Fetching sessions")

Our function below takes a single argument: the id we intend to use for the session. In a production system, you should _always_ make this ID unique as it'll prevent you from accidentally watching the wrong session. If you need a recommendation, we suggest something like a UUID or a GUID library.

- Javascript
- Python
- Java
- C#

```codeBlockLines_p187
const getSessionsById = (id) => {
  return fetch('https://api.browserless.io/graphql', {
    method: 'POST',
    headers: {
      'content-type': 'application/json',
    },
    body: JSON.stringify({
      query: `
        query getSessions($id: String!, $apiToken: String!) {
          sessions(apiToken: $apiToken, id: $id) {
            description
            devtoolsFrontendUrl
            id
            title
            url
            id
            browserId
            browserWSEndpoint
          }
        }
      `,
      variables: {
        id,
        apiToken,
      },
    });
  })
  .then((res) => res.json())
  .then((res) => res.data.sessions)
  .catch((error) => {
    console.log(`Error retrieving sessions ${error.message}`);
    return null;
  });
};

```

```codeBlockLines_p187
  import requests

  def get_sessions_by_id(session_id, api_token):
      try:
          response = requests.post(
              "https://api.browserless.io/graphql",
              json={
                  "query": """
                      query getSessions($id: String!, $apiToken: String!) {
                          sessions(apiToken: $apiToken, id: $id) {
                              description
                              devtoolsFrontendUrl
                              id
                              title
                              url
                              browserId
                              browserWSEndpoint
                          }
                      }
                  """,
                  "variables": {"id": session_id, "apiToken": api_token},
              },
              headers={"Content-Type": "application/json"},
          )

          response.raise_for_status()
          return response.json()["data"]["sessions"]
      except Exception as e:
          print(f"Error retrieving sessions: {e}")
          return None

  # Example Usage
  api_token = "YOUR_API_TOKEN_HERE"
  session_id = "some-unique-id"
  sessions = get_sessions_by_id(session_id, api_token)
  print(sessions)

```

```codeBlockLines_p187
import com.google.gson.*;
import java.net.http.*;
import java.net.URI;
import java.util.*;

public class GraphQLFetcher {
    public static List<Map<String, Object>> getSessionsById(String id, String apiToken) {
        try {
            HttpClient client = HttpClient.newHttpClient();

            String query = """
                query getSessions($id: String!, $apiToken: String!) {
                    sessions(apiToken: $apiToken, id: $id) {
                        description
                        devtoolsFrontendUrl
                        id
                        title
                        url
                        browserId
                        browserWSEndpoint
                    }
                }
            """;

            Map<String, Object> payload = Map.of(
                "query", query,
                "variables", Map.of("id", id, "apiToken", apiToken)
            );

            String requestBody = new Gson().toJson(payload);

            HttpRequest request = HttpRequest.newBuilder()
                .uri(URI.create("https://api.browserless.io/graphql"))
                .header("Content-Type", "application/json")
                .POST(HttpRequest.BodyPublishers.ofString(requestBody))
                .build();

            HttpResponse<String> response = client.send(request, HttpResponse.BodyHandlers.ofString());

            if (response.statusCode() == 200) {
                JsonObject data = JsonParser.parseString(response.body())
                    .getAsJsonObject()
                    .getAsJsonObject("data");

                return new Gson().fromJson(data.getAsJsonArray("sessions"), List.class);
            } else {
                System.err.println("Failed to fetch sessions: " + response.body());
                return null;
            }
        } catch (Exception e) {
            System.err.println("Error retrieving sessions: " + e.getMessage());
            return null;
        }
    }

    public static void main(String[] args) {
        String apiToken = "YOUR_API_TOKEN_HERE";
        String id = "some-unique-id";
        List<Map<String, Object>> sessions = getSessionsById(id, apiToken);
        System.out.println(sessions);
    }
}

```

```codeBlockLines_p187
using System;
using System.Net.Http;
using System.Text;
using System.Text.Json;
using System.Text.Json.Serialization;
using System.Threading.Tasks;

class Program
{
    static async Task Main(string[] args)
    {
        string apiToken = "YOUR_API_TOKEN_HERE";
        string id = "some-unique-id";

        var sessions = await GetSessionsById(id, apiToken);
        Console.WriteLine(JsonSerializer.Serialize(sessions, new JsonSerializerOptions { WriteIndented = true }));
    }

    static async Task<object> GetSessionsById(string id, string apiToken)
    {
        using var httpClient = new HttpClient();
        var payload = new
        {
            query = @"
                query getSessions($id: String!, $apiToken: String!) {
                    sessions(apiToken: $apiToken, id: $id) {
                        description
                        devtoolsFrontendUrl
                        id
                        title
                        url
                        browserId
                        browserWSEndpoint
                    }
                }
            ",
            variables = new { id, apiToken }
        };

        var content = new StringContent(
            JsonSerializer.Serialize(payload),
            Encoding.UTF8,
            "application/json"
        );

        try
        {
            var response = await httpClient.PostAsync("https://api.browserless.io/graphql", content);
            response.EnsureSuccessStatusCode();

            var responseBody = await response.Content.ReadAsStringAsync();
            var json = JsonSerializer.Deserialize<JsonElement>(responseBody);

            return json.GetProperty("data").GetProperty("sessions");
        }
        catch (Exception e)
        {
            Console.WriteLine($"Error retrieving sessions: {e.Message}");
            return null;
        }
    }
}

```

The below query is the underlying GraphQL request, that says we want to retrieve the following properties for our session. In our example we only make use of the `devtoolsFrontendUrl`, so you're free to remove the others if you wish, they're there for educational purposes.

```codeBlockLines_p187
query getSessions($id: String!, $apiToken: String!) {
  sessions(apiToken: $apiToken, id: $id) {
    description
    devtoolsFrontendUrl
    id
    title
    url
    id
    browserId
    browserWSEndpoint
  }
}

```

In GraphQL terms, we're setting up a "function" here that retrieves sessions with your API Token and id. The response will contain something like:

```codeBlockLines_p187
{
  "data": {
    "sessions": [\
      {\
        "id": null,\
        "initialConnectURL": "wss://chrome.browserless.io/firefox/playwright/?token=YOUR_API_TOKEN_HERE",\
        "isTempDataDir": true,\
        "launchOptions": {},\
        "numbConnected": 1,\
        "routePath": ["/firefox/playwright", "/firefox/playwright"],\
        // ...\
      }\
    ]
  }
}

```

> In all of our returned links we _omit_ your API token, so you'll need to add it to the link manually to visit it. This is done for security purposes.

**Hooking up puppeteer/playwright**

In our puppeteer or playwright setups, the `run` function, we start the browser and begin to write our script. Once we know the page is open, we use our GraphQL fetching function to get the active sessions (filtered by id), and log the response.

In reality you can do whatever you'd like with this response: save it in a database or load it in a user's page. However, once the session is done the link will no longer respond properly, and the session will return a `404`.

Here's that code again:

- Puppeteer
- Playwright

```codeBlockLines_p187
const run = async () => {
  const sleep = (ms) => new Promise((res) => setTimeout(res, ms));

  let browser = null;

  try {
    browser = await puppeteer.connect({
      browserWSEndpoint: `wss://chrome.browserless.io?token=${apiToken}&id=${id}`,
    });

    const page = await browser.newPage();
    await page.goto("https://example.com");

    const [session] = await getSessionsById(id);

    if (!session) {
      throw new Error(`Error retrieving session!`);
    }

    console.log(`Open: ${session.devtoolsFrontendUrl} in your browser!`);

    // Let the page stay open for 30 seconds so we can debug!
    await sleep(30000);
  } catch (error) {
    console.error(`Saw error when running: ${error.message}`);
  } finally {
    if (browser) {
      console.log(`Shutting down the browser.`);
      browser.close();
    }
  }
};

run();

```

- Javascript
- Python
- Java
- C#

```codeBlockLines_p187
const run = async () => {
  const sleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms));

  let browser = null;

  try {
    browser = await chromium.connectOverCDP(
      `wss://chrome.browserless.io?token=${apiToken}&id=${id}`
    );

    const context = browser.contexts()[0] || (await browser.newContext());
    const page = await context.newPage();
    await page.goto("https://example.com");

    const [session] = await getSessionsById(id);

    if (!session) {
      throw new Error(`Error retrieving session!`);
    }

    console.log(`Open: ${session.devtoolsFrontendUrl} in your browser!`);

    // Let the page stay open for 30 seconds so we can debug!
    await sleep(30000);
  } catch (error) {
    console.error(`Saw error when running: ${error.message}`);
  } finally {
    if (browser) {
      console.log(`Shutting down the browser.`);
      await browser.close();
    }
  }
};

run();

```

```codeBlockLines_p187
async def run():
    async with async_playwright() as p:
        browser = None
        try:
            browser = await p.chromium.connect_over_cdp(
                f"wss://chrome.browserless.io?token={API_TOKEN}&id={ID}"
            )

            context = browser.contexts[0] if browser.contexts else await browser.new_context()
            page = await context.new_page()
            await page.goto("https://example.com")

            sessions = get_sessions_by_id(ID)
            if not sessions:
                raise Exception("Error retrieving session!")

            session = sessions[0]
            print(f"Open: {session['devtoolsFrontendUrl']} in your browser!")

            # Let the page stay open for 30 seconds
            await asyncio.sleep(30)
        except Exception as e:
            print(f"Saw error when running: {e}")
        finally:
            if browser:
                print("Shutting down the browser.")
                await browser.close()

asyncio.run(run())

```

```codeBlockLines_p187
public class PlaywrightRunExample {
    public static void run(String apiToken, String id, SessionFetcher fetcher) {
        try (Playwright playwright = Playwright.create()) {
            Browser browser = playwright.chromium().connectOverCDP(
                "wss://chrome.browserless.io?token=" + apiToken + "&id=" + id
            );

            BrowserContext context = browser.contexts().isEmpty()
                ? browser.newContext()
                : browser.contexts().get(0);
            Page page = context.newPage();

            page.navigate("https://example.com");

            List<Map<String, Object>> sessions = fetcher.getSessionsById(id);
            if (sessions.isEmpty()) {
                throw new Exception("Error retrieving session!");
            }

            Map<String, Object> session = sessions.get(0);
            System.out.println(
                "Open: " + session.get("devtoolsFrontendUrl") + " in your browser (be sure to add your &token to it!)"
            );

            // Let the page stay open for 30 seconds
            TimeUnit.SECONDS.sleep(30);
        } catch (Exception e) {
            System.err.println("Saw error when running: " + e.getMessage());
        }
    }

    interface SessionFetcher {
        List<Map<String, Object>> getSessionsById(String id);
    }
}

```

```codeBlockLines_p187
class Program
{
    static async Task Run(string apiToken, string id, Func<string, Task<List<Dictionary<string, string>>>> getSessionsById)
    {
        IBrowser browser = null;

        try
        {
            var playwright = await Playwright.CreateAsync();
            browser = await playwright.Chromium.ConnectOverCDPAsync(
                $"wss://chrome.browserless.io?token={apiToken}&id={id}"
            );

            var context = browser.Contexts.Count > 0 ? browser.Contexts[0] : await browser.NewContextAsync();
            var page = await context.NewPageAsync();
            await page.GotoAsync("https://example.com");

            var sessions = await getSessionsById(id);
            if (sessions.Count == 0)
            {
                throw new Exception("Error retrieving session!");
            }

            var session = sessions[0];
            Console.WriteLine(
                $"Open: {session["devtoolsFrontendUrl"]} in your browser (be sure to add your &token to it!)"
            );

            // Let the page stay open for 30 seconds
            await Task.Delay(30000);
        }
        catch (Exception e)
        {
            Console.WriteLine($"Saw error when running: {e.Message}");
        }
        finally
        {
            if (browser != null)
            {
                Console.WriteLine("Shutting down the browser.");
                await browser.CloseAsync();
            }
        }
    }
}

```

You'll note that we have a `page.waitFor` call in here as well: this is to ensure you have time to visit the debugging page. In a production system, the page interactions can happen quickly, and so it's easy to go to a debug page and miss all of the interactivity. If it's crucial that you witness the script as it runs we recommend pausing the script on startup with the `&pause` query-string parameter in your `puppeteer.connect` call.

That's it! You've successfully setup a running puppeteer session, and have a way to view the session as needed! If you've found this helpful, or need help with an issue, please [let us know](https://www.browserless.io/contact)

- [Watching sessions on the docker image](https://docs.browserless.io/enterprise/watching-sessions#watching-sessions-on-the-docker-image)
- [Using the Sessions tab in the Dedicated plans](https://docs.browserless.io/enterprise/watching-sessions#using-the-sessions-tab-in-the-dedicated-plans)
- [Programmatically watching your sessions on Dedicated plans](https://docs.browserless.io/enterprise/watching-sessions#programmatically-watching-your-sessions-on-dedicated-plans)
  - [Selecting the modules to use](https://docs.browserless.io/enterprise/watching-sessions#selecting-the-modules-to-use)
  - [Fetching sessions](https://docs.browserless.io/enterprise/watching-sessions#fetching-sessions)

---

### Navigation Options | Browserless.io
Original URL: https://docs.browserless.io/nav-options

[Skip to main content](https://docs.browserless.io/nav-options#__docusaurus_skipToContent_fallback)


BQL makes it easy to navigate websites and interact with them. Whether you're capturing screenshots, generating PDFs, or handling other automation tasks, you can use the following navigation options to change BQL's behavior.

note

The examples in this section will show you how to use the [`pdf`](https://docs.browserless.io/bql-schema/operations/mutations/pdf) and [`screenshot`](https://docs.browserless.io/bql-schema/operations/mutations/screenshot) mutations.

On this collection weâ€™ll look at:

- [Basic Usage](https://docs.browserless.io/nav-options#basic-usage)
- [Setting HTML content](https://docs.browserless.io/pdf/html-content)
- [Rejecting Undesired Requests](https://docs.browserless.io/pdf/rejects)
- [Navigation Options](https://docs.browserless.io/pdf/navigation-options)
- [Waiting for Things](https://docs.browserless.io/pdf/waiting)

## Basic Usage [â€‹](https://docs.browserless.io/nav-options\#basic-usage "Direct link to Basic Usage")

- PDF
- Screenshot

- BQL Query
- cURL
- Javascript
- Python
- Java
- C#

```codeBlockLines_p187
mutation PDF {
  goto(url: "https://example.com") {
    status
  }

  pdf(displayHeaderFooter: true, printBackground: false, format: a0) {
    base64
  }
}

```

```codeBlockLines_p187
curl --request POST \
  --url 'https://production-sfo.browserless.io/chromium/bql?token=YOUR_API_TOKEN_HERE' \
  --header 'Content-Type: application/json' \
  --data '{"query":"mutation PDF {\n  goto(url: \"https://example.com\") {\n    status\n  }\n\n  pdf(displayHeaderFooter: true, printBackground: false, format: a0) {\n    base64\n  }\n}","variables":"","operationName":"PDF"}'

```

```codeBlockLines_p187
const endpoint = "https://production-sfo.browserless.io/chromium/bql";
const token = "YOUR_API_TOKEN_HERE";

const options = {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json',
  },
  body: JSON.stringify({"query":"mutation PDF {\n  goto(url: \"https://example.com\") {\n    status\n  }\n\n  pdf(displayHeaderFooter: true, printBackground: false, format: a0) {\n    base64\n  }\n}","variables":"","operationName":"PDF"})
};

const url = `${endpoint}?token=${token}`;
const response = await fetch(url, options);
const data = await response.json();

console.log(data);

```

```codeBlockLines_p187
import requests

endpoint = "https://production-sfo.browserless.io/chromium/bql"
query_string = {
    "token": "YOUR_API_TOKEN_HERE",
}
headers = {
    "Content-Type": "application/json",
}
payload = {
    "query": "mutation PDF {\n  goto(url: \"https://example.com\") {\n    status\n  }\n\n  pdf(displayHeaderFooter: true, printBackground: false, format: a0) {\n    base64\n  }\n}",
    "variables": None,
    "operationName": "PDF",
}

response = requests.post(endpoint, params=query_string, headers=headers, json=payload)
print(response.json())

```

```codeBlockLines_p187
String url = "https://production-sfo.browserless.io/chromium/bql";
String token = "YOUR_API_TOKEN_HERE";
String endpoint = String.format("%s?token=%s%s%s", url, token);

HttpResponse<String> response = Unirest.post(endpoint)
    .header("Content-Type", "application/json")
    .body({"query":"mutation PDF {\n  goto(url: \"https://example.com\") {\n    status\n  }\n\n  pdf(displayHeaderFooter: true, printBackground: false, format: a0) {\n    base64\n  }\n}","variables":"","operationName":"PDF"})
    .asString();

```

```codeBlockLines_p187
string url = "https://production-sfo.browserless.io/chromium/bql";
string token = "YOUR_API_TOKEN_HERE";
string endpoint = $"{url}?token={token}";

var payload = new
{
    query = @"mutation PDF {
  goto(url: ""https://example.com"") {
    status
  }

  pdf(displayHeaderFooter: true, printBackground: false, format: a0) {
    base64
  }
}",
    variables = "",
    operationName = "PDF"
};

using (var client = new HttpClient())
{
    var jsonPayload = System.Text.Json.JsonSerializer.Serialize(payload);
    var content = new StringContent(jsonPayload, Encoding.UTF8, "application/json");

    var response = await client.PostAsync(endpoint, content);
    string responseBody = await response.Content.ReadAsStringAsync();

    Console.WriteLine(responseBody);
}

```

- BQL Query
- cURL
- Javascript
- Python
- Java
- C#

```codeBlockLines_p187
mutation Screenshot {
  goto(url: "https://example.com") {
    status
  }

  screenshot(omitBackground:true) {
    base64
  }
}

```

```codeBlockLines_p187
curl --request POST \
  --url 'https://production-sfo.browserless.io/chromium/bql?token=YOUR_API_TOKEN_HERE' \
  --header 'Content-Type: application/json' \
  --data '{"query":"mutation Screenshot {\n  goto(url: \"https://example.com\") {\n    status\n  }\n\n  screenshot(omitBackground:true) {\n    base64\n  }\n}","variables":"","operationName":"Screenshot"}'

```

```codeBlockLines_p187
const endpoint = "https://production-sfo.browserless.io/chromium/bql";
const token = "YOUR_API_TOKEN_HERE";

const options = {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json',
  },
  body: JSON.stringify({"query":"mutation Screenshot {\n  goto(url: \"https://example.com\") {\n    status\n  }\n\n  screenshot(omitBackground:true) {\n    base64\n  }\n}","variables":"","operationName":"Screenshot"})
};

const url = `${endpoint}?token=${token}`;
const response = await fetch(url, options);
const data = await response.json();

console.log(data);

```

```codeBlockLines_p187
import requests

endpoint = "https://production-sfo.browserless.io/chromium/bql"
query_string = {
    "token": "YOUR_API_TOKEN_HERE",
}
headers = {
    "Content-Type": "application/json",
}
payload = {
    "query": "mutation Screenshot {\n  goto(url: \"https://example.com\") {\n    status\n  }\n\n  screenshot(omitBackground:true) {\n    base64\n  }\n}",
    "variables": None,
    "operationName": "Screenshot",
}

response = requests.post(endpoint, params=query_string, headers=headers, json=payload)
print(response.json())

```

```codeBlockLines_p187
String url = "https://production-sfo.browserless.io/chromium/bql";
String token = "YOUR_API_TOKEN_HERE";
String endpoint = String.format("%s?token=%s%s%s", url, token);

HttpResponse<String> response = Unirest.post(endpoint)
    .header("Content-Type", "application/json")
    .body({"query":"mutation Screenshot {\n  goto(url: \"https://example.com\") {\n    status\n  }\n\n  screenshot(omitBackground:true) {\n    base64\n  }\n}","variables":"","operationName":"Screenshot"})
    .asString();

```

```codeBlockLines_p187
string url = "https://production-sfo.browserless.io/chromium/bql";
string token = "YOUR_API_TOKEN_HERE";
string endpoint = $"{url}?token={token}";

var payload = new
{
    query = @"mutation Screenshot {
  goto(url: ""https://example.com"") {
    status
  }

  screenshot(omitBackground: true) {
    base64
  }
}",
    variables = "",
    operationName = "Screenshot"
};

using (HttpClient httpClient = new HttpClient())
{
    var jsonPayload = System.Text.Json.JsonSerializer.Serialize(payload);
    var content = new StringContent(jsonPayload, Encoding.UTF8, "application/json");

    var response = await httpClient.PostAsync(endpoint, content);
    string responseBody = await response.Content.ReadAsStringAsync();
    Console.WriteLine(responseBody);
}

```

BQL Schemas

For more details on BQL mutations, refer to the [BrowserQL Schema](https://docs.browserless.io/bql-schema/schema) reference pages.

Rest API

[Generating PDFs](https://docs.browserless.io/rest-apis/pdf) and [Taking Screenshots](https://docs.browserless.io/rest-apis/screenshot) can also be done with Browserless Rest API.

- [Basic Usage](https://docs.browserless.io/nav-options#basic-usage)

---

### Default navigation behavior | Browserless.io
Original URL: https://docs.browserless.io/nav-options/default-behavior

[Skip to main content](https://docs.browserless.io/nav-options/default-behavior#__docusaurus_skipToContent_fallback)

You can use the `goto` mutation to modify the default navigation behavior for the requested URL.

- PDF
- Screenshot

- BQL Query
- cURL
- Javascript
- Python
- Java
- C#

```codeBlockLines_p187
mutation PDF {
  goto(url: "https://browserless.io/" waitUntil: networkIdle) {
    status
  }

  pdf(displayHeaderFooter: true, printBackground: false, format: a0) {
    base64
  }
}

```

```codeBlockLines_p187
curl --request POST \
  --url 'https://production-sfo.browserless.io/chromium/bql?token=YOUR_API_TOKEN_HERE' \
  --header 'Content-Type: application/json' \
  --data '{"query":"mutation PDF {\n  goto(url: \"https://browserless.io/\" waitUntil: networkIdle) {\n    status\n  }\n\n  pdf(displayHeaderFooter: true, printBackground: false, format: a0) {\n    base64\n  }\n}","variables":"","operationName":"PDF"}'

```

```codeBlockLines_p187
const endpoint = "https://production-sfo.browserless.io/chromium/bql";
const token = "YOUR_API_TOKEN_HERE";

const options = {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json',
  },
  body: JSON.stringify({"query":"mutation PDF {\n  goto(url: \"https://browserless.io/\" waitUntil: networkIdle) {\n    status\n  }\n\n  pdf(displayHeaderFooter: true, printBackground: false, format: a0) {\n    base64\n  }\n}","variables":"","operationName":"PDF"})
};

const url = `${endpoint}?token=${token}`;
const response = await fetch(url, options);
const data = await response.json();

console.log(data);

```

```codeBlockLines_p187
import requests

endpoint = "https://production-sfo.browserless.io/chromium/bql"
query_string = {
    "token": "YOUR_API_TOKEN_HERE",
}
headers = {
    "Content-Type": "application/json",
}
payload = {
    "query": "mutation PDF {\n  goto(url: \"https://browserless.io/\" waitUntil: networkIdle) {\n    status\n  }\n\n  pdf(displayHeaderFooter: true, printBackground: false, format: a0) {\n    base64\n  }\n}",
    "variables": None,
    "operationName": "PDF",
}

response = requests.post(endpoint, params=query_string, headers=headers, json=payload)
print(response.json())

```

```codeBlockLines_p187
String url = "https://production-sfo.browserless.io/chromium/bql";
String token = "YOUR_API_TOKEN_HERE";
String endpoint = String.format("%s?token=%s%s%s", url, token);

HttpResponse<String> response = Unirest.post(endpoint)
    .header("Content-Type", "application/json")
    .body({"query":"mutation PDF {\n  goto(url: \"https://browserless.io/\" waitUntil: networkIdle) {\n    status\n  }\n\n  pdf(displayHeaderFooter: true, printBackground: false, format: a0) {\n    base64\n  }\n}","variables":"","operationName":"PDF"})
    .asString();

```

```codeBlockLines_p187
string url = "https://production-sfo.browserless.io/chromium/bql";
string token = "YOUR_API_TOKEN_HERE";
string endpoint = $"{url}?token={token}";

var payload = new
{
    query = @"mutation PDF {
  goto(url: ""https://browserless.io/"" waitUntil: networkIdle) {
    status
  }

  pdf(displayHeaderFooter: true, printBackground: false, format: a0) {
    base64
  }
}",
    variables = "",
    operationName = "PDF"
};

using (var client = new HttpClient())
{
    var jsonPayload = System.Text.Json.JsonSerializer.Serialize(payload);
    var content = new StringContent(jsonPayload, Encoding.UTF8, "application/json");

    var response = await client.PostAsync(endpoint, content);
    string responseBody = await response.Content.ReadAsStringAsync();

    Console.WriteLine(responseBody);
}

```

- BQL Query
- cURL
- Javascript
- Python
- Java
- C#

```codeBlockLines_p187
mutation Screenshot {
  goto(url: "https://browserless.io/" waitUntil: networkIdle) {
    status
  }

  screenshot(type: webp) {
    base64
  }
}

```

```codeBlockLines_p187
curl --request POST \
  --url 'https://production-sfo.browserless.io/chromium/bql?token=YOUR_API_TOKEN_HERE' \
  --header 'Content-Type: application/json' \
  --data '{"query":"mutation Screenshot {\n  goto(url: \"https://browserless.io/\" waitUntil: networkIdle) {\n    status\n  }\n\n  screenshot(type: webp) {\n    base64\n  }\n}","variables":"","operationName":"Screenshot"}'

```

```codeBlockLines_p187
const endpoint = "https://production-sfo.browserless.io/chromium/bql";
const token = "YOUR_API_TOKEN_HERE";

const options = {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json',
  },
  body: JSON.stringify({"query":"mutation Screenshot {\n  goto(url: \"https://browserless.io/\" waitUntil: networkIdle) {\n    status\n  }\n\n  screenshot(type: webp) {\n    base64\n  }\n}","variables":"","operationName":"Screenshot"})
};

const url = `${endpoint}?token=${token}`;
const response = await fetch(url, options);
const data = await response.json();

console.log(data);

```

```codeBlockLines_p187
import requests

endpoint = "https://production-sfo.browserless.io/chromium/bql"
query_string = {
    "token": "YOUR_API_TOKEN_HERE",
}
headers = {
    "Content-Type": "application/json",
}
payload = {
    "query": "mutation Screenshot {\n  goto(url: \"https://browserless.io/\" waitUntil: networkIdle) {\n    status\n  }\n\n  screenshot(type: webp) {\n    base64\n  }\n}",
    "variables": None,
    "operationName": "Screenshot",
}

response = requests.post(endpoint, params=query_string, headers=headers, json=payload)
print(response.json())

```

```codeBlockLines_p187
String url = "https://production-sfo.browserless.io/chromium/bql";
String token = "YOUR_API_TOKEN_HERE";
String endpoint = String.format("%s?token=%s%s%s", url, token);

HttpResponse<String> response = Unirest.post(endpoint)
    .header("Content-Type", "application/json")
    .body({"query":"mutation Screenshot {\n  goto(url: \"https://browserless.io/\" waitUntil: networkIdle) {\n    status\n  }\n\n  screenshot(type: webp) {\n    base64\n  }\n}","variables":"","operationName":"Screenshot"})
    .asString();

```

```codeBlockLines_p187
string url = "https://production-sfo.browserless.io/chromium/bql";
string token = "YOUR_API_TOKEN_HERE";
string endpoint = $"{url}?token={token}";

var payload = new
{
    query = @"mutation Screenshot {
  goto(url: ""https://browserless.io/"" waitUntil: networkIdle) {
    status
  }

  screenshot(type: webp) {
    base64
  }
}",
    variables = "",
    operationName = "Screenshot"
};

using (var client = new HttpClient())
{
    var jsonPayload = System.Text.Json.JsonSerializer.Serialize(payload);
    var content = new StringContent(jsonPayload, Encoding.UTF8, "application/json");

    var response = await client.PostAsync(endpoint, content);
    string responseBody = await response.Content.ReadAsStringAsync();

    Console.WriteLine(responseBody);
}

```

BQL Schemas

For more details on BQL mutations, refer to the [BrowserQL Schema](https://docs.browserless.io/bql-schema/schema) reference pages.

Rest API

[Generating PDFs](https://docs.browserless.io/rest-apis/pdf) and [Taking Screenshots](https://docs.browserless.io/rest-apis/screenshot) can also be done with Browserless Rest API.

---

### Setting HTML content | Browserless.io
Original URL: https://docs.browserless.io/nav-options/html-content

[Skip to main content](https://docs.browserless.io/nav-options/html-content#__docusaurus_skipToContent_fallback)

You can set the HTML content of the page to render dynamically generated content as well.

- PDF
- Screenshot

- BQL Query
- cURL
- Javascript
- Python
- Java
- C#

```codeBlockLines_p187
mutation PDF {
  content(html: "<h1>Hello, World!</h1>") {
    status
  }

  pdf(displayHeaderFooter: true, printBackground: false, format: a0) {
    base64
  }
}

```

```codeBlockLines_p187
curl --request POST \
  --url 'https://production-sfo.browserless.io/chromium/bql?token=YOUR_API_TOKEN_HERE' \
  --header 'Content-Type: application/json' \
  --data '{"query":"mutation PDF {\ncontent(html: \"<h1>Hello, World!</h1>\") {\n  status\n}\n\npdf(displayHeaderFooter: true, printBackground: false, format: a0) {\n  base64\n}\n}","variables":"","operationName":"PDF"}'

```

```codeBlockLines_p187
const endpoint = "https://production-sfo.browserless.io/chromium/bql";
const token = "YOUR_API_TOKEN_HERE";

const options = {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json',
  },
  body: JSON.stringify({"query":"mutation PDF {\ncontent(html: \"<h1>Hello, World!</h1>\") {\n  status\n}\n\npdf(displayHeaderFooter: true, printBackground: false, format: a0) {\n  base64\n}\n}","variables":"","operationName":"PDF"})
};

const url = `${endpoint}?token=${token}`;
const response = await fetch(url, options);
const data = await response.json();

console.log(data);

```

```codeBlockLines_p187
import requests

endpoint = "https://production-sfo.browserless.io/chromium/bql"
query_string = {
    "token": "YOUR_API_TOKEN_HERE",
}
headers = {
    "Content-Type": "application/json",
}
payload = {
    "query": "mutation PDF {\ncontent(html: \"<h1>Hello, World!</h1>\") {\n  status\n}\n\npdf(displayHeaderFooter: true, printBackground: false, format: a0) {\n  base64\n}\n}",
    "variables": None,
    "operationName": "PDF",
}

response = requests.post(endpoint, params=query_string, headers=headers, json=payload)
print(response.json())

```

```codeBlockLines_p187
String url = "https://production-sfo.browserless.io/chromium/bql";
String token = "YOUR_API_TOKEN_HERE";
String endpoint = String.format("%s?token=%s%s%s", url, token);

HttpResponse<String> response = Unirest.post(endpoint)
    .header("Content-Type", "application/json")
    .body({"query":"mutation PDF {\ncontent(html: \"<h1>Hello, World!</h1>\") {\n  status\n}\n\npdf(displayHeaderFooter: true, printBackground: false, format: a0) {\n  base64\n}\n}","variables":"","operationName":"PDF"})
    .asString();

```

```codeBlockLines_p187
string url = "https://production-sfo.browserless.io/chromium/bql";
string token = "YOUR_API_TOKEN_HERE";
string endpoint = $"{url}?token={token}";

var payload = new
{
    query = @"mutation PDF {
content(html: ""<h1>Hello, World!</h1>"") {
  status
}

pdf(displayHeaderFooter: true, printBackground: false, format: a0) {
  base64
}
}",
    variables = "",
    operationName = "PDF"
};

using (var client = new HttpClient())
{
    var jsonPayload = System.Text.Json.JsonSerializer.Serialize(payload);
    var content = new StringContent(jsonPayload, Encoding.UTF8, "application/json");

    var response = await client.PostAsync(endpoint, content);
    string responseBody = await response.Content.ReadAsStringAsync();

    Console.WriteLine(responseBody);
}

```

- BQL Query
- cURL
- Javascript
- Python
- Java
- C#

```codeBlockLines_p187
mutation Screenshot {
  content(html: "<h1>Hello, World!</h1>") {
    status
  }

  screenshot(type: webp) {
    base64
  }
}

```

```codeBlockLines_p187
curl --request POST \
  --url 'https://production-sfo.browserless.io/chromium/bql?token=YOUR_API_TOKEN_HERE' \
  --header 'Content-Type: application/json' \
  --data '{"query":"mutation Screenshot {\n  content(html: \"<h1>Hello, World!</h1>\") {\n    status\n  }\n\n  screenshot(type: webp) {\n    base64\n  }\n}","variables":"","operationName":"Screenshot"}'

```

```codeBlockLines_p187
const endpoint = "https://production-sfo.browserless.io/chromium/bql";
const token = "YOUR_API_TOKEN_HERE";

const options = {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json',
  },
  body: JSON.stringify({"query":"mutation Screenshot {\n  content(html: \"<h1>Hello, World!</h1>\") {\n    status\n  }\n\n  screenshot(type: webp) {\n    base64\n  }\n}","variables":"","operationName":"Screenshot"})
};

const url = `${endpoint}?token=${token}`;
const response = await fetch(url, options);
const data = await response.json();

console.log(data);

```

```codeBlockLines_p187
import requests

endpoint = "https://production-sfo.browserless.io/chromium/bql"
query_string = {
    "token": "YOUR_API_TOKEN_HERE",
}
headers = {
    "Content-Type": "application/json",
}
payload = {
    "query": "mutation Screenshot {\n  content(html: \"<h1>Hello, World!</h1>\") {\n    status\n  }\n\n  screenshot(type: webp) {\n    base64\n  }\n}",
    "variables": None,
    "operationName": "Screenshot",
}

response = requests.post(endpoint, params=query_string, headers=headers, json=payload)
print(response.json())

```

```codeBlockLines_p187
String url = "https://production-sfo.browserless.io/chromium/bql";
String token = "YOUR_API_TOKEN_HERE";
String endpoint = String.format("%s?token=%s%s%s", url, token);

HttpResponse<String> response = Unirest.post(endpoint)
    .header("Content-Type", "application/json")
    .body({"query":"mutation Screenshot {\n  content(html: \"<h1>Hello, World!</h1>\") {\n    status\n  }\n\n  screenshot(type: webp) {\n    base64\n  }\n}","variables":"","operationName":"Screenshot"})
    .asString();

```

```codeBlockLines_p187
string url = "https://production-sfo.browserless.io/chromium/bql";
string token = "YOUR_API_TOKEN_HERE";
string endpoint = $"{url}?token={token}";

var payload = new
{
    query = @"mutation Screenshot {
  content(html: ""<h1>Hello, World!</h1>"") {
    status
  }

  screenshot(type: webp) {
    base64
  }
}",
    variables = "",
    operationName = "Screenshot"
};

using (var client = new HttpClient())
{
    // Serialize payload to JSON
    var json = System.Text.Json.JsonSerializer.Serialize(payload);

    // Build the request content
    var content = new StringContent(json, Encoding.UTF8, "application/json");

    // Send POST request
    var response = await client.PostAsync(endpoint, content);
    var responseBody = await response.Content.ReadAsStringAsync();

    // Print or use response as needed
    Console.WriteLine(responseBody);
}

```

BQL Schemas

For more details on BQL mutations, refer to the [BrowserQL Schema](https://docs.browserless.io/bql-schema/schema) reference pages.

Rest API

[Generating PDFs](https://docs.browserless.io/rest-apis/pdf) and [Taking Screenshots](https://docs.browserless.io/rest-apis/screenshot) can also be done with Browserless Rest API.

---

### Rejecting Undesired Requests | Browserless.io
Original URL: https://docs.browserless.io/nav-options/rejects

[Skip to main content](https://docs.browserless.io/nav-options/rejects#__docusaurus_skipToContent_fallback)

You can use BrowserQL to block undesired content, resources and requests.

- PDF
- Screenshot

- BQL Query
- cURL
- Javascript
- Python
- Java
- C#

```codeBlockLines_p187
mutation PDF {
  reject(type: [image, stylesheet]) {
    enabled
    time
  }

  goto(url: "https://browserless.io/") {
    status
  }

  pdf(displayHeaderFooter: true, printBackground: false, format: a0) {
    base64
  }
}

```

```codeBlockLines_p187
curl --request POST \
  --url 'https://production-sfo.browserless.io/chromium/bql?token=YOUR_API_TOKEN_HERE' \
  --header 'Content-Type: application/json' \
  --data '{"query":"mutation PDF {\n  reject(type: [image, stylesheet]) {\n    enabled\n    time\n  }\n\n  goto(url: \"https://browserless.io/\") {\n    status\n  }\n\n  pdf(displayHeaderFooter: true, printBackground: false, format: a0) {\n    base64\n  }\n}","variables":"","operationName":"PDF"}'

```

```codeBlockLines_p187
const endpoint = "https://production-sfo.browserless.io/chromium/bql";
const token = "YOUR_API_TOKEN_HERE";

const options = {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json',
  },
  body: JSON.stringify({"query":"mutation PDF {\n  reject(type: [image, stylesheet]) {\n    enabled\n    time\n  }\n\n  goto(url: \"https://browserless.io/\") {\n    status\n  }\n\n  pdf(displayHeaderFooter: true, printBackground: false, format: a0) {\n    base64\n  }\n}","variables":"","operationName":"PDF"})
};

const url = `${endpoint}?token=${token}`;
const response = await fetch(url, options);
const data = await response.json();

console.log(data);

```

```codeBlockLines_p187
import requests

endpoint = "https://production-sfo.browserless.io/chromium/bql"
query_string = {
    "token": "YOUR_API_TOKEN_HERE",
}
headers = {
    "Content-Type": "application/json",
}
payload = {
    "query": "mutation PDF {\n  reject(type: [image, stylesheet]) {\n    enabled\n    time\n  }\n\n  goto(url: \"https://browserless.io/\") {\n    status\n  }\n\n  pdf(displayHeaderFooter: true, printBackground: false, format: a0) {\n    base64\n  }\n}",
    "variables": None,
    "operationName": "PDF",
}

response = requests.post(endpoint, params=query_string, headers=headers, json=payload)
print(response.json())

```

```codeBlockLines_p187
String url = "https://production-sfo.browserless.io/chromium/bql";
String token = "YOUR_API_TOKEN_HERE";
String endpoint = String.format("%s?token=%s%s%s", url, token);

HttpResponse<String> response = Unirest.post(endpoint)
    .header("Content-Type", "application/json")
    .body({"query":"mutation PDF {\n  reject(type: [image, stylesheet]) {\n    enabled\n    time\n  }\n\n  goto(url: \"https://browserless.io/\") {\n    status\n  }\n\n  pdf(displayHeaderFooter: true, printBackground: false, format: a0) {\n    base64\n  }\n}","variables":"","operationName":"PDF"})
    .asString();

```

```codeBlockLines_p187
string url = "https://production-sfo.browserless.io/chromium/bql";
string token = "YOUR_API_TOKEN_HERE";
string endpoint = $"{url}?token={token}";

var payload = new
{
    query = @"mutation PDF {
  reject(type: [image, stylesheet]) {
    enabled
    time
  }

  goto(url: ""https://browserless.io/"") {
    status
  }

  pdf(displayHeaderFooter: true, printBackground: false, format: a0) {
    base64
  }
}",
    variables = "",
    operationName = "PDF"
};

using (var client = new HttpClient())
{
    var jsonPayload = System.Text.Json.JsonSerializer.Serialize(payload);
    var content = new StringContent(jsonPayload, Encoding.UTF8, "application/json");

    var response = await client.PostAsync(endpoint, content);
    string responseBody = await response.Content.ReadAsStringAsync();

    Console.WriteLine(responseBody);
}

```

- BQL Query
- cURL
- Javascript
- Python
- Java
- C#

```codeBlockLines_p187
mutation Screenshot {
  reject(type: [image, stylesheet]) {
    enabled
    time
  }

  goto(url: "https://browserless.io/") {
    status
  }

  screenshot(type: webp) {
    base64
  }
}

```

```codeBlockLines_p187
curl --request POST \
  --url 'https://production-sfo.browserless.io/chromium/bql?token=YOUR_API_TOKEN_HERE' \
  --header 'Content-Type: application/json' \
  --data '{"query":"mutation Screenshot {\n  reject(type: [image, stylesheet]) {\n    enabled\n    time\n  }\n  \n  goto(url: \"https://browserless.io/\") {\n    status\n  }\n\n  screenshot(type: webp) {\n    base64\n  }\n}","variables":"","operationName":"Screenshot"}'

```

```codeBlockLines_p187
const endpoint = "https://production-sfo.browserless.io/chromium/bql";
const token = "YOUR_API_TOKEN_HERE";

const options = {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json',
  },
  body: JSON.stringify({"query":"mutation Screenshot {\n  reject(type: [image, stylesheet]) {\n    enabled\n    time\n  }\n  \n  goto(url: \"https://browserless.io/\") {\n    status\n  }\n\n  screenshot(type: webp) {\n    base64\n  }\n}","variables":"","operationName":"Screenshot"})
};

const url = `${endpoint}?token=${token}`;
const response = await fetch(url, options);
const data = await response.json();

console.log(data);

```

```codeBlockLines_p187
import requests

endpoint = "https://production-sfo.browserless.io/chromium/bql"
query_string = {
    "token": "YOUR_API_TOKEN_HERE",
}
headers = {
    "Content-Type": "application/json",
}
payload = {
    "query": "mutation Screenshot {\n  reject(type: [image, stylesheet]) {\n    enabled\n    time\n  }\n  \n  goto(url: \"https://browserless.io/\") {\n    status\n  }\n\n  screenshot(type: webp) {\n    base64\n  }\n}",
    "variables": None,
    "operationName": "Screenshot",
}

response = requests.post(endpoint, params=query_string, headers=headers, json=payload)
print(response.json())

```

```codeBlockLines_p187
String url = "https://production-sfo.browserless.io/chromium/bql";
String token = "YOUR_API_TOKEN_HERE";
String endpoint = String.format("%s?token=%s%s%s", url, token);

HttpResponse<String> response = Unirest.post(endpoint)
    .header("Content-Type", "application/json")
    .body({"query":"mutation Screenshot {\n  reject(type: [image, stylesheet]) {\n    enabled\n    time\n  }\n  \n  goto(url: \"https://browserless.io/\") {\n    status\n  }\n\n  screenshot(type: webp) {\n    base64\n  }\n}","variables":"","operationName":"Screenshot"})
    .asString();

```

```codeBlockLines_p187
string url = "https://production-sfo.browserless.io/chromium/bql";
string token = "YOUR_API_TOKEN_HERE";
string endpoint = $"{url}?token={token}";

var payload = new
{
    query = @"mutation Screenshot {
  reject(type: [image, stylesheet]) {
    enabled
    time
  }

  goto(url: ""https://browserless.io/"") {
    status
  }

  screenshot(type: webp) {
    base64
  }
}",
    variables = "",
    operationName = "Screenshot"
};

using (HttpClient client = new HttpClient())
{
    var jsonPayload = System.Text.Json.JsonSerializer.Serialize(payload);
    var content = new StringContent(jsonPayload, Encoding.UTF8, "application/json");

    var response = await client.PostAsync(endpoint, content);
    string responseBody = await response.Content.ReadAsStringAsync();

    Console.WriteLine(responseBody);
}

```

BQL Schemas

For more details on BQL mutations, refer to the [BrowserQL Schema](https://docs.browserless.io/bql-schema/schema) reference pages.

Rest API

[Generating PDFs](https://docs.browserless.io/rest-apis/pdf) and [Taking Screenshots](https://docs.browserless.io/rest-apis/screenshot) can also be done with Browserless Rest API.

---

### Browserless | Browserless.io
Original URL: https://docs.browserless.io/open-api

[Skip to main content](https://docs.browserless.io/open-api#__docusaurus_skipToContent_fallback)

![browserless logo](https://docs.browserless.io/docs/browserless-logo-inline.svg)

- Browserless.io
- Software Keys
  - Using a Software Key
- Using the Browserless Proxy
- The Browserless CDP API
  - Browserless.liveURL
  - Browserless.reconnect
  - Browserless.solveCaptcha
  - Browserless.foundCaptcha
  - Browserless.heartbeat
  - Browserless.pageId
- Changelog
- Browser REST APIs
  - post/chrome/content
  - post/chrome/download
  - post/chrome/function
  - get/json/list
  - put/json/new
  - get/json/protocol
  - get/json/version
  - post/chrome/pdf
  - post/chrome/performance
  - post/chrome/scrape
  - post/chrome/screenshot
  - post/chromium/content
  - post/chromium/download
  - post/chromium/function
  - post/chromium/pdf
  - post/chromium/performance
  - post/chromium/scrape
  - post/chromium/screenshot
  - post/edge/content
  - post/edge/download
  - post/edge/function
  - post/edge/pdf
  - post/edge/performance
  - post/edge/scrape
  - post/edge/screenshot
  - post/chrome/export
  - post/chrome/unblock
  - post/chromium/export
  - post/chromium/unblock
  - post/chrome/bql?(/\*)
  - post/chromium/bql?(/\*)
- Management REST APIs
  - get/active
  - get/kill/+(\[0-9a-zA-Z-\_\])
  - get/meta
  - get/
- Browser WebSocket APIs
  - get/devtools/browser/\*
  - get/chrome
  - get/devtools/page/\*
  - get/chrome/playwright
  - get/chromium
  - get/playwright/chromium
  - get/edge
  - get/edge/playwright
  - get/playwright/firefox
  - get/playwright/webkit
  - get/chrome/live/\*
  - get/chrome/stealth
  - get/chromium/live/\*
  - get/chromium/stealth
  - get/reconnect/\*

[API docs by Redocly](https://redocly.com/redoc/)

# Browserless (2.30.1)

Download OpenAPI specification: [Download](https://docs.browserless.io/redocusaurus/plugin-redoc-0.yaml)

## [section/Browserless.io](https://docs.browserless.io/open-api\#section/Browserless.io) Browserless.io

This service extends the Browserless open-source image with many features and enhancements for teams automating at scale. Notable features include:

- A Chrome-devtools-protocol based API for extending and enhancing libraries in a cross-language way.
- A new hybrid-automation toolkit with live session interactivity.
- Robust session management: connect, reconnect, kill and limit what a browser can do.
- Bleeding features like multiplexing numerous clients into a single Chrome process in an isolated way.
- The ability to upload and run custom extensions.
- Run multiple tokens, with access controls on each.
- Multi-browser with all the robust capabilities already in the open-source images.

There's a lot to cover here so let's get started!

## [section/Software-Keys](https://docs.browserless.io/open-api\#section/Software-Keys) Software Keys

The Enterprise image supports time-limited software keys that allow usage for a specific period without requiring any external connections or callbacks. These keys are cryptographically secure and cannot be reverse engineered. When a key expires, the container will exit with a semantic error code.

## [section/Software-Keys/Using-a-Software-Key](https://docs.browserless.io/open-api\#section/Software-Keys/Using-a-Software-Key) Using a Software Key

To use a software key, set the `KEY` environment variable when running the container:

```bash
docker run -e KEY=your-generated-key browserless/enterprise

```

## [section/Using-the-Browserless-Proxy](https://docs.browserless.io/open-api\#section/Using-the-Browserless-Proxy) Using the Browserless Proxy

> The Residential proxy is only available for Enterprise and Cloud plans.

Browserless comes with a built-in mechanism to proxy to what's called "residential" IPs. These are IP addresses are sourced from real-users running a proxy server on their home networking machines. Residential proxying is especially useful for things like bypassing certain bot blockages and more.

Using a residential proxy is as straightforward as adding a few parameters to your library or API calls. Here's the required parameters and the values they support:

- `?proxy=residential`: Specifies that you want to use the residential proxy for this request. Data-center coming soon.
- `?proxyCountry=us`: Specifies a country you wish to use for the request. A two-digit ISO code.
- `?proxySticky=true`: If you want to use the same IP address for the entirety of the session. Generally recommended for most cases.

Simply append these to your connection call, REST API calls, or any library call:

`wss://production-sfo.browserless.io/chromium?token=YOUR-API-TOKEN&proxy=residential&proxyCountry=us&proxySticky`

`https://production-sfo.browserless.io/chromium/unblock?token=YOUR-API-TOKEN&proxy=residential&proxyCountry=us&proxySticky`

Please do note that using a proxy will increase the amount of units consumed. Every megabyte of data transferred consumes 6 units.

## [section/The-Browserless-CDP-API](https://docs.browserless.io/open-api\#section/The-Browserless-CDP-API) The Browserless CDP API

In order to enhance the experience with open source libraries like Puppeteer, we decided to take a new approach to extending these libraries in a language-agnostic way. We call it the Browserless CDP API. Here's a quick list of what it can do:

- Generate and give back live URLs for hybrid automation.
- Solve Captchas.
- Return your page's unique identifier created by Chrome.
- Way more coming!

Since most libraries come with a way to issue "raw" CDP commands, it's an easy way to drop-in custom behaviors without having to write and maintain a library. Plus you can continue to enjoy using the same packages you've already come to know.

Getting started with this API is pretty simple. For instance, if you want to use the live viewer for a particular page, simply do the following:

```js
import puppeteer from 'puppeteer-core';

(async () => {
  const browserWSEndpoint = 'wss://production-sfo.browserless.io/chromium';
  const browser = await puppeteer.connect({ browserWSEndpoint });
  const page = await browser.newPage();
  const cdp = await page.createCDPSession();
  await page.goto('https://example.com');
  const { liveURL } = await cdp.send('Browserless.liveURL');

  // liveURL = 'http://localhost:3000/live/?i=98e83bbfd396241a6963425b1feeba2f';
})();

```

You can then visit this URL in any browser to interact with the headless Chrome running someplace else.

See more below for a full list of the available APIs and features.

## [section/The-Browserless-CDP-API/Browserless.liveURL](https://docs.browserless.io/open-api\#section/The-Browserless-CDP-API/Browserless.liveURL) Browserless.liveURL

> This API is only available for Enterprise plans. [Contact us for more information here.](https://www.browserless.io/contact/)

Returns a fully-qualified URL to load into a web-browser. This URL allows for clicking, typing and other interactions with the underlying page. This URL doesn't require an authorization token, so you're free to share it externally with your own users or employees. If security is a concern, you can set a `timeout` parameter to limit the amount of time this URL is valid for. By default no `timeout` is set and the URL is good as long as the underlying browser is open.

Programmatic control of the session is also available, so you can close the live session once your code has detected a selector, network call, or whatever else. See the below example for programmatic control.

**Basic example**

```js
import puppeteer from 'puppeteer-core';

(async () => {
  const browserWSEndpoint =
    'wss://production-sfo.browserless.io/chromium?token=YOUR-API-TOKEN';
  const browser = await puppeteer.connect({ browserWSEndpoint });
  const page = await browser.newPage();
  const cdp = await page.createCDPSession();
  await page.goto('https://example.com');
  const { liveURL } = await cdp.send('Browserless.liveURL');

  // liveURL = 'https://production-sfo.browserless.io/live/?i=98e83bbfd396241a6963425b1feeba2f';
})();

```

**Timeout example**

```js
import puppeteer from 'puppeteer-core';

(async () => {
  const browserWSEndpoint =
    'wss://production-sfo.browserless.io/chromium?token=YOUR-API-TOKEN';
  const browser = await puppeteer.connect({ browserWSEndpoint });
  const page = await browser.newPage();
  const cdp = await page.createCDPSession();
  await page.goto('https://example.com');
  const { liveURL } = await cdp.send('Browserless.liveURL', {
    timeout: 10000, // 10 seconds to connect!
  });

  // liveURL = 'https://production-sfo.browserless.io/live/?i=98e83bbfd396241a6963425b1feeba2f';
})();

```

**Maintaining the width and height**

By default, Browserless will dynamically change the width and height of the browser to match an end-users screen. This isn't always ideal and can be disabled by setting a `resizable` value to `false`. When this is done, only your script can alter the width and height of the browser:

```js
import puppeteer from 'puppeteer-core';

(async () => {
  const browserWSEndpoint =
    'wss://production-sfo.browserless.io/chromium?token=YOUR-API-TOKEN';
  const browser = await puppeteer.connect({ browserWSEndpoint });
  const page = await browser.newPage();

  // Width and height will always be 1920x1080
  // and the Live URL will maintain this aspect ratio
  await page.setViewport({ width: 1920, height: 1080 });
  const cdp = await page.createCDPSession();
  await page.goto('https://example.com');
  const { liveURL } = await cdp.send('Browserless.liveURL', {
    resizable: false,
  });

  // liveURL = 'https://production-sfo.browserless.io/live/?i=98e83bbfd396241a6963425b1feeba2f';
})();

```

**Setting a Quality and Type**

Setting a "quality" and "type" effects the streamed quality of the live URL's client-side resolution. By default, Browserless sets these to quality: 100 and type of "png". You can experiment different settings to get an ideal resolutions while keep latency slow. The close to 100 quality is, the potential for higher perceived latency.

```js
import puppeteer from 'puppeteer-core';

(async () => {
  const browserWSEndpoint =
    'wss://production-sfo.browserless.io/chromium?token=YOUR-API-TOKEN';
  const browser = await puppeteer.connect({ browserWSEndpoint });
  const page = await browser.newPage();
  const cdp = await page.createCDPSession();
  await page.goto('https://example.com');
  const { liveURL } = await cdp.send('Browserless.liveURL', {
    quality: 100, // Can be 1 - 100
    type: 'png', // Can be 'jpeg' or 'png'
  });

  // liveURL = 'https://production-sfo.browserless.io/live/?i=98e83bbfd396241a6963425b1feeba2f';
})();

```

It's also helpful to "wait" until the user is done doing what's needed. For that reason, Browserless will fire a custom event when the page is closed as well:

**Wait for close**

> Custom CDP Events are not supported in all libraries, including .NET Playwright.

```js
import puppeteer from 'puppeteer-core';

(async () => {
  const browserWSEndpoint =
    'wss://production-sfo.browserless.io/chromium?token=YOUR-API-TOKEN';
  const browser = await puppeteer.connect({ browserWSEndpoint });
  const page = await browser.newPage();
  const cdp = await page.createCDPSession();
  await page.goto('https://example.com');

  const { liveURL } = await cdp.send('Browserless.liveURL');

  console.log(liveURL);

  // Wait for the Browserless.liveComplete event when the live page is closed.
  // Please not that not all libraries support custom CDP events.
  await new Promise((r) => cdp.on('Browserless.liveComplete', r));

  console.log('Done!');

  await browser.close();
})();

```

**Programmatic Control**

```js
import puppeteer from 'puppeteer-core';

(async () => {
  const browserWSEndpoint =
    'wss://production-sfo.browserless.io/chromium?token=YOUR-API-TOKEN';
  const browser = await puppeteer.connect({ browserWSEndpoint });
  const page = await browser.newPage();
  const cdp = await page.createCDPSession();
  await page.goto('https://example.com');

  // Having the liveURLId is required in order to close it later
  const { liveURL, liveURLId } = await cdp.send('Browserless.liveURL');

  await page.waitForSelector('.my-selector');

  // Calling this CDP API with the "liveURLId" will close the session, and terminate the client
  // further usage of the liveURL will fail and no more human-control is possible
  await cdp.send('Browserless.closeLiveURL', { liveURLId });

  // Continue to process or interact with the browser, then:
  await browser.close();
})();

```

It's recommended that you double check the page prior to executing further code to make sure the page is where it should be, elements are present, and so forth. This approach makes it easy to solve hard things like second-factor authentication and more in a trivial fashion.

**Read-only LiveURL Sessions**

The `interactive: false` option allows you to create read-only LiveURL sessions where users can view the browser but cannot interact with it. This is useful for monitoring or demonstration purposes without allowing user input.

```js
import puppeteer from 'puppeteer-core';

(async () => {
  const browserWSEndpoint =
    'wss://production-sfo.browserless.io/chromium?token=YOUR-API-TOKEN';
  const browser = await puppeteer.connect({ browserWSEndpoint });
  const page = await browser.newPage();
  const cdp = await page.createCDPSession();
  await page.goto('https://example.com');

  // Create a read-only LiveURL session that users can view but not interact with
  const { liveURL } = await cdp.send('Browserless.liveURL', {
    interactive: false,
  });

  console.log('Read-only LiveURL:', liveURL);

  await browser.close();
})();

```

## [section/The-Browserless-CDP-API/Browserless.reconnect](https://docs.browserless.io/open-api\#section/The-Browserless-CDP-API/Browserless.reconnect) Browserless.reconnect

> This API is only available for Enterprise plans. [Contact us for more information here.](https://www.browserless.io/contact/)

Reconnecting allows for the underlying Chrome or Chromium process to continue to run for a specified amount of time, and subsequent reconnecting back to it. With this approach you can also "share" this connection URL to other clients to connect to the same browser process, allowing you to parallelize via a single Browser process.

Once a reconnection URL is retrieved, Browserless will intercept close-based commands and stop them from terminating the browser process itself. This prevents clients from accidentally closing the process via `browser.close` or similar.

In order to use this API, simply call `Browserless.reconnect` as a CDP command. You can, optionally, set a `timeout` or an `auth` property. See the below examples for details

**Basic example with timeout**

```js
import puppeteer from 'puppeteer-core';

(async () => {
  const browserWSEndpoint =
    'wss://production-sfo.browserless.io/chromium?token=YOUR-API-TOKEN';
  const browser = await puppeteer.connect({ browserWSEndpoint });
  const page = await browser.newPage();
  const cdp = await page.createCDPSession();
  await page.goto('https://example.com');

  // Allow this browser to run for 10 seconds, then shut down if nothing connects to it.
  // Defaults to the overall timeout set on the instance, which is 5 minutes if not specified.
  const { error, browserWSEndpoint } = await cdp.send('Browserless.reconnect', {
    timeout: 10000,
  });

  if (error) throw error;

  await browser.close();

  // browserWSEndpoint = 'https://production-sfo.browserless.io/reconnect/98e83bbfd396241a6963425b1feeba2f';
})();

```

If you want to enforce authentication, you can pass in an optional `auth` property that clients will need to use in order to connect with. Similar to how authentication works in general, a `token` query-string parameter will need to be applied.

**Authentication example**

```js
import puppeteer from 'puppeteer-core';

(async () => {
  const browserWSEndpoint =
    'wss://production-sfo.browserless.io/chromium?token=YOUR-API-TOKEN';
  const browser = await puppeteer.connect({ browserWSEndpoint });
  const page = await browser.newPage();
  const cdp = await page.createCDPSession();
  await page.goto('https://example.com');

  // Set a custom authentication token that clients have to use in order to connect, or otherwise
  // receive a 401 Response.
  const { error, browserWSEndpoint } = await cdp.send('Browserless.reconnect', {
    auth: 'secret-auth-token',
  });

  if (error) throw error;

  await browser.close();

  // NOTE the URL here doesn't include the auth token!
  // browserWSEndpoint = 'https://production-sfo.browserless.io/reconnect/98e83bbfd396241a6963425b1feeba2f';
})();

```

**Recursive Example**

```js
import puppeteer from 'puppeteer-core';

const job = async (reconnectURL) => {
  const browserWSEndpoint =
    reconnectURL ??
    'wss://production-sfo.browserless.io/chromium?token=YOUR-API-TOKEN';
  const browser = await puppeteer.connect({ browserWSEndpoint });
  const [page] = await browser.page();
  const cdp = await page.createCDPSession();
  await page.goto('https://example.com');

  // Anytime Browserless.reconnect is called, this restarts the timer back to the provided value,
  // effectively "bumping" the timer forward.
  const res = await cdp.send('Browserless.reconnect', {
    timeout: 30000,
  });

  if (res.error) throw error;

  await browser.close();

  // Continuously reconnect back...
  return job(res.browserWSEndpoint);
};

job().catch((e) => console.error(e));

```

## [section/The-Browserless-CDP-API/Browserless.solveCaptcha](https://docs.browserless.io/open-api\#section/The-Browserless-CDP-API/Browserless.solveCaptcha) Browserless.solveCaptcha

> This API is only available for Enterprise and Scale and above plans on Cloud. [Contact us for more information here.](https://www.browserless.io/contact/). Only the `/chrome` and `/chromium` routes support Captcha solving.

Browserless comes with built-in captcha solving capabilities. We use a variety of techniques to try and mitigate the chances of captchas coming up, but if you happen to run into one you can simply call on our API to solve it.

Given the amount of possibilities during a captcha solve, the API returns many properties and information in order to help your script be more informed as to what happened. See the below code example for all details and fields returned by the API.

Please be aware that solving a captcha can take a few seconds up to several minutes, so you'll want to increase your timeouts accordingly for your scripts. Captcha's solved, or attempted to solve, cost 10 units.

```js
import puppeteer from 'puppeteer-core';

(async () => {
  const browser = await puppeteer.connect({
    browserWSEndpoint:
      'wss://production-sfo.browserless.io/chromium?token=YOUR-API-TOKEN&timeout=300000',
  });

  const page = await browser.newPage();
  const cdp = await page.createCDPSession();
  await page.goto('https://www.google.com/recaptcha/api2/demo', {
    waitUntil: 'networkidle0',
  });

  const {
    // A simple boolean indicating whether the script can proceed
    ok,
    // Whether or not a captcha was found
    captchaFound,
    // A human-readable description of what occurred.
    message,
    // Whether a solve was attempted or not
    solveAttempted,
    // If the Captcha was solved, only true if found AND solved
    solved,
    // Any errors during execution are saved here:
    error,
  } = await cdp.send('Browserless.solveCaptcha', {
    // How long to wait for a Captcha to appear to solve.
    // Defaults to 10,000ms, or 10 seconds.
    appearTimeout: 30000,
  });

  console.log(message);

  if (ok) {
    await page.click('#recaptcha-demo-submit');
  } else {
    console.error(`Error solving captcha!`);
  }

  await browser.close();
})().catch((e) => {
  console.error(e);
  process.exit(1);
});

```

In general, if an `ok` response is sent back from this API, then your script is good to proceed with further actions. If a captcha is to suddenly appears after an action then you might want to listen for the `Browserless.foundCaptcha` event (see below) and retry solving.

## [section/The-Browserless-CDP-API/Browserless.foundCaptcha](https://docs.browserless.io/open-api\#section/The-Browserless-CDP-API/Browserless.foundCaptcha) Browserless.foundCaptcha

> This API is only available for Enterprise and Scale and above plans on Cloud. [Contact us for more information here.](https://www.browserless.io/contact/). Only the `/chrome` and `/chromium` routes support Captcha solving.

> Custom CDP Events are not supported in all libraries, including .NET Playwright.

Emitted whenever a captcha widget is found on the page. Useful for checking if there's a captcha and deciding whether or not to proceed with solving.

The example below stops until a captcha is found, which may or may not be the case with every website out there.

```js
import puppeteer from 'puppeteer-core';

// Recaptcha
(async () => {
  const browser = await puppeteer.connect({
    browserWSEndpoint:
      'wss://production-sfo.browserless.io/chromium?token=YOUR-API-TOKEN&timeout=300000',
  });

  const page = await browser.newPage();
  const cdp = await page.createCDPSession();

  await page.goto('https://www.google.com/recaptcha/api2/demo', {
    waitUntil: 'networkidle0',
  });

  // Please note that not all libraries support custom CDP events.
  await new Promise((resolve) =>
    cdp.on('Browserless.captchaFound', () => {
      console.log('Found a captcha!');
      return resolve();
    }),
  );

  const { solved, error } = await cdp.send('Browserless.solveCaptcha');
  console.log({
    solved,
    error,
  });

  // Continue...
  await page.click('#recaptcha-demo-submit');
})().catch((e) => {
  console.error(e);
  process.exit(1);
});

```

## [section/The-Browserless-CDP-API/Browserless.heartbeat](https://docs.browserless.io/open-api\#section/The-Browserless-CDP-API/Browserless.heartbeat) Browserless.heartbeat

> This API is only available for Enterprise hosted and Starter and above plans on Cloud. [Contact us for more information here.](https://www.browserless.io/contact/).

> Custom CDP Events are not supported in all libraries, including .NET Playwright.

A custom event emitted every several seconds, signaling a live connection. This is useful for a few reasons:

- It ensure that your connection with the browser is still good.
- Sending data can trigger some load-balancing technologies to not kill the connection.

Today this event is emitted every 30 seconds.

```js
import puppeteer from 'puppeteer-core';

const browserWSEndpoint = `wss://production-sfo.browserless.io/chromium?token=YOUR-API-TOKEN`;

(async () => {
  const browser = await puppeteer.connect({ browserWSEndpoint });
  const page = await browser.newPage();
  await page.goto('https://example.com/');
  const client = await page.createCDPSession();

  client.on('Browserless.heartbeat', () => {
    console.log('Browserless.heartbeat');
  });
})();

```

## [section/The-Browserless-CDP-API/Browserless.pageId](https://docs.browserless.io/open-api\#section/The-Browserless-CDP-API/Browserless.pageId) Browserless.pageId

> This API is only available for Enterprise hosted and Starter and above plans on Cloud. [Contact us for more information here.](https://www.browserless.io/contact/).

A simple helper utility to return the page's unique ID. Since most libraries treat this ID as opaque, and some even hide it, knowing the page's ID can be of great help when interacting with other parts of Browserless.

```js
import puppeteer from 'puppeteer-core';

(async () => {
  const browserWSEndpoint = 'wss://production-sfo.browserless.io/chromium';
  const browser = await puppeteer.connect({ browserWSEndpoint });
  const page = await browser.newPage();
  const cdp = await page.createCDPSession();
  const { pageId } = await cdp.send('Browserless.pageId');

  // pageId = 'ABC12354AFDC123';
})();

```

You can, optionally, try and "find" this ID in puppeteer or similar libraries. Given that puppeteer has this property underscored, it's likely to change or be unavailable in the future, and requires the infamous `// @ts-ignore` comment to allow TypeScript compilation.

```ts
const getPageId = (page: Page): string => {
  // @ts-ignore
  return page.target()._targetId;
};

```

## [section/Changelog](https://docs.browserless.io/open-api\#section/Changelog) Changelog

## [tag/Browser-REST-APIs](https://docs.browserless.io/open-api\#tag/Browser-REST-APIs) Browser REST APIs

## [tag/Browser-REST-APIs/paths/~1chrome~1content/post](https://docs.browserless.io/open-api\#tag/Browser-REST-APIs/paths/~1chrome~1content/post)/chrome/content

A JSON-based API. Given a "url" or "html" field, runs and returns HTML content after the page has loaded and JavaScript has parsed.

##### query Parameters

|     |     |
| --- | --- |
| blockAds | boolean<br>Whether or nor to load ad-blocking extensions for the session.<br>This currently uses uBlock-Lite and may cause certain sites<br>to not load properly. |
| launch | object or string |
| timeout | number<br>Override the system-level timeout for this request.<br>Accepts a value in milliseconds. |
| token | string<br>The authorization token |
| trackingId | string<br>Custom session identifier |

##### Request Body schema: application/json

|     |     |
| --- | --- |
| addScriptTag | Array of objects |
| addStyleTag | Array of objects |
| authenticate | object or null |
| bestAttempt | boolean<br>When bestAttempt is set to true, browserless attempt to proceed<br>when "awaited" events fail or timeout. This includes things like<br>goto, waitForSelector, and more. |
| cookies | Array of objects |
| emulateMediaType | string |
| gotoOptions | object |
| html | string |
| rejectRequestPattern | Array of strings |
| rejectResourceTypes | Array of strings<br>Items Enum:"cspviolationreport""document""eventsource""fetch""font""image""manifest""media""other""ping""prefetch""preflight""script""signedexchange""stylesheet""texttrack""websocket""xhr" |
| requestInterceptors | Array of objects |
| setExtraHTTPHeaders | object |
| setJavaScriptEnabled | boolean<br>Whether or not to allow JavaScript to run on the page. |
| url | string |
| userAgent | string |
| viewport | object or null |
| waitForEvent | object |
| waitForFunction | object |
| waitForSelector | object |
| waitForTimeout | number |

### Responses

**200**

An HTML payload of the website or HTML after JavaScript
parsing and execution.

**400**

The request contains errors or didn't properly encode content.

**401**

The request is missing, or contains bad, authorization credentials.

**404**

Resource couldn't be found.

**408**

The request took has taken too long to process.

**429**

Too many requests are currently being processed.

**500**

An internal error occurred when handling the request.

post/chrome/content

https://docs.browserless.io/chrome/content

### Request samples

- Payload

Content type

application/json

Copy
Expand all  Collapse all

`{
"addScriptTag": [\
{\
"url": "string",\
"path": "string",\
"content": "string",\
"type": "string",\
"id": "string"}],
"addStyleTag": [\
{\
"url": "string",\
"path": "string",\
"content": "string"}],
"authenticate": {
"username": "string",
"password": "string"},
"bestAttempt": true,
"cookies": [\
{\
"name": "string",\
"value": "string",\
"url": "string",\
"domain": "string",\
"path": "string",\
"secure": true,\
"httpOnly": true,\
"sameSite": "Lax",\
"expires": 0,\
"priority": "High",\
"sameParty": true,\
"sourceScheme": "NonSecure",\
"partitionKey": {\
"sourceOrigin": "string",\
"hasCrossSiteAncestor": true}}],
"emulateMediaType": "string",
"gotoOptions": {
"referer": "string",
"referrerPolicy": "string",
"timeout": 0,
"waitUntil": [\
"domcontentloaded"],
"signal": {
"aborted": true,
"onabort": { },
"reason": null}},
"html": "string",
"rejectRequestPattern": [\
"string"],
"rejectResourceTypes": [\
"cspviolationreport"],
"requestInterceptors": [\
{\
"pattern": "string",\
"response": {\
"status": 0,\
"headers": { },\
"contentType": "string",\
"body": {\
"BYTES_PER_ELEMENT": 0,\
"buffer": {\
"byteLength": 0,\
"__@toStringTag@14939": "string"},\
"byteLength": 0,\
"byteOffset": 0,\
"length": 0,\
"__@toStringTag@14939": "Uint8Array"}}}],
"setExtraHTTPHeaders": { },
"setJavaScriptEnabled": true,
"url": "string",
"userAgent": "string",
"viewport": {
"width": 0,
"height": 0,
"deviceScaleFactor": 0,
"isMobile": true,
"isLandscape": true,
"hasTouch": true},
"waitForEvent": {
"event": "string",
"timeout": 0},
"waitForFunction": {
"fn": "string",
"polling": "string",
"timeout": 0},
"waitForSelector": {
"hidden": true,
"selector": "string",
"timeout": 0,
"visible": true},
"waitForTimeout": 0}`

## [tag/Browser-REST-APIs/paths/~1chrome~1download/post](https://docs.browserless.io/open-api\#tag/Browser-REST-APIs/paths/~1chrome~1download/post)/chrome/download

A JSON or JavaScript content-type API for returning files Chrome has downloaded during
the execution of puppeteer code, which is ran inside context of the browser.
Browserless sets up a blank page, a fresh download directory, injects your puppeteer code, and then executes it.
You can load external libraries via the "import" syntax, and import ESM-style modules
that are written for execution inside of the browser. Once your script is finished, any
downloaded files from Chromium are returned back with the appropriate content-type header.

##### query Parameters

|     |     |
| --- | --- |
| blockAds | boolean<br>Whether or nor to load ad-blocking extensions for the session.<br>This currently uses uBlock-Lite and may cause certain sites<br>to not load properly. |
| launch | object or string<br>Launch options, which can be either an object<br>of puppeteer.launch options or playwright.launchServer<br>options, depending on the API. Must be either JSON<br>object, or a base64-encoded JSON object. |
| timeout | number<br>Override the system-level timeout for this request.<br>Accepts a value in milliseconds. |
| token | string<br>The authorization token |
| trackingId | string<br>Custom session identifier |

##### Request Body schema:   application/jsonapplication/javascriptapplication/json

|     |     |
| --- | --- |
| code<br>required | string |
| context | object |

### Responses

**200**

Responses are determined by the returned value of the downloads
themselves, so there isn't a static response type for this API.

**400**

The request contains errors or didn't properly encode content.

**401**

The request is missing, or contains bad, authorization credentials.

**404**

Resource couldn't be found.

**408**

The request took has taken too long to process.

**429**

Too many requests are currently being processed.

**500**

An internal error occurred when handling the request.

post/chrome/download

https://docs.browserless.io/chrome/download

### Request samples

- Payload

Content type

application/jsonapplication/javascriptapplication/json

Copy
Expand all  Collapse all

`{
"code": "string",
"context": { }}`

## [tag/Browser-REST-APIs/paths/~1chrome~1function/post](https://docs.browserless.io/open-api\#tag/Browser-REST-APIs/paths/~1chrome~1function/post)/chrome/function

A JSON or JavaScript content-type API for running puppeteer code in the browser's context.
Browserless sets up a blank page, injects your puppeteer code, and runs it.
You can optionally load external libraries via the "import" module that are meant for browser usage.
Values returned from the function are checked and an appropriate content-type and response is sent back
to your HTTP call.

##### query Parameters

|     |     |
| --- | --- |
| blockAds | boolean<br>Whether or nor to load ad-blocking extensions for the session.<br>This currently uses uBlock-Lite and may cause certain sites<br>to not load properly. |
| launch | object or string<br>Launch options, which can be either an object<br>of puppeteer.launch options or playwright.launchServer<br>options, depending on the API. Must be either JSON<br>object, or a base64-encoded JSON object. |
| timeout | number<br>Override the system-level timeout for this request.<br>Accepts a value in milliseconds. |
| token | string<br>The authorization token |
| trackingId | string<br>Custom session identifier |

##### Request Body schema:   application/jsonapplication/javascriptapplication/json

|     |     |
| --- | --- |
| code<br>required | string |
| context | object |

### Responses

**200**

Responses are determined by the returned value of the function
itself. Binary responses (PDF's, screenshots) are returned back
as binary data, and primitive JavaScript values are returned back
by type (HTML data is "text/html", Objects are "application/json")

**400**

The request contains errors or didn't properly encode content.

**401**

The request is missing, or contains bad, authorization credentials.

**404**

Resource couldn't be found.

**408**

The request took has taken too long to process.

**429**

Too many requests are currently being processed.

**500**

An internal error occurred when handling the request.

post/chrome/function

https://docs.browserless.io/chrome/function

### Request samples

- Payload

Content type

application/jsonapplication/javascriptapplication/json

Copy
Expand all  Collapse all

`{
"code": "string",
"context": { }}`

## [tag/Browser-REST-APIs/paths/~1json~1list/get](https://docs.browserless.io/open-api\#tag/Browser-REST-APIs/paths/~1json~1list/get)/json/list

Returns a JSON payload that acts as a pass-through to the DevTools /json/list HTTP API in Chromium and Chrome.
Browserless crafts this payload so that remote clients can connect to the underlying "webSocketDebuggerUrl"
properly, excluding any API tokens in that URL. If under authentication be sure to include your authorization.

### Responses

**200**

**400**

The request contains errors or didn't properly encode content.

**401**

The request is missing, or contains bad, authorization credentials.

**404**

Resource couldn't be found.

**408**

The request took has taken too long to process.

**429**

Too many requests are currently being processed.

**500**

An internal error occurred when handling the request.

get/json/list

https://docs.browserless.io/json/list

### Response samples

- 200

Content type

application/json

Copy
Expand all  Collapse all

`[\
{\
"description": "string",\
"devtoolsFrontendUrl": "string",\
"id": "string",\
"title": "string",\
"type": "string",\
"url": "string",\
"webSocketDebuggerUrl": "string"}]`

## [tag/Browser-REST-APIs/paths/~1json~1new/put](https://docs.browserless.io/open-api\#tag/Browser-REST-APIs/paths/~1json~1new/put)/json/new

Returns a JSON payload that acts as a pass-through to the DevTools /json/new HTTP API in Chromium.
Browserless mocks this payload so that remote clients can connect to the underlying "webSocketDebuggerUrl"
which will cause Browserless to start the browser and proxy that request into a blank page.

### Responses

**200**

**400**

The request contains errors or didn't properly encode content.

**401**

The request is missing, or contains bad, authorization credentials.

**404**

Resource couldn't be found.

**408**

The request took has taken too long to process.

**429**

Too many requests are currently being processed.

**500**

An internal error occurred when handling the request.

put/json/new

https://docs.browserless.io/json/new

### Response samples

- 200

Content type

application/json

Copy

`{
"description": "string",
"devtoolsFrontendUrl": "string",
"id": "string",
"title": "string",
"type": "string",
"url": "string",
"webSocketDebuggerUrl": "string"}`

## [tag/Browser-REST-APIs/paths/~1json~1protocol/get](https://docs.browserless.io/open-api\#tag/Browser-REST-APIs/paths/~1json~1protocol/get)/json/protocol

Returns Protocol JSON meta-data that Chrome and Chromium come with.

### Responses

**200**

**400**

The request contains errors or didn't properly encode content.

**401**

The request is missing, or contains bad, authorization credentials.

**404**

Resource couldn't be found.

**408**

The request took has taken too long to process.

**429**

Too many requests are currently being processed.

**500**

An internal error occurred when handling the request.

get/json/protocol

https://docs.browserless.io/json/protocol

### Response samples

- 200

Content type

application/json

Copy

`{ }`

## [tag/Browser-REST-APIs/paths/~1json~1version/get](https://docs.browserless.io/open-api\#tag/Browser-REST-APIs/paths/~1json~1version/get)/json/version

Returns a JSON payload that acts as a pass-through to the DevTools /json/version protocol in Chrome and Chromium.

### Responses

**200**

**400**

The request contains errors or didn't properly encode content.

**401**

The request is missing, or contains bad, authorization credentials.

**404**

Resource couldn't be found.

**408**

The request took has taken too long to process.

**429**

Too many requests are currently being processed.

**500**

An internal error occurred when handling the request.

get/json/version

https://docs.browserless.io/json/version

### Response samples

- 200

Content type

application/json

Copy

`{
"description": "string",
"devtoolsFrontendUrl": "string",
"id": "string",
"title": "string",
"type": "string",
"url": "string",
"webSocketDebuggerUrl": "string"}`

## [tag/Browser-REST-APIs/paths/~1chrome~1pdf/post](https://docs.browserless.io/open-api\#tag/Browser-REST-APIs/paths/~1chrome~1pdf/post)/chrome/pdf

A JSON-based API for getting a PDF binary from either a supplied
"url" or "html" payload in your request. Many options exist for
injecting cookies, request interceptors, user-agents and waiting for
selectors, timers and more.

##### query Parameters

|     |     |
| --- | --- |
| blockAds | boolean<br>Whether or nor to load ad-blocking extensions for the session.<br>This currently uses uBlock-Lite and may cause certain sites<br>to not load properly. |
| launch | object or string<br>Launch options, which can be either an object<br>of puppeteer.launch options or playwright.launchServer<br>options, depending on the API. Must be either JSON<br>object, or a base64-encoded JSON object. |
| timeout | number<br>Override the system-level timeout for this request.<br>Accepts a value in milliseconds. |
| token | string<br>The authorization token |
| trackingId | string<br>Custom session identifier |

##### Request Body schema: application/json

|     |     |
| --- | --- |
| addScriptTag | Array of objects |
| addStyleTag | Array of objects |
| authenticate | object or null |
| bestAttempt | boolean<br>When bestAttempt is set to true, browserless attempt to proceed<br>when "awaited" events fail or timeout. This includes things like<br>goto, waitForSelector, and more. |
| cookies | Array of objects |
| emulateMediaType | string |
| gotoOptions | object |
| html | string |
| options | object<br>Valid options to configure PDF generation via {@link Page.pdf}. |
| rejectRequestPattern | Array of strings |
| rejectResourceTypes | Array of strings<br>Items Enum:"cspviolationreport""document""eventsource""fetch""font""image""manifest""media""other""ping""prefetch""preflight""script""signedexchange""stylesheet""texttrack""websocket""xhr" |
| requestInterceptors | Array of objects |
| setExtraHTTPHeaders | object |
| setJavaScriptEnabled | boolean |
| url | string |
| userAgent | string |
| viewport | object or null |
| waitForEvent | object |
| waitForFunction | object |
| waitForSelector | object |
| waitForTimeout | number |

### Responses

**200**

Responds with an application/pdf content-type and a binary PDF

**400**

The request contains errors or didn't properly encode content.

**401**

The request is missing, or contains bad, authorization credentials.

**404**

Resource couldn't be found.

**408**

The request took has taken too long to process.

**429**

Too many requests are currently being processed.

**500**

An internal error occurred when handling the request.

post/chrome/pdf

https://docs.browserless.io/chrome/pdf

### Request samples

- Payload

Content type

application/json

Copy
Expand all  Collapse all

`{
"addScriptTag": [\
{\
"url": "string",\
"path": "string",\
"content": "string",\
"type": "string",\
"id": "string"}],
"addStyleTag": [\
{\
"url": "string",\
"path": "string",\
"content": "string"}],
"authenticate": {
"username": "string",
"password": "string"},
"bestAttempt": true,
"cookies": [\
{\
"name": "string",\
"value": "string",\
"url": "string",\
"domain": "string",\
"path": "string",\
"secure": true,\
"httpOnly": true,\
"sameSite": "Lax",\
"expires": 0,\
"priority": "High",\
"sameParty": true,\
"sourceScheme": "NonSecure",\
"partitionKey": {\
"sourceOrigin": "string",\
"hasCrossSiteAncestor": true}}],
"emulateMediaType": "string",
"gotoOptions": {
"referer": "string",
"referrerPolicy": "string",
"timeout": 0,
"waitUntil": [\
"domcontentloaded"],
"signal": {
"aborted": true,
"onabort": { },
"reason": null}},
"html": "string",
"options": {
"scale": 0,
"displayHeaderFooter": true,
"headerTemplate": "string",
"footerTemplate": "string",
"printBackground": true,
"landscape": true,
"pageRanges": "string",
"format": "A0",
"width": "string",
"height": "string",
"preferCSSPageSize": true,
"margin": {
"top": "string",
"bottom": "string",
"left": "string",
"right": "string"},
"path": "string",
"omitBackground": true,
"tagged": true,
"outline": true,
"timeout": 0,
"waitForFonts": true},
"rejectRequestPattern": [\
"string"],
"rejectResourceTypes": [\
"cspviolationreport"],
"requestInterceptors": [\
{\
"pattern": "string",\
"response": {\
"status": 0,\
"headers": { },\
"contentType": "string",\
"body": {\
"BYTES_PER_ELEMENT": 0,\
"buffer": {\
"byteLength": 0,\
"__@toStringTag@14939": "string"},\
"byteLength": 0,\
"byteOffset": 0,\
"length": 0,\
"__@toStringTag@14939": "Uint8Array"}}}],
"setExtraHTTPHeaders": { },
"setJavaScriptEnabled": true,
"url": "string",
"userAgent": "string",
"viewport": {
"width": 0,
"height": 0,
"deviceScaleFactor": 0,
"isMobile": true,
"isLandscape": true,
"hasTouch": true},
"waitForEvent": {
"event": "string",
"timeout": 0},
"waitForFunction": {
"fn": "string",
"polling": "string",
"timeout": 0},
"waitForSelector": {
"hidden": true,
"selector": "string",
"timeout": 0,
"visible": true},
"waitForTimeout": 0}`

## [tag/Browser-REST-APIs/paths/~1chrome~1performance/post](https://docs.browserless.io/open-api\#tag/Browser-REST-APIs/paths/~1chrome~1performance/post)/chrome/performance

Run lighthouse performance audits with a supplied "url" in your JSON payload.

##### query Parameters

|     |     |
| --- | --- |
| blockAds | boolean<br>Whether or nor to load ad-blocking extensions for the session.<br>This currently uses uBlock-Lite and may cause certain sites<br>to not load properly. |
| launch | object or string<br>Launch options, which can be either an object<br>of puppeteer.launch options or playwright.launchServer<br>options, depending on the API. Must be either JSON<br>object, or a base64-encoded JSON object. |
| timeout | number<br>Override the system-level timeout for this request.<br>Accepts a value in milliseconds. |
| token | string<br>The authorization token |
| trackingId | string<br>Custom session identifier |

##### Request Body schema: application/json

|     |     |
| --- | --- |
| budgets | Array of objects |
| config | object |
| url | string |

### Responses

**200**

The response of the lighthouse stats. Response objects are
determined by the type of budgets and config in the POST
JSON body

**400**

The request contains errors or didn't properly encode content.

**401**

The request is missing, or contains bad, authorization credentials.

**404**

Resource couldn't be found.

**408**

The request took has taken too long to process.

**429**

Too many requests are currently being processed.

**500**

An internal error occurred when handling the request.

post/chrome/performance

https://docs.browserless.io/chrome/performance

### Request samples

- Payload

Content type

application/json

Copy
Expand all  Collapse all

`{
"budgets": [\
{ }],
"config": { },
"url": "string"}`

### Response samples

- 200

Content type

application/json

Copy

`{ }`

## [tag/Browser-REST-APIs/paths/~1chrome~1scrape/post](https://docs.browserless.io/open-api\#tag/Browser-REST-APIs/paths/~1chrome~1scrape/post)/chrome/scrape

A JSON-based API that returns text, html, and meta-data from a given list of selectors.
Debugging information is available by sending in the appropriate flags in the "debugOpts"
property. Responds with an array of JSON objects.

##### query Parameters

|     |     |
| --- | --- |
| blockAds | boolean<br>Whether or nor to load ad-blocking extensions for the session.<br>This currently uses uBlock-Lite and may cause certain sites<br>to not load properly. |
| launch | object or string |
| timeout | number<br>Override the system-level timeout for this request.<br>Accepts a value in milliseconds. |
| token | string<br>The authorization token |
| trackingId | string<br>Custom session identifier |

##### Request Body schema: application/json

|     |     |
| --- | --- |
| addScriptTag | Array of objects |
| addStyleTag | Array of objects |
| authenticate | object or null |
| bestAttempt | boolean<br>When bestAttempt is set to true, browserless attempt to proceed<br>when "awaited" events fail or timeout. This includes things like<br>goto, waitForSelector, and more. |
| cookies | Array of objects |
| debugOpts | object |
| elements | Array of objects |
| emulateMediaType | string |
| gotoOptions | object |
| html | string |
| rejectRequestPattern | Array of strings |
| rejectResourceTypes | Array of strings<br>Items Enum:"cspviolationreport""document""eventsource""fetch""font""image""manifest""media""other""ping""prefetch""preflight""script""signedexchange""stylesheet""texttrack""websocket""xhr" |
| requestInterceptors | Array of objects |
| setExtraHTTPHeaders | object |
| setJavaScriptEnabled | boolean |
| url | string |
| userAgent | string |
| viewport | object or null |
| waitForEvent | object |
| waitForFunction | object |
| waitForSelector | object |
| waitForTimeout | number |

### Responses

**200**

The JSON response body

**400**

The request contains errors or didn't properly encode content.

**401**

The request is missing, or contains bad, authorization credentials.

**404**

Resource couldn't be found.

**408**

The request took has taken too long to process.

**429**

Too many requests are currently being processed.

**500**

An internal error occurred when handling the request.

post/chrome/scrape

https://docs.browserless.io/chrome/scrape

### Request samples

- Payload

Content type

application/json

Copy
Expand all  Collapse all

`{
"addScriptTag": [\
{\
"url": "string",\
"path": "string",\
"content": "string",\
"type": "string",\
"id": "string"}],
"addStyleTag": [\
{\
"url": "string",\
"path": "string",\
"content": "string"}],
"authenticate": {
"username": "string",
"password": "string"},
"bestAttempt": true,
"cookies": [\
{\
"name": "string",\
"value": "string",\
"url": "string",\
"domain": "string",\
"path": "string",\
"secure": true,\
"httpOnly": true,\
"sameSite": "Lax",\
"expires": 0,\
"priority": "High",\
"sameParty": true,\
"sourceScheme": "NonSecure",\
"partitionKey": {\
"sourceOrigin": "string",\
"hasCrossSiteAncestor": true}}],
"debugOpts": {
"console": true,
"cookies": true,
"html": true,
"network": true,
"screenshot": true},
"elements": [\
{\
"selector": "string",\
"timeout": 0}],
"emulateMediaType": "string",
"gotoOptions": {
"referer": "string",
"referrerPolicy": "string",
"timeout": 0,
"waitUntil": [\
"domcontentloaded"],
"signal": {
"aborted": true,
"onabort": { },
"reason": null}},
"html": "string",
"rejectRequestPattern": [\
"string"],
"rejectResourceTypes": [\
"cspviolationreport"],
"requestInterceptors": [\
{\
"pattern": "string",\
"response": {\
"status": 0,\
"headers": { },\
"contentType": "string",\
"body": {\
"BYTES_PER_ELEMENT": 0,\
"buffer": {\
"byteLength": 0,\
"__@toStringTag@14939": "string"},\
"byteLength": 0,\
"byteOffset": 0,\
"length": 0,\
"__@toStringTag@14939": "Uint8Array"}}}],
"setExtraHTTPHeaders": { },
"setJavaScriptEnabled": true,
"url": "string",
"userAgent": "string",
"viewport": {
"width": 0,
"height": 0,
"deviceScaleFactor": 0,
"isMobile": true,
"isLandscape": true,
"hasTouch": true},
"waitForEvent": {
"event": "string",
"timeout": 0},
"waitForFunction": {
"fn": "string",
"polling": "string",
"timeout": 0},
"waitForSelector": {
"hidden": true,
"selector": "string",
"timeout": 0,
"visible": true},
"waitForTimeout": 0}`

### Response samples

- 200

Content type

application/json

Copy
Expand all  Collapse all

`{
"data": [\
{\
"results": [\
{\
"attributes": [\
{\
"name": "string",\
"value": "string"}],\
"height": 0,\
"html": "string",\
"left": 0,\
"text": "string",\
"top": 0,\
"width": 0}],\
"selector": "string"}],
"debug": {
"console": [\
"string"],
"cookies": [\
{\
"name": "string",\
"value": "string",\
"domain": "string",\
"path": "string",\
"expires": 0,\
"size": 0,\
"httpOnly": true,\
"secure": true,\
"session": true,\
"sameSite": "Lax",\
"priority": "High",\
"sameParty": true,\
"sourceScheme": "NonSecure",\
"partitionKey": {\
"sourceOrigin": "string",\
"hasCrossSiteAncestor": true},\
"partitionKeyOpaque": true}],
"html": null,
"network": {
"inbound": [\
{\
"headers": null,\
"status": 0,\
"url": "string"}],
"outbound": [\
{\
"headers": null,\
"method": "string",\
"url": "string"}]},
"screenshot": null}}`

## [tag/Browser-REST-APIs/paths/~1chrome~1screenshot/post](https://docs.browserless.io/open-api\#tag/Browser-REST-APIs/paths/~1chrome~1screenshot/post)/chrome/screenshot

A JSON-based API for getting a screenshot binary from either a supplied
"url" or "html" payload in your request. Many options exist including
cookies, user-agents, setting timers and network mocks.

##### query Parameters

|     |     |
| --- | --- |
| blockAds | boolean<br>Whether or nor to load ad-blocking extensions for the session.<br>This currently uses uBlock-Lite and may cause certain sites<br>to not load properly. |
| launch | object or string<br>Launch options, which can be either an object<br>of puppeteer.launch options or playwright.launchServer<br>options, depending on the API. Must be either JSON<br>object, or a base64-encoded JSON object. |
| timeout | number<br>Override the system-level timeout for this request.<br>Accepts a value in milliseconds. |
| token | string<br>The authorization token |
| trackingId | string<br>Custom session identifier |

##### Request Body schema: application/json

|     |     |
| --- | --- |
| addScriptTag | Array of objects |
| addStyleTag | Array of objects |
| authenticate | object or null |
| bestAttempt | boolean<br>When bestAttempt is set to true, browserless attempt to proceed<br>when "awaited" events fail or timeout. This includes things like<br>goto, waitForSelector, and more. |
| cookies | Array of objects |
| emulateMediaType | string |
| gotoOptions | object |
| html | string |
| options | object |
| rejectRequestPattern | Array of strings |
| rejectResourceTypes | Array of strings<br>Items Enum:"cspviolationreport""document""eventsource""fetch""font""image""manifest""media""other""ping""prefetch""preflight""script""signedexchange""stylesheet""texttrack""websocket""xhr" |
| requestInterceptors | Array of objects |
| scrollPage | boolean |
| selector | string |
| setExtraHTTPHeaders | object |
| setJavaScriptEnabled | boolean |
| url | string |
| userAgent | string |
| viewport | object or null |
| waitForEvent | object |
| waitForFunction | object |
| waitForSelector | object |
| waitForTimeout | number |

### Responses

**200**

Response can either be a text/plain base64 encoded body
or a binary stream with png/jpeg as a content-type

**400**

The request contains errors or didn't properly encode content.

**401**

The request is missing, or contains bad, authorization credentials.

**404**

Resource couldn't be found.

**408**

The request took has taken too long to process.

**429**

Too many requests are currently being processed.

**500**

An internal error occurred when handling the request.

post/chrome/screenshot

https://docs.browserless.io/chrome/screenshot

### Request samples

- Payload

Content type

application/json

Copy
Expand all  Collapse all

`{
"addScriptTag": [\
{\
"url": "string",\
"path": "string",\
"content": "string",\
"type": "string",\
"id": "string"}],
"addStyleTag": [\
{\
"url": "string",\
"path": "string",\
"content": "string"}],
"authenticate": {
"username": "string",
"password": "string"},
"bestAttempt": true,
"cookies": [\
{\
"name": "string",\
"value": "string",\
"url": "string",\
"domain": "string",\
"path": "string",\
"secure": true,\
"httpOnly": true,\
"sameSite": "Lax",\
"expires": 0,\
"priority": "High",\
"sameParty": true,\
"sourceScheme": "NonSecure",\
"partitionKey": {\
"sourceOrigin": "string",\
"hasCrossSiteAncestor": true}}],
"emulateMediaType": "string",
"gotoOptions": {
"referer": "string",
"referrerPolicy": "string",
"timeout": 0,
"waitUntil": [\
"domcontentloaded"],
"signal": {
"aborted": true,
"onabort": { },
"reason": null}},
"html": "string",
"options": {
"optimizeForSpeed": true,
"type": "jpeg",
"quality": 0,
"fromSurface": true,
"fullPage": true,
"omitBackground": true,
"path": "string",
"clip": {
"scale": 0,
"width": 0,
"height": 0,
"x": 0,
"y": 0},
"encoding": "base64",
"captureBeyondViewport": true},
"rejectRequestPattern": [\
"string"],
"rejectResourceTypes": [\
"cspviolationreport"],
"requestInterceptors": [\
{\
"pattern": "string",\
"response": {\
"status": 0,\
"headers": { },\
"contentType": "string",\
"body": {\
"BYTES_PER_ELEMENT": 0,\
"buffer": {\
"byteLength": 0,\
"__@toStringTag@14939": "string"},\
"byteLength": 0,\
"byteOffset": 0,\
"length": 0,\
"__@toStringTag@14939": "Uint8Array"}}}],
"scrollPage": true,
"selector": "string",
"setExtraHTTPHeaders": { },
"setJavaScriptEnabled": true,
"url": "string",
"userAgent": "string",
"viewport": {
"width": 0,
"height": 0,
"deviceScaleFactor": 0,
"isMobile": true,
"isLandscape": true,
"hasTouch": true},
"waitForEvent": {
"event": "string",
"timeout": 0},
"waitForFunction": {
"fn": "string",
"polling": "string",
"timeout": 0},
"waitForSelector": {
"hidden": true,
"selector": "string",
"timeout": 0,
"visible": true},
"waitForTimeout": 0}`

## [tag/Browser-REST-APIs/paths/~1chromium~1content/post](https://docs.browserless.io/open-api\#tag/Browser-REST-APIs/paths/~1chromium~1content/post)/chromium/content

A JSON-based API. Given a "url" or "html" field, runs and returns HTML content after the page has loaded and JavaScript has parsed.

**Note:** This endpoint is also available at: `/content` for backwards compatibility.

##### query Parameters

|     |     |
| --- | --- |
| blockAds | boolean<br>Whether or nor to load ad-blocking extensions for the session.<br>This currently uses uBlock-Lite and may cause certain sites<br>to not load properly. |
| launch | object or string |
| timeout | number<br>Override the system-level timeout for this request.<br>Accepts a value in milliseconds. |
| token | string<br>The authorization token |
| trackingId | string<br>Custom session identifier |

##### Request Body schema: application/json

|     |     |
| --- | --- |
| addScriptTag | Array of objects |
| addStyleTag | Array of objects |
| authenticate | object or null |
| bestAttempt | boolean<br>When bestAttempt is set to true, browserless attempt to proceed<br>when "awaited" events fail or timeout. This includes things like<br>goto, waitForSelector, and more. |
| cookies | Array of objects |
| emulateMediaType | string |
| gotoOptions | object |
| html | string |
| rejectRequestPattern | Array of strings |
| rejectResourceTypes | Array of strings<br>Items Enum:"cspviolationreport""document""eventsource""fetch""font""image""manifest""media""other""ping""prefetch""preflight""script""signedexchange""stylesheet""texttrack""websocket""xhr" |
| requestInterceptors | Array of objects |
| setExtraHTTPHeaders | object |
| setJavaScriptEnabled | boolean<br>Whether or not to allow JavaScript to run on the page. |
| url | string |
| userAgent | string |
| viewport | object or null |
| waitForEvent | object |
| waitForFunction | object |
| waitForSelector | object |
| waitForTimeout | number |

### Responses

**200**

An HTML payload of the website or HTML after JavaScript
parsing and execution.

**400**

The request contains errors or didn't properly encode content.

**401**

The request is missing, or contains bad, authorization credentials.

**404**

Resource couldn't be found.

**408**

The request took has taken too long to process.

**429**

Too many requests are currently being processed.

**500**

An internal error occurred when handling the request.

post/chromium/content

https://docs.browserless.io/chromium/content

### Request samples

- Payload

Content type

application/json

Copy
Expand all  Collapse all

`{
"addScriptTag": [\
{\
"url": "string",\
"path": "string",\
"content": "string",\
"type": "string",\
"id": "string"}],
"addStyleTag": [\
{\
"url": "string",\
"path": "string",\
"content": "string"}],
"authenticate": {
"username": "string",
"password": "string"},
"bestAttempt": true,
"cookies": [\
{\
"name": "string",\
"value": "string",\
"url": "string",\
"domain": "string",\
"path": "string",\
"secure": true,\
"httpOnly": true,\
"sameSite": "Lax",\
"expires": 0,\
"priority": "High",\
"sameParty": true,\
"sourceScheme": "NonSecure",\
"partitionKey": {\
"sourceOrigin": "string",\
"hasCrossSiteAncestor": true}}],
"emulateMediaType": "string",
"gotoOptions": {
"referer": "string",
"referrerPolicy": "string",
"timeout": 0,
"waitUntil": [\
"domcontentloaded"],
"signal": {
"aborted": true,
"onabort": { },
"reason": null}},
"html": "string",
"rejectRequestPattern": [\
"string"],
"rejectResourceTypes": [\
"cspviolationreport"],
"requestInterceptors": [\
{\
"pattern": "string",\
"response": {\
"status": 0,\
"headers": { },\
"contentType": "string",\
"body": {\
"BYTES_PER_ELEMENT": 0,\
"buffer": {\
"byteLength": 0,\
"__@toStringTag@14939": "string"},\
"byteLength": 0,\
"byteOffset": 0,\
"length": 0,\
"__@toStringTag@14939": "Uint8Array"}}}],
"setExtraHTTPHeaders": { },
"setJavaScriptEnabled": true,
"url": "string",
"userAgent": "string",
"viewport": {
"width": 0,
"height": 0,
"deviceScaleFactor": 0,
"isMobile": true,
"isLandscape": true,
"hasTouch": true},
"waitForEvent": {
"event": "string",
"timeout": 0},
"waitForFunction": {
"fn": "string",
"polling": "string",
"timeout": 0},
"waitForSelector": {
"hidden": true,
"selector": "string",
"timeout": 0,
"visible": true},
"waitForTimeout": 0}`

## [tag/Browser-REST-APIs/paths/~1chromium~1download/post](https://docs.browserless.io/open-api\#tag/Browser-REST-APIs/paths/~1chromium~1download/post)/chromium/download

A JSON or JavaScript content-type API for returning files Chrome has downloaded during
the execution of puppeteer code, which is ran inside context of the browser.
Browserless sets up a blank page, a fresh download directory, injects your puppeteer code, and then executes it.
You can load external libraries via the "import" syntax, and import ESM-style modules
that are written for execution inside of the browser. Once your script is finished, any
downloaded files from Chromium are returned back with the appropriate content-type header.

**Note:** This endpoint is also available at: `/download` for backwards compatibility.

##### query Parameters

|     |     |
| --- | --- |
| blockAds | boolean<br>Whether or nor to load ad-blocking extensions for the session.<br>This currently uses uBlock-Lite and may cause certain sites<br>to not load properly. |
| launch | object or string<br>Launch options, which can be either an object<br>of puppeteer.launch options or playwright.launchServer<br>options, depending on the API. Must be either JSON<br>object, or a base64-encoded JSON object. |
| timeout | number<br>Override the system-level timeout for this request.<br>Accepts a value in milliseconds. |
| token | string<br>The authorization token |
| trackingId | string<br>Custom session identifier |

##### Request Body schema:   application/jsonapplication/javascriptapplication/json

|     |     |
| --- | --- |
| code<br>required | string |
| context | object |

### Responses

**200**

Responses are determined by the returned value of the downloads
themselves, so there isn't a static response type for this API.

**400**

The request contains errors or didn't properly encode content.

**401**

The request is missing, or contains bad, authorization credentials.

**404**

Resource couldn't be found.

**408**

The request took has taken too long to process.

**429**

Too many requests are currently being processed.

**500**

An internal error occurred when handling the request.

post/chromium/download

https://docs.browserless.io/chromium/download

### Request samples

- Payload

Content type

application/jsonapplication/javascriptapplication/json

Copy
Expand all  Collapse all

`{
"code": "string",
"context": { }}`

## [tag/Browser-REST-APIs/paths/~1chromium~1function/post](https://docs.browserless.io/open-api\#tag/Browser-REST-APIs/paths/~1chromium~1function/post)/chromium/function

A JSON or JavaScript content-type API for running puppeteer code in the browser's context.
Browserless sets up a blank page, injects your puppeteer code, and runs it.
You can optionally load external libraries via the "import" module that are meant for browser usage.
Values returned from the function are checked and an appropriate content-type and response is sent back
to your HTTP call.

**Note:** This endpoint is also available at: `/function` for backwards compatibility.

##### query Parameters

|     |     |
| --- | --- |
| blockAds | boolean<br>Whether or nor to load ad-blocking extensions for the session.<br>This currently uses uBlock-Lite and may cause certain sites<br>to not load properly. |
| launch | object or string<br>Launch options, which can be either an object<br>of puppeteer.launch options or playwright.launchServer<br>options, depending on the API. Must be either JSON<br>object, or a base64-encoded JSON object. |
| timeout | number<br>Override the system-level timeout for this request.<br>Accepts a value in milliseconds. |
| token | string<br>The authorization token |
| trackingId | string<br>Custom session identifier |

##### Request Body schema:   application/jsonapplication/javascriptapplication/json

|     |     |
| --- | --- |
| code<br>required | string |
| context | object |

### Responses

**200**

Responses are determined by the returned value of the function
itself. Binary responses (PDF's, screenshots) are returned back
as binary data, and primitive JavaScript values are returned back
by type (HTML data is "text/html", Objects are "application/json")

**400**

The request contains errors or didn't properly encode content.

**401**

The request is missing, or contains bad, authorization credentials.

**404**

Resource couldn't be found.

**408**

The request took has taken too long to process.

**429**

Too many requests are currently being processed.

**500**

An internal error occurred when handling the request.

post/chromium/function

https://docs.browserless.io/chromium/function

### Request samples

- Payload

Content type

application/jsonapplication/javascriptapplication/json

Copy
Expand all  Collapse all

`{
"code": "string",
"context": { }}`

## [tag/Browser-REST-APIs/paths/~1chromium~1pdf/post](https://docs.browserless.io/open-api\#tag/Browser-REST-APIs/paths/~1chromium~1pdf/post)/chromium/pdf

A JSON-based API for getting a PDF binary from either a supplied
"url" or "html" payload in your request. Many options exist for
injecting cookies, request interceptors, user-agents and waiting for
selectors, timers and more.

**Note:** This endpoint is also available at: `/pdf` for backwards compatibility.

##### query Parameters

|     |     |
| --- | --- |
| blockAds | boolean<br>Whether or nor to load ad-blocking extensions for the session.<br>This currently uses uBlock-Lite and may cause certain sites<br>to not load properly. |
| launch | any or string<br>Launch options, which can be either an object<br>of puppeteer.launch options or playwright.launchServer<br>options, depending on the API. Must be either JSON<br>object, or a base64-encoded JSON object. |
| timeout | number<br>Override the system-level timeout for this request.<br>Accepts a value in milliseconds. |
| token | string<br>The authorization token |
| trackingId | string<br>Custom session identifier |

##### Request Body schema: application/json

|     |     |
| --- | --- |
| addScriptTag | Array of objects |
| addStyleTag | Array of objects |
| authenticate | object |
| bestAttempt | boolean<br>When bestAttempt is set to true, browserless attempt to proceed<br>when "awaited" events fail or timeout. This includes things like<br>goto, waitForSelector, and more. |
| blockConsentModals | boolean |
| cookies | Array of objects |
| emulateMediaType | string |
| gotoOptions | object |
| html | string |
| options | object<br>Valid options to configure PDF generation via {@link Page.pdf}. |
| rejectRequestPattern | Array of strings |
| rejectResourceTypes | Array of strings<br>Items Enum:"cspviolationreport""document""eventsource""fetch""font""image""manifest""media""other""ping""prefetch""preflight""script""signedexchange""stylesheet""texttrack""websocket""xhr" |
| requestInterceptors | Array of objects |
| setExtraHTTPHeaders | object |
| setJavaScriptEnabled | boolean |
| url | string |
| userAgent | string |
| viewport | object |
| waitForEvent | object |
| waitForFunction | object |
| waitForSelector | object |
| waitForTimeout | number |

### Responses

**400**

The request contains errors or didn't properly encode content.

**401**

The request is missing, or contains bad, authorization credentials.

**404**

Resource couldn't be found.

**408**

The request took has taken too long to process.

**429**

Too many requests are currently being processed.

**500**

An internal error occurred when handling the request.

post/chromium/pdf

https://docs.browserless.io/chromium/pdf

### Request samples

- Payload

Content type

application/json

Copy
Expand all  Collapse all

`{
"addScriptTag": [\
{\
"url": "string",\
"path": "string",\
"content": "string",\
"type": "string",\
"id": "string"}],
"addStyleTag": [\
{\
"url": "string",\
"path": "string",\
"content": "string"}],
"authenticate": {
"username": "string",
"password": "string"},
"bestAttempt": true,
"blockConsentModals": true,
"cookies": [\
{\
"name": "string",\
"value": "string",\
"url": "string",\
"domain": "string",\
"path": "string",\
"secure": true,\
"httpOnly": true,\
"sameSite": "Lax",\
"expires": 0,\
"priority": "High",\
"sameParty": true,\
"sourceScheme": "NonSecure",\
"partitionKey": {\
"sourceOrigin": "string",\
"hasCrossSiteAncestor": true}}],
"emulateMediaType": "string",
"gotoOptions": {
"referer": "string",
"referrerPolicy": "string",
"timeout": 0,
"waitUntil": [\
"domcontentloaded"],
"signal": {
"aborted": true,
"onabort": { },
"reason": null}},
"html": "string",
"options": {
"scale": 0,
"displayHeaderFooter": true,
"headerTemplate": "string",
"footerTemplate": "string",
"printBackground": true,
"landscape": true,
"pageRanges": "string",
"format": "A0",
"width": "string",
"height": "string",
"preferCSSPageSize": true,
"margin": {
"top": "string",
"bottom": "string",
"left": "string",
"right": "string"},
"path": "string",
"omitBackground": true,
"tagged": true,
"outline": true,
"timeout": 0,
"waitForFonts": true},
"rejectRequestPattern": [\
"string"],
"rejectResourceTypes": [\
"cspviolationreport"],
"requestInterceptors": [\
{\
"pattern": "string",\
"response": {\
"status": 0,\
"headers": { },\
"contentType": "string",\
"body": {\
"BYTES_PER_ELEMENT": 0,\
"buffer": {\
"byteLength": 0,\
"__@toStringTag@14939": "string"},\
"byteLength": 0,\
"byteOffset": 0,\
"length": 0,\
"__@toStringTag@14939": "Uint8Array"}}}],
"setExtraHTTPHeaders": { },
"setJavaScriptEnabled": true,
"url": "string",
"userAgent": "string",
"viewport": {
"width": 0,
"height": 0,
"deviceScaleFactor": 0,
"isMobile": true,
"isLandscape": true,
"hasTouch": true},
"waitForEvent": {
"event": "string",
"timeout": 0},
"waitForFunction": {
"fn": "string",
"polling": "string",
"timeout": 0},
"waitForSelector": {
"hidden": true,
"selector": "string",
"timeout": 0,
"visible": true},
"waitForTimeout": 0}`

## [tag/Browser-REST-APIs/paths/~1chromium~1performance/post](https://docs.browserless.io/open-api\#tag/Browser-REST-APIs/paths/~1chromium~1performance/post)/chromium/performance

Run lighthouse performance audits with a supplied "url" in your JSON payload.

**Note:** This endpoint is also available at: `/performance` for backwards compatibility.

##### query Parameters

|     |     |
| --- | --- |
| blockAds | boolean<br>Whether or nor to load ad-blocking extensions for the session.<br>This currently uses uBlock-Lite and may cause certain sites<br>to not load properly. |
| launch | object or string<br>Launch options, which can be either an object<br>of puppeteer.launch options or playwright.launchServer<br>options, depending on the API. Must be either JSON<br>object, or a base64-encoded JSON object. |
| timeout | number<br>Override the system-level timeout for this request.<br>Accepts a value in milliseconds. |
| token | string<br>The authorization token |
| trackingId | string<br>Custom session identifier |

##### Request Body schema: application/json

|     |     |
| --- | --- |
| budgets | Array of objects |
| config | object |
| url | string |

### Responses

**200**

The response of the lighthouse stats. Response objects are
determined by the type of budgets and config in the POST
JSON body

**400**

The request contains errors or didn't properly encode content.

**401**

The request is missing, or contains bad, authorization credentials.

**404**

Resource couldn't be found.

**408**

The request took has taken too long to process.

**429**

Too many requests are currently being processed.

**500**

An internal error occurred when handling the request.

post/chromium/performance

https://docs.browserless.io/chromium/performance

### Request samples

- Payload

Content type

application/json

Copy
Expand all  Collapse all

`{
"budgets": [\
{ }],
"config": { },
"url": "string"}`

### Response samples

- 200

Content type

application/json

Copy

`{ }`

## [tag/Browser-REST-APIs/paths/~1chromium~1scrape/post](https://docs.browserless.io/open-api\#tag/Browser-REST-APIs/paths/~1chromium~1scrape/post)/chromium/scrape

A JSON-based API that returns text, html, and meta-data from a given list of selectors.
Debugging information is available by sending in the appropriate flags in the "debugOpts"
property. Responds with an array of JSON objects.

**Note:** This endpoint is also available at: `/scrape` for backwards compatibility.

##### query Parameters

|     |     |
| --- | --- |
| blockAds | boolean<br>Whether or nor to load ad-blocking extensions for the session.<br>This currently uses uBlock-Lite and may cause certain sites<br>to not load properly. |
| launch | object or string |
| timeout | number<br>Override the system-level timeout for this request.<br>Accepts a value in milliseconds. |
| token | string<br>The authorization token |
| trackingId | string<br>Custom session identifier |

##### Request Body schema: application/json

|     |     |
| --- | --- |
| addScriptTag | Array of objects |
| addStyleTag | Array of objects |
| authenticate | object or null |
| bestAttempt | boolean<br>When bestAttempt is set to true, browserless attempt to proceed<br>when "awaited" events fail or timeout. This includes things like<br>goto, waitForSelector, and more. |
| cookies | Array of objects |
| debugOpts | object |
| elements | Array of objects |
| emulateMediaType | string |
| gotoOptions | object |
| html | string |
| rejectRequestPattern | Array of strings |
| rejectResourceTypes | Array of strings<br>Items Enum:"cspviolationreport""document""eventsource""fetch""font""image""manifest""media""other""ping""prefetch""preflight""script""signedexchange""stylesheet""texttrack""websocket""xhr" |
| requestInterceptors | Array of objects |
| setExtraHTTPHeaders | object |
| setJavaScriptEnabled | boolean |
| url | string |
| userAgent | string |
| viewport | object or null |
| waitForEvent | object |
| waitForFunction | object |
| waitForSelector | object |
| waitForTimeout | number |

### Responses

**200**

The JSON response body

**400**

The request contains errors or didn't properly encode content.

**401**

The request is missing, or contains bad, authorization credentials.

**404**

Resource couldn't be found.

**408**

The request took has taken too long to process.

**429**

Too many requests are currently being processed.

**500**

An internal error occurred when handling the request.

post/chromium/scrape

https://docs.browserless.io/chromium/scrape

### Request samples

- Payload

Content type

application/json

Copy
Expand all  Collapse all

`{
"addScriptTag": [\
{\
"url": "string",\
"path": "string",\
"content": "string",\
"type": "string",\
"id": "string"}],
"addStyleTag": [\
{\
"url": "string",\
"path": "string",\
"content": "string"}],
"authenticate": {
"username": "string",
"password": "string"},
"bestAttempt": true,
"cookies": [\
{\
"name": "string",\
"value": "string",\
"url": "string",\
"domain": "string",\
"path": "string",\
"secure": true,\
"httpOnly": true,\
"sameSite": "Lax",\
"expires": 0,\
"priority": "High",\
"sameParty": true,\
"sourceScheme": "NonSecure",\
"partitionKey": {\
"sourceOrigin": "string",\
"hasCrossSiteAncestor": true}}],
"debugOpts": {
"console": true,
"cookies": true,
"html": true,
"network": true,
"screenshot": true},
"elements": [\
{\
"selector": "string",\
"timeout": 0}],
"emulateMediaType": "string",
"gotoOptions": {
"referer": "string",
"referrerPolicy": "string",
"timeout": 0,
"waitUntil": [\
"domcontentloaded"],
"signal": {
"aborted": true,
"onabort": { },
"reason": null}},
"html": "string",
"rejectRequestPattern": [\
"string"],
"rejectResourceTypes": [\
"cspviolationreport"],
"requestInterceptors": [\
{\
"pattern": "string",\
"response": {\
"status": 0,\
"headers": { },\
"contentType": "string",\
"body": {\
"BYTES_PER_ELEMENT": 0,\
"buffer": {\
"byteLength": 0,\
"__@toStringTag@14939": "string"},\
"byteLength": 0,\
"byteOffset": 0,\
"length": 0,\
"__@toStringTag@14939": "Uint8Array"}}}],
"setExtraHTTPHeaders": { },
"setJavaScriptEnabled": true,
"url": "string",
"userAgent": "string",
"viewport": {
"width": 0,
"height": 0,
"deviceScaleFactor": 0,
"isMobile": true,
"isLandscape": true,
"hasTouch": true},
"waitForEvent": {
"event": "string",
"timeout": 0},
"waitForFunction": {
"fn": "string",
"polling": "string",
"timeout": 0},
"waitForSelector": {
"hidden": true,
"selector": "string",
"timeout": 0,
"visible": true},
"waitForTimeout": 0}`

### Response samples

- 200

Content type

application/json

Copy
Expand all  Collapse all

`{
"data": [\
{\
"results": [\
{\
"attributes": [\
{\
"name": "string",\
"value": "string"}],\
"height": 0,\
"html": "string",\
"left": 0,\
"text": "string",\
"top": 0,\
"width": 0}],\
"selector": "string"}],
"debug": {
"console": [\
"string"],
"cookies": [\
{\
"name": "string",\
"value": "string",\
"domain": "string",\
"path": "string",\
"expires": 0,\
"size": 0,\
"httpOnly": true,\
"secure": true,\
"session": true,\
"sameSite": "Lax",\
"priority": "High",\
"sameParty": true,\
"sourceScheme": "NonSecure",\
"partitionKey": {\
"sourceOrigin": "string",\
"hasCrossSiteAncestor": true},\
"partitionKeyOpaque": true}],
"html": null,
"network": {
"inbound": [\
{\
"headers": null,\
"status": 0,\
"url": "string"}],
"outbound": [\
{\
"headers": null,\
"method": "string",\
"url": "string"}]},
"screenshot": null}}`

## [tag/Browser-REST-APIs/paths/~1chromium~1screenshot/post](https://docs.browserless.io/open-api\#tag/Browser-REST-APIs/paths/~1chromium~1screenshot/post)/chromium/screenshot

A JSON-based API for getting a screenshot binary from either a supplied
"url" or "html" payload in your request. Many options exist including
cookies, user-agents, setting timers and network mocks.

**Note:** This endpoint is also available at: `/screenshot` for backwards compatibility.

##### query Parameters

|     |     |
| --- | --- |
| blockAds | boolean<br>Whether or nor to load ad-blocking extensions for the session.<br>This currently uses uBlock-Lite and may cause certain sites<br>to not load properly. |
| launch | any or string<br>Launch options, which can be either an object<br>of puppeteer.launch options or playwright.launchServer<br>options, depending on the API. Must be either JSON<br>object, or a base64-encoded JSON object. |
| timeout | number<br>Override the system-level timeout for this request.<br>Accepts a value in milliseconds. |
| token | string<br>The authorization token |
| trackingId | string<br>Custom session identifier |

##### Request Body schema: application/json

|     |     |
| --- | --- |
| addScriptTag | Array of objects |
| addStyleTag | Array of objects |
| authenticate | object |
| bestAttempt | boolean<br>When bestAttempt is set to true, browserless attempt to proceed<br>when "awaited" events fail or timeout. This includes things like<br>goto, waitForSelector, and more. |
| blockConsentModals | boolean |
| cookies | Array of objects |
| emulateMediaType | string |
| gotoOptions | object |
| html | string |
| options | object |
| rejectRequestPattern | Array of strings |
| rejectResourceTypes | Array of strings<br>Items Enum:"cspviolationreport""document""eventsource""fetch""font""image""manifest""media""other""ping""prefetch""preflight""script""signedexchange""stylesheet""texttrack""websocket""xhr" |
| requestInterceptors | Array of objects |
| scrollPage | boolean |
| selector | string |
| setExtraHTTPHeaders | object |
| setJavaScriptEnabled | boolean |
| url | string |
| userAgent | string |
| viewport | object |
| waitForEvent | object |
| waitForFunction | object |
| waitForSelector | object |
| waitForTimeout | number |

### Responses

**400**

The request contains errors or didn't properly encode content.

**401**

The request is missing, or contains bad, authorization credentials.

**404**

Resource couldn't be found.

**408**

The request took has taken too long to process.

**429**

Too many requests are currently being processed.

**500**

An internal error occurred when handling the request.

post/chromium/screenshot

https://docs.browserless.io/chromium/screenshot

### Request samples

- Payload

Content type

application/json

Copy
Expand all  Collapse all

`{
"addScriptTag": [\
{\
"url": "string",\
"path": "string",\
"content": "string",\
"type": "string",\
"id": "string"}],
"addStyleTag": [\
{\
"url": "string",\
"path": "string",\
"content": "string"}],
"authenticate": {
"username": "string",
"password": "string"},
"bestAttempt": true,
"blockConsentModals": true,
"cookies": [\
{\
"name": "string",\
"value": "string",\
"url": "string",\
"domain": "string",\
"path": "string",\
"secure": true,\
"httpOnly": true,\
"sameSite": "Lax",\
"expires": 0,\
"priority": "High",\
"sameParty": true,\
"sourceScheme": "NonSecure",\
"partitionKey": {\
"sourceOrigin": "string",\
"hasCrossSiteAncestor": true}}],
"emulateMediaType": "string",
"gotoOptions": {
"referer": "string",
"referrerPolicy": "string",
"timeout": 0,
"waitUntil": [\
"domcontentloaded"],
"signal": {
"aborted": true,
"onabort": { },
"reason": null}},
"html": "string",
"options": {
"optimizeForSpeed": true,
"type": "jpeg",
"quality": 0,
"fromSurface": true,
"fullPage": true,
"omitBackground": true,
"path": "string",
"clip": {
"scale": 0,
"width": 0,
"height": 0,
"x": 0,
"y": 0},
"encoding": "base64",
"captureBeyondViewport": true},
"rejectRequestPattern": [\
"string"],
"rejectResourceTypes": [\
"cspviolationreport"],
"requestInterceptors": [\
{\
"pattern": "string",\
"response": {\
"status": 0,\
"headers": { },\
"contentType": "string",\
"body": {\
"BYTES_PER_ELEMENT": 0,\
"buffer": {\
"byteLength": 0,\
"__@toStringTag@14939": "string"},\
"byteLength": 0,\
"byteOffset": 0,\
"length": 0,\
"__@toStringTag@14939": "Uint8Array"}}}],
"scrollPage": true,
"selector": "string",
"setExtraHTTPHeaders": { },
"setJavaScriptEnabled": true,
"url": "string",
"userAgent": "string",
"viewport": {
"width": 0,
"height": 0,
"deviceScaleFactor": 0,
"isMobile": true,
"isLandscape": true,
"hasTouch": true},
"waitForEvent": {
"event": "string",
"timeout": 0},
"waitForFunction": {
"fn": "string",
"polling": "string",
"timeout": 0},
"waitForSelector": {
"hidden": true,
"selector": "string",
"timeout": 0,
"visible": true},
"waitForTimeout": 0}`

## [tag/Browser-REST-APIs/paths/~1edge~1content/post](https://docs.browserless.io/open-api\#tag/Browser-REST-APIs/paths/~1edge~1content/post)/edge/content

A JSON-based API. Given a "url" or "html" field, runs and returns HTML content after the page has loaded and JavaScript has parsed.

##### query Parameters

|     |     |
| --- | --- |
| blockAds | boolean<br>Whether or nor to load ad-blocking extensions for the session.<br>This currently uses uBlock-Lite and may cause certain sites<br>to not load properly. |
| launch | object or string |
| timeout | number<br>Override the system-level timeout for this request.<br>Accepts a value in milliseconds. |
| token | string<br>The authorization token |
| trackingId | string<br>Custom session identifier |

##### Request Body schema: application/json

|     |     |
| --- | --- |
| addScriptTag | Array of objects |
| addStyleTag | Array of objects |
| authenticate | object or null |
| bestAttempt | boolean<br>When bestAttempt is set to true, browserless attempt to proceed<br>when "awaited" events fail or timeout. This includes things like<br>goto, waitForSelector, and more. |
| cookies | Array of objects |
| emulateMediaType | string |
| gotoOptions | object |
| html | string |
| rejectRequestPattern | Array of strings |
| rejectResourceTypes | Array of strings<br>Items Enum:"cspviolationreport""document""eventsource""fetch""font""image""manifest""media""other""ping""prefetch""preflight""script""signedexchange""stylesheet""texttrack""websocket""xhr" |
| requestInterceptors | Array of objects |
| setExtraHTTPHeaders | object |
| setJavaScriptEnabled | boolean<br>Whether or not to allow JavaScript to run on the page. |
| url | string |
| userAgent | string |
| viewport | object or null |
| waitForEvent | object |
| waitForFunction | object |
| waitForSelector | object |
| waitForTimeout | number |

### Responses

**200**

An HTML payload of the website or HTML after JavaScript
parsing and execution.

**400**

The request contains errors or didn't properly encode content.

**401**

The request is missing, or contains bad, authorization credentials.

**404**

Resource couldn't be found.

**408**

The request took has taken too long to process.

**429**

Too many requests are currently being processed.

**500**

An internal error occurred when handling the request.

post/edge/content

https://docs.browserless.io/edge/content

### Request samples

- Payload

Content type

application/json

Copy
Expand all  Collapse all

`{
"addScriptTag": [\
{\
"url": "string",\
"path": "string",\
"content": "string",\
"type": "string",\
"id": "string"}],
"addStyleTag": [\
{\
"url": "string",\
"path": "string",\
"content": "string"}],
"authenticate": {
"username": "string",
"password": "string"},
"bestAttempt": true,
"cookies": [\
{\
"name": "string",\
"value": "string",\
"url": "string",\
"domain": "string",\
"path": "string",\
"secure": true,\
"httpOnly": true,\
"sameSite": "Lax",\
"expires": 0,\
"priority": "High",\
"sameParty": true,\
"sourceScheme": "NonSecure",\
"partitionKey": {\
"sourceOrigin": "string",\
"hasCrossSiteAncestor": true}}],
"emulateMediaType": "string",
"gotoOptions": {
"referer": "string",
"referrerPolicy": "string",
"timeout": 0,
"waitUntil": [\
"domcontentloaded"],
"signal": {
"aborted": true,
"onabort": { },
"reason": null}},
"html": "string",
"rejectRequestPattern": [\
"string"],
"rejectResourceTypes": [\
"cspviolationreport"],
"requestInterceptors": [\
{\
"pattern": "string",\
"response": {\
"status": 0,\
"headers": { },\
"contentType": "string",\
"body": {\
"BYTES_PER_ELEMENT": 0,\
"buffer": {\
"byteLength": 0,\
"__@toStringTag@14939": "string"},\
"byteLength": 0,\
"byteOffset": 0,\
"length": 0,\
"__@toStringTag@14939": "Uint8Array"}}}],
"setExtraHTTPHeaders": { },
"setJavaScriptEnabled": true,
"url": "string",
"userAgent": "string",
"viewport": {
"width": 0,
"height": 0,
"deviceScaleFactor": 0,
"isMobile": true,
"isLandscape": true,
"hasTouch": true},
"waitForEvent": {
"event": "string",
"timeout": 0},
"waitForFunction": {
"fn": "string",
"polling": "string",
"timeout": 0},
"waitForSelector": {
"hidden": true,
"selector": "string",
"timeout": 0,
"visible": true},
"waitForTimeout": 0}`

## [tag/Browser-REST-APIs/paths/~1edge~1download/post](https://docs.browserless.io/open-api\#tag/Browser-REST-APIs/paths/~1edge~1download/post)/edge/download

A JSON or JavaScript content-type API for returning files Chrome has downloaded during
the execution of puppeteer code, which is ran inside context of the browser.
Browserless sets up a blank page, a fresh download directory, injects your puppeteer code, and then executes it.
You can load external libraries via the "import" syntax, and import ESM-style modules
that are written for execution inside of the browser. Once your script is finished, any
downloaded files from Chromium are returned back with the appropriate content-type header.

##### query Parameters

|     |     |
| --- | --- |
| blockAds | boolean<br>Whether or nor to load ad-blocking extensions for the session.<br>This currently uses uBlock-Lite and may cause certain sites<br>to not load properly. |
| launch | object or string<br>Launch options, which can be either an object<br>of puppeteer.launch options or playwright.launchServer<br>options, depending on the API. Must be either JSON<br>object, or a base64-encoded JSON object. |
| timeout | number<br>Override the system-level timeout for this request.<br>Accepts a value in milliseconds. |
| token | string<br>The authorization token |
| trackingId | string<br>Custom session identifier |

##### Request Body schema:   application/jsonapplication/javascriptapplication/json

|     |     |
| --- | --- |
| code<br>required | string |
| context | object |

### Responses

**200**

Responses are determined by the returned value of the downloads
themselves, so there isn't a static response type for this API.

**400**

The request contains errors or didn't properly encode content.

**401**

The request is missing, or contains bad, authorization credentials.

**404**

Resource couldn't be found.

**408**

The request took has taken too long to process.

**429**

Too many requests are currently being processed.

**500**

An internal error occurred when handling the request.

post/edge/download

https://docs.browserless.io/edge/download

### Request samples

- Payload

Content type

application/jsonapplication/javascriptapplication/json

Copy
Expand all  Collapse all

`{
"code": "string",
"context": { }}`

## [tag/Browser-REST-APIs/paths/~1edge~1function/post](https://docs.browserless.io/open-api\#tag/Browser-REST-APIs/paths/~1edge~1function/post)/edge/function

A JSON or JavaScript content-type API for running puppeteer code in the browser's context.
Browserless sets up a blank page, injects your puppeteer code, and runs it.
You can optionally load external libraries via the "import" module that are meant for browser usage.
Values returned from the function are checked and an appropriate content-type and response is sent back
to your HTTP call.

##### query Parameters

|     |     |
| --- | --- |
| blockAds | boolean<br>Whether or nor to load ad-blocking extensions for the session.<br>This currently uses uBlock-Lite and may cause certain sites<br>to not load properly. |
| launch | object or string<br>Launch options, which can be either an object<br>of puppeteer.launch options or playwright.launchServer<br>options, depending on the API. Must be either JSON<br>object, or a base64-encoded JSON object. |
| timeout | number<br>Override the system-level timeout for this request.<br>Accepts a value in milliseconds. |
| token | string<br>The authorization token |
| trackingId | string<br>Custom session identifier |

##### Request Body schema:   application/jsonapplication/javascriptapplication/json

|     |     |
| --- | --- |
| code<br>required | string |
| context | object |

### Responses

**200**

Responses are determined by the returned value of the function
itself. Binary responses (PDF's, screenshots) are returned back
as binary data, and primitive JavaScript values are returned back
by type (HTML data is "text/html", Objects are "application/json")

**400**

The request contains errors or didn't properly encode content.

**401**

The request is missing, or contains bad, authorization credentials.

**404**

Resource couldn't be found.

**408**

The request took has taken too long to process.

**429**

Too many requests are currently being processed.

**500**

An internal error occurred when handling the request.

post/edge/function

https://docs.browserless.io/edge/function

### Request samples

- Payload

Content type

application/jsonapplication/javascriptapplication/json

Copy
Expand all  Collapse all

`{
"code": "string",
"context": { }}`

## [tag/Browser-REST-APIs/paths/~1edge~1pdf/post](https://docs.browserless.io/open-api\#tag/Browser-REST-APIs/paths/~1edge~1pdf/post)/edge/pdf

A JSON-based API for getting a PDF binary from either a supplied
"url" or "html" payload in your request. Many options exist for
injecting cookies, request interceptors, user-agents and waiting for
selectors, timers and more.

##### query Parameters

|     |     |
| --- | --- |
| blockAds | boolean<br>Whether or nor to load ad-blocking extensions for the session.<br>This currently uses uBlock-Lite and may cause certain sites<br>to not load properly. |
| launch | object or string<br>Launch options, which can be either an object<br>of puppeteer.launch options or playwright.launchServer<br>options, depending on the API. Must be either JSON<br>object, or a base64-encoded JSON object. |
| timeout | number<br>Override the system-level timeout for this request.<br>Accepts a value in milliseconds. |
| token | string<br>The authorization token |
| trackingId | string<br>Custom session identifier |

##### Request Body schema: application/json

|     |     |
| --- | --- |
| addScriptTag | Array of objects |
| addStyleTag | Array of objects |
| authenticate | object or null |
| bestAttempt | boolean<br>When bestAttempt is set to true, browserless attempt to proceed<br>when "awaited" events fail or timeout. This includes things like<br>goto, waitForSelector, and more. |
| cookies | Array of objects |
| emulateMediaType | string |
| gotoOptions | object |
| html | string |
| options | object<br>Valid options to configure PDF generation via {@link Page.pdf}. |
| rejectRequestPattern | Array of strings |
| rejectResourceTypes | Array of strings<br>Items Enum:"cspviolationreport""document""eventsource""fetch""font""image""manifest""media""other""ping""prefetch""preflight""script""signedexchange""stylesheet""texttrack""websocket""xhr" |
| requestInterceptors | Array of objects |
| setExtraHTTPHeaders | object |
| setJavaScriptEnabled | boolean |
| url | string |
| userAgent | string |
| viewport | object or null |
| waitForEvent | object |
| waitForFunction | object |
| waitForSelector | object |
| waitForTimeout | number |

### Responses

**200**

Responds with an application/pdf content-type and a binary PDF

**400**

The request contains errors or didn't properly encode content.

**401**

The request is missing, or contains bad, authorization credentials.

**404**

Resource couldn't be found.

**408**

The request took has taken too long to process.

**429**

Too many requests are currently being processed.

**500**

An internal error occurred when handling the request.

post/edge/pdf

https://docs.browserless.io/edge/pdf

### Request samples

- Payload

Content type

application/json

Copy
Expand all  Collapse all

`{
"addScriptTag": [\
{\
"url": "string",\
"path": "string",\
"content": "string",\
"type": "string",\
"id": "string"}],
"addStyleTag": [\
{\
"url": "string",\
"path": "string",\
"content": "string"}],
"authenticate": {
"username": "string",
"password": "string"},
"bestAttempt": true,
"cookies": [\
{\
"name": "string",\
"value": "string",\
"url": "string",\
"domain": "string",\
"path": "string",\
"secure": true,\
"httpOnly": true,\
"sameSite": "Lax",\
"expires": 0,\
"priority": "High",\
"sameParty": true,\
"sourceScheme": "NonSecure",\
"partitionKey": {\
"sourceOrigin": "string",\
"hasCrossSiteAncestor": true}}],
"emulateMediaType": "string",
"gotoOptions": {
"referer": "string",
"referrerPolicy": "string",
"timeout": 0,
"waitUntil": [\
"domcontentloaded"],
"signal": {
"aborted": true,
"onabort": { },
"reason": null}},
"html": "string",
"options": {
"scale": 0,
"displayHeaderFooter": true,
"headerTemplate": "string",
"footerTemplate": "string",
"printBackground": true,
"landscape": true,
"pageRanges": "string",
"format": "A0",
"width": "string",
"height": "string",
"preferCSSPageSize": true,
"margin": {
"top": "string",
"bottom": "string",
"left": "string",
"right": "string"},
"path": "string",
"omitBackground": true,
"tagged": true,
"outline": true,
"timeout": 0,
"waitForFonts": true},
"rejectRequestPattern": [\
"string"],
"rejectResourceTypes": [\
"cspviolationreport"],
"requestInterceptors": [\
{\
"pattern": "string",\
"response": {\
"status": 0,\
"headers": { },\
"contentType": "string",\
"body": {\
"BYTES_PER_ELEMENT": 0,\
"buffer": {\
"byteLength": 0,\
"__@toStringTag@14939": "string"},\
"byteLength": 0,\
"byteOffset": 0,\
"length": 0,\
"__@toStringTag@14939": "Uint8Array"}}}],
"setExtraHTTPHeaders": { },
"setJavaScriptEnabled": true,
"url": "string",
"userAgent": "string",
"viewport": {
"width": 0,
"height": 0,
"deviceScaleFactor": 0,
"isMobile": true,
"isLandscape": true,
"hasTouch": true},
"waitForEvent": {
"event": "string",
"timeout": 0},
"waitForFunction": {
"fn": "string",
"polling": "string",
"timeout": 0},
"waitForSelector": {
"hidden": true,
"selector": "string",
"timeout": 0,
"visible": true},
"waitForTimeout": 0}`

## [tag/Browser-REST-APIs/paths/~1edge~1performance/post](https://docs.browserless.io/open-api\#tag/Browser-REST-APIs/paths/~1edge~1performance/post)/edge/performance

Run lighthouse performance audits with a supplied "url" in your JSON payload.

##### query Parameters

|     |     |
| --- | --- |
| blockAds | boolean<br>Whether or nor to load ad-blocking extensions for the session.<br>This currently uses uBlock-Lite and may cause certain sites<br>to not load properly. |
| launch | object or string<br>Launch options, which can be either an object<br>of puppeteer.launch options or playwright.launchServer<br>options, depending on the API. Must be either JSON<br>object, or a base64-encoded JSON object. |
| timeout | number<br>Override the system-level timeout for this request.<br>Accepts a value in milliseconds. |
| token | string<br>The authorization token |
| trackingId | string<br>Custom session identifier |

##### Request Body schema: application/json

|     |     |
| --- | --- |
| budgets | Array of objects |
| config | object |
| url | string |

### Responses

**200**

The response of the lighthouse stats. Response objects are
determined by the type of budgets and config in the POST
JSON body

**400**

The request contains errors or didn't properly encode content.

**401**

The request is missing, or contains bad, authorization credentials.

**404**

Resource couldn't be found.

**408**

The request took has taken too long to process.

**429**

Too many requests are currently being processed.

**500**

An internal error occurred when handling the request.

post/edge/performance

https://docs.browserless.io/edge/performance

### Request samples

- Payload

Content type

application/json

Copy
Expand all  Collapse all

`{
"budgets": [\
{ }],
"config": { },
"url": "string"}`

### Response samples

- 200

Content type

application/json

Copy

`{ }`

## [tag/Browser-REST-APIs/paths/~1edge~1scrape/post](https://docs.browserless.io/open-api\#tag/Browser-REST-APIs/paths/~1edge~1scrape/post)/edge/scrape

A JSON-based API that returns text, html, and meta-data from a given list of selectors.
Debugging information is available by sending in the appropriate flags in the "debugOpts"
property. Responds with an array of JSON objects.

##### query Parameters

|     |     |
| --- | --- |
| blockAds | boolean<br>Whether or nor to load ad-blocking extensions for the session.<br>This currently uses uBlock-Lite and may cause certain sites<br>to not load properly. |
| launch | object or string |
| timeout | number<br>Override the system-level timeout for this request.<br>Accepts a value in milliseconds. |
| token | string<br>The authorization token |
| trackingId | string<br>Custom session identifier |

##### Request Body schema: application/json

|     |     |
| --- | --- |
| addScriptTag | Array of objects |
| addStyleTag | Array of objects |
| authenticate | object or null |
| bestAttempt | boolean<br>When bestAttempt is set to true, browserless attempt to proceed<br>when "awaited" events fail or timeout. This includes things like<br>goto, waitForSelector, and more. |
| cookies | Array of objects |
| debugOpts | object |
| elements | Array of objects |
| emulateMediaType | string |
| gotoOptions | object |
| html | string |
| rejectRequestPattern | Array of strings |
| rejectResourceTypes | Array of strings<br>Items Enum:"cspviolationreport""document""eventsource""fetch""font""image""manifest""media""other""ping""prefetch""preflight""script""signedexchange""stylesheet""texttrack""websocket""xhr" |
| requestInterceptors | Array of objects |
| setExtraHTTPHeaders | object |
| setJavaScriptEnabled | boolean |
| url | string |
| userAgent | string |
| viewport | object or null |
| waitForEvent | object |
| waitForFunction | object |
| waitForSelector | object |
| waitForTimeout | number |

### Responses

**200**

The JSON response body

**400**

The request contains errors or didn't properly encode content.

**401**

The request is missing, or contains bad, authorization credentials.

**404**

Resource couldn't be found.

**408**

The request took has taken too long to process.

**429**

Too many requests are currently being processed.

**500**

An internal error occurred when handling the request.

post/edge/scrape

https://docs.browserless.io/edge/scrape

### Request samples

- Payload

Content type

application/json

Copy
Expand all  Collapse all

`{
"addScriptTag": [\
{\
"url": "string",\
"path": "string",\
"content": "string",\
"type": "string",\
"id": "string"}],
"addStyleTag": [\
{\
"url": "string",\
"path": "string",\
"content": "string"}],
"authenticate": {
"username": "string",
"password": "string"},
"bestAttempt": true,
"cookies": [\
{\
"name": "string",\
"value": "string",\
"url": "string",\
"domain": "string",\
"path": "string",\
"secure": true,\
"httpOnly": true,\
"sameSite": "Lax",\
"expires": 0,\
"priority": "High",\
"sameParty": true,\
"sourceScheme": "NonSecure",\
"partitionKey": {\
"sourceOrigin": "string",\
"hasCrossSiteAncestor": true}}],
"debugOpts": {
"console": true,
"cookies": true,
"html": true,
"network": true,
"screenshot": true},
"elements": [\
{\
"selector": "string",\
"timeout": 0}],
"emulateMediaType": "string",
"gotoOptions": {
"referer": "string",
"referrerPolicy": "string",
"timeout": 0,
"waitUntil": [\
"domcontentloaded"],
"signal": {
"aborted": true,
"onabort": { },
"reason": null}},
"html": "string",
"rejectRequestPattern": [\
"string"],
"rejectResourceTypes": [\
"cspviolationreport"],
"requestInterceptors": [\
{\
"pattern": "string",\
"response": {\
"status": 0,\
"headers": { },\
"contentType": "string",\
"body": {\
"BYTES_PER_ELEMENT": 0,\
"buffer": {\
"byteLength": 0,\
"__@toStringTag@14939": "string"},\
"byteLength": 0,\
"byteOffset": 0,\
"length": 0,\
"__@toStringTag@14939": "Uint8Array"}}}],
"setExtraHTTPHeaders": { },
"setJavaScriptEnabled": true,
"url": "string",
"userAgent": "string",
"viewport": {
"width": 0,
"height": 0,
"deviceScaleFactor": 0,
"isMobile": true,
"isLandscape": true,
"hasTouch": true},
"waitForEvent": {
"event": "string",
"timeout": 0},
"waitForFunction": {
"fn": "string",
"polling": "string",
"timeout": 0},
"waitForSelector": {
"hidden": true,
"selector": "string",
"timeout": 0,
"visible": true},
"waitForTimeout": 0}`

### Response samples

- 200

Content type

application/json

Copy
Expand all  Collapse all

`{
"data": [\
{\
"results": [\
{\
"attributes": [\
{\
"name": "string",\
"value": "string"}],\
"height": 0,\
"html": "string",\
"left": 0,\
"text": "string",\
"top": 0,\
"width": 0}],\
"selector": "string"}],
"debug": {
"console": [\
"string"],
"cookies": [\
{\
"name": "string",\
"value": "string",\
"domain": "string",\
"path": "string",\
"expires": 0,\
"size": 0,\
"httpOnly": true,\
"secure": true,\
"session": true,\
"sameSite": "Lax",\
"priority": "High",\
"sameParty": true,\
"sourceScheme": "NonSecure",\
"partitionKey": {\
"sourceOrigin": "string",\
"hasCrossSiteAncestor": true},\
"partitionKeyOpaque": true}],
"html": null,
"network": {
"inbound": [\
{\
"headers": null,\
"status": 0,\
"url": "string"}],
"outbound": [\
{\
"headers": null,\
"method": "string",\
"url": "string"}]},
"screenshot": null}}`

## [tag/Browser-REST-APIs/paths/~1edge~1screenshot/post](https://docs.browserless.io/open-api\#tag/Browser-REST-APIs/paths/~1edge~1screenshot/post)/edge/screenshot

A JSON-based API for getting a screenshot binary from either a supplied
"url" or "html" payload in your request. Many options exist including
cookies, user-agents, setting timers and network mocks.

##### query Parameters

|     |     |
| --- | --- |
| blockAds | boolean<br>Whether or nor to load ad-blocking extensions for the session.<br>This currently uses uBlock-Lite and may cause certain sites<br>to not load properly. |
| launch | object or string<br>Launch options, which can be either an object<br>of puppeteer.launch options or playwright.launchServer<br>options, depending on the API. Must be either JSON<br>object, or a base64-encoded JSON object. |
| timeout | number<br>Override the system-level timeout for this request.<br>Accepts a value in milliseconds. |
| token | string<br>The authorization token |
| trackingId | string<br>Custom session identifier |

##### Request Body schema: application/json

|     |     |
| --- | --- |
| addScriptTag | Array of objects |
| addStyleTag | Array of objects |
| authenticate | object or null |
| bestAttempt | boolean<br>When bestAttempt is set to true, browserless attempt to proceed<br>when "awaited" events fail or timeout. This includes things like<br>goto, waitForSelector, and more. |
| cookies | Array of objects |
| emulateMediaType | string |
| gotoOptions | object |
| html | string |
| options | object |
| rejectRequestPattern | Array of strings |
| rejectResourceTypes | Array of strings<br>Items Enum:"cspviolationreport""document""eventsource""fetch""font""image""manifest""media""other""ping""prefetch""preflight""script""signedexchange""stylesheet""texttrack""websocket""xhr" |
| requestInterceptors | Array of objects |
| scrollPage | boolean |
| selector | string |
| setExtraHTTPHeaders | object |
| setJavaScriptEnabled | boolean |
| url | string |
| userAgent | string |
| viewport | object or null |
| waitForEvent | object |
| waitForFunction | object |
| waitForSelector | object |
| waitForTimeout | number |

### Responses

**200**

Response can either be a text/plain base64 encoded body
or a binary stream with png/jpeg as a content-type

**400**

The request contains errors or didn't properly encode content.

**401**

The request is missing, or contains bad, authorization credentials.

**404**

Resource couldn't be found.

**408**

The request took has taken too long to process.

**429**

Too many requests are currently being processed.

**500**

An internal error occurred when handling the request.

post/edge/screenshot

https://docs.browserless.io/edge/screenshot

### Request samples

- Payload

Content type

application/json

Copy
Expand all  Collapse all

`{
"addScriptTag": [\
{\
"url": "string",\
"path": "string",\
"content": "string",\
"type": "string",\
"id": "string"}],
"addStyleTag": [\
{\
"url": "string",\
"path": "string",\
"content": "string"}],
"authenticate": {
"username": "string",
"password": "string"},
"bestAttempt": true,
"cookies": [\
{\
"name": "string",\
"value": "string",\
"url": "string",\
"domain": "string",\
"path": "string",\
"secure": true,\
"httpOnly": true,\
"sameSite": "Lax",\
"expires": 0,\
"priority": "High",\
"sameParty": true,\
"sourceScheme": "NonSecure",\
"partitionKey": {\
"sourceOrigin": "string",\
"hasCrossSiteAncestor": true}}],
"emulateMediaType": "string",
"gotoOptions": {
"referer": "string",
"referrerPolicy": "string",
"timeout": 0,
"waitUntil": [\
"domcontentloaded"],
"signal": {
"aborted": true,
"onabort": { },
"reason": null}},
"html": "string",
"options": {
"optimizeForSpeed": true,
"type": "jpeg",
"quality": 0,
"fromSurface": true,
"fullPage": true,
"omitBackground": true,
"path": "string",
"clip": {
"scale": 0,
"width": 0,
"height": 0,
"x": 0,
"y": 0},
"encoding": "base64",
"captureBeyondViewport": true},
"rejectRequestPattern": [\
"string"],
"rejectResourceTypes": [\
"cspviolationreport"],
"requestInterceptors": [\
{\
"pattern": "string",\
"response": {\
"status": 0,\
"headers": { },\
"contentType": "string",\
"body": {\
"BYTES_PER_ELEMENT": 0,\
"buffer": {\
"byteLength": 0,\
"__@toStringTag@14939": "string"},\
"byteLength": 0,\
"byteOffset": 0,\
"length": 0,\
"__@toStringTag@14939": "Uint8Array"}}}],
"scrollPage": true,
"selector": "string",
"setExtraHTTPHeaders": { },
"setJavaScriptEnabled": true,
"url": "string",
"userAgent": "string",
"viewport": {
"width": 0,
"height": 0,
"deviceScaleFactor": 0,
"isMobile": true,
"isLandscape": true,
"hasTouch": true},
"waitForEvent": {
"event": "string",
"timeout": 0},
"waitForFunction": {
"fn": "string",
"polling": "string",
"timeout": 0},
"waitForSelector": {
"hidden": true,
"selector": "string",
"timeout": 0,
"visible": true},
"waitForTimeout": 0}`

## [tag/Browser-REST-APIs/paths/~1chrome~1export/post](https://docs.browserless.io/open-api\#tag/Browser-REST-APIs/paths/~1chrome~1export/post)/chrome/export

> This API is only available for Enterprise, hosted and self-hosted plans. [Contact us for more information here.](https://www.browserless.io/contact/)

Exports a webpage to a PDF or image format. This API is useful for generating reports, screenshots, or PDFs of web pages.

##### query Parameters

|     |     |
| --- | --- |
| blockAds | boolean<br>Whether or nor to load ad-blocking extensions for the session.<br>This currently uses uBlock-Lite and may cause certain sites<br>to not load properly. |
| launch | any or string<br>Launch options, which can be either an object<br>of puppeteer.launch options or playwright.launchServer<br>options, depending on the API. Must be either JSON<br>object, or a base64-encoded JSON object. |
| timeout | number<br>Override the system-level timeout for this request.<br>Accepts a value in milliseconds. |
| token | string<br>The authorization token |
| trackingId | string<br>Custom session identifier |

##### Request Body schema: application/json

|     |     |
| --- | --- |
| bestAttempt | boolean<br>When bestAttempt is set to true, browserless attempt to proceed<br>when "awaited" events fail or timeout. This includes things like<br>goto, waitForSelector, and more. |
| url | string<br>The URL of the site you want to archive. |
| gotoOptions | object |
| waitForEvent | object |
| waitForFunction | object |
| waitForSelector | object |
| waitForTimeout | number |
| headers | object |

### Responses

**200**

**400**

The request contains errors or didn't properly encode content.

**401**

The request is missing, or contains bad, authorization credentials.

**404**

Resource couldn't be found.

**408**

The request took has taken too long to process.

**429**

Too many requests are currently being processed.

**500**

An internal error occurred when handling the request.

post/chrome/export

https://docs.browserless.io/chrome/export

### Request samples

- Payload

Content type

application/json

Copy
Expand all  Collapse all

`{
"bestAttempt": true,
"url": "string",
"gotoOptions": {
"referer": "string",
"referrerPolicy": "string",
"timeout": 0,
"waitUntil": [\
"domcontentloaded"],
"signal": {
"aborted": true,
"onabort": { },
"reason": null}},
"waitForEvent": {
"event": "string",
"timeout": 0},
"waitForFunction": {
"fn": "string",
"polling": "string",
"timeout": 0},
"waitForSelector": {
"hidden": true,
"selector": "string",
"timeout": 0,
"visible": true},
"waitForTimeout": 0,
"headers": { }}`

### Response samples

- 200

Content type

application/json

Copy

`{
"html": "string"}`

## [tag/Browser-REST-APIs/paths/~1chrome~1unblock/post](https://docs.browserless.io/open-api\#tag/Browser-REST-APIs/paths/~1chrome~1unblock/post)/chrome/unblock

> This API is only available for Enterprise and Cloud-unit plans. [Contact us for more information here.](https://www.browserless.io/contact/), or [sign-up here](https://www.browserless.io/pricing/).

Unblocks the provided URL from being blocked due to bot detection.
Returns a payload of Cookies, HTML, a base64 encoded screenshot,
and a "browserWSEndpoint" to allow connecting to the browser when
specified in the JSON Payload. Only supports CDP or Puppeteer
like libraries when connecting to the "browserWSEndpoint".

##### query Parameters

|     |     |
| --- | --- |
| blockAds | boolean<br>Whether or nor to load ad-blocking extensions for the session.<br>This currently uses uBlock-Lite and may cause certain sites<br>to not load properly. |
| launch | any or string<br>Launch options, which can be either an object<br>of puppeteer.launch options or playwright.launchServer<br>options, depending on the API. Must be either JSON<br>object, or a base64-encoded JSON object. |
| timeout | number<br>Override the system-level timeout for this request.<br>Accepts a value in milliseconds. |
| token | string<br>The authorization token |
| trackingId | string<br>Custom session identifier |

##### Request Body schema: application/json

|     |     |
| --- | --- |
| bestAttempt | boolean<br>When bestAttempt is set to true, browserless attempt to proceed<br>when "awaited" events fail or timeout. This includes things like<br>goto, waitForSelector, and more. |
| url | string<br>The URL of the site you want to unblock. |
| browserWSEndpoint | boolean<br>Whether or not to keep the underlying browser alive and around for<br>future reconnects. Defaults to false. |
| cookies | boolean<br>Whether or not to to return cookies for the site, defaults to true. |
| content | boolean<br>Whether or not to to return content for the site, defaults to true. |
| screenshot | boolean<br>Whether or not to to return a full-page screenshot for the site, defaults to true. |
| ttl | number<br>When the browserWSEndpoint is requested this tells<br>browserless how long to keep this browser alive for<br>re-connection until shutting it down completely.<br>Maximum of 30000 for 30 seconds (30,000ms). |
| gotoOptions | object |
| waitForEvent | object |
| waitForFunction | object |
| waitForSelector | object |
| waitForTimeout | number |

### Responses

**200**

**400**

The request contains errors or didn't properly encode content.

**401**

The request is missing, or contains bad, authorization credentials.

**404**

Resource couldn't be found.

**408**

The request took has taken too long to process.

**429**

Too many requests are currently being processed.

**500**

An internal error occurred when handling the request.

post/chrome/unblock

https://docs.browserless.io/chrome/unblock

### Request samples

- Payload

Content type

application/json

Copy
Expand all  Collapse all

`{
"bestAttempt": true,
"url": "string",
"browserWSEndpoint": true,
"cookies": true,
"content": true,
"screenshot": true,
"ttl": 0,
"gotoOptions": {
"referer": "string",
"referrerPolicy": "string",
"timeout": 0,
"waitUntil": [\
"domcontentloaded"],
"signal": {
"aborted": true,
"onabort": { },
"reason": null}},
"waitForEvent": {
"event": "string",
"timeout": 0},
"waitForFunction": {
"fn": "string",
"polling": "string",
"timeout": 0},
"waitForSelector": {
"hidden": true,
"selector": "string",
"timeout": 0,
"visible": true},
"waitForTimeout": 0}`

### Response samples

- 200

Content type

application/json

Copy
Expand all  Collapse all

`{
"cookies": [\
{\
"name": "string",\
"value": "string",\
"domain": "string",\
"path": "string",\
"expires": 0,\
"size": 0,\
"httpOnly": true,\
"secure": true,\
"session": true,\
"sameSite": "Lax",\
"priority": "High",\
"sameParty": true,\
"sourceScheme": "NonSecure",\
"partitionKey": {\
"sourceOrigin": "string",\
"hasCrossSiteAncestor": true},\
"partitionKeyOpaque": true}],
"content": "string",
"browserWSEndpoint": "string",
"ttl": 0,
"screenshot": "string"}`

## [tag/Browser-REST-APIs/paths/~1chromium~1export/post](https://docs.browserless.io/open-api\#tag/Browser-REST-APIs/paths/~1chromium~1export/post)/chromium/export

> This API is only available for Enterprise, hosted and self-hosted plans. [Contact us for more information here.](https://www.browserless.io/contact/)

Exports a webpage to a PDF or image format. This API is useful for generating reports, screenshots, or PDFs of web pages.

**Note:** This endpoint is also available at: `/export` for backwards compatibility.

##### query Parameters

|     |     |
| --- | --- |
| blockAds | boolean<br>Whether or nor to load ad-blocking extensions for the session.<br>This currently uses uBlock-Lite and may cause certain sites<br>to not load properly. |
| launch | any or string<br>Launch options, which can be either an object<br>of puppeteer.launch options or playwright.launchServer<br>options, depending on the API. Must be either JSON<br>object, or a base64-encoded JSON object. |
| timeout | number<br>Override the system-level timeout for this request.<br>Accepts a value in milliseconds. |
| token | string<br>The authorization token |
| trackingId | string<br>Custom session identifier |

##### Request Body schema: application/json

|     |     |
| --- | --- |
| bestAttempt | boolean<br>When bestAttempt is set to true, browserless attempt to proceed<br>when "awaited" events fail or timeout. This includes things like<br>goto, waitForSelector, and more. |
| url | string<br>The URL of the site you want to archive. |
| gotoOptions | object |
| waitForEvent | object |
| waitForFunction | object |
| waitForSelector | object |
| waitForTimeout | number |
| headers | object |

### Responses

**200**

**400**

The request contains errors or didn't properly encode content.

**401**

The request is missing, or contains bad, authorization credentials.

**404**

Resource couldn't be found.

**408**

The request took has taken too long to process.

**429**

Too many requests are currently being processed.

**500**

An internal error occurred when handling the request.

post/chromium/export

https://docs.browserless.io/chromium/export

### Request samples

- Payload

Content type

application/json

Copy
Expand all  Collapse all

`{
"bestAttempt": true,
"url": "string",
"gotoOptions": {
"referer": "string",
"referrerPolicy": "string",
"timeout": 0,
"waitUntil": [\
"domcontentloaded"],
"signal": {
"aborted": true,
"onabort": { },
"reason": null}},
"waitForEvent": {
"event": "string",
"timeout": 0},
"waitForFunction": {
"fn": "string",
"polling": "string",
"timeout": 0},
"waitForSelector": {
"hidden": true,
"selector": "string",
"timeout": 0,
"visible": true},
"waitForTimeout": 0,
"headers": { }}`

### Response samples

- 200

Content type

application/json

Copy

`{
"html": "string"}`

## [tag/Browser-REST-APIs/paths/~1chromium~1unblock/post](https://docs.browserless.io/open-api\#tag/Browser-REST-APIs/paths/~1chromium~1unblock/post)/chromium/unblock

> This API is only available for Enterprise and Cloud-unit plans. [Contact us for more information here.](https://www.browserless.io/contact/), or [sign-up here](https://www.browserless.io/pricing/).

Unblocks the provided URL from being blocked due to bot detection.
Returns a payload of Cookies, HTML, a base64 encoded screenshot,
and a "browserWSEndpoint" to allow connecting to the browser when
specified in the JSON Payload. Only supports CDP or Puppeteer
like libraries when connecting to the "browserWSEndpoint".

**Note:** This endpoint is also available at: `/unblock` for backwards compatibility.

##### query Parameters

|     |     |
| --- | --- |
| blockAds | boolean<br>Whether or nor to load ad-blocking extensions for the session.<br>This currently uses uBlock-Lite and may cause certain sites<br>to not load properly. |
| launch | any or string<br>Launch options, which can be either an object<br>of puppeteer.launch options or playwright.launchServer<br>options, depending on the API. Must be either JSON<br>object, or a base64-encoded JSON object. |
| timeout | number<br>Override the system-level timeout for this request.<br>Accepts a value in milliseconds. |
| token | string<br>The authorization token |
| trackingId | string<br>Custom session identifier |

##### Request Body schema: application/json

|     |     |
| --- | --- |
| bestAttempt | boolean<br>When bestAttempt is set to true, browserless attempt to proceed<br>when "awaited" events fail or timeout. This includes things like<br>goto, waitForSelector, and more. |
| url | string<br>The URL of the site you want to unblock. |
| browserWSEndpoint | boolean<br>Whether or not to keep the underlying browser alive and around for<br>future reconnects. Defaults to false. |
| cookies | boolean<br>Whether or not to to return cookies for the site, defaults to true. |
| content | boolean<br>Whether or not to to return content for the site, defaults to true. |
| screenshot | boolean<br>Whether or not to to return a full-page screenshot for the site, defaults to true. |
| ttl | number<br>When the browserWSEndpoint is requested this tells<br>browserless how long to keep this browser alive for<br>re-connection until shutting it down completely.<br>Maximum of 30000 for 30 seconds (30,000ms). |
| gotoOptions | object |
| waitForEvent | object |
| waitForFunction | object |
| waitForSelector | object |
| waitForTimeout | number |

### Responses

**200**

**400**

The request contains errors or didn't properly encode content.

**401**

The request is missing, or contains bad, authorization credentials.

**404**

Resource couldn't be found.

**408**

The request took has taken too long to process.

**429**

Too many requests are currently being processed.

**500**

An internal error occurred when handling the request.

post/chromium/unblock

https://docs.browserless.io/chromium/unblock

### Request samples

- Payload

Content type

application/json

Copy
Expand all  Collapse all

`{
"bestAttempt": true,
"url": "string",
"browserWSEndpoint": true,
"cookies": true,
"content": true,
"screenshot": true,
"ttl": 0,
"gotoOptions": {
"referer": "string",
"referrerPolicy": "string",
"timeout": 0,
"waitUntil": [\
"domcontentloaded"],
"signal": {
"aborted": true,
"onabort": { },
"reason": null}},
"waitForEvent": {
"event": "string",
"timeout": 0},
"waitForFunction": {
"fn": "string",
"polling": "string",
"timeout": 0},
"waitForSelector": {
"hidden": true,
"selector": "string",
"timeout": 0,
"visible": true},
"waitForTimeout": 0}`

### Response samples

- 200

Content type

application/json

Copy
Expand all  Collapse all

`{
"cookies": [\
{\
"name": "string",\
"value": "string",\
"domain": "string",\
"path": "string",\
"expires": 0,\
"size": 0,\
"httpOnly": true,\
"secure": true,\
"session": true,\
"sameSite": "Lax",\
"priority": "High",\
"sameParty": true,\
"sourceScheme": "NonSecure",\
"partitionKey": {\
"sourceOrigin": "string",\
"hasCrossSiteAncestor": true},\
"partitionKeyOpaque": true}],
"content": "string",
"browserWSEndpoint": "string",
"ttl": 0,
"screenshot": "string"}`

## [tag/Browser-REST-APIs/paths/~1chrome~1bql?(~1*)/post](https://docs.browserless.io/open-api\#tag/Browser-REST-APIs/paths/~1chrome~1bql?(~1*)/post)/chrome/bql?(/\*)

> This API is only available for Enterprise, hosted and self-hosted plans. [Contact us for more information here.](https://www.browserless.io/contact/)

Parses and executes BrowserQL requests, powered by the BrowserQL Editor or by other API integrations. See the BrowserQL Editor for more documentation on this API.

##### query Parameters

|     |     |
| --- | --- |
| blockAds | boolean<br>Whether or nor to load ad-blocking extensions for the session.<br>This currently uses uBlock-Lite and may cause certain sites<br>to not load properly. |
| blockConsentModals | boolean |
| humanlike | boolean |
| launch | any or string<br>Launch options, which can be either an object<br>of puppeteer.launch options or playwright.launchServer<br>options, depending on the API. Must be either JSON<br>object, or a base64-encoded JSON object. |
| timeout | number<br>Override the system-level timeout for this request.<br>Accepts a value in milliseconds. |
| token | string<br>The authorization token |
| trackingId | string<br>Custom session identifier |

##### Request Body schema: application/json

|     |     |
| --- | --- |
| query | string |
| operationName | string |
| variables | object |

### Responses

**400**

The request contains errors or didn't properly encode content.

**401**

The request is missing, or contains bad, authorization credentials.

**404**

Resource couldn't be found.

**408**

The request took has taken too long to process.

**429**

Too many requests are currently being processed.

**500**

An internal error occurred when handling the request.

post/chrome/bql?(/\*)

https://docs.browserless.io/chrome/bql?(/\*)

### Request samples

- Payload

Content type

application/json

Copy
Expand all  Collapse all

`{
"query": "string",
"operationName": "string",
"variables": {
"property1": null,
"property2": null}}`

## [tag/Browser-REST-APIs/paths/~1chromium~1bql?(~1*)/post](https://docs.browserless.io/open-api\#tag/Browser-REST-APIs/paths/~1chromium~1bql?(~1*)/post)/chromium/bql?(/\*)

> This API is only available for Enterprise, hosted and self-hosted plans. [Contact us for more information here.](https://www.browserless.io/contact/)

Parses and executes BrowserQL requests, powered by the BrowserQL Editor or by other API integrations. See the BrowserQL Editor for more documentation on this API.

##### query Parameters

|     |     |
| --- | --- |
| blockAds | boolean<br>Whether or nor to load ad-blocking extensions for the session.<br>This currently uses uBlock-Lite and may cause certain sites<br>to not load properly. |
| blockConsentModals | boolean |
| humanlike | boolean |
| launch | any or string<br>Launch options, which can be either an object<br>of puppeteer.launch options or playwright.launchServer<br>options, depending on the API. Must be either JSON<br>object, or a base64-encoded JSON object. |
| timeout | number<br>Override the system-level timeout for this request.<br>Accepts a value in milliseconds. |
| token | string<br>The authorization token |
| trackingId | string<br>Custom session identifier |

##### Request Body schema: application/json

|     |     |
| --- | --- |
| query | string |
| operationName | string |
| variables | object |

### Responses

**400**

The request contains errors or didn't properly encode content.

**401**

The request is missing, or contains bad, authorization credentials.

**404**

Resource couldn't be found.

**408**

The request took has taken too long to process.

**429**

Too many requests are currently being processed.

**500**

An internal error occurred when handling the request.

post/chromium/bql?(/\*)

https://docs.browserless.io/chromium/bql?(/\*)

### Request samples

- Payload

Content type

application/json

Copy
Expand all  Collapse all

`{
"query": "string",
"operationName": "string",
"variables": {
"property1": null,
"property2": null}}`

## [tag/Management-REST-APIs](https://docs.browserless.io/open-api\#tag/Management-REST-APIs) Management REST APIs

## [tag/Management-REST-APIs/paths/~1active/get](https://docs.browserless.io/open-api\#tag/Management-REST-APIs/paths/~1active/get)/active

Returns a simple "204" HTTP code, with no response, indicating that the service itself is up and running.
Useful for liveliness probes or other external checks.

### Responses

**400**

The request contains errors or didn't properly encode content.

**401**

The request is missing, or contains bad, authorization credentials.

**404**

Resource couldn't be found.

**408**

The request took has taken too long to process.

**429**

Too many requests are currently being processed.

**500**

An internal error occurred when handling the request.

get/active

https://docs.browserless.io/active

## [tag/Management-REST-APIs/paths/~1kill~1+([0-9a-zA-Z-_])/get](https://docs.browserless.io/open-api\#tag/Management-REST-APIs/paths/~1kill~1+([0-9a-zA-Z-_])/get)/kill/+(\[0-9a-zA-Z-\_\])

Kill running sessions based on BrowserId or TrackingId.

##### query Parameters

|     |     |
| --- | --- |
| token<br>required | string<br>The authorization token |
| blockAds | boolean<br>Whether or nor to load ad-blocking extensions for the session.<br>This currently uses uBlock-Lite and may cause certain sites<br>to not load properly. |
| browserId | string |
| launch | object or object or string<br>Launch options, which can be either an object<br>of puppeteer.launch options or playwright.launchServer<br>options, depending on the API. Must be either JSON<br>object, or a base64-encoded JSON object. |
| timeout | number<br>Override the system-level timeout for this request.<br>Accepts a value in milliseconds. |
| trackingId | string<br>Custom session identifier |

### Responses

**400**

The request contains errors or didn't properly encode content.

**401**

The request is missing, or contains bad, authorization credentials.

**404**

Resource couldn't be found.

**408**

The request took has taken too long to process.

**429**

Too many requests are currently being processed.

**500**

An internal error occurred when handling the request.

get/kill/+(\[0-9a-zA-Z-\_\])

https://docs.browserless.io/kill/+(\[0-9a-zA-Z-\_\])

## [tag/Management-REST-APIs/paths/~1meta/get](https://docs.browserless.io/open-api\#tag/Management-REST-APIs/paths/~1meta/get)/meta

Returns a JSON payload of the current system versions, including the core API version.

### Responses

**200**

**400**

The request contains errors or didn't properly encode content.

**401**

The request is missing, or contains bad, authorization credentials.

**404**

Resource couldn't be found.

**408**

The request took has taken too long to process.

**429**

Too many requests are currently being processed.

**500**

An internal error occurred when handling the request.

get/meta

https://docs.browserless.io/meta

### Response samples

- 200

Content type

application/json

Copy
Expand all  Collapse all

`{
"version": "string",
"chromium": null,
"webkit": null,
"firefox": null,
"playwright": [\
"string"],
"puppeteer": [\
"string"]}`

## [tag/Management-REST-APIs/paths/~1/get](https://docs.browserless.io/open-api\#tag/Management-REST-APIs/paths/~1/get)/

Serves static files inside of this "static" directory. Content-types will vary depending on the type =of file being returned.

### Responses

**400**

The request contains errors or didn't properly encode content.

**401**

The request is missing, or contains bad, authorization credentials.

**404**

Resource couldn't be found.

**408**

The request took has taken too long to process.

**429**

Too many requests are currently being processed.

**500**

An internal error occurred when handling the request.

get/

https://docs.browserless.io/

## [tag/Browser-WebSocket-APIs](https://docs.browserless.io/open-api\#tag/Browser-WebSocket-APIs) Browser WebSocket APIs

## [tag/Browser-WebSocket-APIs/paths/~1devtools~1browser~1*/get](https://docs.browserless.io/open-api\#tag/Browser-WebSocket-APIs/paths/~1devtools~1browser~1*/get)/devtools/browser/\*

Connect to an already-running Chromium process with a library like
puppeteer, or others, that work over chrome-devtools-protocol. Chromium
must already be launched in order to not return a 404.

##### query Parameters

|     |     |
| --- | --- |
| blockAds | boolean<br>Whether or nor to load ad-blocking extensions for the session.<br>This currently uses uBlock-Lite and may cause certain sites<br>to not load properly. |
| launch | object or string<br>Launch options, which can be either an object<br>of puppeteer.launch options or playwright.launchServer<br>options, depending on the API. Must be either JSON<br>object, or a base64-encoded JSON object. |
| timeout | number<br>Override the system-level timeout for this request.<br>Accepts a value in milliseconds. |
| token | string<br>The authorization token |
| trackingId | string<br>Custom session identifier |

### Responses

**101**

Indicates successful WebSocket upgrade.

**400**

The request contains errors or didn't properly encode content.

**401**

The request is missing, or contains bad, authorization credentials.

**404**

Resource couldn't be found.

**408**

The request took has taken too long to process.

**429**

Too many requests are currently being processed.

**500**

An internal error occurred when handling the request.

get/devtools/browser/\*

https://docs.browserless.io/devtools/browser/\*

## [tag/Browser-WebSocket-APIs/paths/~1chrome/get](https://docs.browserless.io/open-api\#tag/Browser-WebSocket-APIs/paths/~1chrome/get)/chrome

Launch and connect to Chromium with a library like puppeteer or others that work over chrome-devtools-protocol.

##### query Parameters

|     |     |
| --- | --- |
| blockAds | boolean<br>Whether or nor to load ad-blocking extensions for the session.<br>This currently uses uBlock-Lite and may cause certain sites<br>to not load properly. |
| launch | any or string<br>Launch options, which can be either an object<br>of puppeteer.launch options or playwright.launchServer<br>options, depending on the API. Must be either JSON<br>object, or a base64-encoded JSON object. |
| record | boolean |
| timeout | number<br>Override the system-level timeout for this request.<br>Accepts a value in milliseconds. |
| token | string<br>The authorization token |
| trackingId | string<br>Custom session identifier |

### Responses

**101**

Indicates successful WebSocket upgrade.

**400**

The request contains errors or didn't properly encode content.

**401**

The request is missing, or contains bad, authorization credentials.

**404**

Resource couldn't be found.

**408**

The request took has taken too long to process.

**429**

Too many requests are currently being processed.

**500**

An internal error occurred when handling the request.

get/chrome

https://docs.browserless.io/chrome

## [tag/Browser-WebSocket-APIs/paths/~1devtools~1page~1*/get](https://docs.browserless.io/open-api\#tag/Browser-WebSocket-APIs/paths/~1devtools~1page~1*/get)/devtools/page/\*

Connect to an existing page in Chromium with a library like
chrome-remote-interface or others that work the page websocketDebugger
URL. You can get this unique URL by calling the /json/list API
or by finding the page's unique ID from your library of choice.

##### query Parameters

|     |     |
| --- | --- |
| blockAds | boolean<br>Whether or nor to load ad-blocking extensions for the session.<br>This currently uses uBlock-Lite and may cause certain sites<br>to not load properly. |
| launch | object or string<br>Launch options, which can be either an object<br>of puppeteer.launch options or playwright.launchServer<br>options, depending on the API. Must be either JSON<br>object, or a base64-encoded JSON object. |
| timeout | number<br>Override the system-level timeout for this request.<br>Accepts a value in milliseconds. |
| token | string<br>The authorization token |
| trackingId | string<br>Custom session identifier |

### Responses

**101**

Indicates successful WebSocket upgrade.

**400**

The request contains errors or didn't properly encode content.

**401**

The request is missing, or contains bad, authorization credentials.

**404**

Resource couldn't be found.

**408**

The request took has taken too long to process.

**429**

Too many requests are currently being processed.

**500**

An internal error occurred when handling the request.

get/devtools/page/\*

https://docs.browserless.io/devtools/page/\*

## [tag/Browser-WebSocket-APIs/paths/~1chrome~1playwright/get](https://docs.browserless.io/open-api\#tag/Browser-WebSocket-APIs/paths/~1chrome~1playwright/get)/chrome/playwright

Connect to Chromium with any playwright style library.

##### query Parameters

|     |     |
| --- | --- |
| blockAds | boolean<br>Whether or nor to load ad-blocking extensions for the session.<br>This currently uses uBlock-Lite and may cause certain sites<br>to not load properly. |
| launch | object or string<br>Launch options, which can be either an object<br>of puppeteer.launch options or playwright.launchServer<br>options, depending on the API. Must be either JSON<br>object, or a base64-encoded JSON object. |
| timeout | number<br>Override the system-level timeout for this request.<br>Accepts a value in milliseconds. |
| token | string<br>The authorization token |
| trackingId | string<br>Custom session identifier |

### Responses

**101**

Indicates successful WebSocket upgrade.

**400**

The request contains errors or didn't properly encode content.

**401**

The request is missing, or contains bad, authorization credentials.

**404**

Resource couldn't be found.

**408**

The request took has taken too long to process.

**429**

Too many requests are currently being processed.

**500**

An internal error occurred when handling the request.

get/chrome/playwright

https://docs.browserless.io/chrome/playwright

## [tag/Browser-WebSocket-APIs/paths/~1chromium/get](https://docs.browserless.io/open-api\#tag/Browser-WebSocket-APIs/paths/~1chromium/get)/chromium

Launch and connect to Chromium with a library like puppeteer or others that work over chrome-devtools-protocol.

**Note:** This endpoint is also available at: \`\` for backwards compatibility.

##### query Parameters

|     |     |
| --- | --- |
| blockAds | boolean<br>Whether or nor to load ad-blocking extensions for the session.<br>This currently uses uBlock-Lite and may cause certain sites<br>to not load properly. |
| launch | any or string<br>Launch options, which can be either an object<br>of puppeteer.launch options or playwright.launchServer<br>options, depending on the API. Must be either JSON<br>object, or a base64-encoded JSON object. |
| record | boolean |
| timeout | number<br>Override the system-level timeout for this request.<br>Accepts a value in milliseconds. |
| token | string<br>The authorization token |
| trackingId | string<br>Custom session identifier |

### Responses

**101**

Indicates successful WebSocket upgrade.

**400**

The request contains errors or didn't properly encode content.

**401**

The request is missing, or contains bad, authorization credentials.

**404**

Resource couldn't be found.

**408**

The request took has taken too long to process.

**429**

Too many requests are currently being processed.

**500**

An internal error occurred when handling the request.

get/chromium

https://docs.browserless.io/chromium

## [tag/Browser-WebSocket-APIs/paths/~1playwright~1chromium/get](https://docs.browserless.io/open-api\#tag/Browser-WebSocket-APIs/paths/~1playwright~1chromium/get)/playwright/chromium

Connect to Chromium with any playwright style library.

**Note:** This endpoint is also available at: `/chromium/playwright` for backwards compatibility.

##### query Parameters

|     |     |
| --- | --- |
| blockAds | boolean<br>Whether or nor to load ad-blocking extensions for the session.<br>This currently uses uBlock-Lite and may cause certain sites<br>to not load properly. |
| launch | object or string<br>Launch options, which can be either an object<br>of puppeteer.launch options or playwright.launchServer<br>options, depending on the API. Must be either JSON<br>object, or a base64-encoded JSON object. |
| timeout | number<br>Override the system-level timeout for this request.<br>Accepts a value in milliseconds. |
| token | string<br>The authorization token |
| trackingId | string<br>Custom session identifier |

### Responses

**101**

Indicates successful WebSocket upgrade.

**400**

The request contains errors or didn't properly encode content.

**401**

The request is missing, or contains bad, authorization credentials.

**404**

Resource couldn't be found.

**408**

The request took has taken too long to process.

**429**

Too many requests are currently being processed.

**500**

An internal error occurred when handling the request.

get/playwright/chromium

https://docs.browserless.io/playwright/chromium

## [tag/Browser-WebSocket-APIs/paths/~1edge/get](https://docs.browserless.io/open-api\#tag/Browser-WebSocket-APIs/paths/~1edge/get)/edge

Launch and connect to Chromium with a library like puppeteer or others that work over chrome-devtools-protocol.

##### query Parameters

|     |     |
| --- | --- |
| blockAds | boolean<br>Whether or nor to load ad-blocking extensions for the session.<br>This currently uses uBlock-Lite and may cause certain sites<br>to not load properly. |
| launch | object or string<br>Launch options, which can be either an object<br>of puppeteer.launch options or playwright.launchServer<br>options, depending on the API. Must be either JSON<br>object, or a base64-encoded JSON object. |
| timeout | number<br>Override the system-level timeout for this request.<br>Accepts a value in milliseconds. |
| token | string<br>The authorization token |
| trackingId | string<br>Custom session identifier |

### Responses

**101**

Indicates successful WebSocket upgrade.

**400**

The request contains errors or didn't properly encode content.

**401**

The request is missing, or contains bad, authorization credentials.

**404**

Resource couldn't be found.

**408**

The request took has taken too long to process.

**429**

Too many requests are currently being processed.

**500**

An internal error occurred when handling the request.

get/edge

https://docs.browserless.io/edge

## [tag/Browser-WebSocket-APIs/paths/~1edge~1playwright/get](https://docs.browserless.io/open-api\#tag/Browser-WebSocket-APIs/paths/~1edge~1playwright/get)/edge/playwright

Connect to Chromium with any playwright style library.

##### query Parameters

|     |     |
| --- | --- |
| blockAds | boolean<br>Whether or nor to load ad-blocking extensions for the session.<br>This currently uses uBlock-Lite and may cause certain sites<br>to not load properly. |
| launch | object or string<br>Launch options, which can be either an object<br>of puppeteer.launch options or playwright.launchServer<br>options, depending on the API. Must be either JSON<br>object, or a base64-encoded JSON object. |
| timeout | number<br>Override the system-level timeout for this request.<br>Accepts a value in milliseconds. |
| token | string<br>The authorization token |
| trackingId | string<br>Custom session identifier |

### Responses

**101**

Indicates successful WebSocket upgrade.

**400**

The request contains errors or didn't properly encode content.

**401**

The request is missing, or contains bad, authorization credentials.

**404**

Resource couldn't be found.

**408**

The request took has taken too long to process.

**429**

Too many requests are currently being processed.

**500**

An internal error occurred when handling the request.

get/edge/playwright

https://docs.browserless.io/edge/playwright

## [tag/Browser-WebSocket-APIs/paths/~1playwright~1firefox/get](https://docs.browserless.io/open-api\#tag/Browser-WebSocket-APIs/paths/~1playwright~1firefox/get)/playwright/firefox

Connect to Firefox with any playwright-compliant library.

**Note:** This endpoint is also available at: `/firefox/playwright` for backwards compatibility.

##### query Parameters

|     |     |
| --- | --- |
| blockAds | boolean<br>Whether or nor to load ad-blocking extensions for the session.<br>This currently uses uBlock-Lite and may cause certain sites<br>to not load properly. |
| launch | object<br>Launch options, which can be either an object<br>of puppeteer.launch options or playwright.launchServer<br>options, depending on the API. Must be either JSON<br>object, or a base64-encoded JSON object. |
| timeout | number<br>Override the system-level timeout for this request.<br>Accepts a value in milliseconds. |
| token | string<br>The authorization token |
| trackingId | string<br>Custom session identifier |

### Responses

**101**

Indicates successful WebSocket upgrade.

**400**

The request contains errors or didn't properly encode content.

**401**

The request is missing, or contains bad, authorization credentials.

**404**

Resource couldn't be found.

**408**

The request took has taken too long to process.

**429**

Too many requests are currently being processed.

**500**

An internal error occurred when handling the request.

get/playwright/firefox

https://docs.browserless.io/playwright/firefox

## [tag/Browser-WebSocket-APIs/paths/~1playwright~1webkit/get](https://docs.browserless.io/open-api\#tag/Browser-WebSocket-APIs/paths/~1playwright~1webkit/get)/playwright/webkit

Connect to Webkit with any playwright-compliant library.

**Note:** This endpoint is also available at: `/webkit/playwright` for backwards compatibility.

##### query Parameters

|     |     |
| --- | --- |
| blockAds | boolean<br>Whether or nor to load ad-blocking extensions for the session.<br>This currently uses uBlock-Lite and may cause certain sites<br>to not load properly. |
| launch | object or string<br>Launch options, which can be either an object<br>of puppeteer.launch options or playwright.launchServer<br>options, depending on the API. Must be either JSON<br>object, or a base64-encoded JSON object. |
| timeout | number<br>Override the system-level timeout for this request.<br>Accepts a value in milliseconds. |
| token | string<br>The authorization token |
| trackingId | string<br>Custom session identifier |

### Responses

**101**

Indicates successful WebSocket upgrade.

**400**

The request contains errors or didn't properly encode content.

**401**

The request is missing, or contains bad, authorization credentials.

**404**

Resource couldn't be found.

**408**

The request took has taken too long to process.

**429**

Too many requests are currently being processed.

**500**

An internal error occurred when handling the request.

get/playwright/webkit

https://docs.browserless.io/playwright/webkit

## [tag/Browser-WebSocket-APIs/paths/~1chrome~1live~1*/get](https://docs.browserless.io/open-api\#tag/Browser-WebSocket-APIs/paths/~1chrome~1live~1*/get)/chrome/live/\*

> This API is only available for Enterprise plans and self-hosted Enterprise plans. [Contact us for more information here.](https://www.browserless.io/contact/), or [sign-up here](https://www.browserless.io/pricing/).

Websocket back-end that powers the live session experience.

### Responses

**101**

Indicates successful WebSocket upgrade.

**400**

The request contains errors or didn't properly encode content.

**401**

The request is missing, or contains bad, authorization credentials.

**404**

Resource couldn't be found.

**408**

The request took has taken too long to process.

**429**

Too many requests are currently being processed.

**500**

An internal error occurred when handling the request.

get/chrome/live/\*

https://docs.browserless.io/chrome/live/\*

## [tag/Browser-WebSocket-APIs/paths/~1chrome~1stealth/get](https://docs.browserless.io/open-api\#tag/Browser-WebSocket-APIs/paths/~1chrome~1stealth/get)/chrome/stealth

> This API is only available for Enterprise and Cloud-unit plans. [Contact us for more information here.](https://www.browserless.io/contact/), or [sign-up here](https://www.browserless.io/pricing/).

Launch and connect to Stealthy Chromium with a library like puppeteer or others that work over chrome-devtools-protocol for scraping in a more stealth-like fashion.

##### query Parameters

|     |     |
| --- | --- |
| blockAds | boolean<br>Whether or nor to load ad-blocking extensions for the session.<br>This currently uses uBlock-Lite and may cause certain sites<br>to not load properly. |
| launch | any or string<br>Launch options, which can be either an object<br>of puppeteer.launch options or playwright.launchServer<br>options, depending on the API. Must be either JSON<br>object, or a base64-encoded JSON object. |
| timeout | number<br>Override the system-level timeout for this request.<br>Accepts a value in milliseconds. |
| token | string<br>The authorization token |
| trackingId | string<br>Custom session identifier |

### Responses

**101**

Indicates successful WebSocket upgrade.

**400**

The request contains errors or didn't properly encode content.

**401**

The request is missing, or contains bad, authorization credentials.

**404**

Resource couldn't be found.

**408**

The request took has taken too long to process.

**429**

Too many requests are currently being processed.

**500**

An internal error occurred when handling the request.

get/chrome/stealth

https://docs.browserless.io/chrome/stealth

## [tag/Browser-WebSocket-APIs/paths/~1chromium~1live~1*/get](https://docs.browserless.io/open-api\#tag/Browser-WebSocket-APIs/paths/~1chromium~1live~1*/get)/chromium/live/\*

> This API is only available for Enterprise plans and self-hosted Enterprise plans. [Contact us for more information here.](https://www.browserless.io/contact/), or [sign-up here](https://www.browserless.io/pricing/).

Websocket back-end that powers the live session experience.

**Note:** This endpoint is also available at: `/live/*` for backwards compatibility.

### Responses

**101**

Indicates successful WebSocket upgrade.

**400**

The request contains errors or didn't properly encode content.

**401**

The request is missing, or contains bad, authorization credentials.

**404**

Resource couldn't be found.

**408**

The request took has taken too long to process.

**429**

Too many requests are currently being processed.

**500**

An internal error occurred when handling the request.

get/chromium/live/\*

https://docs.browserless.io/chromium/live/\*

## [tag/Browser-WebSocket-APIs/paths/~1chromium~1stealth/get](https://docs.browserless.io/open-api\#tag/Browser-WebSocket-APIs/paths/~1chromium~1stealth/get)/chromium/stealth

> This API is only available for Enterprise and Cloud-unit plans. [Contact us for more information here.](https://www.browserless.io/contact/), or [sign-up here](https://www.browserless.io/pricing/).

Launch and connect to Stealthy Chromium with a library like puppeteer or others that work over chrome-devtools-protocol for scraping in a more stealth-like fashion.

**Note:** This endpoint is also available at: `/stealth` for backwards compatibility.

##### query Parameters

|     |     |
| --- | --- |
| blockAds | boolean<br>Whether or nor to load ad-blocking extensions for the session.<br>This currently uses uBlock-Lite and may cause certain sites<br>to not load properly. |
| launch | any or string<br>Launch options, which can be either an object<br>of puppeteer.launch options or playwright.launchServer<br>options, depending on the API. Must be either JSON<br>object, or a base64-encoded JSON object. |
| timeout | number<br>Override the system-level timeout for this request.<br>Accepts a value in milliseconds. |
| token | string<br>The authorization token |
| trackingId | string<br>Custom session identifier |

### Responses

**101**

Indicates successful WebSocket upgrade.

**400**

The request contains errors or didn't properly encode content.

**401**

The request is missing, or contains bad, authorization credentials.

**404**

Resource couldn't be found.

**408**

The request took has taken too long to process.

**429**

Too many requests are currently being processed.

**500**

An internal error occurred when handling the request.

get/chromium/stealth

https://docs.browserless.io/chromium/stealth

## [tag/Browser-WebSocket-APIs/paths/~1reconnect~1*/get](https://docs.browserless.io/open-api\#tag/Browser-WebSocket-APIs/paths/~1reconnect~1*/get)/reconnect/\*

Reconnect to an existing Chromium or Chrome session with a library like puppeteer or others that work over chrome-devtools-protocol.

##### query Parameters

|     |     |
| --- | --- |
| blockAds | boolean<br>Whether or nor to load ad-blocking extensions for the session.<br>This currently uses uBlock-Lite and may cause certain sites<br>to not load properly. |
| launch | any or any or string<br>Launch options, which can be either an object<br>of puppeteer.launch options or playwright.launchServer<br>options, depending on the API. Must be either JSON<br>object, or a base64-encoded JSON object. |
| timeout | number<br>Override the system-level timeout for this request.<br>Accepts a value in milliseconds. |
| token | string<br>The authorization token |
| trackingId | string<br>Custom session identifier |

### Responses

**101**

Indicates successful WebSocket upgrade.

**400**

The request contains errors or didn't properly encode content.

**401**

The request is missing, or contains bad, authorization credentials.

**404**

Resource couldn't be found.

**408**

The request took has taken too long to process.

**429**

Too many requests are currently being processed.

**500**

An internal error occurred when handling the request.

get/reconnect/\*

https://docs.browserless.io/reconnect/\*

---

### API Comparison | Browserless.io
Original URL: https://docs.browserless.io/overview/comparison

[Skip to main content](https://docs.browserless.io/overview/comparison#__docusaurus_skipToContent_fallback)


To choose the right Browserless offering, it helps to understand their differences. The table below summarizes key features and capabilities of BrowserQL (BQL) vs Browserless BaaS v2 vs RESTful APIs:

| Feature/Capability | BrowserQL (BQL) | Browsers as a Service (v2) | REST APIs |
| --- | --- | --- | --- |
| Usage Paradigm | GraphQL queries (run via a cloud IDE or GraphQL endpoint) | Connect via WebSocket using Puppeteer/Playwright libraries | HTTP/HTTPS requests to specific endpoints |
| Primary Use-Case | Stealth web automation, bypassing bot detection and CAPTCHAs | Running custom automation scripts with familiar libraries | One-off tasks (PDF, screenshot, data extraction) via simple calls |
| Stealth Capabilities | Advanced (human-like behavior, CAPTCHA solving) | Basic (stealth mode parameter) | Basic (stealth parameter) |
| Flexibility | High (specialized automation language) | Highest (full browser control) | Limited (predefined endpoints) |
| Ease of Use | Medium (requires learning BQL) | Medium (requires knowledge of browser automation libraries) | Simplest (HTTP requests only) |
| Connection Method | HTTPS | WebSocket | HTTPS |
| Proxy Support | [Advanced (built-in residential)](https://docs.browserless.io/browserql/bot-detection/proxies) | [Yes (via parameters)](https://docs.browserless.io/baas/proxies) | [Yes (via parameters)](https://docs.browserless.io/baas/proxies) |
| Session Management | Yes (reconnect mutation) | Yes (with proper setup) | No (stateless) |

## When to Use Each API [â€‹](https://docs.browserless.io/overview/comparison\#when-to-use-each-api "Direct link to When to Use Each API")

### BrowserQL [â€‹](https://docs.browserless.io/overview/comparison\#browserql "Direct link to BrowserQL")

Best for scenarios requiring advanced bot detection bypass, such as:

- Sites with sophisticated bot detection systems
- When CAPTCHA solving is required
- When you need human-like browser behavior
- For stealth-first web automation

### BaaS v2 [â€‹](https://docs.browserless.io/overview/comparison\#baas-v2 "Direct link to BaaS v2")

Ideal for general-purpose browser automation:

- When you have existing Puppeteer or Playwright code
- For scenarios where you need full browser control
- For complex multi-step workflows
- When you're comfortable with browser automation libraries

### REST APIs [â€‹](https://docs.browserless.io/overview/comparison\#rest-apis "Direct link to REST APIs")

Perfect for simple, stateless operations:

- Taking screenshots
- Generating PDFs
- Basic content extraction
- When integration simplicity is the priority
- For one-off tasks that don't require maintaining state

- [When to Use Each API](https://docs.browserless.io/overview/comparison#when-to-use-each-api)
  - [BrowserQL](https://docs.browserless.io/overview/comparison#browserql)
  - [BaaS v2](https://docs.browserless.io/overview/comparison#baas-v2)
  - [REST APIs](https://docs.browserless.io/overview/comparison#rest-apis)

---

### Connection URLs and Endpoints | Browserless.io
Original URL: https://docs.browserless.io/overview/connection-urls

[Skip to main content](https://docs.browserless.io/overview/connection-urls#__docusaurus_skipToContent_fallback)


This section covers all connection URLs and endpoints for Browserless services. Learn when to use WebSocket (wss://) vs HTTP(S) URLs, and how to include your token and options in these URLs.

### Connection URL Builder

Service Type:

BrowserQLBaaS v2REST API

Library:

PuppeteerPlaywright

Browser:

ChromiumChrome

Stealth Mode:

DisabledEnabled

Region:

US WestEurope UKEurope Amsterdam

API Token:

#### Connection URL:

Copy

```
wss://production-sfo.browserless.io/?token=YOUR_TOKEN
```

#### Code Snippet:

Copy

```
const browser = await puppeteer.connect({
  browserWSEndpoint: 'wss://production-sfo.browserless.io/?token=YOUR_TOKEN',
});
```

## Base URL and Regions [â€‹](https://docs.browserless.io/overview/connection-urls\#base-url-and-regions "Direct link to Base URL and Regions")

Browserless has multiple regional base URLs:

- `https://production-sfo.browserless.io` (US West)
- `https://production-lon.browserless.io` (Europe UK)
- `https://production-ams.browserless.io` (Europe Amsterdam)

For WebSocket connections, simply replace `https://` with `wss://` for the same host. For
example:

- WebSocket (Puppeteer/Playwright): `wss://production-sfo.browserless.io/...`
- HTTP REST API call: `https://production-sfo.browserless.io/...`

Choose the region closest to you to reduce latency (see [Load Balancers](https://docs.browserless.io/baas/load-balancers)). All require the token query parameter.

## Using Your API Token in URLs [â€‹](https://docs.browserless.io/overview/connection-urls\#using-your-api-token-in-urls "Direct link to Using Your API Token in URLs")

Add your API token to the URL query string as `?token=YOUR_TOKEN`. Required for authentication (see [Using your API token](https://docs.browserless.io/baas/start)). Invalid tokens result in HTTP 401/403 errors. Keep this URL secure and never expose it in client-side code or logs.

Example:
`wss://production-sfo.browserless.io?token=094632bb-e326-4c63-b953-82b55700b14c` is a basic connection string for a new Chrome session on the SFO cluster using the given token.

## BrowserQL Connection [â€‹](https://docs.browserless.io/overview/connection-urls\#browserql-connection "Direct link to BrowserQL Connection")

If you are using the BQL IDE, the connection is handled for you (the IDE lets you select a region
and enters your token). However, advanced users can also call the BQL service directly via a
GraphQL HTTP request or WebSocket:

- **GraphQL HTTP Endpoint**: You can send a GraphQL HTTP POST to the base URL with
`/graphql`. For example: `POST https://production-sfo.browserless.io/graphql?token=YOUR_TOKEN`.
The body of the request should be a JSON with your GraphQL query or mutation. The
response will be JSON with your results. (This is usually used for the management
GraphQL API for checking session pressure, etc., not commonly for running BQL
browser sessions, which are handled by the dedicated BQL endpoint.)

- **Dedicated BQL Endpoint**: When running browser sessions with BQL, Browserless
uses a special endpoint internally (often shown as `/bql`). For instance, when a BQL
session is created, it may run at a URL like
`https://production-sfo.browserless.io/bql/SESSION_ID?token=YOUR_TOKEN`. This is typically abstracted away by the IDE or the initial request. In practice, you
will start a BQL session via the IDE or a GraphQL call, and if you need to reconnect to it
for a hybrid scenario, you'll use the reconnect URL provided in the response (which
looks like the above). In summary, for pure BQL usage, you normally don't manually
construct these URLs.


## BaaS v2 (Puppeteer/Playwright) Connection URLs [â€‹](https://docs.browserless.io/overview/connection-urls\#baas-v2-puppeteerplaywright-connection-urls "Direct link to BaaS v2 (Puppeteer/Playwright) Connection URLs")

To connect an automation library to Browserless, use a WebSocket URL ( `wss://`). The
WebSocket endpoint tells Browserless to launch a browser for you and gives you control over it.
The format can vary slightly depending on the browser and library:

- **Puppeteer (Chrome/Chromium)**: Use the base WebSocket URL with your token.
Example: `wss://production-sfo.browserless.io?token=YOUR_TOKEN`. This
will launch a Chromium instance on Browserless. Puppeteer's browserWSEndpoint
should be set to this URL (see [How it Works](https://docs.browserless.io/baas/start)).



note





By default, this gives you a Chromium browser. Browserless treats Chrome/Chromium essentially the same; you can explicitly request Chrome by using `/chrome` in the path, but on the cloud service the default is a headless Chromium build with necessary features.

- **Playwright (Chromium via CDP)**: Playwright can connect over Chrome DevTools
Protocol (CDP) similarly to Puppeteer. You would use
`playwright.chromium.connect_over_cdp("wss://production-sfo.browserless.io?token=YOUR_TOKEN")`. This is effectively the same as Puppeteer's
approach and will give you a Chromium browser (see [Launch Options](https://docs.browserless.io/baas/chrome-flags)).

- **Playwright (Firefox)**: To use Firefox (since Playwright supports Firefox via its own
protocol), you must include the browser in the path and specify that you want the
Playwright protocol. Browserless uses a convention: `/<browser>/playwright` in the
URL for Playwright connections. So for Firefox:
`wss://production-sfo.browserless.io/firefox/playwright?token=YOUR_TOKEN` (see [How it Works](https://docs.browserless.io/baas/start)).

- **Playwright (WebKit)**:
`wss://production-sfo.browserless.io/webkit/playwright?token=YOUR_TOKEN` â€“ spawns a WebKit browser (usually for Safari automation needs). WebKit
support is available in Browserless v2 for Playwright connections.

- **Selecting Chrome vs Chromium**: If you specifically need Chrome (the branded Google
Chrome, which might have minor differences or supports Widevine, etc.), you can use
the path `/chrome` in the URL. For example:
`wss://production-sfo.browserless.io/chrome?token=YOUR_TOKEN`. By
default, `/` or `/chromium` point to the latest Chromium. In practice, most use cases don't
require distinguishing, but the option exists.


### Summary of WebSocket URL formats [â€‹](https://docs.browserless.io/overview/connection-urls\#summary-of-websocket-url-formats "Direct link to Summary of WebSocket URL formats")

- **Chromium (puppeteer, playwright ConnectOverCDP or other CDP libraries)**:
`wss://production-<region>.browserless.io/?token=YOUR_TOKEN`
- **Chromium (Playwright connect's method)**:
`wss://production-<region>.browserless.io/chromium/playwright?token=YOUR_TOKEN`
- **Chrome (stable version)**:
`wss://production-<region>.browserless.io/chrome?token=YOUR_TOKEN`
- **Firefox (Playwright)**:
`wss://production-<region>.browserless.io/firefox/playwright?token=YOUR_TOKEN`
- **WebKit (Playwright)**:
`wss://production-<region>.browserless.io/webkit/playwright?token=YOUR_TOKEN`

## REST APIs [â€‹](https://docs.browserless.io/overview/connection-urls\#rest-apis "Direct link to REST APIs")

Browserless provides REST API endpoints for common operations:

```codeBlockLines_p187
// Screenshot API
https://production-sfo.browserless.io/screenshot?token=YOUR_TOKEN

// PDF API
https://production-sfo.browserless.io/pdf?token=YOUR_TOKEN

// Content API
https://production-sfo.browserless.io/content?token=YOUR_TOKEN

```

## Launch Parameters and Options [â€‹](https://docs.browserless.io/overview/connection-urls\#launch-parameters-and-options "Direct link to Launch Parameters and Options")

Browserless allows extensive configuration of how browsers are launched and behave during
your sessions. These launch parameters can be provided either via query parameters in the
URL or through a special JSON launch payload. Whether you're using BQL, BaaS v2, or REST, these
options let you tweak the browser environment to fit your needs.

### Passing Launch Options [â€‹](https://docs.browserless.io/overview/connection-urls\#passing-launch-options "Direct link to Passing Launch Options")

There are two ways to specify launch options on Browserless v2:

1. **Individual Query Parameters**: Many common options can be set by adding a query
parameter to your connection URL or API call. For example, `&headless=false` to run
in headful mode, `&proxy=residential` to use the built-in residential proxies, etc. This
is straightforward for boolean or simple options.

2. **Combined launch Parameter (JSON)**: For complex configurations, you can use a
single query param `launch` with a JSON string as its value. This JSON can include any
Chrome flags or Browserless-specific settings in a structured way. This approach is
useful when you need to set multiple flags at once or use non-boolean values. It's
essentially the equivalent of Puppeteer's `launch({ options })` but provided to the
cloud service. For example,
`&launch={"headless":false,"stealth":true,"args":["--window-size=1920,1080"]}` (URL-encoded) would configure a headful, stealth-enabled browser with
a specific window size (see [Launch Options](https://docs.browserless.io/baas/chrome-flags)).


Both methods achieve the same result. Under the hood, Browserless will merge any individual
query params with the JSON launch config if both are provided (individual params typically
override the JSON fields if there's overlap). For simplicity, if you only need to toggle a few
settings, use query params; if you have many settings, use the single launch param.

### Common Launch Options (Query Parameters) [â€‹](https://docs.browserless.io/overview/connection-urls\#common-launch-options-query-parameters "Direct link to Common Launch Options (Query Parameters)")

Below is a list of common launch options you can use in query strings. Unless stated otherwise,
these can be used in BaaS v2 (library connections) and REST API calls alike. (BrowserQL
internally uses some of these, but BQL users typically set these via the IDE session settings
rather than manually in a URL.)

- **headless** (boolean): Default: true (headless mode). Set to false to launch the
browser in "headful" mode (with a GUI). In cloud environments you won't actually see a
GUI, but headful mode can sometimes bypass bot detection (since some bots detect
headless). Using `headless=false` will consume more resources. Example:
`&headless=false`.

- **stealth** (boolean): Default: false (for BaaS/REST). Enable stealth plugin/mode for
the browser. If true, Browserless will apply stealth techniques to the browser (like
puppeteer-extra's stealth plugin) to remove obvious automation signals. In BrowserQL,
stealth is generally always on by design (hence no toggle in BQL except through
humanlike). In BaaS, you might use `stealth=true` when you need some bot evasion
but are not using BQL. Example: `&stealth=true`.


You can also use the stealth URLs directly:

- `/chrome/stealth` \- For stealthy Chrome browser
- `/chromium/stealth` or `/stealth` \- For stealthy Chromium browser

These endpoints are only available for Enterprise and Cloud-unit plans and provide improved bot detection evasion compared to the stealth query parameter alone.

- **humanlike** (boolean): Default: false. (BrowserQL only.) This enables Human-like
behavior â€“ simulation of human input patterns (mouse movements, random small
delays, etc.) to make automation less detectable. Example: `&humanlike=true`.

For a complete list of launch options, see the [Launch Options](https://docs.browserless.io/baas/chrome-flags) documentation.

- [Base URL and Regions](https://docs.browserless.io/overview/connection-urls#base-url-and-regions)
- [Using Your API Token in URLs](https://docs.browserless.io/overview/connection-urls#using-your-api-token-in-urls)
- [BrowserQL Connection](https://docs.browserless.io/overview/connection-urls#browserql-connection)
- [BaaS v2 (Puppeteer/Playwright) Connection URLs](https://docs.browserless.io/overview/connection-urls#baas-v2-puppeteerplaywright-connection-urls)
  - [Summary of WebSocket URL formats](https://docs.browserless.io/overview/connection-urls#summary-of-websocket-url-formats)
- [REST APIs](https://docs.browserless.io/overview/connection-urls#rest-apis)
- [Launch Parameters and Options](https://docs.browserless.io/overview/connection-urls#launch-parameters-and-options)
  - [Passing Launch Options](https://docs.browserless.io/overview/connection-urls#passing-launch-options)
  - [Common Launch Options (Query Parameters)](https://docs.browserless.io/overview/connection-urls#common-launch-options-query-parameters)

---

### Introduction to Browserless | Browserless.io
Original URL: https://docs.browserless.io/overview/intro

[Skip to main content](https://docs.browserless.io/overview/intro#__docusaurus_skipToContent_fallback)


Browserless is a cloud-based service for running headless browsers at scale. It provides multiple offerings for different use cases, all using the same cloud infrastructure but accessed in various ways. This overview introduces the three main Browserless offerings (excluding legacy v1, which is deprecated) and when to use each:

- **[BrowserQL (BQL)](https://docs.browserless.io/browserql/start)** â€“ A GraphQL-based API for browser automation. BQL is a first-class, stealth-focused solution ideal for bypassing [CAPTCHAs](https://docs.browserless.io/browserql/bot-detection/solving-captchas) and bot detectors. It comes with a fully-featured web IDE and uses a minimalistic, scriptable query language instead of traditional code.

- **[Browsers as a Service (BaaS) v2](https://docs.browserless.io/baas/start)** â€“ A direct browser-as-a-service API that you can connect to using standard libraries like [Puppeteer](https://docs.browserless.io/baas/start#connecting-puppeteer) or [Playwright](https://docs.browserless.io/baas/start#connecting-playwright). BaaS v2 closely mimics running a browser locally, allowing you to use familiar code by simply changing the connection URL to point at Browserless.

- **[RESTful APIs](https://docs.browserless.io/rest-apis/intro)** â€“ A set of ready-made HTTP endpoints for common browser tasks (such as generating PDFs or screenshots, scraping content, etc.). These endpoints let you perform automation via simple HTTP(S) requests without writing a full script. They are great for quick integrations or one-off tasks, although not as flexible for complex flows.


Which to choose?

Don't know which solution better fits your needs? Refer to the [API Comparison page](https://docs.browserless.io/overview/comparison), and find detailed information defining the best solution for each situation.

## API Tokens and Authentication [â€‹](https://docs.browserless.io/overview/intro\#api-tokens-and-authentication "Direct link to API Tokens and Authentication")

All Browserless cloud offerings require an API token for authentication. When you sign up, you'll get a unique token associated with your account. Include this token in every request, usually as a query parameter `?token=<YOUR_API_TOKEN>`. (The token can also be provided via headers in some cases, but using the token in query strings is most reliable.) [Get your API token](https://account.browserless.io/).

## Global Endpoints [â€‹](https://docs.browserless.io/overview/intro\#global-endpoints "Direct link to Global Endpoints")

Browserless operates multiple regional endpoints for low-latency access. The primary shared clusters are in US West (SFO), EU West (London), and EU Central (Amsterdam) ( [Load Balancers](https://docs.browserless.io/baas/load-balancers)). For example:

- `https://production-sfo.browserless.io` â€“ San Francisco, USA (default US endpoint)
- `https://production-lon.browserless.io` â€“ London, UK (European endpoint)
- `https://production-ams.browserless.io` â€“ Amsterdam, NL (another EU endpoint)

You can use the endpoint closest to your servers or users. All endpoints offer the same API and require your token.

## Getting Started Checklist [â€‹](https://docs.browserless.io/overview/intro\#getting-started-checklist "Direct link to Getting Started Checklist")

To quickly get started with Browserless:

1. [Get your API token](https://account.browserless.io/)
2. Choose an API ( [BrowserQL](https://docs.browserless.io/browserql/start), [BaaS v2](https://docs.browserless.io/baas/start), or [REST APIs](https://docs.browserless.io/rest-apis/intro))
3. Follow the respective Quick Start guide for your chosen API

- [API Tokens and Authentication](https://docs.browserless.io/overview/intro#api-tokens-and-authentication)
- [Global Endpoints](https://docs.browserless.io/overview/intro#global-endpoints)
- [Getting Started Checklist](https://docs.browserless.io/overview/intro#getting-started-checklist)

---

### Launch Parameters | Browserless.io
Original URL: https://docs.browserless.io/overview/launch-parameters

[Skip to main content](https://docs.browserless.io/overview/launch-parameters#__docusaurus_skipToContent_fallback)


Configure how browsers launch and behave with parameters provided via URL query parameters or JSON payload. This section covers available options, defaults, and usage across [BrowserQL](https://docs.browserless.io/browserql/start), [BaaS v2](https://docs.browserless.io/baas/start), and [REST APIs](https://docs.browserless.io/rest-apis/intro).

## Passing Launch Options [â€‹](https://docs.browserless.io/overview/launch-parameters\#passing-launch-options "Direct link to Passing Launch Options")

Two ways to specify launch options:

1. **Individual Query Parameters**: Add options directly to URLs (e.g., `&headless=false`, `&proxy=residential`). Best for simple boolean options.

2. **Combined `launch` Parameter (JSON)**: For complex configurations, use a single query param `launch` with a JSON string as its value. This JSON can include any Chrome flags or Browserless-specific settings in a structured way. It's essentially the equivalent of Puppeteer's `launch({ options })` but provided to the cloud service:







```codeBlockLines_p187
&launch={"headless":false,"stealth":true,"args":["--window-size=1920,1080"]}

```











(URL-encoded) would configure a headful, stealth-enabled browser with a specific window size.


Browserless merges both methods if used together, with individual parameters taking precedence. Use query params for simple toggles and the launch parameter for multiple settings.

## Common Launch Options [â€‹](https://docs.browserless.io/overview/launch-parameters\#common-launch-options "Direct link to Common Launch Options")

Below is a list of common launch options you can use in query strings. Unless stated otherwise,
these can be used in BaaS v2 (library connections) and REST API calls alike. BrowserQL
internally uses some of these, but BQL users typically set these via the IDE session settings
rather than manually in a URL.

| Parameter | Description | Default | BrowserQL | BaaS v2 | REST APIs |
| --- | --- | --- | --- | --- | --- |
| headless | Runs the browser in headless mode. Set to false to enable headful mode (with a GUI). While the GUI isn't visible in cloud environments, headful mode may help bypass bot detection. Note: it uses more resources. | `true` | âœ… | âœ… | âœ… |
| stealth | Enables stealth mode to reduce automation signals (similar to puppeteer-extraâ€™s stealth plugin). In BQL, stealth is always on by design and controlled via the humanlike option. In BaaS/REST, set to true to enable stealth techniques. | - `false` (for BaaS/REST)<br>- `true` (for BQL) | âœ… | âœ… | âœ… |
| humanlike | Simulates human-like behavior such as natural mouse movement, typing, and random delays. In the BQL IDE, this can be toggled in session settings. For direct BQL GraphQL calls, use humanlike: true in the launch payload. Recommended for strict bot detection scenarios. | `false` | âœ… | âŒ | âŒ |
| blockAds | Enables the built-in ad blocker (powered by uBlock Origin). Helps speed up scripts and reduce noise by blocking ads and trackers. Especially useful for scraping to avoid popups and clutter. | `false` | âœ… | âœ… | âœ… |
| blockConsentModals | Automatically blocks or dismisses cookie/GDPR consent banners. Available in BQL sessions and the /screenshot and /pdf REST APIs. In BQL, toggle it via the IDE or launch JSON. Useful for cleaner scraping by removing overlays. | `false` | âœ… | âŒ | âœ… |
| proxy | Routes browser traffic through a proxy. Options: proxy=residential for Browserlessâ€™s residential proxy pool; proxy=\`<your proxy URL>\` for your own proxy. Omit to use a direct connection. | none | âœ… | âœ… | âœ… |
| proxyCountry | Used with proxy=residential to specify the exit nodeâ€™s country. Accepts ISO 3166 country codes (e.g., us, gb, de). If omitted, a random location is chosen. | none | âœ… | âœ… | âœ… |
| proxySticky | Used with proxy=residential to maintain the same proxy IP across a session (when possible). Useful for sites that expect consistent IP usage. | `false` | âœ… | âœ… | âœ… |
| timeout | Maximum session duration in milliseconds. The session will automatically close after this time to prevent overuse. | 60000 | âœ… | âœ… | âœ… |

## BaaS v2 Advanced Options [â€‹](https://docs.browserless.io/overview/launch-parameters\#baas-v2-advanced-options "Direct link to BaaS v2 Advanced Options")

For BaaS v2, you can use the `launch` parameter to pass a JSON object with advanced Chrome flags and Puppeteer options. Learn more in our [Launch Options guide](https://docs.browserless.io/baas/chrome-flags):

- Puppeteer
- Playwright

```codeBlockLines_p187
const launchArgs = {
  headless: false,
  stealth: true,
  args: ['--window-size=1920,1080', '--force-color-profile=srgb']
};

const browser = await puppeteer.connect({
  browserWSEndpoint: `wss://production-sfo.browserless.io?token=YOUR_API_TOKEN&launch=${JSON.stringify(launchArgs)}`,
});

```

```codeBlockLines_p187
const launchArgs = {
  headless: false,
  stealth: true,
  args: ['--window-size=1920,1080', '--force-color-profile=srgb']
};

const browser = await playwright.chromium.connectOverCDP(
  `wss://production-sfo.browserless.io?token=YOUR_API_TOKEN&launch=${JSON.stringify(launchArgs)}`
);

```

## REST API Options [â€‹](https://docs.browserless.io/overview/launch-parameters\#rest-api-options "Direct link to REST API Options")

When using REST APIs, you can include launch parameters in the URL query string or in the JSON body of your request:

```codeBlockLines_p187
// In URL query string
fetch("https://production-sfo.browserless.io/screenshot?token=YOUR_API_TOKEN&blockAds=true&stealth=true")

// In JSON body
fetch("https://production-sfo.browserless.io/pdf?token=YOUR_API_TOKEN", {
  method: "POST",
  headers: { "Content-Type": "application/json" },
  body: JSON.stringify({
    url: "https://example.com",
    options: { format: "A4" },
    launch: { stealth: true, blockAds: true }
  })
})

```

For a comprehensive list of available REST API endpoints and their parameters, please refer to our [Swagger API documentation](https://docs.browserless.io/open-api).

For a comprehensive list of Chrome flags and browserless-specific options, please refer to our [Launch Options](https://docs.browserless.io/baas/chrome-flags) documentation.

- [Passing Launch Options](https://docs.browserless.io/overview/launch-parameters#passing-launch-options)
- [Common Launch Options](https://docs.browserless.io/overview/launch-parameters#common-launch-options)
- [BaaS v2 Advanced Options](https://docs.browserless.io/overview/launch-parameters#baas-v2-advanced-options)
- [REST API Options](https://docs.browserless.io/overview/launch-parameters#rest-api-options)

---

### Browserless.io
Original URL: https://docs.browserless.io/pdf/html-content

[Skip to main content](https://docs.browserless.io/pdf/html-content#__docusaurus_skipToContent_fallback)

# Page Not Found

We could not find what you were looking for.

Please contact the owner of the site that linked you to the original URL and let them know their link is broken.

---

### Browserless.io
Original URL: https://docs.browserless.io/pdf/navigation-options

[Skip to main content](https://docs.browserless.io/pdf/navigation-options#__docusaurus_skipToContent_fallback)

# Page Not Found

We could not find what you were looking for.

Please contact the owner of the site that linked you to the original URL and let them know their link is broken.

---

### Browserless.io
Original URL: https://docs.browserless.io/pdf/rejects

[Skip to main content](https://docs.browserless.io/pdf/rejects#__docusaurus_skipToContent_fallback)

# Page Not Found

We could not find what you were looking for.

Please contact the owner of the site that linked you to the original URL and let them know their link is broken.

---

### Untitled
Original URL: https://docs.browserless.io/redocusaurus/plugin-redoc-0.yaml

customSiteTitle: Browserless Documentation
definitions:
 FrameAddScriptTagOptions:
 type: object
 properties:
 url:
 description: URL of the script to be added.
 type: string
 path:
 description: Path to a JavaScript file to be injected into the frame.
 type: string
 content:
 description: JavaScript to be injected into the frame.
 type: string
 type:
 description: >-
 Sets the \`type\` of the script. Use \`module\` in order to load an ES2015
 module.
 type: string
 id:
 description: Sets the \`id\` of the script.
 type: string
 additionalProperties: false
 FrameAddStyleTagOptions:
 type: object
 properties:
 url:
 description: the URL of the CSS file to be added.
 type: string
 path:
 description: The path to a CSS file to be injected into the frame.
 type: string
 content:
 description: Raw CSS content to be injected into the frame.
 type: string
 additionalProperties: false
 Credentials:
 type: object
 properties:
 username:
 type: string
 password:
 type: string
 additionalProperties: false
 required:
 \- password
 \- username
 CookieParam:
 description: \|-
 Cookie parameter object used to set cookies in the page-level cookies
 API.
 type: object
 properties:
 name:
 description: Cookie name.
 type: string
 value:
 description: Cookie value.
 type: string
 url:
 description: >-
 The request-URI to associate with the setting of the cookie. This
 value can affect

 the default domain, path, and source scheme values of the created
 cookie.
 type: string
 domain:
 description: Cookie domain.
 type: string
 path:
 description: Cookie path.
 type: string
 secure:
 description: True if cookie is secure.
 type: boolean
 httpOnly:
 description: True if cookie is http-only.
 type: boolean
 sameSite:
 description: Cookie SameSite type.
 enum:
 \- Lax
 \- None
 \- Strict
 type: string
 expires:
 description: Cookie expiration date, session cookie if not set
 type: number
 priority:
 description: Cookie Priority. Supported only in Chrome.
 enum:
 \- High
 \- Low
 \- Medium
 type: string
 sameParty:
 description: True if cookie is SameParty. Supported only in Chrome.
 type: boolean
 sourceScheme:
 description: Cookie source scheme type. Supported only in Chrome.
 enum:
 \- NonSecure
 \- Secure
 \- Unset
 type: string
 partitionKey:
 description: >-
 Cookie partition key. In Chrome, it matches the top-level site the

 partitioned cookie is available in. In Firefox, it matches the

 source origin in the

 {@link https://w3c.github.io/webdriver-bidi/#type-storage-PartitionKey
 PartitionKey}.
 anyOf:
 \- $ref: '#/definitions/CookiePartitionKey'
 \- type: string
 additionalProperties: false
 required:
 \- name
 \- value
 CookiePartitionKey:
 description: Represents a cookie partition key in Chrome.
 type: object
 properties:
 sourceOrigin:
 description: >-
 The site of the top-level URL the browser was visiting at the start of
 the request

 to the endpoint that set the cookie.

 In Chrome, maps to the CDP's \`topLevelSite\` partition key.
 type: string
 hasCrossSiteAncestor:
 description: \|-
 Indicates if the cookie has any ancestors that are cross-site to
 the topLevelSite.

 Supported only in Chrome.
 type: boolean
 additionalProperties: false
 required:
 \- sourceOrigin
 GoToOptions:
 type: object
 properties:
 referer:
 description: >-
 If provided, it will take preference over the referer header value set
 by

 {@link Page.setExtraHTTPHeaderspage.setExtraHTTPHeaders()}.
 type: string
 referrerPolicy:
 description: >-
 If provided, it will take preference over the referer-policy header
 value

 set by {@link Page.setExtraHTTPHeaderspage.setExtraHTTPHeaders()}.
 type: string
 timeout:
 description: >-
 Maximum wait time in milliseconds. Pass 0 to disable the timeout.

 The default value can be changed by using the

 {@link Page.setDefaultTimeout} or {@link
 Page.setDefaultNavigationTimeout}

 methods.
 type: number
 waitUntil:
 description: >-
 When to consider waiting succeeds. Given an array of event strings,
 waiting

 is considered to be successful after all events have been fired.
 anyOf:
 \- type: array
 items:
 $ref: '#/definitions/PuppeteerLifeCycleEvent'
 \- enum:
 \- domcontentloaded
 \- load
 \- networkidle0
 \- networkidle2
 type: string
 signal:
 description: A signal object that allows you to cancel the call.
 $ref: '#/definitions/AbortSignal'
 additionalProperties: false
 PuppeteerLifeCycleEvent:
 enum:
 \- domcontentloaded
 \- load
 \- networkidle0
 \- networkidle2
 type: string
 AbortSignal:
 type: object
 properties:
 aborted:
 type: boolean
 onabort:
 anyOf:
 \- type: object
 additionalProperties: false
 \- type: 'null'
 reason: {}
 additionalProperties: false
 required:
 \- aborted
 \- onabort
 \- reason
 Partial:
 type: object
 properties:
 status:
 type: number
 headers:
 description: \|-
 Optional response headers.

 The record values will be converted to string following:
 Arrays' values will be mapped to String
 (Used when you need multiple headers with the same name).
 Non-arrays will be converted to String.
 $ref: '#/definitions/Record'
 contentType:
 type: string
 body:
 anyOf:
 \- type: object
 additionalProperties: false
 patternProperties:
 ^\[0-9\]+$:
 type: number
 properties:
 BYTES\_PER\_ELEMENT:
 type: number
 buffer:
 $ref: '#/definitions/ArrayBufferLike'
 byteLength:
 type: number
 byteOffset:
 type: number
 length:
 type: number
 \_\_@toStringTag@14939:
 type: string
 const: Uint8Array
 required:
 \- BYTES\_PER\_ELEMENT
 \- \_\_@toStringTag@14939
 \- buffer
 \- byteLength
 \- byteOffset
 \- length
 \- type: string
 additionalProperties: false
 Record:
 type: object
 additionalProperties: false
 ArrayBufferLike:
 anyOf:
 \- $ref: '#/definitions/ArrayBuffer'
 \- $ref: '#/definitions/SharedArrayBuffer'
 ArrayBuffer:
 type: object
 properties:
 byteLength:
 type: number
 \_\_@toStringTag@14939:
 type: string
 additionalProperties: false
 required:
 \- \_\_@toStringTag@14939
 \- byteLength
 SharedArrayBuffer:
 type: object
 properties:
 byteLength:
 type: number
 \_\_@species@14977:
 $ref: '#/definitions/SharedArrayBuffer'
 \_\_@toStringTag@14939:
 type: string
 const: SharedArrayBuffer
 additionalProperties: false
 required:
 \- \_\_@species@14977
 \- \_\_@toStringTag@14939
 \- byteLength
 Record:
 type: object
 additionalProperties: false
 Viewport:
 type: object
 properties:
 width:
 description: The page width in CSS pixels.
 type: number
 height:
 description: The page height in CSS pixels.
 type: number
 deviceScaleFactor:
 description: >-
 Specify device scale factor.

 See {@link
 https://developer.mozilla.org/en-US/docs/Web/API/Window/devicePixelRatio
 devicePixelRatio} for more info.
 type: number
 isMobile:
 description: Whether the \`meta viewport\` tag is taken into account.
 type: boolean
 isLandscape:
 description: Specifies if the viewport is in landscape mode.
 type: boolean
 hasTouch:
 description: Specify if the viewport supports touch events.
 type: boolean
 additionalProperties: false
 required:
 \- height
 \- width
 CDPLaunchOptions:
 type: object
 properties:
 args:
 type: array
 items:
 type: string
 defaultViewport:
 type: object
 properties:
 deviceScaleFactor:
 type: number
 hasTouch:
 type: boolean
 height:
 type: number
 isLandscape:
 type: boolean
 isMobile:
 type: boolean
 width:
 type: number
 additionalProperties: false
 required:
 \- height
 \- width
 devtools:
 type: boolean
 dumpio:
 type: boolean
 headless:
 enum:
 \- false
 \- shell
 \- true
 ignoreDefaultArgs:
 anyOf:
 \- type: array
 items:
 type: string
 \- type: boolean
 ignoreHTTPSErrors:
 type: boolean
 slowMo:
 type: number
 stealth:
 type: boolean
 timeout:
 type: number
 userDataDir:
 type: string
 waitForInitialPage:
 type: boolean
 additionalProperties: false
 BrowserServerOptions:
 type: object
 properties:
 args:
 type: array
 items:
 type: string
 chromiumSandbox:
 type: boolean
 devtools:
 type: boolean
 downloadsPath:
 type: string
 headless:
 type: boolean
 ignoreDefaultArgs:
 anyOf:
 \- type: array
 items:
 type: string
 \- type: boolean
 proxy:
 type: object
 properties:
 bypass:
 type: string
 password:
 type: string
 server:
 type: string
 username:
 type: string
 additionalProperties: false
 required:
 \- server
 timeout:
 type: number
 tracesDir:
 type: string
 additionalProperties: false
 JSONSchema:
 type: object
 properties:
 code:
 type: string
 context:
 $ref: '#/definitions/Record'
 additionalProperties: false
 required:
 \- code
 Record:
 type: object
 additionalProperties: false
 CDPJSONPayload:
 type: object
 properties:
 description:
 description: The description of the target. Generally the page's title.
 type: string
 devtoolsFrontendUrl:
 description: The fully-qualified URL of the Devtools inspector app.
 type: string
 id:
 description: A Unique Id for the underlying target.
 type: string
 title:
 description: The title of the target. For pages this is the page's title.
 type: string
 type:
 description: The type of target, generally "page" or "background\_page".
 type: string
 url:
 description: The current URL the target is consuming or visiting.
 type: string
 webSocketDebuggerUrl:
 description: \|-
 The target or page's WebSocket Debugger URL. Primarily used for legacy
 libraries to connect and inspect or remote automate this target.
 type: string
 additionalProperties: false
 required:
 \- description
 \- devtoolsFrontendUrl
 \- id
 \- title
 \- type
 \- url
 \- webSocketDebuggerUrl
 PDFOptions:
 description: Valid options to configure PDF generation via {@link Page.pdf}.
 type: object
 properties:
 scale:
 description: >-
 Scales the rendering of the web page. Amount must be between \`0.1\` and
 \`2\`.
 type: number
 displayHeaderFooter:
 description: Whether to show the header and footer.
 type: boolean
 headerTemplate:
 description: >-
 HTML template for the print header. Should be valid HTML with the
 following

 classes used to inject values into them:

 \- \`date\` formatted print date

 \- \`title\` document title

 \- \`url\` document location

 \- \`pageNumber\` current page number

 \- \`totalPages\` total pages in the document
 type: string
 footerTemplate:
 description: >-
 HTML template for the print footer. Has the same constraints and
 support

 for special classes as {@link PDFOptions.headerTemplate}.
 type: string
 printBackground:
 description: Set to \`true\` to print background graphics.
 type: boolean
 landscape:
 description: Whether to print in landscape orientation.
 type: boolean
 pageRanges:
 description: Paper ranges to print, e.g. \`1-5, 8, 11-13\`.
 type: string
 format:
 description: All the valid paper format types when printing a PDF.
 enum:
 \- A0
 \- A1
 \- A2
 \- A3
 \- A4
 \- A5
 \- A6
 \- LEDGER
 \- LEGAL
 \- LETTER
 \- Ledger
 \- Legal
 \- Letter
 \- TABLOID
 \- Tabloid
 \- a0
 \- a1
 \- a2
 \- a3
 \- a4
 \- a5
 \- a6
 \- ledger
 \- legal
 \- letter
 \- tabloid
 type: string
 width:
 description: >-
 Sets the width of paper. You can pass in a number or a string with a
 unit.
 type:
 \- string
 \- number
 height:
 description: >-
 Sets the height of paper. You can pass in a number or a string with a
 unit.
 type:
 \- string
 \- number
 preferCSSPageSize:
 description: \|-
 Give any CSS \`@page\` size declared in the page priority over what is
 declared in the \`width\` or \`height\` or \`format\` option.
 type: boolean
 margin:
 description: Set the PDF margins.
 $ref: '#/definitions/PDFMargin'
 path:
 description: The path to save the file to.
 type: string
 omitBackground:
 description: >-
 Hides default white background and allows generating pdfs with
 transparency.
 type: boolean
 tagged:
 description: Generate tagged (accessible) PDF.
 type: boolean
 outline:
 description: Generate document outline.
 type: boolean
 timeout:
 description: >-
 Timeout in milliseconds. Pass \`0\` to disable timeout.

 The default value can be changed by using {@link
 Page.setDefaultTimeout}
 type: number
 waitForFonts:
 description: >-
 If true, waits for \`document.fonts.ready\` to resolve. This might
 require

 activating the page using {@link Page.bringToFront} if the page is in
 the

 background.
 type: boolean
 additionalProperties: false
 PDFMargin:
 type: object
 properties:
 top:
 type:
 \- string
 \- number
 bottom:
 type:
 \- string
 \- number
 left:
 type:
 \- string
 \- number
 right:
 type:
 \- string
 \- number
 additionalProperties: false
 ScrapeDebugOptions:
 type: object
 properties:
 console:
 type: boolean
 cookies:
 type: boolean
 html:
 type: boolean
 network:
 type: boolean
 screenshot:
 type: boolean
 additionalProperties: false
 ScrapeElementSelector:
 type: object
 properties:
 selector:
 type: string
 timeout:
 type: number
 additionalProperties: false
 required:
 \- selector
 Cookie:
 description: Represents a cookie object.
 type: object
 properties:
 name:
 description: Cookie name.
 type: string
 value:
 description: Cookie value.
 type: string
 domain:
 description: Cookie domain.
 type: string
 path:
 description: Cookie path.
 type: string
 expires:
 description: >-
 Cookie expiration date as the number of seconds since the UNIX epoch.
 Set to \`-1\` for

 session cookies
 type: number
 size:
 description: Cookie size.
 type: number
 httpOnly:
 description: True if cookie is http-only.
 type: boolean
 secure:
 description: True if cookie is secure.
 type: boolean
 session:
 description: True in case of session cookie.
 type: boolean
 sameSite:
 description: Cookie SameSite type.
 enum:
 \- Lax
 \- None
 \- Strict
 type: string
 priority:
 description: Cookie Priority. Supported only in Chrome.
 enum:
 \- High
 \- Low
 \- Medium
 type: string
 sameParty:
 description: True if cookie is SameParty. Supported only in Chrome.
 type: boolean
 sourceScheme:
 description: Cookie source scheme type. Supported only in Chrome.
 enum:
 \- NonSecure
 \- Secure
 \- Unset
 type: string
 partitionKey:
 description: >-
 Cookie partition key. In Chrome, it is the top-level site the

 partitioned cookie is available in. In Firefox, it matches the

 source origin in the

 {@link https://w3c.github.io/webdriver-bidi/#type-storage-PartitionKey
 PartitionKey}.
 anyOf:
 \- $ref: '#/definitions/CookiePartitionKey'
 \- type: string
 partitionKeyOpaque:
 description: True if cookie partition key is opaque. Supported only in Chrome.
 type: boolean
 additionalProperties: false
 required:
 \- domain
 \- expires
 \- httpOnly
 \- name
 \- path
 \- secure
 \- session
 \- size
 \- value
 InBoundRequest:
 type: object
 properties:
 headers: {}
 status:
 type: number
 url:
 type: string
 additionalProperties: false
 required:
 \- headers
 \- status
 \- url
 OutBoundRequest:
 type: object
 properties:
 headers: {}
 method:
 type: string
 url:
 type: string
 additionalProperties: false
 required:
 \- headers
 \- method
 \- url
 ScreenshotOptions:
 type: object
 properties:
 optimizeForSpeed:
 type: boolean
 type:
 enum:
 \- jpeg
 \- png
 \- webp
 type: string
 quality:
 description: Quality of the image, between 0-100. Not applicable to \`png\` images.
 type: number
 fromSurface:
 description: Capture the screenshot from the surface, rather than the view.
 type: boolean
 fullPage:
 description: When \`true\`, takes a screenshot of the full page.
 type: boolean
 omitBackground:
 description: >-
 Hides default white background and allows capturing screenshots with
 transparency.
 type: boolean
 path:
 description: >-
 The file path to save the image to. The screenshot type will be
 inferred

 from file extension. If path is a relative path, then it is resolved

 relative to current working directory. If no path is provided, the
 image

 won't be saved to the disk.
 type: string
 clip:
 description: Specifies the region of the page/element to clip.
 $ref: '#/definitions/ScreenshotClip'
 encoding:
 description: Encoding of the image.
 enum:
 \- base64
 \- binary
 type: string
 captureBeyondViewport:
 description: Capture the screenshot beyond the viewport.
 type: boolean
 additionalProperties: false
 ScreenshotClip:
 type: object
 properties:
 scale:
 type: number
 width:
 description: the width of the element in pixels.
 type: number
 height:
 description: the height of the element in pixels.
 type: number
 x:
 type: number
 'y':
 type: number
 additionalProperties: false
 required:
 \- height
 \- width
 \- x
 \- 'y'
 import("/home/runner/work/enterprise/enterprise/node\_modules/@browserless.io/browserless/build/types",{with:{"resolution-mode":"import"}}).CDPLaunchOptions:
 type: object
 properties:
 args:
 type: array
 items:
 type: string
 defaultViewport:
 type: object
 properties:
 deviceScaleFactor:
 type: number
 hasTouch:
 type: boolean
 height:
 type: number
 isLandscape:
 type: boolean
 isMobile:
 type: boolean
 width:
 type: number
 additionalProperties: false
 required:
 \- height
 \- width
 devtools:
 type: boolean
 dumpio:
 type: boolean
 headless:
 enum:
 \- false
 \- shell
 \- true
 ignoreDefaultArgs:
 anyOf:
 \- type: array
 items:
 type: string
 \- type: boolean
 ignoreHTTPSErrors:
 type: boolean
 slowMo:
 type: number
 stealth:
 type: boolean
 timeout:
 type: number
 userDataDir:
 type: string
 waitForInitialPage:
 type: boolean
 additionalProperties: false
 CookieSameSite:
 description: \|-
 Represents the cookie's 'SameSite' status:
 https://tools.ietf.org/html/draft-west-first-party-cookies
 enum:
 \- Lax
 \- None
 \- Strict
 type: string
 CookiePriority:
 description: \|-
 Represents the cookie's 'Priority' status:
 https://tools.ietf.org/html/draft-west-cookie-priority-00
 enum:
 \- High
 \- Low
 \- Medium
 type: string
 CookieSourceScheme:
 description: >-
 Represents the source scheme of the origin that originally set the cookie.
 A value of

 "Unset" allows protocol clients to emulate legacy cookie scope for the
 scheme.

 This is a temporary ability and it will be removed in the future.
 enum:
 \- NonSecure
 \- Secure
 \- Unset
 type: string
 PaperFormat:
 description: All the valid paper format types when printing a PDF.
 enum:
 \- A0
 \- A1
 \- A2
 \- A3
 \- A4
 \- A5
 \- A6
 \- LEDGER
 \- LEGAL
 \- LETTER
 \- Ledger
 \- Legal
 \- Letter
 \- TABLOID
 \- Tabloid
 \- a0
 \- a1
 \- a2
 \- a3
 \- a4
 \- a5
 \- a6
 \- ledger
 \- legal
 \- letter
 \- tabloid
 type: string
 import("/home/runner/work/enterprise/enterprise/node\_modules/@browserless.io/browserless/build/types",{with:{"resolution-mode":"import"}}).BrowserServerOptions:
 type: object
 properties:
 args:
 type: array
 items:
 type: string
 chromiumSandbox:
 type: boolean
 devtools:
 type: boolean
 downloadsPath:
 type: string
 headless:
 type: boolean
 ignoreDefaultArgs:
 anyOf:
 \- type: array
 items:
 type: string
 \- type: boolean
 proxy:
 type: object
 properties:
 bypass:
 type: string
 password:
 type: string
 server:
 type: string
 username:
 type: string
 additionalProperties: false
 required:
 \- server
 timeout:
 type: number
 tracesDir:
 type: string
 additionalProperties: false
info:
 title: Browserless
  x-logo:
 altText: browserless logo
 url: ./docs/browserless-logo-inline.svg
 description: >
 # Browserless.io

 This service extends the Browserless open-source image with many features
 and enhancements for teams automating at scale. Notable features include:

 \- A Chrome-devtools-protocol based API for extending and enhancing libraries
 in a cross-language way.

 \- A new hybrid-automation toolkit with live session interactivity.

 \- Robust session management: connect, reconnect, kill and limit what a
 browser can do.

 \- Bleeding features like multiplexing numerous clients into a single Chrome
 process in an isolated way.

 \- The ability to upload and run custom extensions.

 \- Run multiple tokens, with access controls on each.

 \- Multi-browser with all the robust capabilities already in the open-source
 images.

 There's a lot to cover here so let's get started!

 # Software Keys

 The Enterprise image supports time-limited software keys that allow usage
 for a specific period without requiring any external connections or
 callbacks. These keys are cryptographically secure and cannot be reverse
 engineered. When a key expires, the container will exit with a semantic
 error code.

 ## Using a Software Key

 To use a software key, set the \`KEY\` environment variable when running the
 container:

 \`\`\`bash

 docker run -e KEY=your-generated-key browserless/enterprise

 \`\`\`

 # Using the Browserless Proxy

 \> The Residential proxy is only available for Enterprise and Cloud plans.

 Browserless comes with a built-in mechanism to proxy to what's called
 "residential" IPs. These are IP addresses are sourced from real-users
 running a proxy server on their home networking machines. Residential
 proxying is especially useful for things like bypassing certain bot
 blockages and more.

 Using a residential proxy is as straightforward as adding a few parameters
 to your library or API calls. Here's the required parameters and the values
 they support:

 \- \`?proxy=residential\`: Specifies that you want to use the residential proxy
 for this request. Data-center coming soon.

 \- \`?proxyCountry=us\`: Specifies a country you wish to use for the request. A
 two-digit ISO code.

 \- \`?proxySticky=true\`: If you want to use the same IP address for the
 entirety of the session. Generally recommended for most cases.

 Simply append these to your connection call, REST API calls, or any library
 call:

 \`wss://production-sfo.browserless.io/chromium?token=YOUR-API-TOKEN&proxy=residential&proxyCountry=us&proxySticky\`

 \`https://production-sfo.browserless.io/chromium/unblock?token=YOUR-API-TOKEN&proxy=residential&proxyCountry=us&proxySticky\`

 Please do note that using a proxy will increase the amount of units
 consumed. Every megabyte of data transferred consumes 6 units.

 # The Browserless CDP API

 In order to enhance the experience with open source libraries like
 Puppeteer, we decided to take a new approach to extending these libraries in
 a language-agnostic way. We call it the Browserless CDP API. Here's a quick
 list of what it can do:

 \- Generate and give back live URLs for hybrid automation.

 \- Solve Captchas.

 \- Return your page's unique identifier created by Chrome.

 \- Way more coming!

 Since most libraries come with a way to issue "raw" CDP commands, it's an
 easy way to drop-in custom behaviors without having to write and maintain a
 library. Plus you can continue to enjoy using the same packages you've
 already come to know.

 Getting started with this API is pretty simple. For instance, if you want to
 use the live viewer for a particular page, simply do the following:

 \`\`\`js

 import puppeteer from 'puppeteer-core';

 (async () => {
 const browserWSEndpoint = 'wss://production-sfo.browserless.io/chromium';
 const browser = await puppeteer.connect({ browserWSEndpoint });
 const page = await browser.newPage();
 const cdp = await page.createCDPSession();
 await page.goto('https://example.com');
 const { liveURL } = await cdp.send('Browserless.liveURL');

 // liveURL = 'http://localhost:3000/live/?i=98e83bbfd396241a6963425b1feeba2f';
 })();

 \`\`\`

 You can then visit this URL in any browser to interact with the headless
 Chrome running someplace else.

 See more below for a full list of the available APIs and features.

 ## Browserless.liveURL

 \> This API is only available for Enterprise plans. \[Contact us for more\
 information here.\](https://www.browserless.io/contact/)

 Returns a fully-qualified URL to load into a web-browser. This URL allows
 for clicking, typing and other interactions with the underlying page. This
 URL doesn't require an authorization token, so you're free to share it
 externally with your own users or employees. If security is a concern, you
 can set a \`timeout\` parameter to limit the amount of time this URL is valid
 for. By default no \`timeout\` is set and the URL is good as long as the
 underlying browser is open.

 Programmatic control of the session is also available, so you can close the
 live session once your code has detected a selector, network call, or
 whatever else. See the below example for programmatic control.

 \*\*Basic example\*\*

 \`\`\`js

 import puppeteer from 'puppeteer-core';

 (async () => {
 const browserWSEndpoint =
 'wss://production-sfo.browserless.io/chromium?token=YOUR-API-TOKEN';
 const browser = await puppeteer.connect({ browserWSEndpoint });
 const page = await browser.newPage();
 const cdp = await page.createCDPSession();
 await page.goto('https://example.com');
 const { liveURL } = await cdp.send('Browserless.liveURL');

 // liveURL = 'https://production-sfo.browserless.io/live/?i=98e83bbfd396241a6963425b1feeba2f';
 })();

 \`\`\`

 \*\*Timeout example\*\*

 \`\`\`js

 import puppeteer from 'puppeteer-core';

 (async () => {
 const browserWSEndpoint =
 'wss://production-sfo.browserless.io/chromium?token=YOUR-API-TOKEN';
 const browser = await puppeteer.connect({ browserWSEndpoint });
 const page = await browser.newPage();
 const cdp = await page.createCDPSession();
 await page.goto('https://example.com');
 const { liveURL } = await cdp.send('Browserless.liveURL', {
 timeout: 10000, // 10 seconds to connect!
 });

 // liveURL = 'https://production-sfo.browserless.io/live/?i=98e83bbfd396241a6963425b1feeba2f';
 })();

 \`\`\`

 \*\*Maintaining the width and height\*\*

 By default, Browserless will dynamically change the width and height of the
 browser to match an end-users screen. This isn't always ideal and can be
 disabled by setting a \`resizable\` value to \`false\`. When this is done, only
 your script can alter the width and height of the browser:

 \`\`\`js

 import puppeteer from 'puppeteer-core';

 (async () => {
 const browserWSEndpoint =
 'wss://production-sfo.browserless.io/chromium?token=YOUR-API-TOKEN';
 const browser = await puppeteer.connect({ browserWSEndpoint });
 const page = await browser.newPage();

 // Width and height will always be 1920x1080
 // and the Live URL will maintain this aspect ratio
 await page.setViewport({ width: 1920, height: 1080 });
 const cdp = await page.createCDPSession();
 await page.goto('https://example.com');
 const { liveURL } = await cdp.send('Browserless.liveURL', {
 resizable: false,
 });

 // liveURL = 'https://production-sfo.browserless.io/live/?i=98e83bbfd396241a6963425b1feeba2f';
 })();

 \`\`\`

 \*\*Setting a Quality and Type\*\*

 Setting a "quality" and "type" effects the streamed quality of the live
 URL's client-side resolution. By default, Browserless sets these to quality:
 100 and type of "png". You can experiment different settings to get an ideal
 resolutions while keep latency slow. The close to 100 quality is, the
 potential for higher perceived latency.

 \`\`\`js

 import puppeteer from 'puppeteer-core';

 (async () => {
 const browserWSEndpoint =
 'wss://production-sfo.browserless.io/chromium?token=YOUR-API-TOKEN';
 const browser = await puppeteer.connect({ browserWSEndpoint });
 const page = await browser.newPage();
 const cdp = await page.createCDPSession();
 await page.goto('https://example.com');
 const { liveURL } = await cdp.send('Browserless.liveURL', {
 quality: 100, // Can be 1 - 100
 type: 'png', // Can be 'jpeg' or 'png'
 });

 // liveURL = 'https://production-sfo.browserless.io/live/?i=98e83bbfd396241a6963425b1feeba2f';
 })();

 \`\`\`

 It's also helpful to "wait" until the user is done doing what's needed. For
 that reason, Browserless will fire a custom event when the page is closed as
 well:

 \*\*Wait for close\*\*

 \> Custom CDP Events are not supported in all libraries, including .NET
 Playwright.

 \`\`\`js

 import puppeteer from 'puppeteer-core';

 (async () => {
 const browserWSEndpoint =
 'wss://production-sfo.browserless.io/chromium?token=YOUR-API-TOKEN';
 const browser = await puppeteer.connect({ browserWSEndpoint });
 const page = await browser.newPage();
 const cdp = await page.createCDPSession();
 await page.goto('https://example.com');

 const { liveURL } = await cdp.send('Browserless.liveURL');

 console.log(liveURL);

 // Wait for the Browserless.liveComplete event when the live page is closed.
 // Please not that not all libraries support custom CDP events.
 await new Promise((r) => cdp.on('Browserless.liveComplete', r));

 console.log('Done!');

 await browser.close();
 })();

 \`\`\`

 \*\*Programmatic Control\*\*

 \`\`\`js

 import puppeteer from 'puppeteer-core';

 (async () => {
 const browserWSEndpoint =
 'wss://production-sfo.browserless.io/chromium?token=YOUR-API-TOKEN';
 const browser = await puppeteer.connect({ browserWSEndpoint });
 const page = await browser.newPage();
 const cdp = await page.createCDPSession();
 await page.goto('https://example.com');

 // Having the liveURLId is required in order to close it later
 const { liveURL, liveURLId } = await cdp.send('Browserless.liveURL');

 await page.waitForSelector('.my-selector');

 // Calling this CDP API with the "liveURLId" will close the session, and terminate the client
 // further usage of the liveURL will fail and no more human-control is possible
 await cdp.send('Browserless.closeLiveURL', { liveURLId });

 // Continue to process or interact with the browser, then:
 await browser.close();
 })();

 \`\`\`

 It's recommended that you double check the page prior to executing further
 code to make sure the page is where it should be, elements are present, and
 so forth. This approach makes it easy to solve hard things like
 second-factor authentication and more in a trivial fashion.

 \*\*Read-only LiveURL Sessions\*\*

 The \`interactive: false\` option allows you to create read-only LiveURL
 sessions where users can view the browser but cannot interact with it. This
 is useful for monitoring or demonstration purposes without allowing user
 input.

 \`\`\`js

 import puppeteer from 'puppeteer-core';

 (async () => {
 const browserWSEndpoint =
 'wss://production-sfo.browserless.io/chromium?token=YOUR-API-TOKEN';
 const browser = await puppeteer.connect({ browserWSEndpoint });
 const page = await browser.newPage();
 const cdp = await page.createCDPSession();
 await page.goto('https://example.com');

 // Create a read-only LiveURL session that users can view but not interact with
 const { liveURL } = await cdp.send('Browserless.liveURL', {
 interactive: false,
 });

 console.log('Read-only LiveURL:', liveURL);

 await browser.close();
 })();

 \`\`\`

 ## Browserless.reconnect

 \> This API is only available for Enterprise plans. \[Contact us for more\
 information here.\](https://www.browserless.io/contact/)

 Reconnecting allows for the underlying Chrome or Chromium process to
 continue to run for a specified amount of time, and subsequent reconnecting
 back to it. With this approach you can also "share" this connection URL to
 other clients to connect to the same browser process, allowing you to
 parallelize via a single Browser process.

 Once a reconnection URL is retrieved, Browserless will intercept close-based
 commands and stop them from terminating the browser process itself. This
 prevents clients from accidentally closing the process via \`browser.close\`
 or similar.

 In order to use this API, simply call \`Browserless.reconnect\` as a CDP
 command. You can, optionally, set a \`timeout\` or an \`auth\` property. See the
 below examples for details

 \*\*Basic example with timeout\*\*

 \`\`\`js

 import puppeteer from 'puppeteer-core';

 (async () => {
 const browserWSEndpoint =
 'wss://production-sfo.browserless.io/chromium?token=YOUR-API-TOKEN';
 const browser = await puppeteer.connect({ browserWSEndpoint });
 const page = await browser.newPage();
 const cdp = await page.createCDPSession();
 await page.goto('https://example.com');

 // Allow this browser to run for 10 seconds, then shut down if nothing connects to it.
 // Defaults to the overall timeout set on the instance, which is 5 minutes if not specified.
 const { error, browserWSEndpoint } = await cdp.send('Browserless.reconnect', {
 timeout: 10000,
 });

 if (error) throw error;

 await browser.close();

 // browserWSEndpoint = 'https://production-sfo.browserless.io/reconnect/98e83bbfd396241a6963425b1feeba2f';
 })();

 \`\`\`

 If you want to enforce authentication, you can pass in an optional \`auth\`
 property that clients will need to use in order to connect with. Similar to
 how authentication works in general, a \`token\` query-string parameter will
 need to be applied.

 \*\*Authentication example\*\*

 \`\`\`js

 import puppeteer from 'puppeteer-core';

 (async () => {
 const browserWSEndpoint =
 'wss://production-sfo.browserless.io/chromium?token=YOUR-API-TOKEN';
 const browser = await puppeteer.connect({ browserWSEndpoint });
 const page = await browser.newPage();
 const cdp = await page.createCDPSession();
 await page.goto('https://example.com');

 // Set a custom authentication token that clients have to use in order to connect, or otherwise
 // receive a 401 Response.
 const { error, browserWSEndpoint } = await cdp.send('Browserless.reconnect', {
 auth: 'secret-auth-token',
 });

 if (error) throw error;

 await browser.close();

 // NOTE the URL here doesn't include the auth token!
 // browserWSEndpoint = 'https://production-sfo.browserless.io/reconnect/98e83bbfd396241a6963425b1feeba2f';
 })();

 \`\`\`

 \*\*Recursive Example\*\*

 \`\`\`js

 import puppeteer from 'puppeteer-core';

 const job = async (reconnectURL) => {
 const browserWSEndpoint =
 reconnectURL ??
 'wss://production-sfo.browserless.io/chromium?token=YOUR-API-TOKEN';
 const browser = await puppeteer.connect({ browserWSEndpoint });
 const \[page\] = await browser.page();
 const cdp = await page.createCDPSession();
 await page.goto('https://example.com');

 // Anytime Browserless.reconnect is called, this restarts the timer back to the provided value,
 // effectively "bumping" the timer forward.
 const res = await cdp.send('Browserless.reconnect', {
 timeout: 30000,
 });

 if (res.error) throw error;

 await browser.close();

 // Continuously reconnect back...
 return job(res.browserWSEndpoint);
 };

 job().catch((e) => console.error(e));

 \`\`\`

 ## Browserless.solveCaptcha

 \> This API is only available for Enterprise and Scale and above plans on
 Cloud. \[Contact us for more information\
 here.\](https://www.browserless.io/contact/). Only the \`/chrome\` and
 \`/chromium\` routes support Captcha solving.

 Browserless comes with built-in captcha solving capabilities. We use a
 variety of techniques to try and mitigate the chances of captchas coming up,
 but if you happen to run into one you can simply call on our API to solve
 it.

 Given the amount of possibilities during a captcha solve, the API returns
 many properties and information in order to help your script be more
 informed as to what happened. See the below code example for all details and
 fields returned by the API.

 Please be aware that solving a captcha can take a few seconds up to several
 minutes, so you'll want to increase your timeouts accordingly for your
 scripts. Captcha's solved, or attempted to solve, cost 10 units.

 \`\`\`js

 import puppeteer from 'puppeteer-core';

 (async () => {
 const browser = await puppeteer.connect({
 browserWSEndpoint:
 'wss://production-sfo.browserless.io/chromium?token=YOUR-API-TOKEN&timeout=300000',
 });

 const page = await browser.newPage();
 const cdp = await page.createCDPSession();
 await page.goto('https://www.google.com/recaptcha/api2/demo', {
 waitUntil: 'networkidle0',
 });

 const {
 // A simple boolean indicating whether the script can proceed
 ok,
 // Whether or not a captcha was found
 captchaFound,
 // A human-readable description of what occurred.
 message,
 // Whether a solve was attempted or not
 solveAttempted,
 // If the Captcha was solved, only true if found AND solved
 solved,
 // Any errors during execution are saved here:
 error,
 } = await cdp.send('Browserless.solveCaptcha', {
 // How long to wait for a Captcha to appear to solve.
 // Defaults to 10,000ms, or 10 seconds.
 appearTimeout: 30000,
 });

 console.log(message);

 if (ok) {
 await page.click('#recaptcha-demo-submit');
 } else {
 console.error(\`Error solving captcha!\`);
 }

 await browser.close();
 })().catch((e) => {
 console.error(e);
 process.exit(1);
 });

 \`\`\`

 In general, if an \`ok\` response is sent back from this API, then your script
 is good to proceed with further actions. If a captcha is to suddenly appears
 after an action then you might want to listen for the
 \`Browserless.foundCaptcha\` event (see below) and retry solving.

 ## Browserless.foundCaptcha

 \> This API is only available for Enterprise and Scale and above plans on
 Cloud. \[Contact us for more information\
 here.\](https://www.browserless.io/contact/). Only the \`/chrome\` and
 \`/chromium\` routes support Captcha solving.

 \> Custom CDP Events are not supported in all libraries, including .NET
 Playwright.

 Emitted whenever a captcha widget is found on the page. Useful for checking
 if there's a captcha and deciding whether or not to proceed with solving.

 The example below stops until a captcha is found, which may or may not be
 the case with every website out there.

 \`\`\`js

 import puppeteer from 'puppeteer-core';

 // Recaptcha

 (async () => {
 const browser = await puppeteer.connect({
 browserWSEndpoint:
 'wss://production-sfo.browserless.io/chromium?token=YOUR-API-TOKEN&timeout=300000',
 });

 const page = await browser.newPage();
 const cdp = await page.createCDPSession();

 await page.goto('https://www.google.com/recaptcha/api2/demo', {
 waitUntil: 'networkidle0',
 });

 // Please note that not all libraries support custom CDP events.
 await new Promise((resolve) =>
 cdp.on('Browserless.captchaFound', () => {
 console.log('Found a captcha!');
 return resolve();
 }),
 );

 const { solved, error } = await cdp.send('Browserless.solveCaptcha');
 console.log({
 solved,
 error,
 });

 // Continue...
 await page.click('#recaptcha-demo-submit');
 })().catch((e) => {
 console.error(e);
 process.exit(1);
 });

 \`\`\`

 ## Browserless.heartbeat

 \> This API is only available for Enterprise hosted and Starter and above
 plans on Cloud. \[Contact us for more information\
 here.\](https://www.browserless.io/contact/).

 \> Custom CDP Events are not supported in all libraries, including .NET
 Playwright.

 A custom event emitted every several seconds, signaling a live connection.
 This is useful for a few reasons:

 \- It ensure that your connection with the browser is still good.

 \- Sending data can trigger some load-balancing technologies to not kill the
 connection.

 Today this event is emitted every 30 seconds.

 \`\`\`js

 import puppeteer from 'puppeteer-core';

 const browserWSEndpoint =
 \`wss://production-sfo.browserless.io/chromium?token=YOUR-API-TOKEN\`;

 (async () => {
 const browser = await puppeteer.connect({ browserWSEndpoint });
 const page = await browser.newPage();
 await page.goto('https://example.com/');
 const client = await page.createCDPSession();

 client.on('Browserless.heartbeat', () => {
 console.log('Browserless.heartbeat');
 });
 })();

 \`\`\`

 ## Browserless.pageId

 \> This API is only available for Enterprise hosted and Starter and above
 plans on Cloud. \[Contact us for more information\
 here.\](https://www.browserless.io/contact/).

 A simple helper utility to return the page's unique ID. Since most libraries
 treat this ID as opaque, and some even hide it, knowing the page's ID can be
 of great help when interacting with other parts of Browserless.

 \`\`\`js

 import puppeteer from 'puppeteer-core';

 (async () => {
 const browserWSEndpoint = 'wss://production-sfo.browserless.io/chromium';
 const browser = await puppeteer.connect({ browserWSEndpoint });
 const page = await browser.newPage();
 const cdp = await page.createCDPSession();
 const { pageId } = await cdp.send('Browserless.pageId');

 // pageId = 'ABC12354AFDC123';
 })();

 \`\`\`

 You can, optionally, try and "find" this ID in puppeteer or similar
 libraries. Given that puppeteer has this property underscored, it's likely
 to change or be unavailable in the future, and requires the infamous \`//
 @ts-ignore\` comment to allow TypeScript compilation.

 \`\`\`ts

 const getPageId = (page: Page): string => {
 // @ts-ignore
 return page.target().\_targetId;
 };

 \`\`\`

 # Changelog
openapi: 3.0.0
paths:
 /chrome/content:
 post:
 definitions: {}
 description: >-
 A JSON-based API. Given a "url" or "html" field, runs and returns HTML
 content after the page has loaded and JavaScript has parsed.
 parameters:
 \- in: query
 name: blockAds
 schema:
 description: \|-
 Whether or nor to load ad-blocking extensions for the session.
 This currently uses uBlock-Lite and may cause certain sites
 to not load properly.
 type: boolean
 \- in: query
 name: launch
 schema:
 anyOf:
 \- $ref: '#/definitions/CDPLaunchOptions'
 \- type: string
 \- in: query
 name: timeout
 schema:
 description: \|-
 Override the system-level timeout for this request.
 Accepts a value in milliseconds.
 type: number
 \- in: query
 name: token
 schema:
 description: The authorization token
 type: string
 \- in: query
 name: trackingId
 schema:
 description: Custom session identifier
 type: string
 requestBody:
 content:
 application/json:
 schema:
 properties:
 addScriptTag:
 type: array
 items:
 $ref: '#/definitions/FrameAddScriptTagOptions'
 addStyleTag:
 type: array
 items:
 $ref: '#/definitions/FrameAddStyleTagOptions'
 authenticate:
 anyOf:
 \- $ref: '#/definitions/Credentials'
 \- type: 'null'
 bestAttempt:
 description: >-
 When bestAttempt is set to true, browserless attempt to
 proceed

 when "awaited" events fail or timeout. This includes things
 like

 goto, waitForSelector, and more.
 type: boolean
 cookies:
 type: array
 items:
 $ref: '#/definitions/CookieParam'
 emulateMediaType:
 type: string
 gotoOptions:
 $ref: '#/definitions/GoToOptions'
 html:
 type: string
 rejectRequestPattern:
 type: array
 items:
 type: string
 rejectResourceTypes:
 type: array
 items:
 enum:
 \- cspviolationreport
 \- document
 \- eventsource
 \- fetch
 \- font
 \- image
 \- manifest
 \- media
 \- other
 \- ping
 \- prefetch
 \- preflight
 \- script
 \- signedexchange
 \- stylesheet
 \- texttrack
 \- websocket
 \- xhr
 type: string
 requestInterceptors:
 type: array
 items:
 description: >-
 An array of patterns (using \`req.url().match(r.pattern)\`
 to match) and their

 corresponding responses to use in order to fulfill those
 requests.
 type: object
 properties:
 pattern:
 description: >-
 An array of patterns (using
 \`req.url().match(r.pattern)\` to match) and their

 corresponding responses to use in order to fulfill
 those requests.
 type: string
 response:
 $ref: '#/definitions/Partial'
 additionalProperties: false
 required:
 \- pattern
 \- response
 setExtraHTTPHeaders:
 $ref: '#/definitions/Record'
 setJavaScriptEnabled:
 description: Whether or not to allow JavaScript to run on the page.
 type: boolean
 url:
 type: string
 userAgent:
 type: string
 viewport:
 anyOf:
 \- $ref: '#/definitions/Viewport'
 \- type: 'null'
 waitForEvent:
 type: object
 properties:
 event:
 type: string
 timeout:
 type: number
 additionalProperties: false
 required:
 \- event
 waitForFunction:
 type: object
 properties:
 fn:
 description: >-
 The function, or statement, to be evaluated in browser
 context
 type: string
 polling:
 description: >-
 An interval at which the pageFunction is executed,
 defaults to raf.

 If polling is a number, then it is treated as an
 interval in milliseconds

 at which the function would be executed. If polling is a
 string,

 then it can be one of the following values: "raf" or
 "mutation"
 type:
 \- string
 \- number
 timeout:
 description: >-
 Maximum time to wait for in milliseconds. Defaults to
 30000 (30 seconds).

 Pass 0 to disable timeout.
 type: number
 additionalProperties: false
 required:
 \- fn
 waitForSelector:
 type: object
 properties:
 hidden:
 type: boolean
 selector:
 type: string
 timeout:
 type: number
 visible:
 type: boolean
 additionalProperties: false
 required:
 \- selector
 waitForTimeout:
 type: number
 type: object
 responses:
 '200':
 content:
 text/html:
 schema:
 description: \|-
 An HTML payload of the website or HTML after JavaScript
 parsing and execution.
 type: string
 $schema: http://json-schema.org/draft-07/schema#
 description: \|-
 An HTML payload of the website or HTML after JavaScript
 parsing and execution.
 '400':
 code: 400
 description: The request contains errors or didn't properly encode content.
 message: HTTP/1.1 400 Bad Request
 '401':
 code: 401
 description: The request is missing, or contains bad, authorization credentials.
 message: HTTP/1.1 401 Unauthorized
 '404':
 code: 404
 description: Resource couldn't be found.
 message: HTTP/1.1 404 Not Found
 '408':
 code: 408
 description: The request took has taken too long to process.
 message: HTTP/1.1 408 Request Timeout
 '429':
 code: 429
 description: Too many requests are currently being processed.
 message: HTTP/1.1 429 Too Many Requests
 '500':
 code: 500
 description: An internal error occurred when handling the request.
 message: HTTP/1.1 500 Internal Server Error
 summary: /chrome/content
 tags:
 \- Browser REST APIs
 /chrome/download:
 post:
 definitions: {}
 description: >-
 A JSON or JavaScript content-type API for returning files Chrome has
 downloaded during

 the execution of puppeteer code, which is ran inside context of the
 browser.

 Browserless sets up a blank page, a fresh download directory, injects
 your puppeteer code, and then executes it.

 You can load external libraries via the "import" syntax, and import
 ESM-style modules

 that are written for execution inside of the browser. Once your script
 is finished, any

 downloaded files from Chromium are returned back with the appropriate
 content-type header.
 parameters:
 \- in: query
 name: blockAds
 schema:
 description: \|-
 Whether or nor to load ad-blocking extensions for the session.
 This currently uses uBlock-Lite and may cause certain sites
 to not load properly.
 type: boolean
 \- in: query
 name: launch
 schema:
 description: \|-
 Launch options, which can be either an object
 of puppeteer.launch options or playwright.launchServer
 options, depending on the API. Must be either JSON
 object, or a base64-encoded JSON object.
 anyOf:
 \- $ref: '#/definitions/CDPLaunchOptions'
 \- type: string
 \- in: query
 name: timeout
 schema:
 description: \|-
 Override the system-level timeout for this request.
 Accepts a value in milliseconds.
 type: number
 \- in: query
 name: token
 schema:
 description: The authorization token
 type: string
 \- in: query
 name: trackingId
 schema:
 description: Custom session identifier
 type: string
 requestBody:
 content:
 application/json:
 schema:
 $ref: '#/definitions/JSONSchema'
 application/javascript:
 schema:
 type: string
 responses:
 '200':
 content:
 '\*/\*':
 schema:
 description: >-
 Responses are determined by the returned value of the
 downloads

 themselves, so there isn't a static response type for this
 API.
 $schema: http://json-schema.org/draft-07/schema#
 description: \|-
 Responses are determined by the returned value of the downloads
 themselves, so there isn't a static response type for this API.
 '400':
 code: 400
 description: The request contains errors or didn't properly encode content.
 message: HTTP/1.1 400 Bad Request
 '401':
 code: 401
 description: The request is missing, or contains bad, authorization credentials.
 message: HTTP/1.1 401 Unauthorized
 '404':
 code: 404
 description: Resource couldn't be found.
 message: HTTP/1.1 404 Not Found
 '408':
 code: 408
 description: The request took has taken too long to process.
 message: HTTP/1.1 408 Request Timeout
 '429':
 code: 429
 description: Too many requests are currently being processed.
 message: HTTP/1.1 429 Too Many Requests
 '500':
 code: 500
 description: An internal error occurred when handling the request.
 message: HTTP/1.1 500 Internal Server Error
 summary: /chrome/download
 tags:
 \- Browser REST APIs
 /chrome/function:
 post:
 definitions: {}
 description: >-
 A JSON or JavaScript content-type API for running puppeteer code in the
 browser's context.

 Browserless sets up a blank page, injects your puppeteer code, and runs
 it.

 You can optionally load external libraries via the "import" module that
 are meant for browser usage.

 Values returned from the function are checked and an appropriate
 content-type and response is sent back

 to your HTTP call.
 parameters:
 \- in: query
 name: blockAds
 schema:
 description: \|-
 Whether or nor to load ad-blocking extensions for the session.
 This currently uses uBlock-Lite and may cause certain sites
 to not load properly.
 type: boolean
 \- in: query
 name: launch
 schema:
 description: \|-
 Launch options, which can be either an object
 of puppeteer.launch options or playwright.launchServer
 options, depending on the API. Must be either JSON
 object, or a base64-encoded JSON object.
 anyOf:
 \- $ref: '#/definitions/CDPLaunchOptions'
 \- type: string
 \- in: query
 name: timeout
 schema:
 description: \|-
 Override the system-level timeout for this request.
 Accepts a value in milliseconds.
 type: number
 \- in: query
 name: token
 schema:
 description: The authorization token
 type: string
 \- in: query
 name: trackingId
 schema:
 description: Custom session identifier
 type: string
 requestBody:
 content:
 application/json:
 schema:
 $ref: '#/definitions/JSONSchema'
 application/javascript:
 schema:
 type: string
 responses:
 '200':
 content:
 '\*/\*':
 schema:
 description: >-
 Responses are determined by the returned value of the function

 itself. Binary responses (PDF's, screenshots) are returned
 back

 as binary data, and primitive JavaScript values are returned
 back

 by type (HTML data is "text/html", Objects are
 "application/json")
 $schema: http://json-schema.org/draft-07/schema#
 description: \|-
 Responses are determined by the returned value of the function
 itself. Binary responses (PDF's, screenshots) are returned back
 as binary data, and primitive JavaScript values are returned back
 by type (HTML data is "text/html", Objects are "application/json")
 '400':
 code: 400
 description: The request contains errors or didn't properly encode content.
 message: HTTP/1.1 400 Bad Request
 '401':
 code: 401
 description: The request is missing, or contains bad, authorization credentials.
 message: HTTP/1.1 401 Unauthorized
 '404':
 code: 404
 description: Resource couldn't be found.
 message: HTTP/1.1 404 Not Found
 '408':
 code: 408
 description: The request took has taken too long to process.
 message: HTTP/1.1 408 Request Timeout
 '429':
 code: 429
 description: Too many requests are currently being processed.
 message: HTTP/1.1 429 Too Many Requests
 '500':
 code: 500
 description: An internal error occurred when handling the request.
 message: HTTP/1.1 500 Internal Server Error
 summary: /chrome/function
 tags:
 \- Browser REST APIs
 /json/list:
 get:
 definitions: {}
 description: >-
 Returns a JSON payload that acts as a pass-through to the DevTools
 /json/list HTTP API in Chromium and Chrome.

 Browserless crafts this payload so that remote clients can connect to
 the underlying "webSocketDebuggerUrl"

 properly, excluding any API tokens in that URL. If under authentication
 be sure to include your authorization.
 parameters: \[\]
 requestBody:
 content: {}
 responses:
 '200':
 content:
 application/json:
 schema:
 type: array
 items:
 $ref: '#/definitions/CDPJSONPayload'
 definitions:
 CDPJSONPayload:
 type: object
 properties:
 description:
 description: >-
 The description of the target. Generally the page's
 title.
 type: string
 devtoolsFrontendUrl:
 description: The fully-qualified URL of the Devtools inspector app.
 type: string
 id:
 description: A Unique Id for the underlying target.
 type: string
 title:
 description: >-
 The title of the target. For pages this is the page's
 title.
 type: string
 type:
 description: >-
 The type of target, generally "page" or
 "background\_page".
 type: string
 url:
 description: The current URL the target is consuming or visiting.
 type: string
 webSocketDebuggerUrl:
 description: >-
 The target or page's WebSocket Debugger URL. Primarily
 used for legacy

 libraries to connect and inspect or remote automate
 this target.
 type: string
 additionalProperties: false
 required:
 \- description
 \- devtoolsFrontendUrl
 \- id
 \- title
 \- type
 \- url
 \- webSocketDebuggerUrl
 $schema: http://json-schema.org/draft-07/schema#
 '400':
 code: 400
 description: The request contains errors or didn't properly encode content.
 message: HTTP/1.1 400 Bad Request
 '401':
 code: 401
 description: The request is missing, or contains bad, authorization credentials.
 message: HTTP/1.1 401 Unauthorized
 '404':
 code: 404
 description: Resource couldn't be found.
 message: HTTP/1.1 404 Not Found
 '408':
 code: 408
 description: The request took has taken too long to process.
 message: HTTP/1.1 408 Request Timeout
 '429':
 code: 429
 description: Too many requests are currently being processed.
 message: HTTP/1.1 429 Too Many Requests
 '500':
 code: 500
 description: An internal error occurred when handling the request.
 message: HTTP/1.1 500 Internal Server Error
 summary: /json/list
 tags:
 \- Browser REST APIs
 /json/new:
 put:
 definitions: {}
 description: >-
 Returns a JSON payload that acts as a pass-through to the DevTools
 /json/new HTTP API in Chromium.

 Browserless mocks this payload so that remote clients can connect to the
 underlying "webSocketDebuggerUrl"

 which will cause Browserless to start the browser and proxy that request
 into a blank page.
 parameters: \[\]
 requestBody:
 content: {}
 responses:
 '200':
 content:
 application/json:
 schema:
 type: object
 properties:
 description:
 description: The description of the target. Generally the page's title.
 type: string
 devtoolsFrontendUrl:
 description: The fully-qualified URL of the Devtools inspector app.
 type: string
 id:
 description: A Unique Id for the underlying target.
 type: string
 title:
 description: >-
 The title of the target. For pages this is the page's
 title.
 type: string
 type:
 description: The type of target, generally "page" or "background\_page".
 type: string
 url:
 description: The current URL the target is consuming or visiting.
 type: string
 webSocketDebuggerUrl:
 description: >-
 The target or page's WebSocket Debugger URL. Primarily
 used for legacy

 libraries to connect and inspect or remote automate this
 target.
 type: string
 additionalProperties: false
 required:
 \- description
 \- devtoolsFrontendUrl
 \- id
 \- title
 \- type
 \- url
 \- webSocketDebuggerUrl
 $schema: http://json-schema.org/draft-07/schema#
 '400':
 code: 400
 description: The request contains errors or didn't properly encode content.
 message: HTTP/1.1 400 Bad Request
 '401':
 code: 401
 description: The request is missing, or contains bad, authorization credentials.
 message: HTTP/1.1 401 Unauthorized
 '404':
 code: 404
 description: Resource couldn't be found.
 message: HTTP/1.1 404 Not Found
 '408':
 code: 408
 description: The request took has taken too long to process.
 message: HTTP/1.1 408 Request Timeout
 '429':
 code: 429
 description: Too many requests are currently being processed.
 message: HTTP/1.1 429 Too Many Requests
 '500':
 code: 500
 description: An internal error occurred when handling the request.
 message: HTTP/1.1 500 Internal Server Error
 summary: /json/new
 tags:
 \- Browser REST APIs
 /json/protocol:
 get:
 definitions: {}
 description: Returns Protocol JSON meta-data that Chrome and Chromium come with.
 parameters: \[\]
 requestBody:
 content: {}
 responses:
 '200':
 content:
 application/json:
 schema:
 type: object
 properties: {}
 additionalProperties: true
 $schema: http://json-schema.org/draft-07/schema#
 '400':
 code: 400
 description: The request contains errors or didn't properly encode content.
 message: HTTP/1.1 400 Bad Request
 '401':
 code: 401
 description: The request is missing, or contains bad, authorization credentials.
 message: HTTP/1.1 401 Unauthorized
 '404':
 code: 404
 description: Resource couldn't be found.
 message: HTTP/1.1 404 Not Found
 '408':
 code: 408
 description: The request took has taken too long to process.
 message: HTTP/1.1 408 Request Timeout
 '429':
 code: 429
 description: Too many requests are currently being processed.
 message: HTTP/1.1 429 Too Many Requests
 '500':
 code: 500
 description: An internal error occurred when handling the request.
 message: HTTP/1.1 500 Internal Server Error
 summary: /json/protocol
 tags:
 \- Browser REST APIs
 /json/version:
 get:
 definitions: {}
 description: >-
 Returns a JSON payload that acts as a pass-through to the DevTools
 /json/version protocol in Chrome and Chromium.
 parameters: \[\]
 requestBody:
 content: {}
 responses:
 '200':
 content:
 application/json:
 schema:
 type: object
 properties:
 description:
 description: The description of the target. Generally the page's title.
 type: string
 devtoolsFrontendUrl:
 description: The fully-qualified URL of the Devtools inspector app.
 type: string
 id:
 description: A Unique Id for the underlying target.
 type: string
 title:
 description: >-
 The title of the target. For pages this is the page's
 title.
 type: string
 type:
 description: The type of target, generally "page" or "background\_page".
 type: string
 url:
 description: The current URL the target is consuming or visiting.
 type: string
 webSocketDebuggerUrl:
 description: >-
 The target or page's WebSocket Debugger URL. Primarily
 used for legacy

 libraries to connect and inspect or remote automate this
 target.
 type: string
 additionalProperties: false
 required:
 \- description
 \- devtoolsFrontendUrl
 \- id
 \- title
 \- type
 \- url
 \- webSocketDebuggerUrl
 $schema: http://json-schema.org/draft-07/schema#
 '400':
 code: 400
 description: The request contains errors or didn't properly encode content.
 message: HTTP/1.1 400 Bad Request
 '401':
 code: 401
 description: The request is missing, or contains bad, authorization credentials.
 message: HTTP/1.1 401 Unauthorized
 '404':
 code: 404
 description: Resource couldn't be found.
 message: HTTP/1.1 404 Not Found
 '408':
 code: 408
 description: The request took has taken too long to process.
 message: HTTP/1.1 408 Request Timeout
 '429':
 code: 429
 description: Too many requests are currently being processed.
 message: HTTP/1.1 429 Too Many Requests
 '500':
 code: 500
 description: An internal error occurred when handling the request.
 message: HTTP/1.1 500 Internal Server Error
 summary: /json/version
 tags:
 \- Browser REST APIs
 /chrome/pdf:
 post:
 definitions: {}
 description: \|-
 A JSON-based API for getting a PDF binary from either a supplied
 "url" or "html" payload in your request. Many options exist for
 injecting cookies, request interceptors, user-agents and waiting for
 selectors, timers and more.
 parameters:
 \- in: query
 name: blockAds
 schema:
 description: \|-
 Whether or nor to load ad-blocking extensions for the session.
 This currently uses uBlock-Lite and may cause certain sites
 to not load properly.
 type: boolean
 \- in: query
 name: launch
 schema:
 description: \|-
 Launch options, which can be either an object
 of puppeteer.launch options or playwright.launchServer
 options, depending on the API. Must be either JSON
 object, or a base64-encoded JSON object.
 anyOf:
 \- $ref: '#/definitions/CDPLaunchOptions'
 \- type: string
 \- in: query
 name: timeout
 schema:
 description: \|-
 Override the system-level timeout for this request.
 Accepts a value in milliseconds.
 type: number
 \- in: query
 name: token
 schema:
 description: The authorization token
 type: string
 \- in: query
 name: trackingId
 schema:
 description: Custom session identifier
 type: string
 requestBody:
 content:
 application/json:
 schema:
 properties:
 addScriptTag:
 type: array
 items:
 $ref: '#/definitions/FrameAddScriptTagOptions'
 addStyleTag:
 type: array
 items:
 $ref: '#/definitions/FrameAddStyleTagOptions'
 authenticate:
 anyOf:
 \- $ref: '#/definitions/Credentials'
 \- type: 'null'
 bestAttempt:
 description: >-
 When bestAttempt is set to true, browserless attempt to
 proceed

 when "awaited" events fail or timeout. This includes things
 like

 goto, waitForSelector, and more.
 type: boolean
 cookies:
 type: array
 items:
 $ref: '#/definitions/CookieParam'
 emulateMediaType:
 type: string
 gotoOptions:
 $ref: '#/definitions/GoToOptions'
 html:
 type: string
 options:
 $ref: '#/definitions/PDFOptions'
 rejectRequestPattern:
 type: array
 items:
 type: string
 rejectResourceTypes:
 type: array
 items:
 enum:
 \- cspviolationreport
 \- document
 \- eventsource
 \- fetch
 \- font
 \- image
 \- manifest
 \- media
 \- other
 \- ping
 \- prefetch
 \- preflight
 \- script
 \- signedexchange
 \- stylesheet
 \- texttrack
 \- websocket
 \- xhr
 type: string
 requestInterceptors:
 type: array
 items:
 description: >-
 An array of patterns (using \`req.url().match(r.pattern)\`
 to match) and their

 corresponding responses to use in order to fulfill those
 requests.
 type: object
 properties:
 pattern:
 description: >-
 An array of patterns (using
 \`req.url().match(r.pattern)\` to match) and their

 corresponding responses to use in order to fulfill
 those requests.
 type: string
 response:
 $ref: '#/definitions/Partial'
 additionalProperties: false
 required:
 \- pattern
 \- response
 setExtraHTTPHeaders:
 $ref: '#/definitions/Record'
 setJavaScriptEnabled:
 type: boolean
 url:
 type: string
 userAgent:
 type: string
 viewport:
 anyOf:
 \- $ref: '#/definitions/Viewport'
 \- type: 'null'
 waitForEvent:
 type: object
 properties:
 event:
 type: string
 timeout:
 type: number
 additionalProperties: false
 required:
 \- event
 waitForFunction:
 type: object
 properties:
 fn:
 description: >-
 The function, or statement, to be evaluated in browser
 context
 type: string
 polling:
 description: >-
 An interval at which the pageFunction is executed,
 defaults to raf.

 If polling is a number, then it is treated as an
 interval in milliseconds

 at which the function would be executed. If polling is a
 string,

 then it can be one of the following values: "raf" or
 "mutation"
 type:
 \- string
 \- number
 timeout:
 description: >-
 Maximum time to wait for in milliseconds. Defaults to
 30000 (30 seconds).

 Pass 0 to disable timeout.
 type: number
 additionalProperties: false
 required:
 \- fn
 waitForSelector:
 type: object
 properties:
 hidden:
 type: boolean
 selector:
 type: string
 timeout:
 type: number
 visible:
 type: boolean
 additionalProperties: false
 required:
 \- selector
 waitForTimeout:
 type: number
 type: object
 responses:
 '200':
 content:
 application/pdf:
 schema:
 description: Responds with an application/pdf content-type and a binary PDF
 type: string
 $schema: http://json-schema.org/draft-07/schema#
 description: Responds with an application/pdf content-type and a binary PDF
 '400':
 code: 400
 description: The request contains errors or didn't properly encode content.
 message: HTTP/1.1 400 Bad Request
 '401':
 code: 401
 description: The request is missing, or contains bad, authorization credentials.
 message: HTTP/1.1 401 Unauthorized
 '404':
 code: 404
 description: Resource couldn't be found.
 message: HTTP/1.1 404 Not Found
 '408':
 code: 408
 description: The request took has taken too long to process.
 message: HTTP/1.1 408 Request Timeout
 '429':
 code: 429
 description: Too many requests are currently being processed.
 message: HTTP/1.1 429 Too Many Requests
 '500':
 code: 500
 description: An internal error occurred when handling the request.
 message: HTTP/1.1 500 Internal Server Error
 summary: /chrome/pdf
 tags:
 \- Browser REST APIs
 /chrome/performance:
 post:
 definitions: {}
 description: >-
 Run lighthouse performance audits with a supplied "url" in your JSON
 payload.
 parameters:
 \- in: query
 name: blockAds
 schema:
 description: \|-
 Whether or nor to load ad-blocking extensions for the session.
 This currently uses uBlock-Lite and may cause certain sites
 to not load properly.
 type: boolean
 \- in: query
 name: launch
 schema:
 description: \|-
 Launch options, which can be either an object
 of puppeteer.launch options or playwright.launchServer
 options, depending on the API. Must be either JSON
 object, or a base64-encoded JSON object.
 anyOf:
 \- $ref: '#/definitions/CDPLaunchOptions'
 \- type: string
 \- in: query
 name: timeout
 schema:
 description: \|-
 Override the system-level timeout for this request.
 Accepts a value in milliseconds.
 type: number
 \- in: query
 name: token
 schema:
 description: The authorization token
 type: string
 \- in: query
 name: trackingId
 schema:
 description: Custom session identifier
 type: string
 requestBody:
 content:
 application/json:
 schema:
 properties:
 budgets:
 type: array
 items:
 type: object
 properties: {}
 additionalProperties: true
 config:
 type: object
 properties: {}
 additionalProperties: true
 url:
 type: string
 type: object
 responses:
 '200':
 content:
 application/json:
 schema:
 description: \|-
 The response of the lighthouse stats. Response objects are
 determined by the type of budgets and config in the POST
 JSON body
 type: object
 properties: {}
 additionalProperties: true
 $schema: http://json-schema.org/draft-07/schema#
 description: \|-
 The response of the lighthouse stats. Response objects are
 determined by the type of budgets and config in the POST
 JSON body
 '400':
 code: 400
 description: The request contains errors or didn't properly encode content.
 message: HTTP/1.1 400 Bad Request
 '401':
 code: 401
 description: The request is missing, or contains bad, authorization credentials.
 message: HTTP/1.1 401 Unauthorized
 '404':
 code: 404
 description: Resource couldn't be found.
 message: HTTP/1.1 404 Not Found
 '408':
 code: 408
 description: The request took has taken too long to process.
 message: HTTP/1.1 408 Request Timeout
 '429':
 code: 429
 description: Too many requests are currently being processed.
 message: HTTP/1.1 429 Too Many Requests
 '500':
 code: 500
 description: An internal error occurred when handling the request.
 message: HTTP/1.1 500 Internal Server Error
 summary: /chrome/performance
 tags:
 \- Browser REST APIs
 /chrome/scrape:
 post:
 definitions: {}
 description: >-
 A JSON-based API that returns text, html, and meta-data from a given
 list of selectors.

 Debugging information is available by sending in the appropriate flags
 in the "debugOpts"

 property. Responds with an array of JSON objects.
 parameters:
 \- in: query
 name: blockAds
 schema:
 description: \|-
 Whether or nor to load ad-blocking extensions for the session.
 This currently uses uBlock-Lite and may cause certain sites
 to not load properly.
 type: boolean
 \- in: query
 name: launch
 schema:
 anyOf:
 \- $ref: '#/definitions/CDPLaunchOptions'
 \- type: string
 \- in: query
 name: timeout
 schema:
 description: \|-
 Override the system-level timeout for this request.
 Accepts a value in milliseconds.
 type: number
 \- in: query
 name: token
 schema:
 description: The authorization token
 type: string
 \- in: query
 name: trackingId
 schema:
 description: Custom session identifier
 type: string
 requestBody:
 content:
 application/json:
 schema:
 properties:
 addScriptTag:
 type: array
 items:
 $ref: '#/definitions/FrameAddScriptTagOptions'
 addStyleTag:
 type: array
 items:
 $ref: '#/definitions/FrameAddStyleTagOptions'
 authenticate:
 anyOf:
 \- $ref: '#/definitions/Credentials'
 \- type: 'null'
 bestAttempt:
 description: >-
 When bestAttempt is set to true, browserless attempt to
 proceed

 when "awaited" events fail or timeout. This includes things
 like

 goto, waitForSelector, and more.
 type: boolean
 cookies:
 type: array
 items:
 $ref: '#/definitions/CookieParam'
 debugOpts:
 $ref: '#/definitions/ScrapeDebugOptions'
 elements:
 type: array
 items:
 $ref: '#/definitions/ScrapeElementSelector'
 emulateMediaType:
 type: string
 gotoOptions:
 $ref: '#/definitions/GoToOptions'
 html:
 type: string
 rejectRequestPattern:
 type: array
 items:
 type: string
 rejectResourceTypes:
 type: array
 items:
 enum:
 \- cspviolationreport
 \- document
 \- eventsource
 \- fetch
 \- font
 \- image
 \- manifest
 \- media
 \- other
 \- ping
 \- prefetch
 \- preflight
 \- script
 \- signedexchange
 \- stylesheet
 \- texttrack
 \- websocket
 \- xhr
 type: string
 requestInterceptors:
 type: array
 items:
 description: >-
 An array of patterns (using \`req.url().match(r.pattern)\`
 to match) and their

 corresponding responses to use in order to fulfill those
 requests.
 type: object
 properties:
 pattern:
 description: >-
 An array of patterns (using
 \`req.url().match(r.pattern)\` to match) and their

 corresponding responses to use in order to fulfill
 those requests.
 type: string
 response:
 $ref: '#/definitions/Partial'
 additionalProperties: false
 required:
 \- pattern
 \- response
 setExtraHTTPHeaders:
 $ref: '#/definitions/Record'
 setJavaScriptEnabled:
 type: boolean
 url:
 type: string
 userAgent:
 type: string
 viewport:
 anyOf:
 \- $ref: '#/definitions/Viewport'
 \- type: 'null'
 waitForEvent:
 type: object
 properties:
 event:
 type: string
 timeout:
 type: number
 additionalProperties: false
 required:
 \- event
 waitForFunction:
 type: object
 properties:
 fn:
 description: >-
 The function, or statement, to be evaluated in browser
 context
 type: string
 polling:
 description: >-
 An interval at which the pageFunction is executed,
 defaults to raf.

 If polling is a number, then it is treated as an
 interval in milliseconds

 at which the function would be executed. If polling is a
 string,

 then it can be one of the following values: "raf" or
 "mutation"
 type:
 \- string
 \- number
 timeout:
 description: >-
 Maximum time to wait for in milliseconds. Defaults to
 30000 (30 seconds).

 Pass 0 to disable timeout.
 type: number
 additionalProperties: false
 required:
 \- fn
 waitForSelector:
 type: object
 properties:
 hidden:
 type: boolean
 selector:
 type: string
 timeout:
 type: number
 visible:
 type: boolean
 additionalProperties: false
 required:
 \- selector
 waitForTimeout:
 type: number
 type: object
 responses:
 '200':
 content:
 application/json:
 schema:
 description: The JSON response body
 type: object
 properties:
 data:
 anyOf:
 \- type: array
 items:
 type: object
 properties:
 results:
 type: array
 items:
 type: object
 properties:
 attributes:
 description: A list of HTML attributes of the element
 type: array
 items:
 type: object
 properties:
 name:
 description: >-
 The name of the HTML attribute for the
 element
 type: string
 value:
 description: >-
 The value of the HTML attribute for the
 element
 type: string
 additionalProperties: false
 required:
 \- name
 \- value
 height:
 description: The height the element
 type: number
 html:
 description: The HTML the element
 type: string
 left:
 description: >-
 The amount of pixels from the left of the
 page
 type: number
 text:
 description: The text the element
 type: string
 top:
 description: >-
 The amount of pixels from the top of the
 page
 type: number
 width:
 description: The width the element
 type: number
 additionalProperties: false
 required:
 \- attributes
 \- height
 \- html
 \- left
 \- text
 \- top
 \- width
 selector:
 description: The DOM selector of the element
 type: string
 additionalProperties: false
 required:
 \- results
 \- selector
 \- type: 'null'
 debug:
 description: When debugOpts options are present, results are here
 anyOf:
 \- type: object
 properties:
 console:
 description: A list of console messages from the browser
 type: array
 items:
 type: string
 cookies:
 description: List of cookies for the site or null
 anyOf:
 \- type: array
 items:
 $ref: '#/definitions/Cookie'
 \- type: 'null'
 html:
 description: The HTML string of the website or null
 type:
 \- 'null'
 \- string
 network:
 type: object
 properties:
 inbound:
 type: array
 items:
 $ref: '#/definitions/InBoundRequest'
 outbound:
 type: array
 items:
 $ref: '#/definitions/OutBoundRequest'
 additionalProperties: false
 required:
 \- inbound
 \- outbound
 screenshot:
 description: A base64-encoded string of the site or null
 type:
 \- 'null'
 \- string
 additionalProperties: false
 required:
 \- console
 \- cookies
 \- html
 \- network
 \- screenshot
 \- type: 'null'
 additionalProperties: false
 required:
 \- data
 \- debug
 definitions:
 Cookie:
 description: Represents a cookie object.
 type: object
 properties:
 name:
 description: Cookie name.
 type: string
 value:
 description: Cookie value.
 type: string
 domain:
 description: Cookie domain.
 type: string
 path:
 description: Cookie path.
 type: string
 expires:
 description: >-
 Cookie expiration date as the number of seconds since
 the UNIX epoch. Set to \`-1\` for

 session cookies
 type: number
 size:
 description: Cookie size.
 type: number
 httpOnly:
 description: True if cookie is http-only.
 type: boolean
 secure:
 description: True if cookie is secure.
 type: boolean
 session:
 description: True in case of session cookie.
 type: boolean
 sameSite:
 description: Cookie SameSite type.
 enum:
 \- Lax
 \- None
 \- Strict
 type: string
 priority:
 description: Cookie Priority. Supported only in Chrome.
 enum:
 \- High
 \- Low
 \- Medium
 type: string
 sameParty:
 description: True if cookie is SameParty. Supported only in Chrome.
 type: boolean
 sourceScheme:
 description: Cookie source scheme type. Supported only in Chrome.
 enum:
 \- NonSecure
 \- Secure
 \- Unset
 type: string
 partitionKey:
 description: >-
 Cookie partition key. In Chrome, it is the top-level
 site the

 partitioned cookie is available in. In Firefox, it
 matches the

 source origin in the

 {@link
 https://w3c.github.io/webdriver-bidi/#type-storage-PartitionKey
 PartitionKey}.
 anyOf:
 \- $ref: '#/definitions/CookiePartitionKey'
 \- type: string
 partitionKeyOpaque:
 description: >-
 True if cookie partition key is opaque. Supported only
 in Chrome.
 type: boolean
 additionalProperties: false
 required:
 \- domain
 \- expires
 \- httpOnly
 \- name
 \- path
 \- secure
 \- session
 \- size
 \- value
 CookiePartitionKey:
 description: Represents a cookie partition key in Chrome.
 type: object
 properties:
 sourceOrigin:
 description: >-
 The site of the top-level URL the browser was visiting
 at the start of the request

 to the endpoint that set the cookie.

 In Chrome, maps to the CDP's \`topLevelSite\` partition
 key.
 type: string
 hasCrossSiteAncestor:
 description: >-
 Indicates if the cookie has any ancestors that are
 cross-site to

 the topLevelSite.

 Supported only in Chrome.
 type: boolean
 additionalProperties: false
 required:
 \- sourceOrigin
 InBoundRequest:
 type: object
 properties:
 headers: {}
 status:
 type: number
 url:
 type: string
 additionalProperties: false
 required:
 \- headers
 \- status
 \- url
 OutBoundRequest:
 type: object
 properties:
 headers: {}
 method:
 type: string
 url:
 type: string
 additionalProperties: false
 required:
 \- headers
 \- method
 \- url
 $schema: http://json-schema.org/draft-07/schema#
 description: The JSON response body
 '400':
 code: 400
 description: The request contains errors or didn't properly encode content.
 message: HTTP/1.1 400 Bad Request
 '401':
 code: 401
 description: The request is missing, or contains bad, authorization credentials.
 message: HTTP/1.1 401 Unauthorized
 '404':
 code: 404
 description: Resource couldn't be found.
 message: HTTP/1.1 404 Not Found
 '408':
 code: 408
 description: The request took has taken too long to process.
 message: HTTP/1.1 408 Request Timeout
 '429':
 code: 429
 description: Too many requests are currently being processed.
 message: HTTP/1.1 429 Too Many Requests
 '500':
 code: 500
 description: An internal error occurred when handling the request.
 message: HTTP/1.1 500 Internal Server Error
 summary: /chrome/scrape
 tags:
 \- Browser REST APIs
 /chrome/screenshot:
 post:
 definitions: {}
 description: \|-
 A JSON-based API for getting a screenshot binary from either a supplied
 "url" or "html" payload in your request. Many options exist including
 cookies, user-agents, setting timers and network mocks.
 parameters:
 \- in: query
 name: blockAds
 schema:
 description: \|-
 Whether or nor to load ad-blocking extensions for the session.
 This currently uses uBlock-Lite and may cause certain sites
 to not load properly.
 type: boolean
 \- in: query
 name: launch
 schema:
 description: \|-
 Launch options, which can be either an object
 of puppeteer.launch options or playwright.launchServer
 options, depending on the API. Must be either JSON
 object, or a base64-encoded JSON object.
 anyOf:
 \- $ref: '#/definitions/CDPLaunchOptions'
 \- type: string
 \- in: query
 name: timeout
 schema:
 description: \|-
 Override the system-level timeout for this request.
 Accepts a value in milliseconds.
 type: number
 \- in: query
 name: token
 schema:
 description: The authorization token
 type: string
 \- in: query
 name: trackingId
 schema:
 description: Custom session identifier
 type: string
 requestBody:
 content:
 application/json:
 schema:
 properties:
 addScriptTag:
 type: array
 items:
 $ref: '#/definitions/FrameAddScriptTagOptions'
 addStyleTag:
 type: array
 items:
 $ref: '#/definitions/FrameAddStyleTagOptions'
 authenticate:
 anyOf:
 \- $ref: '#/definitions/Credentials'
 \- type: 'null'
 bestAttempt:
 description: >-
 When bestAttempt is set to true, browserless attempt to
 proceed

 when "awaited" events fail or timeout. This includes things
 like

 goto, waitForSelector, and more.
 type: boolean
 cookies:
 type: array
 items:
 $ref: '#/definitions/CookieParam'
 emulateMediaType:
 type: string
 gotoOptions:
 $ref: '#/definitions/GoToOptions'
 html:
 type: string
 options:
 $ref: '#/definitions/ScreenshotOptions'
 rejectRequestPattern:
 type: array
 items:
 type: string
 rejectResourceTypes:
 type: array
 items:
 enum:
 \- cspviolationreport
 \- document
 \- eventsource
 \- fetch
 \- font
 \- image
 \- manifest
 \- media
 \- other
 \- ping
 \- prefetch
 \- preflight
 \- script
 \- signedexchange
 \- stylesheet
 \- texttrack
 \- websocket
 \- xhr
 type: string
 requestInterceptors:
 type: array
 items:
 description: >-
 An array of patterns (using \`req.url().match(r.pattern)\`
 to match) and their

 corresponding responses to use in order to fulfill those
 requests.
 type: object
 properties:
 pattern:
 description: >-
 An array of patterns (using
 \`req.url().match(r.pattern)\` to match) and their

 corresponding responses to use in order to fulfill
 those requests.
 type: string
 response:
 $ref: '#/definitions/Partial'
 additionalProperties: false
 required:
 \- pattern
 \- response
 scrollPage:
 type: boolean
 selector:
 type: string
 setExtraHTTPHeaders:
 $ref: '#/definitions/Record'
 setJavaScriptEnabled:
 type: boolean
 url:
 type: string
 userAgent:
 type: string
 viewport:
 anyOf:
 \- $ref: '#/definitions/Viewport'
 \- type: 'null'
 waitForEvent:
 type: object
 properties:
 event:
 type: string
 timeout:
 type: number
 additionalProperties: false
 required:
 \- event
 waitForFunction:
 type: object
 properties:
 fn:
 description: >-
 The function, or statement, to be evaluated in browser
 context
 type: string
 polling:
 description: >-
 An interval at which the pageFunction is executed,
 defaults to raf.

 If polling is a number, then it is treated as an
 interval in milliseconds

 at which the function would be executed. If polling is a
 string,

 then it can be one of the following values: "raf" or
 "mutation"
 type:
 \- string
 \- number
 timeout:
 description: >-
 Maximum time to wait for in milliseconds. Defaults to
 30000 (30 seconds).

 Pass 0 to disable timeout.
 type: number
 additionalProperties: false
 required:
 \- fn
 waitForSelector:
 type: object
 properties:
 hidden:
 type: boolean
 selector:
 type: string
 timeout:
 type: number
 visible:
 type: boolean
 additionalProperties: false
 required:
 \- selector
 waitForTimeout:
 type: number
 type: object
 responses:
 '200':
 content:
 image/png:
 schema:
 type: text
 image/jpeg:
 schema:
 type: text
 text/plain:
 schema:
 type: text
 description: \|-
 Response can either be a text/plain base64 encoded body
 or a binary stream with png/jpeg as a content-type
 '400':
 code: 400
 description: The request contains errors or didn't properly encode content.
 message: HTTP/1.1 400 Bad Request
 '401':
 code: 401
 description: The request is missing, or contains bad, authorization credentials.
 message: HTTP/1.1 401 Unauthorized
 '404':
 code: 404
 description: Resource couldn't be found.
 message: HTTP/1.1 404 Not Found
 '408':
 code: 408
 description: The request took has taken too long to process.
 message: HTTP/1.1 408 Request Timeout
 '429':
 code: 429
 description: Too many requests are currently being processed.
 message: HTTP/1.1 429 Too Many Requests
 '500':
 code: 500
 description: An internal error occurred when handling the request.
 message: HTTP/1.1 500 Internal Server Error
 summary: /chrome/screenshot
 tags:
 \- Browser REST APIs
 /chromium/content:
 post:
 definitions: {}
 description: >-
 A JSON-based API. Given a "url" or "html" field, runs and returns HTML
 content after the page has loaded and JavaScript has parsed.

 \*\*Note:\*\* This endpoint is also available at: \`/content\` for backwards
 compatibility.
 parameters:
 \- in: query
 name: blockAds
 schema:
 description: \|-
 Whether or nor to load ad-blocking extensions for the session.
 This currently uses uBlock-Lite and may cause certain sites
 to not load properly.
 type: boolean
 \- in: query
 name: launch
 schema:
 anyOf:
 \- $ref: '#/definitions/CDPLaunchOptions'
 \- type: string
 \- in: query
 name: timeout
 schema:
 description: \|-
 Override the system-level timeout for this request.
 Accepts a value in milliseconds.
 type: number
 \- in: query
 name: token
 schema:
 description: The authorization token
 type: string
 \- in: query
 name: trackingId
 schema:
 description: Custom session identifier
 type: string
 requestBody:
 content:
 application/json:
 schema:
 properties:
 addScriptTag:
 type: array
 items:
 $ref: '#/definitions/FrameAddScriptTagOptions'
 addStyleTag:
 type: array
 items:
 $ref: '#/definitions/FrameAddStyleTagOptions'
 authenticate:
 anyOf:
 \- $ref: '#/definitions/Credentials'
 \- type: 'null'
 bestAttempt:
 description: >-
 When bestAttempt is set to true, browserless attempt to
 proceed

 when "awaited" events fail or timeout. This includes things
 like

 goto, waitForSelector, and more.
 type: boolean
 cookies:
 type: array
 items:
 $ref: '#/definitions/CookieParam'
 emulateMediaType:
 type: string
 gotoOptions:
 $ref: '#/definitions/GoToOptions'
 html:
 type: string
 rejectRequestPattern:
 type: array
 items:
 type: string
 rejectResourceTypes:
 type: array
 items:
 enum:
 \- cspviolationreport
 \- document
 \- eventsource
 \- fetch
 \- font
 \- image
 \- manifest
 \- media
 \- other
 \- ping
 \- prefetch
 \- preflight
 \- script
 \- signedexchange
 \- stylesheet
 \- texttrack
 \- websocket
 \- xhr
 type: string
 requestInterceptors:
 type: array
 items:
 description: >-
 An array of patterns (using \`req.url().match(r.pattern)\`
 to match) and their

 corresponding responses to use in order to fulfill those
 requests.
 type: object
 properties:
 pattern:
 description: >-
 An array of patterns (using
 \`req.url().match(r.pattern)\` to match) and their

 corresponding responses to use in order to fulfill
 those requests.
 type: string
 response:
 $ref: '#/definitions/Partial'
 additionalProperties: false
 required:
 \- pattern
 \- response
 setExtraHTTPHeaders:
 $ref: '#/definitions/Record'
 setJavaScriptEnabled:
 description: Whether or not to allow JavaScript to run on the page.
 type: boolean
 url:
 type: string
 userAgent:
 type: string
 viewport:
 anyOf:
 \- $ref: '#/definitions/Viewport'
 \- type: 'null'
 waitForEvent:
 type: object
 properties:
 event:
 type: string
 timeout:
 type: number
 additionalProperties: false
 required:
 \- event
 waitForFunction:
 type: object
 properties:
 fn:
 description: >-
 The function, or statement, to be evaluated in browser
 context
 type: string
 polling:
 description: >-
 An interval at which the pageFunction is executed,
 defaults to raf.

 If polling is a number, then it is treated as an
 interval in milliseconds

 at which the function would be executed. If polling is a
 string,

 then it can be one of the following values: "raf" or
 "mutation"
 type:
 \- string
 \- number
 timeout:
 description: >-
 Maximum time to wait for in milliseconds. Defaults to
 30000 (30 seconds).

 Pass 0 to disable timeout.
 type: number
 additionalProperties: false
 required:
 \- fn
 waitForSelector:
 type: object
 properties:
 hidden:
 type: boolean
 selector:
 type: string
 timeout:
 type: number
 visible:
 type: boolean
 additionalProperties: false
 required:
 \- selector
 waitForTimeout:
 type: number
 type: object
 responses:
 '200':
 content:
 text/html:
 schema:
 description: \|-
 An HTML payload of the website or HTML after JavaScript
 parsing and execution.
 type: string
 $schema: http://json-schema.org/draft-07/schema#
 description: \|-
 An HTML payload of the website or HTML after JavaScript
 parsing and execution.
 '400':
 code: 400
 description: The request contains errors or didn't properly encode content.
 message: HTTP/1.1 400 Bad Request
 '401':
 code: 401
 description: The request is missing, or contains bad, authorization credentials.
 message: HTTP/1.1 401 Unauthorized
 '404':
 code: 404
 description: Resource couldn't be found.
 message: HTTP/1.1 404 Not Found
 '408':
 code: 408
 description: The request took has taken too long to process.
 message: HTTP/1.1 408 Request Timeout
 '429':
 code: 429
 description: Too many requests are currently being processed.
 message: HTTP/1.1 429 Too Many Requests
 '500':
 code: 500
 description: An internal error occurred when handling the request.
 message: HTTP/1.1 500 Internal Server Error
 summary: /chromium/content
 tags:
 \- Browser REST APIs
 /chromium/download:
 post:
 definitions: {}
 description: >-
 A JSON or JavaScript content-type API for returning files Chrome has
 downloaded during

 the execution of puppeteer code, which is ran inside context of the
 browser.

 Browserless sets up a blank page, a fresh download directory, injects
 your puppeteer code, and then executes it.

 You can load external libraries via the "import" syntax, and import
 ESM-style modules

 that are written for execution inside of the browser. Once your script
 is finished, any

 downloaded files from Chromium are returned back with the appropriate
 content-type header.

 \*\*Note:\*\* This endpoint is also available at: \`/download\` for backwards
 compatibility.
 parameters:
 \- in: query
 name: blockAds
 schema:
 description: \|-
 Whether or nor to load ad-blocking extensions for the session.
 This currently uses uBlock-Lite and may cause certain sites
 to not load properly.
 type: boolean
 \- in: query
 name: launch
 schema:
 description: \|-
 Launch options, which can be either an object
 of puppeteer.launch options or playwright.launchServer
 options, depending on the API. Must be either JSON
 object, or a base64-encoded JSON object.
 anyOf:
 \- $ref: '#/definitions/CDPLaunchOptions'
 \- type: string
 \- in: query
 name: timeout
 schema:
 description: \|-
 Override the system-level timeout for this request.
 Accepts a value in milliseconds.
 type: number
 \- in: query
 name: token
 schema:
 description: The authorization token
 type: string
 \- in: query
 name: trackingId
 schema:
 description: Custom session identifier
 type: string
 requestBody:
 content:
 application/json:
 schema:
 $ref: '#/definitions/JSONSchema'
 application/javascript:
 schema:
 type: string
 responses:
 '200':
 content:
 '\*/\*':
 schema:
 description: >-
 Responses are determined by the returned value of the
 downloads

 themselves, so there isn't a static response type for this
 API.
 $schema: http://json-schema.org/draft-07/schema#
 description: \|-
 Responses are determined by the returned value of the downloads
 themselves, so there isn't a static response type for this API.
 '400':
 code: 400
 description: The request contains errors or didn't properly encode content.
 message: HTTP/1.1 400 Bad Request
 '401':
 code: 401
 description: The request is missing, or contains bad, authorization credentials.
 message: HTTP/1.1 401 Unauthorized
 '404':
 code: 404
 description: Resource couldn't be found.
 message: HTTP/1.1 404 Not Found
 '408':
 code: 408
 description: The request took has taken too long to process.
 message: HTTP/1.1 408 Request Timeout
 '429':
 code: 429
 description: Too many requests are currently being processed.
 message: HTTP/1.1 429 Too Many Requests
 '500':
 code: 500
 description: An internal error occurred when handling the request.
 message: HTTP/1.1 500 Internal Server Error
 summary: /chromium/download
 tags:
 \- Browser REST APIs
 /chromium/function:
 post:
 definitions: {}
 description: >-
 A JSON or JavaScript content-type API for running puppeteer code in the
 browser's context.

 Browserless sets up a blank page, injects your puppeteer code, and runs
 it.

 You can optionally load external libraries via the "import" module that
 are meant for browser usage.

 Values returned from the function are checked and an appropriate
 content-type and response is sent back

 to your HTTP call.

 \*\*Note:\*\* This endpoint is also available at: \`/function\` for backwards
 compatibility.
 parameters:
 \- in: query
 name: blockAds
 schema:
 description: \|-
 Whether or nor to load ad-blocking extensions for the session.
 This currently uses uBlock-Lite and may cause certain sites
 to not load properly.
 type: boolean
 \- in: query
 name: launch
 schema:
 description: \|-
 Launch options, which can be either an object
 of puppeteer.launch options or playwright.launchServer
 options, depending on the API. Must be either JSON
 object, or a base64-encoded JSON object.
 anyOf:
 \- $ref: '#/definitions/CDPLaunchOptions'
 \- type: string
 \- in: query
 name: timeout
 schema:
 description: \|-
 Override the system-level timeout for this request.
 Accepts a value in milliseconds.
 type: number
 \- in: query
 name: token
 schema:
 description: The authorization token
 type: string
 \- in: query
 name: trackingId
 schema:
 description: Custom session identifier
 type: string
 requestBody:
 content:
 application/json:
 schema:
 $ref: '#/definitions/JSONSchema'
 application/javascript:
 schema:
 type: string
 responses:
 '200':
 content:
 '\*/\*':
 schema:
 description: >-
 Responses are determined by the returned value of the function

 itself. Binary responses (PDF's, screenshots) are returned
 back

 as binary data, and primitive JavaScript values are returned
 back

 by type (HTML data is "text/html", Objects are
 "application/json")
 $schema: http://json-schema.org/draft-07/schema#
 description: \|-
 Responses are determined by the returned value of the function
 itself. Binary responses (PDF's, screenshots) are returned back
 as binary data, and primitive JavaScript values are returned back
 by type (HTML data is "text/html", Objects are "application/json")
 '400':
 code: 400
 description: The request contains errors or didn't properly encode content.
 message: HTTP/1.1 400 Bad Request
 '401':
 code: 401
 description: The request is missing, or contains bad, authorization credentials.
 message: HTTP/1.1 401 Unauthorized
 '404':
 code: 404
 description: Resource couldn't be found.
 message: HTTP/1.1 404 Not Found
 '408':
 code: 408
 description: The request took has taken too long to process.
 message: HTTP/1.1 408 Request Timeout
 '429':
 code: 429
 description: Too many requests are currently being processed.
 message: HTTP/1.1 429 Too Many Requests
 '500':
 code: 500
 description: An internal error occurred when handling the request.
 message: HTTP/1.1 500 Internal Server Error
 summary: /chromium/function
 tags:
 \- Browser REST APIs
 /chromium/pdf:
 post:
 definitions: {}
 description: >-
 A JSON-based API for getting a PDF binary from either a supplied

 "url" or "html" payload in your request. Many options exist for

 injecting cookies, request interceptors, user-agents and waiting for

 selectors, timers and more.

 \*\*Note:\*\* This endpoint is also available at: \`/pdf\` for backwards
 compatibility.
 parameters:
 \- in: query
 name: blockAds
 schema:
 description: \|-
 Whether or nor to load ad-blocking extensions for the session.
 This currently uses uBlock-Lite and may cause certain sites
 to not load properly.
 type: boolean
 \- in: query
 name: launch
 schema:
 description: \|-
 Launch options, which can be either an object
 of puppeteer.launch options or playwright.launchServer
 options, depending on the API. Must be either JSON
 object, or a base64-encoded JSON object.
 anyOf:
 \- $ref: >-
 #/definitions/import("/home/runner/work/enterprise/enterprise/node\_modules/@browserless.io/browserless/build/types",{with:{"resolution-mode":"import"}}).CDPLaunchOptions
 \- type: string
 \- in: query
 name: timeout
 schema:
 description: \|-
 Override the system-level timeout for this request.
 Accepts a value in milliseconds.
 type: number
 \- in: query
 name: token
 schema:
 description: The authorization token
 type: string
 \- in: query
 name: trackingId
 schema:
 description: Custom session identifier
 type: string
 requestBody:
 content:
 application/json:
 schema:
 properties:
 addScriptTag:
 type: array
 items:
 $ref: '#/definitions/FrameAddScriptTagOptions'
 addStyleTag:
 type: array
 items:
 $ref: '#/definitions/FrameAddStyleTagOptions'
 authenticate:
 $ref: '#/definitions/Credentials'
 bestAttempt:
 description: >-
 When bestAttempt is set to true, browserless attempt to
 proceed

 when "awaited" events fail or timeout. This includes things
 like

 goto, waitForSelector, and more.
 type: boolean
 blockConsentModals:
 type: boolean
 cookies:
 type: array
 items:
 $ref: '#/definitions/CookieParam'
 emulateMediaType:
 type: string
 gotoOptions:
 $ref: '#/definitions/GoToOptions'
 html:
 type: string
 options:
 $ref: '#/definitions/PDFOptions'
 rejectRequestPattern:
 type: array
 items:
 type: string
 rejectResourceTypes:
 type: array
 items:
 enum:
 \- cspviolationreport
 \- document
 \- eventsource
 \- fetch
 \- font
 \- image
 \- manifest
 \- media
 \- other
 \- ping
 \- prefetch
 \- preflight
 \- script
 \- signedexchange
 \- stylesheet
 \- texttrack
 \- websocket
 \- xhr
 type: string
 requestInterceptors:
 type: array
 items:
 description: >-
 An array of patterns (using \`req.url().match(r.pattern)\`
 to match) and their

 corresponding responses to use in order to fulfill those
 requests.
 type: object
 properties:
 pattern:
 description: >-
 An array of patterns (using
 \`req.url().match(r.pattern)\` to match) and their

 corresponding responses to use in order to fulfill
 those requests.
 type: string
 response:
 $ref: '#/definitions/Partial'
 additionalProperties: false
 required:
 \- pattern
 \- response
 setExtraHTTPHeaders:
 $ref: '#/definitions/Record'
 setJavaScriptEnabled:
 type: boolean
 url:
 type: string
 userAgent:
 type: string
 viewport:
 $ref: '#/definitions/Viewport'
 waitForEvent:
 type: object
 properties:
 event:
 type: string
 timeout:
 type: number
 additionalProperties: false
 required:
 \- event
 waitForFunction:
 type: object
 properties:
 fn:
 description: >-
 The function, or statement, to be evaluated in browser
 context
 type: string
 polling:
 description: >-
 An interval at which the pageFunction is executed,
 defaults to raf.

 If polling is a number, then it is treated as an
 interval in milliseconds

 at which the function would be executed. If polling is a
 string,

 then it can be one of the following values: "raf" or
 "mutation"
 type:
 \- string
 \- number
 timeout:
 description: >-
 Maximum time to wait for in milliseconds. Defaults to
 30000 (30 seconds).

 Pass 0 to disable timeout.
 type: number
 additionalProperties: false
 required:
 \- fn
 waitForSelector:
 type: object
 properties:
 hidden:
 type: boolean
 selector:
 type: string
 timeout:
 type: number
 visible:
 type: boolean
 additionalProperties: false
 required:
 \- selector
 waitForTimeout:
 type: number
 type: object
 responses:
 '400':
 code: 400
 description: The request contains errors or didn't properly encode content.
 message: HTTP/1.1 400 Bad Request
 '401':
 code: 401
 description: The request is missing, or contains bad, authorization credentials.
 message: HTTP/1.1 401 Unauthorized
 '404':
 code: 404
 description: Resource couldn't be found.
 message: HTTP/1.1 404 Not Found
 '408':
 code: 408
 description: The request took has taken too long to process.
 message: HTTP/1.1 408 Request Timeout
 '429':
 code: 429
 description: Too many requests are currently being processed.
 message: HTTP/1.1 429 Too Many Requests
 '500':
 code: 500
 description: An internal error occurred when handling the request.
 message: HTTP/1.1 500 Internal Server Error
 summary: /chromium/pdf
 tags:
 \- Browser REST APIs
 /chromium/performance:
 post:
 definitions: {}
 description: >-
 Run lighthouse performance audits with a supplied "url" in your JSON
 payload.

 \*\*Note:\*\* This endpoint is also available at: \`/performance\` for
 backwards compatibility.
 parameters:
 \- in: query
 name: blockAds
 schema:
 description: \|-
 Whether or nor to load ad-blocking extensions for the session.
 This currently uses uBlock-Lite and may cause certain sites
 to not load properly.
 type: boolean
 \- in: query
 name: launch
 schema:
 description: \|-
 Launch options, which can be either an object
 of puppeteer.launch options or playwright.launchServer
 options, depending on the API. Must be either JSON
 object, or a base64-encoded JSON object.
 anyOf:
 \- $ref: '#/definitions/CDPLaunchOptions'
 \- type: string
 \- in: query
 name: timeout
 schema:
 description: \|-
 Override the system-level timeout for this request.
 Accepts a value in milliseconds.
 type: number
 \- in: query
 name: token
 schema:
 description: The authorization token
 type: string
 \- in: query
 name: trackingId
 schema:
 description: Custom session identifier
 type: string
 requestBody:
 content:
 application/json:
 schema:
 properties:
 budgets:
 type: array
 items:
 type: object
 properties: {}
 additionalProperties: true
 config:
 type: object
 properties: {}
 additionalProperties: true
 url:
 type: string
 type: object
 responses:
 '200':
 content:
 application/json:
 schema:
 description: \|-
 The response of the lighthouse stats. Response objects are
 determined by the type of budgets and config in the POST
 JSON body
 type: object
 properties: {}
 additionalProperties: true
 $schema: http://json-schema.org/draft-07/schema#
 description: \|-
 The response of the lighthouse stats. Response objects are
 determined by the type of budgets and config in the POST
 JSON body
 '400':
 code: 400
 description: The request contains errors or didn't properly encode content.
 message: HTTP/1.1 400 Bad Request
 '401':
 code: 401
 description: The request is missing, or contains bad, authorization credentials.
 message: HTTP/1.1 401 Unauthorized
 '404':
 code: 404
 description: Resource couldn't be found.
 message: HTTP/1.1 404 Not Found
 '408':
 code: 408
 description: The request took has taken too long to process.
 message: HTTP/1.1 408 Request Timeout
 '429':
 code: 429
 description: Too many requests are currently being processed.
 message: HTTP/1.1 429 Too Many Requests
 '500':
 code: 500
 description: An internal error occurred when handling the request.
 message: HTTP/1.1 500 Internal Server Error
 summary: /chromium/performance
 tags:
 \- Browser REST APIs
 /chromium/scrape:
 post:
 definitions: {}
 description: >-
 A JSON-based API that returns text, html, and meta-data from a given
 list of selectors.

 Debugging information is available by sending in the appropriate flags
 in the "debugOpts"

 property. Responds with an array of JSON objects.

 \*\*Note:\*\* This endpoint is also available at: \`/scrape\` for backwards
 compatibility.
 parameters:
 \- in: query
 name: blockAds
 schema:
 description: \|-
 Whether or nor to load ad-blocking extensions for the session.
 This currently uses uBlock-Lite and may cause certain sites
 to not load properly.
 type: boolean
 \- in: query
 name: launch
 schema:
 anyOf:
 \- $ref: '#/definitions/CDPLaunchOptions'
 \- type: string
 \- in: query
 name: timeout
 schema:
 description: \|-
 Override the system-level timeout for this request.
 Accepts a value in milliseconds.
 type: number
 \- in: query
 name: token
 schema:
 description: The authorization token
 type: string
 \- in: query
 name: trackingId
 schema:
 description: Custom session identifier
 type: string
 requestBody:
 content:
 application/json:
 schema:
 properties:
 addScriptTag:
 type: array
 items:
 $ref: '#/definitions/FrameAddScriptTagOptions'
 addStyleTag:
 type: array
 items:
 $ref: '#/definitions/FrameAddStyleTagOptions'
 authenticate:
 anyOf:
 \- $ref: '#/definitions/Credentials'
 \- type: 'null'
 bestAttempt:
 description: >-
 When bestAttempt is set to true, browserless attempt to
 proceed

 when "awaited" events fail or timeout. This includes things
 like

 goto, waitForSelector, and more.
 type: boolean
 cookies:
 type: array
 items:
 $ref: '#/definitions/CookieParam'
 debugOpts:
 $ref: '#/definitions/ScrapeDebugOptions'
 elements:
 type: array
 items:
 $ref: '#/definitions/ScrapeElementSelector'
 emulateMediaType:
 type: string
 gotoOptions:
 $ref: '#/definitions/GoToOptions'
 html:
 type: string
 rejectRequestPattern:
 type: array
 items:
 type: string
 rejectResourceTypes:
 type: array
 items:
 enum:
 \- cspviolationreport
 \- document
 \- eventsource
 \- fetch
 \- font
 \- image
 \- manifest
 \- media
 \- other
 \- ping
 \- prefetch
 \- preflight
 \- script
 \- signedexchange
 \- stylesheet
 \- texttrack
 \- websocket
 \- xhr
 type: string
 requestInterceptors:
 type: array
 items:
 description: >-
 An array of patterns (using \`req.url().match(r.pattern)\`
 to match) and their

 corresponding responses to use in order to fulfill those
 requests.
 type: object
 properties:
 pattern:
 description: >-
 An array of patterns (using
 \`req.url().match(r.pattern)\` to match) and their

 corresponding responses to use in order to fulfill
 those requests.
 type: string
 response:
 $ref: '#/definitions/Partial'
 additionalProperties: false
 required:
 \- pattern
 \- response
 setExtraHTTPHeaders:
 $ref: '#/definitions/Record'
 setJavaScriptEnabled:
 type: boolean
 url:
 type: string
 userAgent:
 type: string
 viewport:
 anyOf:
 \- $ref: '#/definitions/Viewport'
 \- type: 'null'
 waitForEvent:
 type: object
 properties:
 event:
 type: string
 timeout:
 type: number
 additionalProperties: false
 required:
 \- event
 waitForFunction:
 type: object
 properties:
 fn:
 description: >-
 The function, or statement, to be evaluated in browser
 context
 type: string
 polling:
 description: >-
 An interval at which the pageFunction is executed,
 defaults to raf.

 If polling is a number, then it is treated as an
 interval in milliseconds

 at which the function would be executed. If polling is a
 string,

 then it can be one of the following values: "raf" or
 "mutation"
 type:
 \- string
 \- number
 timeout:
 description: >-
 Maximum time to wait for in milliseconds. Defaults to
 30000 (30 seconds).

 Pass 0 to disable timeout.
 type: number
 additionalProperties: false
 required:
 \- fn
 waitForSelector:
 type: object
 properties:
 hidden:
 type: boolean
 selector:
 type: string
 timeout:
 type: number
 visible:
 type: boolean
 additionalProperties: false
 required:
 \- selector
 waitForTimeout:
 type: number
 type: object
 responses:
 '200':
 content:
 application/json:
 schema:
 description: The JSON response body
 type: object
 properties:
 data:
 anyOf:
 \- type: array
 items:
 type: object
 properties:
 results:
 type: array
 items:
 type: object
 properties:
 attributes:
 description: A list of HTML attributes of the element
 type: array
 items:
 type: object
 properties:
 name:
 description: >-
 The name of the HTML attribute for the
 element
 type: string
 value:
 description: >-
 The value of the HTML attribute for the
 element
 type: string
 additionalProperties: false
 required:
 \- name
 \- value
 height:
 description: The height the element
 type: number
 html:
 description: The HTML the element
 type: string
 left:
 description: >-
 The amount of pixels from the left of the
 page
 type: number
 text:
 description: The text the element
 type: string
 top:
 description: >-
 The amount of pixels from the top of the
 page
 type: number
 width:
 description: The width the element
 type: number
 additionalProperties: false
 required:
 \- attributes
 \- height
 \- html
 \- left
 \- text
 \- top
 \- width
 selector:
 description: The DOM selector of the element
 type: string
 additionalProperties: false
 required:
 \- results
 \- selector
 \- type: 'null'
 debug:
 description: When debugOpts options are present, results are here
 anyOf:
 \- type: object
 properties:
 console:
 description: A list of console messages from the browser
 type: array
 items:
 type: string
 cookies:
 description: List of cookies for the site or null
 anyOf:
 \- type: array
 items:
 $ref: '#/definitions/Cookie'
 \- type: 'null'
 html:
 description: The HTML string of the website or null
 type:
 \- 'null'
 \- string
 network:
 type: object
 properties:
 inbound:
 type: array
 items:
 $ref: '#/definitions/InBoundRequest'
 outbound:
 type: array
 items:
 $ref: '#/definitions/OutBoundRequest'
 additionalProperties: false
 required:
 \- inbound
 \- outbound
 screenshot:
 description: A base64-encoded string of the site or null
 type:
 \- 'null'
 \- string
 additionalProperties: false
 required:
 \- console
 \- cookies
 \- html
 \- network
 \- screenshot
 \- type: 'null'
 additionalProperties: false
 required:
 \- data
 \- debug
 definitions:
 Cookie:
 description: Represents a cookie object.
 type: object
 properties:
 name:
 description: Cookie name.
 type: string
 value:
 description: Cookie value.
 type: string
 domain:
 description: Cookie domain.
 type: string
 path:
 description: Cookie path.
 type: string
 expires:
 description: >-
 Cookie expiration date as the number of seconds since
 the UNIX epoch. Set to \`-1\` for

 session cookies
 type: number
 size:
 description: Cookie size.
 type: number
 httpOnly:
 description: True if cookie is http-only.
 type: boolean
 secure:
 description: True if cookie is secure.
 type: boolean
 session:
 description: True in case of session cookie.
 type: boolean
 sameSite:
 description: Cookie SameSite type.
 enum:
 \- Lax
 \- None
 \- Strict
 type: string
 priority:
 description: Cookie Priority. Supported only in Chrome.
 enum:
 \- High
 \- Low
 \- Medium
 type: string
 sameParty:
 description: True if cookie is SameParty. Supported only in Chrome.
 type: boolean
 sourceScheme:
 description: Cookie source scheme type. Supported only in Chrome.
 enum:
 \- NonSecure
 \- Secure
 \- Unset
 type: string
 partitionKey:
 description: >-
 Cookie partition key. In Chrome, it is the top-level
 site the

 partitioned cookie is available in. In Firefox, it
 matches the

 source origin in the

 {@link
 https://w3c.github.io/webdriver-bidi/#type-storage-PartitionKey
 PartitionKey}.
 anyOf:
 \- $ref: '#/definitions/CookiePartitionKey'
 \- type: string
 partitionKeyOpaque:
 description: >-
 True if cookie partition key is opaque. Supported only
 in Chrome.
 type: boolean
 additionalProperties: false
 required:
 \- domain
 \- expires
 \- httpOnly
 \- name
 \- path
 \- secure
 \- session
 \- size
 \- value
 CookiePartitionKey:
 description: Represents a cookie partition key in Chrome.
 type: object
 properties:
 sourceOrigin:
 description: >-
 The site of the top-level URL the browser was visiting
 at the start of the request

 to the endpoint that set the cookie.

 In Chrome, maps to the CDP's \`topLevelSite\` partition
 key.
 type: string
 hasCrossSiteAncestor:
 description: >-
 Indicates if the cookie has any ancestors that are
 cross-site to

 the topLevelSite.

 Supported only in Chrome.
 type: boolean
 additionalProperties: false
 required:
 \- sourceOrigin
 InBoundRequest:
 type: object
 properties:
 headers: {}
 status:
 type: number
 url:
 type: string
 additionalProperties: false
 required:
 \- headers
 \- status
 \- url
 OutBoundRequest:
 type: object
 properties:
 headers: {}
 method:
 type: string
 url:
 type: string
 additionalProperties: false
 required:
 \- headers
 \- method
 \- url
 $schema: http://json-schema.org/draft-07/schema#
 description: The JSON response body
 '400':
 code: 400
 description: The request contains errors or didn't properly encode content.
 message: HTTP/1.1 400 Bad Request
 '401':
 code: 401
 description: The request is missing, or contains bad, authorization credentials.
 message: HTTP/1.1 401 Unauthorized
 '404':
 code: 404
 description: Resource couldn't be found.
 message: HTTP/1.1 404 Not Found
 '408':
 code: 408
 description: The request took has taken too long to process.
 message: HTTP/1.1 408 Request Timeout
 '429':
 code: 429
 description: Too many requests are currently being processed.
 message: HTTP/1.1 429 Too Many Requests
 '500':
 code: 500
 description: An internal error occurred when handling the request.
 message: HTTP/1.1 500 Internal Server Error
 summary: /chromium/scrape
 tags:
 \- Browser REST APIs
 /chromium/screenshot:
 post:
 definitions: {}
 description: >-
 A JSON-based API for getting a screenshot binary from either a supplied

 "url" or "html" payload in your request. Many options exist including

 cookies, user-agents, setting timers and network mocks.

 \*\*Note:\*\* This endpoint is also available at: \`/screenshot\` for
 backwards compatibility.
 parameters:
 \- in: query
 name: blockAds
 schema:
 description: \|-
 Whether or nor to load ad-blocking extensions for the session.
 This currently uses uBlock-Lite and may cause certain sites
 to not load properly.
 type: boolean
 \- in: query
 name: launch
 schema:
 description: \|-
 Launch options, which can be either an object
 of puppeteer.launch options or playwright.launchServer
 options, depending on the API. Must be either JSON
 object, or a base64-encoded JSON object.
 anyOf:
 \- $ref: >-
 #/definitions/import("/home/runner/work/enterprise/enterprise/node\_modules/@browserless.io/browserless/build/types",{with:{"resolution-mode":"import"}}).CDPLaunchOptions
 \- type: string
 \- in: query
 name: timeout
 schema:
 description: \|-
 Override the system-level timeout for this request.
 Accepts a value in milliseconds.
 type: number
 \- in: query
 name: token
 schema:
 description: The authorization token
 type: string
 \- in: query
 name: trackingId
 schema:
 description: Custom session identifier
 type: string
 requestBody:
 content:
 application/json:
 schema:
 properties:
 addScriptTag:
 type: array
 items:
 $ref: '#/definitions/FrameAddScriptTagOptions'
 addStyleTag:
 type: array
 items:
 $ref: '#/definitions/FrameAddStyleTagOptions'
 authenticate:
 $ref: '#/definitions/Credentials'
 bestAttempt:
 description: >-
 When bestAttempt is set to true, browserless attempt to
 proceed

 when "awaited" events fail or timeout. This includes things
 like

 goto, waitForSelector, and more.
 type: boolean
 blockConsentModals:
 type: boolean
 cookies:
 type: array
 items:
 $ref: '#/definitions/CookieParam'
 emulateMediaType:
 type: string
 gotoOptions:
 $ref: '#/definitions/GoToOptions'
 html:
 type: string
 options:
 $ref: '#/definitions/ScreenshotOptions'
 rejectRequestPattern:
 type: array
 items:
 type: string
 rejectResourceTypes:
 type: array
 items:
 enum:
 \- cspviolationreport
 \- document
 \- eventsource
 \- fetch
 \- font
 \- image
 \- manifest
 \- media
 \- other
 \- ping
 \- prefetch
 \- preflight
 \- script
 \- signedexchange
 \- stylesheet
 \- texttrack
 \- websocket
 \- xhr
 type: string
 requestInterceptors:
 type: array
 items:
 description: >-
 An array of patterns (using \`req.url().match(r.pattern)\`
 to match) and their

 corresponding responses to use in order to fulfill those
 requests.
 type: object
 properties:
 pattern:
 description: >-
 An array of patterns (using
 \`req.url().match(r.pattern)\` to match) and their

 corresponding responses to use in order to fulfill
 those requests.
 type: string
 response:
 $ref: '#/definitions/Partial'
 additionalProperties: false
 required:
 \- pattern
 \- response
 scrollPage:
 type: boolean
 selector:
 type: string
 setExtraHTTPHeaders:
 $ref: '#/definitions/Record'
 setJavaScriptEnabled:
 type: boolean
 url:
 type: string
 userAgent:
 type: string
 viewport:
 $ref: '#/definitions/Viewport'
 waitForEvent:
 type: object
 properties:
 event:
 type: string
 timeout:
 type: number
 additionalProperties: false
 required:
 \- event
 waitForFunction:
 type: object
 properties:
 fn:
 description: >-
 The function, or statement, to be evaluated in browser
 context
 type: string
 polling:
 description: >-
 An interval at which the pageFunction is executed,
 defaults to raf.

 If polling is a number, then it is treated as an
 interval in milliseconds

 at which the function would be executed. If polling is a
 string,

 then it can be one of the following values: "raf" or
 "mutation"
 type:
 \- string
 \- number
 timeout:
 description: >-
 Maximum time to wait for in milliseconds. Defaults to
 30000 (30 seconds).

 Pass 0 to disable timeout.
 type: number
 additionalProperties: false
 required:
 \- fn
 waitForSelector:
 type: object
 properties:
 hidden:
 type: boolean
 selector:
 type: string
 timeout:
 type: number
 visible:
 type: boolean
 additionalProperties: false
 required:
 \- selector
 waitForTimeout:
 type: number
 type: object
 responses:
 '400':
 code: 400
 description: The request contains errors or didn't properly encode content.
 message: HTTP/1.1 400 Bad Request
 '401':
 code: 401
 description: The request is missing, or contains bad, authorization credentials.
 message: HTTP/1.1 401 Unauthorized
 '404':
 code: 404
 description: Resource couldn't be found.
 message: HTTP/1.1 404 Not Found
 '408':
 code: 408
 description: The request took has taken too long to process.
 message: HTTP/1.1 408 Request Timeout
 '429':
 code: 429
 description: Too many requests are currently being processed.
 message: HTTP/1.1 429 Too Many Requests
 '500':
 code: 500
 description: An internal error occurred when handling the request.
 message: HTTP/1.1 500 Internal Server Error
 summary: /chromium/screenshot
 tags:
 \- Browser REST APIs
 /edge/content:
 post:
 definitions: {}
 description: >-
 A JSON-based API. Given a "url" or "html" field, runs and returns HTML
 content after the page has loaded and JavaScript has parsed.
 parameters:
 \- in: query
 name: blockAds
 schema:
 description: \|-
 Whether or nor to load ad-blocking extensions for the session.
 This currently uses uBlock-Lite and may cause certain sites
 to not load properly.
 type: boolean
 \- in: query
 name: launch
 schema:
 anyOf:
 \- $ref: '#/definitions/CDPLaunchOptions'
 \- type: string
 \- in: query
 name: timeout
 schema:
 description: \|-
 Override the system-level timeout for this request.
 Accepts a value in milliseconds.
 type: number
 \- in: query
 name: token
 schema:
 description: The authorization token
 type: string
 \- in: query
 name: trackingId
 schema:
 description: Custom session identifier
 type: string
 requestBody:
 content:
 application/json:
 schema:
 properties:
 addScriptTag:
 type: array
 items:
 $ref: '#/definitions/FrameAddScriptTagOptions'
 addStyleTag:
 type: array
 items:
 $ref: '#/definitions/FrameAddStyleTagOptions'
 authenticate:
 anyOf:
 \- $ref: '#/definitions/Credentials'
 \- type: 'null'
 bestAttempt:
 description: >-
 When bestAttempt is set to true, browserless attempt to
 proceed

 when "awaited" events fail or timeout. This includes things
 like

 goto, waitForSelector, and more.
 type: boolean
 cookies:
 type: array
 items:
 $ref: '#/definitions/CookieParam'
 emulateMediaType:
 type: string
 gotoOptions:
 $ref: '#/definitions/GoToOptions'
 html:
 type: string
 rejectRequestPattern:
 type: array
 items:
 type: string
 rejectResourceTypes:
 type: array
 items:
 enum:
 \- cspviolationreport
 \- document
 \- eventsource
 \- fetch
 \- font
 \- image
 \- manifest
 \- media
 \- other
 \- ping
 \- prefetch
 \- preflight
 \- script
 \- signedexchange
 \- stylesheet
 \- texttrack
 \- websocket
 \- xhr
 type: string
 requestInterceptors:
 type: array
 items:
 description: >-
 An array of patterns (using \`req.url().match(r.pattern)\`
 to match) and their

 corresponding responses to use in order to fulfill those
 requests.
 type: object
 properties:
 pattern:
 description: >-
 An array of patterns (using
 \`req.url().match(r.pattern)\` to match) and their

 corresponding responses to use in order to fulfill
 those requests.
 type: string
 response:
 $ref: '#/definitions/Partial'
 additionalProperties: false
 required:
 \- pattern
 \- response
 setExtraHTTPHeaders:
 $ref: '#/definitions/Record'
 setJavaScriptEnabled:
 description: Whether or not to allow JavaScript to run on the page.
 type: boolean
 url:
 type: string
 userAgent:
 type: string
 viewport:
 anyOf:
 \- $ref: '#/definitions/Viewport'
 \- type: 'null'
 waitForEvent:
 type: object
 properties:
 event:
 type: string
 timeout:
 type: number
 additionalProperties: false
 required:
 \- event
 waitForFunction:
 type: object
 properties:
 fn:
 description: >-
 The function, or statement, to be evaluated in browser
 context
 type: string
 polling:
 description: >-
 An interval at which the pageFunction is executed,
 defaults to raf.

 If polling is a number, then it is treated as an
 interval in milliseconds

 at which the function would be executed. If polling is a
 string,

 then it can be one of the following values: "raf" or
 "mutation"
 type:
 \- string
 \- number
 timeout:
 description: >-
 Maximum time to wait for in milliseconds. Defaults to
 30000 (30 seconds).

 Pass 0 to disable timeout.
 type: number
 additionalProperties: false
 required:
 \- fn
 waitForSelector:
 type: object
 properties:
 hidden:
 type: boolean
 selector:
 type: string
 timeout:
 type: number
 visible:
 type: boolean
 additionalProperties: false
 required:
 \- selector
 waitForTimeout:
 type: number
 type: object
 responses:
 '200':
 content:
 text/html:
 schema:
 description: \|-
 An HTML payload of the website or HTML after JavaScript
 parsing and execution.
 type: string
 $schema: http://json-schema.org/draft-07/schema#
 description: \|-
 An HTML payload of the website or HTML after JavaScript
 parsing and execution.
 '400':
 code: 400
 description: The request contains errors or didn't properly encode content.
 message: HTTP/1.1 400 Bad Request
 '401':
 code: 401
 description: The request is missing, or contains bad, authorization credentials.
 message: HTTP/1.1 401 Unauthorized
 '404':
 code: 404
 description: Resource couldn't be found.
 message: HTTP/1.1 404 Not Found
 '408':
 code: 408
 description: The request took has taken too long to process.
 message: HTTP/1.1 408 Request Timeout
 '429':
 code: 429
 description: Too many requests are currently being processed.
 message: HTTP/1.1 429 Too Many Requests
 '500':
 code: 500
 description: An internal error occurred when handling the request.
 message: HTTP/1.1 500 Internal Server Error
 summary: /edge/content
 tags:
 \- Browser REST APIs
 /edge/download:
 post:
 definitions: {}
 description: >-
 A JSON or JavaScript content-type API for returning files Chrome has
 downloaded during

 the execution of puppeteer code, which is ran inside context of the
 browser.

 Browserless sets up a blank page, a fresh download directory, injects
 your puppeteer code, and then executes it.

 You can load external libraries via the "import" syntax, and import
 ESM-style modules

 that are written for execution inside of the browser. Once your script
 is finished, any

 downloaded files from Chromium are returned back with the appropriate
 content-type header.
 parameters:
 \- in: query
 name: blockAds
 schema:
 description: \|-
 Whether or nor to load ad-blocking extensions for the session.
 This currently uses uBlock-Lite and may cause certain sites
 to not load properly.
 type: boolean
 \- in: query
 name: launch
 schema:
 description: \|-
 Launch options, which can be either an object
 of puppeteer.launch options or playwright.launchServer
 options, depending on the API. Must be either JSON
 object, or a base64-encoded JSON object.
 anyOf:
 \- $ref: '#/definitions/CDPLaunchOptions'
 \- type: string
 \- in: query
 name: timeout
 schema:
 description: \|-
 Override the system-level timeout for this request.
 Accepts a value in milliseconds.
 type: number
 \- in: query
 name: token
 schema:
 description: The authorization token
 type: string
 \- in: query
 name: trackingId
 schema:
 description: Custom session identifier
 type: string
 requestBody:
 content:
 application/json:
 schema:
 $ref: '#/definitions/JSONSchema'
 application/javascript:
 schema:
 type: string
 responses:
 '200':
 content:
 '\*/\*':
 schema:
 description: >-
 Responses are determined by the returned value of the
 downloads

 themselves, so there isn't a static response type for this
 API.
 $schema: http://json-schema.org/draft-07/schema#
 description: \|-
 Responses are determined by the returned value of the downloads
 themselves, so there isn't a static response type for this API.
 '400':
 code: 400
 description: The request contains errors or didn't properly encode content.
 message: HTTP/1.1 400 Bad Request
 '401':
 code: 401
 description: The request is missing, or contains bad, authorization credentials.
 message: HTTP/1.1 401 Unauthorized
 '404':
 code: 404
 description: Resource couldn't be found.
 message: HTTP/1.1 404 Not Found
 '408':
 code: 408
 description: The request took has taken too long to process.
 message: HTTP/1.1 408 Request Timeout
 '429':
 code: 429
 description: Too many requests are currently being processed.
 message: HTTP/1.1 429 Too Many Requests
 '500':
 code: 500
 description: An internal error occurred when handling the request.
 message: HTTP/1.1 500 Internal Server Error
 summary: /edge/download
 tags:
 \- Browser REST APIs
 /edge/function:
 post:
 definitions: {}
 description: >-
 A JSON or JavaScript content-type API for running puppeteer code in the
 browser's context.

 Browserless sets up a blank page, injects your puppeteer code, and runs
 it.

 You can optionally load external libraries via the "import" module that
 are meant for browser usage.

 Values returned from the function are checked and an appropriate
 content-type and response is sent back

 to your HTTP call.
 parameters:
 \- in: query
 name: blockAds
 schema:
 description: \|-
 Whether or nor to load ad-blocking extensions for the session.
 This currently uses uBlock-Lite and may cause certain sites
 to not load properly.
 type: boolean
 \- in: query
 name: launch
 schema:
 description: \|-
 Launch options, which can be either an object
 of puppeteer.launch options or playwright.launchServer
 options, depending on the API. Must be either JSON
 object, or a base64-encoded JSON object.
 anyOf:
 \- $ref: '#/definitions/CDPLaunchOptions'
 \- type: string
 \- in: query
 name: timeout
 schema:
 description: \|-
 Override the system-level timeout for this request.
 Accepts a value in milliseconds.
 type: number
 \- in: query
 name: token
 schema:
 description: The authorization token
 type: string
 \- in: query
 name: trackingId
 schema:
 description: Custom session identifier
 type: string
 requestBody:
 content:
 application/json:
 schema:
 $ref: '#/definitions/JSONSchema'
 application/javascript:
 schema:
 type: string
 responses:
 '200':
 content:
 '\*/\*':
 schema:
 description: >-
 Responses are determined by the returned value of the function

 itself. Binary responses (PDF's, screenshots) are returned
 back

 as binary data, and primitive JavaScript values are returned
 back

 by type (HTML data is "text/html", Objects are
 "application/json")
 $schema: http://json-schema.org/draft-07/schema#
 description: \|-
 Responses are determined by the returned value of the function
 itself. Binary responses (PDF's, screenshots) are returned back
 as binary data, and primitive JavaScript values are returned back
 by type (HTML data is "text/html", Objects are "application/json")
 '400':
 code: 400
 description: The request contains errors or didn't properly encode content.
 message: HTTP/1.1 400 Bad Request
 '401':
 code: 401
 description: The request is missing, or contains bad, authorization credentials.
 message: HTTP/1.1 401 Unauthorized
 '404':
 code: 404
 description: Resource couldn't be found.
 message: HTTP/1.1 404 Not Found
 '408':
 code: 408
 description: The request took has taken too long to process.
 message: HTTP/1.1 408 Request Timeout
 '429':
 code: 429
 description: Too many requests are currently being processed.
 message: HTTP/1.1 429 Too Many Requests
 '500':
 code: 500
 description: An internal error occurred when handling the request.
 message: HTTP/1.1 500 Internal Server Error
 summary: /edge/function
 tags:
 \- Browser REST APIs
 /edge/pdf:
 post:
 definitions: {}
 description: \|-
 A JSON-based API for getting a PDF binary from either a supplied
 "url" or "html" payload in your request. Many options exist for
 injecting cookies, request interceptors, user-agents and waiting for
 selectors, timers and more.
 parameters:
 \- in: query
 name: blockAds
 schema:
 description: \|-
 Whether or nor to load ad-blocking extensions for the session.
 This currently uses uBlock-Lite and may cause certain sites
 to not load properly.
 type: boolean
 \- in: query
 name: launch
 schema:
 description: \|-
 Launch options, which can be either an object
 of puppeteer.launch options or playwright.launchServer
 options, depending on the API. Must be either JSON
 object, or a base64-encoded JSON object.
 anyOf:
 \- $ref: '#/definitions/CDPLaunchOptions'
 \- type: string
 \- in: query
 name: timeout
 schema:
 description: \|-
 Override the system-level timeout for this request.
 Accepts a value in milliseconds.
 type: number
 \- in: query
 name: token
 schema:
 description: The authorization token
 type: string
 \- in: query
 name: trackingId
 schema:
 description: Custom session identifier
 type: string
 requestBody:
 content:
 application/json:
 schema:
 properties:
 addScriptTag:
 type: array
 items:
 $ref: '#/definitions/FrameAddScriptTagOptions'
 addStyleTag:
 type: array
 items:
 $ref: '#/definitions/FrameAddStyleTagOptions'
 authenticate:
 anyOf:
 \- $ref: '#/definitions/Credentials'
 \- type: 'null'
 bestAttempt:
 description: >-
 When bestAttempt is set to true, browserless attempt to
 proceed

 when "awaited" events fail or timeout. This includes things
 like

 goto, waitForSelector, and more.
 type: boolean
 cookies:
 type: array
 items:
 $ref: '#/definitions/CookieParam'
 emulateMediaType:
 type: string
 gotoOptions:
 $ref: '#/definitions/GoToOptions'
 html:
 type: string
 options:
 $ref: '#/definitions/PDFOptions'
 rejectRequestPattern:
 type: array
 items:
 type: string
 rejectResourceTypes:
 type: array
 items:
 enum:
 \- cspviolationreport
 \- document
 \- eventsource
 \- fetch
 \- font
 \- image
 \- manifest
 \- media
 \- other
 \- ping
 \- prefetch
 \- preflight
 \- script
 \- signedexchange
 \- stylesheet
 \- texttrack
 \- websocket
 \- xhr
 type: string
 requestInterceptors:
 type: array
 items:
 description: >-
 An array of patterns (using \`req.url().match(r.pattern)\`
 to match) and their

 corresponding responses to use in order to fulfill those
 requests.
 type: object
 properties:
 pattern:
 description: >-
 An array of patterns (using
 \`req.url().match(r.pattern)\` to match) and their

 corresponding responses to use in order to fulfill
 those requests.
 type: string
 response:
 $ref: '#/definitions/Partial'
 additionalProperties: false
 required:
 \- pattern
 \- response
 setExtraHTTPHeaders:
 $ref: '#/definitions/Record'
 setJavaScriptEnabled:
 type: boolean
 url:
 type: string
 userAgent:
 type: string
 viewport:
 anyOf:
 \- $ref: '#/definitions/Viewport'
 \- type: 'null'
 waitForEvent:
 type: object
 properties:
 event:
 type: string
 timeout:
 type: number
 additionalProperties: false
 required:
 \- event
 waitForFunction:
 type: object
 properties:
 fn:
 description: >-
 The function, or statement, to be evaluated in browser
 context
 type: string
 polling:
 description: >-
 An interval at which the pageFunction is executed,
 defaults to raf.

 If polling is a number, then it is treated as an
 interval in milliseconds

 at which the function would be executed. If polling is a
 string,

 then it can be one of the following values: "raf" or
 "mutation"
 type:
 \- string
 \- number
 timeout:
 description: >-
 Maximum time to wait for in milliseconds. Defaults to
 30000 (30 seconds).

 Pass 0 to disable timeout.
 type: number
 additionalProperties: false
 required:
 \- fn
 waitForSelector:
 type: object
 properties:
 hidden:
 type: boolean
 selector:
 type: string
 timeout:
 type: number
 visible:
 type: boolean
 additionalProperties: false
 required:
 \- selector
 waitForTimeout:
 type: number
 type: object
 responses:
 '200':
 content:
 application/pdf:
 schema:
 description: Responds with an application/pdf content-type and a binary PDF
 type: string
 $schema: http://json-schema.org/draft-07/schema#
 description: Responds with an application/pdf content-type and a binary PDF
 '400':
 code: 400
 description: The request contains errors or didn't properly encode content.
 message: HTTP/1.1 400 Bad Request
 '401':
 code: 401
 description: The request is missing, or contains bad, authorization credentials.
 message: HTTP/1.1 401 Unauthorized
 '404':
 code: 404
 description: Resource couldn't be found.
 message: HTTP/1.1 404 Not Found
 '408':
 code: 408
 description: The request took has taken too long to process.
 message: HTTP/1.1 408 Request Timeout
 '429':
 code: 429
 description: Too many requests are currently being processed.
 message: HTTP/1.1 429 Too Many Requests
 '500':
 code: 500
 description: An internal error occurred when handling the request.
 message: HTTP/1.1 500 Internal Server Error
 summary: /edge/pdf
 tags:
 \- Browser REST APIs
 /edge/performance:
 post:
 definitions: {}
 description: >-
 Run lighthouse performance audits with a supplied "url" in your JSON
 payload.
 parameters:
 \- in: query
 name: blockAds
 schema:
 description: \|-
 Whether or nor to load ad-blocking extensions for the session.
 This currently uses uBlock-Lite and may cause certain sites
 to not load properly.
 type: boolean
 \- in: query
 name: launch
 schema:
 description: \|-
 Launch options, which can be either an object
 of puppeteer.launch options or playwright.launchServer
 options, depending on the API. Must be either JSON
 object, or a base64-encoded JSON object.
 anyOf:
 \- $ref: '#/definitions/CDPLaunchOptions'
 \- type: string
 \- in: query
 name: timeout
 schema:
 description: \|-
 Override the system-level timeout for this request.
 Accepts a value in milliseconds.
 type: number
 \- in: query
 name: token
 schema:
 description: The authorization token
 type: string
 \- in: query
 name: trackingId
 schema:
 description: Custom session identifier
 type: string
 requestBody:
 content:
 application/json:
 schema:
 properties:
 budgets:
 type: array
 items:
 type: object
 properties: {}
 additionalProperties: true
 config:
 type: object
 properties: {}
 additionalProperties: true
 url:
 type: string
 type: object
 responses:
 '200':
 content:
 application/json:
 schema:
 description: \|-
 The response of the lighthouse stats. Response objects are
 determined by the type of budgets and config in the POST
 JSON body
 type: object
 properties: {}
 additionalProperties: true
 $schema: http://json-schema.org/draft-07/schema#
 description: \|-
 The response of the lighthouse stats. Response objects are
 determined by the type of budgets and config in the POST
 JSON body
 '400':
 code: 400
 description: The request contains errors or didn't properly encode content.
 message: HTTP/1.1 400 Bad Request
 '401':
 code: 401
 description: The request is missing, or contains bad, authorization credentials.
 message: HTTP/1.1 401 Unauthorized
 '404':
 code: 404
 description: Resource couldn't be found.
 message: HTTP/1.1 404 Not Found
 '408':
 code: 408
 description: The request took has taken too long to process.
 message: HTTP/1.1 408 Request Timeout
 '429':
 code: 429
 description: Too many requests are currently being processed.
 message: HTTP/1.1 429 Too Many Requests
 '500':
 code: 500
 description: An internal error occurred when handling the request.
 message: HTTP/1.1 500 Internal Server Error
 summary: /edge/performance
 tags:
 \- Browser REST APIs
 /edge/scrape:
 post:
 definitions: {}
 description: >-
 A JSON-based API that returns text, html, and meta-data from a given
 list of selectors.

 Debugging information is available by sending in the appropriate flags
 in the "debugOpts"

 property. Responds with an array of JSON objects.
 parameters:
 \- in: query
 name: blockAds
 schema:
 description: \|-
 Whether or nor to load ad-blocking extensions for the session.
 This currently uses uBlock-Lite and may cause certain sites
 to not load properly.
 type: boolean
 \- in: query
 name: launch
 schema:
 anyOf:
 \- $ref: '#/definitions/CDPLaunchOptions'
 \- type: string
 \- in: query
 name: timeout
 schema:
 description: \|-
 Override the system-level timeout for this request.
 Accepts a value in milliseconds.
 type: number
 \- in: query
 name: token
 schema:
 description: The authorization token
 type: string
 \- in: query
 name: trackingId
 schema:
 description: Custom session identifier
 type: string
 requestBody:
 content:
 application/json:
 schema:
 properties:
 addScriptTag:
 type: array
 items:
 $ref: '#/definitions/FrameAddScriptTagOptions'
 addStyleTag:
 type: array
 items:
 $ref: '#/definitions/FrameAddStyleTagOptions'
 authenticate:
 anyOf:
 \- $ref: '#/definitions/Credentials'
 \- type: 'null'
 bestAttempt:
 description: >-
 When bestAttempt is set to true, browserless attempt to
 proceed

 when "awaited" events fail or timeout. This includes things
 like

 goto, waitForSelector, and more.
 type: boolean
 cookies:
 type: array
 items:
 $ref: '#/definitions/CookieParam'
 debugOpts:
 $ref: '#/definitions/ScrapeDebugOptions'
 elements:
 type: array
 items:
 $ref: '#/definitions/ScrapeElementSelector'
 emulateMediaType:
 type: string
 gotoOptions:
 $ref: '#/definitions/GoToOptions'
 html:
 type: string
 rejectRequestPattern:
 type: array
 items:
 type: string
 rejectResourceTypes:
 type: array
 items:
 enum:
 \- cspviolationreport
 \- document
 \- eventsource
 \- fetch
 \- font
 \- image
 \- manifest
 \- media
 \- other
 \- ping
 \- prefetch
 \- preflight
 \- script
 \- signedexchange
 \- stylesheet
 \- texttrack
 \- websocket
 \- xhr
 type: string
 requestInterceptors:
 type: array
 items:
 description: >-
 An array of patterns (using \`req.url().match(r.pattern)\`
 to match) and their

 corresponding responses to use in order to fulfill those
 requests.
 type: object
 properties:
 pattern:
 description: >-
 An array of patterns (using
 \`req.url().match(r.pattern)\` to match) and their

 corresponding responses to use in order to fulfill
 those requests.
 type: string
 response:
 $ref: '#/definitions/Partial'
 additionalProperties: false
 required:
 \- pattern
 \- response
 setExtraHTTPHeaders:
 $ref: '#/definitions/Record'
 setJavaScriptEnabled:
 type: boolean
 url:
 type: string
 userAgent:
 type: string
 viewport:
 anyOf:
 \- $ref: '#/definitions/Viewport'
 \- type: 'null'
 waitForEvent:
 type: object
 properties:
 event:
 type: string
 timeout:
 type: number
 additionalProperties: false
 required:
 \- event
 waitForFunction:
 type: object
 properties:
 fn:
 description: >-
 The function, or statement, to be evaluated in browser
 context
 type: string
 polling:
 description: >-
 An interval at which the pageFunction is executed,
 defaults to raf.

 If polling is a number, then it is treated as an
 interval in milliseconds

 at which the function would be executed. If polling is a
 string,

 then it can be one of the following values: "raf" or
 "mutation"
 type:
 \- string
 \- number
 timeout:
 description: >-
 Maximum time to wait for in milliseconds. Defaults to
 30000 (30 seconds).

 Pass 0 to disable timeout.
 type: number
 additionalProperties: false
 required:
 \- fn
 waitForSelector:
 type: object
 properties:
 hidden:
 type: boolean
 selector:
 type: string
 timeout:
 type: number
 visible:
 type: boolean
 additionalProperties: false
 required:
 \- selector
 waitForTimeout:
 type: number
 type: object
 responses:
 '200':
 content:
 application/json:
 schema:
 description: The JSON response body
 type: object
 properties:
 data:
 anyOf:
 \- type: array
 items:
 type: object
 properties:
 results:
 type: array
 items:
 type: object
 properties:
 attributes:
 description: A list of HTML attributes of the element
 type: array
 items:
 type: object
 properties:
 name:
 description: >-
 The name of the HTML attribute for the
 element
 type: string
 value:
 description: >-
 The value of the HTML attribute for the
 element
 type: string
 additionalProperties: false
 required:
 \- name
 \- value
 height:
 description: The height the element
 type: number
 html:
 description: The HTML the element
 type: string
 left:
 description: >-
 The amount of pixels from the left of the
 page
 type: number
 text:
 description: The text the element
 type: string
 top:
 description: >-
 The amount of pixels from the top of the
 page
 type: number
 width:
 description: The width the element
 type: number
 additionalProperties: false
 required:
 \- attributes
 \- height
 \- html
 \- left
 \- text
 \- top
 \- width
 selector:
 description: The DOM selector of the element
 type: string
 additionalProperties: false
 required:
 \- results
 \- selector
 \- type: 'null'
 debug:
 description: When debugOpts options are present, results are here
 anyOf:
 \- type: object
 properties:
 console:
 description: A list of console messages from the browser
 type: array
 items:
 type: string
 cookies:
 description: List of cookies for the site or null
 anyOf:
 \- type: array
 items:
 $ref: '#/definitions/Cookie'
 \- type: 'null'
 html:
 description: The HTML string of the website or null
 type:
 \- 'null'
 \- string
 network:
 type: object
 properties:
 inbound:
 type: array
 items:
 $ref: '#/definitions/InBoundRequest'
 outbound:
 type: array
 items:
 $ref: '#/definitions/OutBoundRequest'
 additionalProperties: false
 required:
 \- inbound
 \- outbound
 screenshot:
 description: A base64-encoded string of the site or null
 type:
 \- 'null'
 \- string
 additionalProperties: false
 required:
 \- console
 \- cookies
 \- html
 \- network
 \- screenshot
 \- type: 'null'
 additionalProperties: false
 required:
 \- data
 \- debug
 definitions:
 Cookie:
 description: Represents a cookie object.
 type: object
 properties:
 name:
 description: Cookie name.
 type: string
 value:
 description: Cookie value.
 type: string
 domain:
 description: Cookie domain.
 type: string
 path:
 description: Cookie path.
 type: string
 expires:
 description: >-
 Cookie expiration date as the number of seconds since
 the UNIX epoch. Set to \`-1\` for

 session cookies
 type: number
 size:
 description: Cookie size.
 type: number
 httpOnly:
 description: True if cookie is http-only.
 type: boolean
 secure:
 description: True if cookie is secure.
 type: boolean
 session:
 description: True in case of session cookie.
 type: boolean
 sameSite:
 description: Cookie SameSite type.
 enum:
 \- Lax
 \- None
 \- Strict
 type: string
 priority:
 description: Cookie Priority. Supported only in Chrome.
 enum:
 \- High
 \- Low
 \- Medium
 type: string
 sameParty:
 description: True if cookie is SameParty. Supported only in Chrome.
 type: boolean
 sourceScheme:
 description: Cookie source scheme type. Supported only in Chrome.
 enum:
 \- NonSecure
 \- Secure
 \- Unset
 type: string
 partitionKey:
 description: >-
 Cookie partition key. In Chrome, it is the top-level
 site the

 partitioned cookie is available in. In Firefox, it
 matches the

 source origin in the

 {@link
 https://w3c.github.io/webdriver-bidi/#type-storage-PartitionKey
 PartitionKey}.
 anyOf:
 \- $ref: '#/definitions/CookiePartitionKey'
 \- type: string
 partitionKeyOpaque:
 description: >-
 True if cookie partition key is opaque. Supported only
 in Chrome.
 type: boolean
 additionalProperties: false
 required:
 \- domain
 \- expires
 \- httpOnly
 \- name
 \- path
 \- secure
 \- session
 \- size
 \- value
 CookiePartitionKey:
 description: Represents a cookie partition key in Chrome.
 type: object
 properties:
 sourceOrigin:
 description: >-
 The site of the top-level URL the browser was visiting
 at the start of the request

 to the endpoint that set the cookie.

 In Chrome, maps to the CDP's \`topLevelSite\` partition
 key.
 type: string
 hasCrossSiteAncestor:
 description: >-
 Indicates if the cookie has any ancestors that are
 cross-site to

 the topLevelSite.

 Supported only in Chrome.
 type: boolean
 additionalProperties: false
 required:
 \- sourceOrigin
 InBoundRequest:
 type: object
 properties:
 headers: {}
 status:
 type: number
 url:
 type: string
 additionalProperties: false
 required:
 \- headers
 \- status
 \- url
 OutBoundRequest:
 type: object
 properties:
 headers: {}
 method:
 type: string
 url:
 type: string
 additionalProperties: false
 required:
 \- headers
 \- method
 \- url
 $schema: http://json-schema.org/draft-07/schema#
 description: The JSON response body
 '400':
 code: 400
 description: The request contains errors or didn't properly encode content.
 message: HTTP/1.1 400 Bad Request
 '401':
 code: 401
 description: The request is missing, or contains bad, authorization credentials.
 message: HTTP/1.1 401 Unauthorized
 '404':
 code: 404
 description: Resource couldn't be found.
 message: HTTP/1.1 404 Not Found
 '408':
 code: 408
 description: The request took has taken too long to process.
 message: HTTP/1.1 408 Request Timeout
 '429':
 code: 429
 description: Too many requests are currently being processed.
 message: HTTP/1.1 429 Too Many Requests
 '500':
 code: 500
 description: An internal error occurred when handling the request.
 message: HTTP/1.1 500 Internal Server Error
 summary: /edge/scrape
 tags:
 \- Browser REST APIs
 /edge/screenshot:
 post:
 definitions: {}
 description: \|-
 A JSON-based API for getting a screenshot binary from either a supplied
 "url" or "html" payload in your request. Many options exist including
 cookies, user-agents, setting timers and network mocks.
 parameters:
 \- in: query
 name: blockAds
 schema:
 description: \|-
 Whether or nor to load ad-blocking extensions for the session.
 This currently uses uBlock-Lite and may cause certain sites
 to not load properly.
 type: boolean
 \- in: query
 name: launch
 schema:
 description: \|-
 Launch options, which can be either an object
 of puppeteer.launch options or playwright.launchServer
 options, depending on the API. Must be either JSON
 object, or a base64-encoded JSON object.
 anyOf:
 \- $ref: '#/definitions/CDPLaunchOptions'
 \- type: string
 \- in: query
 name: timeout
 schema:
 description: \|-
 Override the system-level timeout for this request.
 Accepts a value in milliseconds.
 type: number
 \- in: query
 name: token
 schema:
 description: The authorization token
 type: string
 \- in: query
 name: trackingId
 schema:
 description: Custom session identifier
 type: string
 requestBody:
 content:
 application/json:
 schema:
 properties:
 addScriptTag:
 type: array
 items:
 $ref: '#/definitions/FrameAddScriptTagOptions'
 addStyleTag:
 type: array
 items:
 $ref: '#/definitions/FrameAddStyleTagOptions'
 authenticate:
 anyOf:
 \- $ref: '#/definitions/Credentials'
 \- type: 'null'
 bestAttempt:
 description: >-
 When bestAttempt is set to true, browserless attempt to
 proceed

 when "awaited" events fail or timeout. This includes things
 like

 goto, waitForSelector, and more.
 type: boolean
 cookies:
 type: array
 items:
 $ref: '#/definitions/CookieParam'
 emulateMediaType:
 type: string
 gotoOptions:
 $ref: '#/definitions/GoToOptions'
 html:
 type: string
 options:
 $ref: '#/definitions/ScreenshotOptions'
 rejectRequestPattern:
 type: array
 items:
 type: string
 rejectResourceTypes:
 type: array
 items:
 enum:
 \- cspviolationreport
 \- document
 \- eventsource
 \- fetch
 \- font
 \- image
 \- manifest
 \- media
 \- other
 \- ping
 \- prefetch
 \- preflight
 \- script
 \- signedexchange
 \- stylesheet
 \- texttrack
 \- websocket
 \- xhr
 type: string
 requestInterceptors:
 type: array
 items:
 description: >-
 An array of patterns (using \`req.url().match(r.pattern)\`
 to match) and their

 corresponding responses to use in order to fulfill those
 requests.
 type: object
 properties:
 pattern:
 description: >-
 An array of patterns (using
 \`req.url().match(r.pattern)\` to match) and their

 corresponding responses to use in order to fulfill
 those requests.
 type: string
 response:
 $ref: '#/definitions/Partial'
 additionalProperties: false
 required:
 \- pattern
 \- response
 scrollPage:
 type: boolean
 selector:
 type: string
 setExtraHTTPHeaders:
 $ref: '#/definitions/Record'
 setJavaScriptEnabled:
 type: boolean
 url:
 type: string
 userAgent:
 type: string
 viewport:
 anyOf:
 \- $ref: '#/definitions/Viewport'
 \- type: 'null'
 waitForEvent:
 type: object
 properties:
 event:
 type: string
 timeout:
 type: number
 additionalProperties: false
 required:
 \- event
 waitForFunction:
 type: object
 properties:
 fn:
 description: >-
 The function, or statement, to be evaluated in browser
 context
 type: string
 polling:
 description: >-
 An interval at which the pageFunction is executed,
 defaults to raf.

 If polling is a number, then it is treated as an
 interval in milliseconds

 at which the function would be executed. If polling is a
 string,

 then it can be one of the following values: "raf" or
 "mutation"
 type:
 \- string
 \- number
 timeout:
 description: >-
 Maximum time to wait for in milliseconds. Defaults to
 30000 (30 seconds).

 Pass 0 to disable timeout.
 type: number
 additionalProperties: false
 required:
 \- fn
 waitForSelector:
 type: object
 properties:
 hidden:
 type: boolean
 selector:
 type: string
 timeout:
 type: number
 visible:
 type: boolean
 additionalProperties: false
 required:
 \- selector
 waitForTimeout:
 type: number
 type: object
 responses:
 '200':
 content:
 image/png:
 schema:
 type: text
 image/jpeg:
 schema:
 type: text
 text/plain:
 schema:
 type: text
 description: \|-
 Response can either be a text/plain base64 encoded body
 or a binary stream with png/jpeg as a content-type
 '400':
 code: 400
 description: The request contains errors or didn't properly encode content.
 message: HTTP/1.1 400 Bad Request
 '401':
 code: 401
 description: The request is missing, or contains bad, authorization credentials.
 message: HTTP/1.1 401 Unauthorized
 '404':
 code: 404
 description: Resource couldn't be found.
 message: HTTP/1.1 404 Not Found
 '408':
 code: 408
 description: The request took has taken too long to process.
 message: HTTP/1.1 408 Request Timeout
 '429':
 code: 429
 description: Too many requests are currently being processed.
 message: HTTP/1.1 429 Too Many Requests
 '500':
 code: 500
 description: An internal error occurred when handling the request.
 message: HTTP/1.1 500 Internal Server Error
 summary: /edge/screenshot
 tags:
 \- Browser REST APIs
 /active:
 get:
 definitions: {}
 description: >-
 Returns a simple "204" HTTP code, with no response, indicating that the
 service itself is up and running.

 Useful for liveliness probes or other external checks.
 parameters: \[\]
 requestBody:
 content: {}
 responses:
 '400':
 code: 400
 description: The request contains errors or didn't properly encode content.
 message: HTTP/1.1 400 Bad Request
 '401':
 code: 401
 description: The request is missing, or contains bad, authorization credentials.
 message: HTTP/1.1 401 Unauthorized
 '404':
 code: 404
 description: Resource couldn't be found.
 message: HTTP/1.1 404 Not Found
 '408':
 code: 408
 description: The request took has taken too long to process.
 message: HTTP/1.1 408 Request Timeout
 '429':
 code: 429
 description: Too many requests are currently being processed.
 message: HTTP/1.1 429 Too Many Requests
 '500':
 code: 500
 description: An internal error occurred when handling the request.
 message: HTTP/1.1 500 Internal Server Error
 summary: /active
 tags:
 \- Management REST APIs
 /kill/+(\[0-9a-zA-Z-\_\]):
 get:
 definitions: {}
 description: Kill running sessions based on BrowserId or TrackingId.
 parameters:
 \- in: query
 name: token
 required: true
 schema:
 description: The authorization token
 type: string
 \- in: query
 name: blockAds
 required: false
 schema:
 description: \|-
 Whether or nor to load ad-blocking extensions for the session.
 This currently uses uBlock-Lite and may cause certain sites
 to not load properly.
 type: boolean
 \- in: query
 name: browserId
 required: false
 schema:
 type: string
 \- in: query
 name: launch
 required: false
 schema:
 description: \|-
 Launch options, which can be either an object
 of puppeteer.launch options or playwright.launchServer
 options, depending on the API. Must be either JSON
 object, or a base64-encoded JSON object.
 anyOf:
 \- $ref: '#/definitions/CDPLaunchOptions'
 \- $ref: '#/definitions/BrowserServerOptions'
 \- type: string
 \- in: query
 name: timeout
 required: false
 schema:
 description: \|-
 Override the system-level timeout for this request.
 Accepts a value in milliseconds.
 type: number
 \- in: query
 name: trackingId
 required: false
 schema:
 description: Custom session identifier
 type: string
 requestBody:
 content: {}
 responses:
 '400':
 code: 400
 description: The request contains errors or didn't properly encode content.
 message: HTTP/1.1 400 Bad Request
 '401':
 code: 401
 description: The request is missing, or contains bad, authorization credentials.
 message: HTTP/1.1 401 Unauthorized
 '404':
 code: 404
 description: Resource couldn't be found.
 message: HTTP/1.1 404 Not Found
 '408':
 code: 408
 description: The request took has taken too long to process.
 message: HTTP/1.1 408 Request Timeout
 '429':
 code: 429
 description: Too many requests are currently being processed.
 message: HTTP/1.1 429 Too Many Requests
 '500':
 code: 500
 description: An internal error occurred when handling the request.
 message: HTTP/1.1 500 Internal Server Error
 summary: /kill/+(\[0-9a-zA-Z-\_\])
 tags:
 \- Management REST APIs
 /meta:
 get:
 definitions: {}
 description: >-
 Returns a JSON payload of the current system versions, including the
 core API version.
 parameters: \[\]
 requestBody:
 content: {}
 responses:
 '200':
 content:
 application/json:
 schema:
 type: object
 properties:
 version:
 description: The semantic version of the Browserless API
 type: string
 chromium:
 description: >-
 The version of Chromium installed, or null if not
 installed
 type:
 \- 'null'
 \- string
 webkit:
 description: The version of Webkit installed, or null if not installed
 type:
 \- 'null'
 \- string
 firefox:
 description: The version of Firefox installed, or null if not installed
 type:
 \- 'null'
 \- string
 playwright:
 description: The supported version(s) of puppeteer
 type: array
 items:
 type: string
 puppeteer:
 description: The supported version(s) of playwright
 type: array
 items:
 type: string
 additionalProperties: false
 required:
 \- chromium
 \- firefox
 \- playwright
 \- puppeteer
 \- version
 \- webkit
 $schema: http://json-schema.org/draft-07/schema#
 '400':
 code: 400
 description: The request contains errors or didn't properly encode content.
 message: HTTP/1.1 400 Bad Request
 '401':
 code: 401
 description: The request is missing, or contains bad, authorization credentials.
 message: HTTP/1.1 401 Unauthorized
 '404':
 code: 404
 description: Resource couldn't be found.
 message: HTTP/1.1 404 Not Found
 '408':
 code: 408
 description: The request took has taken too long to process.
 message: HTTP/1.1 408 Request Timeout
 '429':
 code: 429
 description: Too many requests are currently being processed.
 message: HTTP/1.1 429 Too Many Requests
 '500':
 code: 500
 description: An internal error occurred when handling the request.
 message: HTTP/1.1 500 Internal Server Error
 summary: /meta
 tags:
 \- Management REST APIs
 /:
 get:
 definitions: {}
 description: >-
 Serves static files inside of this "static" directory. Content-types
 will vary depending on the type =of file being returned.
 parameters: \[\]
 requestBody:
 content: {}
 responses:
 '400':
 code: 400
 description: The request contains errors or didn't properly encode content.
 message: HTTP/1.1 400 Bad Request
 '401':
 code: 401
 description: The request is missing, or contains bad, authorization credentials.
 message: HTTP/1.1 401 Unauthorized
 '404':
 code: 404
 description: Resource couldn't be found.
 message: HTTP/1.1 404 Not Found
 '408':
 code: 408
 description: The request took has taken too long to process.
 message: HTTP/1.1 408 Request Timeout
 '429':
 code: 429
 description: Too many requests are currently being processed.
 message: HTTP/1.1 429 Too Many Requests
 '500':
 code: 500
 description: An internal error occurred when handling the request.
 message: HTTP/1.1 500 Internal Server Error
 summary: /
 tags:
 \- Management REST APIs
 /devtools/browser/\*:
 get:
 definitions: {}
 description: \|-
 Connect to an already-running Chromium process with a library like
 puppeteer, or others, that work over chrome-devtools-protocol. Chromium
 must already be launched in order to not return a 404.
 parameters:
 \- in: query
 name: blockAds
 schema:
 description: \|-
 Whether or nor to load ad-blocking extensions for the session.
 This currently uses uBlock-Lite and may cause certain sites
 to not load properly.
 type: boolean
 \- in: query
 name: launch
 schema:
 description: \|-
 Launch options, which can be either an object
 of puppeteer.launch options or playwright.launchServer
 options, depending on the API. Must be either JSON
 object, or a base64-encoded JSON object.
 anyOf:
 \- $ref: '#/definitions/CDPLaunchOptions'
 \- type: string
 \- in: query
 name: timeout
 schema:
 description: \|-
 Override the system-level timeout for this request.
 Accepts a value in milliseconds.
 type: number
 \- in: query
 name: token
 schema:
 description: The authorization token
 type: string
 \- in: query
 name: trackingId
 schema:
 description: Custom session identifier
 type: string
 requestBody:
 content: {}
 responses:
 '101':
 description: Indicates successful WebSocket upgrade.
 '400':
 code: 400
 description: The request contains errors or didn't properly encode content.
 message: HTTP/1.1 400 Bad Request
 '401':
 code: 401
 description: The request is missing, or contains bad, authorization credentials.
 message: HTTP/1.1 401 Unauthorized
 '404':
 code: 404
 description: Resource couldn't be found.
 message: HTTP/1.1 404 Not Found
 '408':
 code: 408
 description: The request took has taken too long to process.
 message: HTTP/1.1 408 Request Timeout
 '429':
 code: 429
 description: Too many requests are currently being processed.
 message: HTTP/1.1 429 Too Many Requests
 '500':
 code: 500
 description: An internal error occurred when handling the request.
 message: HTTP/1.1 500 Internal Server Error
 summary: /devtools/browser/\*
 tags:
 \- Browser WebSocket APIs
 /chrome:
 get:
 definitions: {}
 description: >-
 Launch and connect to Chromium with a library like puppeteer or others
 that work over chrome-devtools-protocol.
 parameters:
 \- in: query
 name: blockAds
 schema:
 description: \|-
 Whether or nor to load ad-blocking extensions for the session.
 This currently uses uBlock-Lite and may cause certain sites
 to not load properly.
 type: boolean
 \- in: query
 name: launch
 schema:
 description: \|-
 Launch options, which can be either an object
 of puppeteer.launch options or playwright.launchServer
 options, depending on the API. Must be either JSON
 object, or a base64-encoded JSON object.
 anyOf:
 \- $ref: >-
 #/definitions/import("/home/runner/work/enterprise/enterprise/node\_modules/@browserless.io/browserless/build/types",{with:{"resolution-mode":"import"}}).CDPLaunchOptions
 \- type: string
 \- in: query
 name: record
 schema:
 type: boolean
 \- in: query
 name: timeout
 schema:
 description: \|-
 Override the system-level timeout for this request.
 Accepts a value in milliseconds.
 type: number
 \- in: query
 name: token
 schema:
 description: The authorization token
 type: string
 \- in: query
 name: trackingId
 schema:
 description: Custom session identifier
 type: string
 requestBody:
 content: {}
 responses:
 '101':
 description: Indicates successful WebSocket upgrade.
 '400':
 code: 400
 description: The request contains errors or didn't properly encode content.
 message: HTTP/1.1 400 Bad Request
 '401':
 code: 401
 description: The request is missing, or contains bad, authorization credentials.
 message: HTTP/1.1 401 Unauthorized
 '404':
 code: 404
 description: Resource couldn't be found.
 message: HTTP/1.1 404 Not Found
 '408':
 code: 408
 description: The request took has taken too long to process.
 message: HTTP/1.1 408 Request Timeout
 '429':
 code: 429
 description: Too many requests are currently being processed.
 message: HTTP/1.1 429 Too Many Requests
 '500':
 code: 500
 description: An internal error occurred when handling the request.
 message: HTTP/1.1 500 Internal Server Error
 summary: /chrome
 tags:
 \- Browser WebSocket APIs
 /devtools/page/\*:
 get:
 definitions: {}
 description: \|-
 Connect to an existing page in Chromium with a library like
 chrome-remote-interface or others that work the page websocketDebugger
 URL. You can get this unique URL by calling the /json/list API
 or by finding the page's unique ID from your library of choice.
 parameters:
 \- in: query
 name: blockAds
 schema:
 description: \|-
 Whether or nor to load ad-blocking extensions for the session.
 This currently uses uBlock-Lite and may cause certain sites
 to not load properly.
 type: boolean
 \- in: query
 name: launch
 schema:
 description: \|-
 Launch options, which can be either an object
 of puppeteer.launch options or playwright.launchServer
 options, depending on the API. Must be either JSON
 object, or a base64-encoded JSON object.
 anyOf:
 \- $ref: '#/definitions/CDPLaunchOptions'
 \- type: string
 \- in: query
 name: timeout
 schema:
 description: \|-
 Override the system-level timeout for this request.
 Accepts a value in milliseconds.
 type: number
 \- in: query
 name: token
 schema:
 description: The authorization token
 type: string
 \- in: query
 name: trackingId
 schema:
 description: Custom session identifier
 type: string
 requestBody:
 content: {}
 responses:
 '101':
 description: Indicates successful WebSocket upgrade.
 '400':
 code: 400
 description: The request contains errors or didn't properly encode content.
 message: HTTP/1.1 400 Bad Request
 '401':
 code: 401
 description: The request is missing, or contains bad, authorization credentials.
 message: HTTP/1.1 401 Unauthorized
 '404':
 code: 404
 description: Resource couldn't be found.
 message: HTTP/1.1 404 Not Found
 '408':
 code: 408
 description: The request took has taken too long to process.
 message: HTTP/1.1 408 Request Timeout
 '429':
 code: 429
 description: Too many requests are currently being processed.
 message: HTTP/1.1 429 Too Many Requests
 '500':
 code: 500
 description: An internal error occurred when handling the request.
 message: HTTP/1.1 500 Internal Server Error
 summary: /devtools/page/\*
 tags:
 \- Browser WebSocket APIs
 /chrome/playwright:
 get:
 definitions: {}
 description: Connect to Chromium with any playwright style library.
 parameters:
 \- in: query
 name: blockAds
 schema:
 description: \|-
 Whether or nor to load ad-blocking extensions for the session.
 This currently uses uBlock-Lite and may cause certain sites
 to not load properly.
 type: boolean
 \- in: query
 name: launch
 schema:
 description: \|-
 Launch options, which can be either an object
 of puppeteer.launch options or playwright.launchServer
 options, depending on the API. Must be either JSON
 object, or a base64-encoded JSON object.
 anyOf:
 \- $ref: '#/definitions/BrowserServerOptions'
 \- type: string
 \- in: query
 name: timeout
 schema:
 description: \|-
 Override the system-level timeout for this request.
 Accepts a value in milliseconds.
 type: number
 \- in: query
 name: token
 schema:
 description: The authorization token
 type: string
 \- in: query
 name: trackingId
 schema:
 description: Custom session identifier
 type: string
 requestBody:
 content: {}
 responses:
 '101':
 description: Indicates successful WebSocket upgrade.
 '400':
 code: 400
 description: The request contains errors or didn't properly encode content.
 message: HTTP/1.1 400 Bad Request
 '401':
 code: 401
 description: The request is missing, or contains bad, authorization credentials.
 message: HTTP/1.1 401 Unauthorized
 '404':
 code: 404
 description: Resource couldn't be found.
 message: HTTP/1.1 404 Not Found
 '408':
 code: 408
 description: The request took has taken too long to process.
 message: HTTP/1.1 408 Request Timeout
 '429':
 code: 429
 description: Too many requests are currently being processed.
 message: HTTP/1.1 429 Too Many Requests
 '500':
 code: 500
 description: An internal error occurred when handling the request.
 message: HTTP/1.1 500 Internal Server Error
 summary: /chrome/playwright
 tags:
 \- Browser WebSocket APIs
 /chromium:
 get:
 definitions: {}
 description: >-
 Launch and connect to Chromium with a library like puppeteer or others
 that work over chrome-devtools-protocol.

 \*\*Note:\*\* This endpoint is also available at: \`\` for backwards
 compatibility.
 parameters:
 \- in: query
 name: blockAds
 schema:
 description: \|-
 Whether or nor to load ad-blocking extensions for the session.
 This currently uses uBlock-Lite and may cause certain sites
 to not load properly.
 type: boolean
 \- in: query
 name: launch
 schema:
 description: \|-
 Launch options, which can be either an object
 of puppeteer.launch options or playwright.launchServer
 options, depending on the API. Must be either JSON
 object, or a base64-encoded JSON object.
 anyOf:
 \- $ref: >-
 #/definitions/import("/home/runner/work/enterprise/enterprise/node\_modules/@browserless.io/browserless/build/types",{with:{"resolution-mode":"import"}}).CDPLaunchOptions
 \- type: string
 \- in: query
 name: record
 schema:
 type: boolean
 \- in: query
 name: timeout
 schema:
 description: \|-
 Override the system-level timeout for this request.
 Accepts a value in milliseconds.
 type: number
 \- in: query
 name: token
 schema:
 description: The authorization token
 type: string
 \- in: query
 name: trackingId
 schema:
 description: Custom session identifier
 type: string
 requestBody:
 content: {}
 responses:
 '101':
 description: Indicates successful WebSocket upgrade.
 '400':
 code: 400
 description: The request contains errors or didn't properly encode content.
 message: HTTP/1.1 400 Bad Request
 '401':
 code: 401
 description: The request is missing, or contains bad, authorization credentials.
 message: HTTP/1.1 401 Unauthorized
 '404':
 code: 404
 description: Resource couldn't be found.
 message: HTTP/1.1 404 Not Found
 '408':
 code: 408
 description: The request took has taken too long to process.
 message: HTTP/1.1 408 Request Timeout
 '429':
 code: 429
 description: Too many requests are currently being processed.
 message: HTTP/1.1 429 Too Many Requests
 '500':
 code: 500
 description: An internal error occurred when handling the request.
 message: HTTP/1.1 500 Internal Server Error
 summary: /chromium
 tags:
 \- Browser WebSocket APIs
 /playwright/chromium:
 get:
 definitions: {}
 description: >-
 Connect to Chromium with any playwright style library.

 \*\*Note:\*\* This endpoint is also available at: \`/chromium/playwright\` for
 backwards compatibility.
 parameters:
 \- in: query
 name: blockAds
 schema:
 description: \|-
 Whether or nor to load ad-blocking extensions for the session.
 This currently uses uBlock-Lite and may cause certain sites
 to not load properly.
 type: boolean
 \- in: query
 name: launch
 schema:
 description: \|-
 Launch options, which can be either an object
 of puppeteer.launch options or playwright.launchServer
 options, depending on the API. Must be either JSON
 object, or a base64-encoded JSON object.
 anyOf:
 \- $ref: '#/definitions/BrowserServerOptions'
 \- type: string
 \- in: query
 name: timeout
 schema:
 description: \|-
 Override the system-level timeout for this request.
 Accepts a value in milliseconds.
 type: number
 \- in: query
 name: token
 schema:
 description: The authorization token
 type: string
 \- in: query
 name: trackingId
 schema:
 description: Custom session identifier
 type: string
 requestBody:
 content: {}
 responses:
 '101':
 description: Indicates successful WebSocket upgrade.
 '400':
 code: 400
 description: The request contains errors or didn't properly encode content.
 message: HTTP/1.1 400 Bad Request
 '401':
 code: 401
 description: The request is missing, or contains bad, authorization credentials.
 message: HTTP/1.1 401 Unauthorized
 '404':
 code: 404
 description: Resource couldn't be found.
 message: HTTP/1.1 404 Not Found
 '408':
 code: 408
 description: The request took has taken too long to process.
 message: HTTP/1.1 408 Request Timeout
 '429':
 code: 429
 description: Too many requests are currently being processed.
 message: HTTP/1.1 429 Too Many Requests
 '500':
 code: 500
 description: An internal error occurred when handling the request.
 message: HTTP/1.1 500 Internal Server Error
 summary: /playwright/chromium
 tags:
 \- Browser WebSocket APIs
 /edge:
 get:
 definitions: {}
 description: >-
 Launch and connect to Chromium with a library like puppeteer or others
 that work over chrome-devtools-protocol.
 parameters:
 \- in: query
 name: blockAds
 schema:
 description: \|-
 Whether or nor to load ad-blocking extensions for the session.
 This currently uses uBlock-Lite and may cause certain sites
 to not load properly.
 type: boolean
 \- in: query
 name: launch
 schema:
 description: \|-
 Launch options, which can be either an object
 of puppeteer.launch options or playwright.launchServer
 options, depending on the API. Must be either JSON
 object, or a base64-encoded JSON object.
 anyOf:
 \- $ref: '#/definitions/CDPLaunchOptions'
 \- type: string
 \- in: query
 name: timeout
 schema:
 description: \|-
 Override the system-level timeout for this request.
 Accepts a value in milliseconds.
 type: number
 \- in: query
 name: token
 schema:
 description: The authorization token
 type: string
 \- in: query
 name: trackingId
 schema:
 description: Custom session identifier
 type: string
 requestBody:
 content: {}
 responses:
 '101':
 description: Indicates successful WebSocket upgrade.
 '400':
 code: 400
 description: The request contains errors or didn't properly encode content.
 message: HTTP/1.1 400 Bad Request
 '401':
 code: 401
 description: The request is missing, or contains bad, authorization credentials.
 message: HTTP/1.1 401 Unauthorized
 '404':
 code: 404
 description: Resource couldn't be found.
 message: HTTP/1.1 404 Not Found
 '408':
 code: 408
 description: The request took has taken too long to process.
 message: HTTP/1.1 408 Request Timeout
 '429':
 code: 429
 description: Too many requests are currently being processed.
 message: HTTP/1.1 429 Too Many Requests
 '500':
 code: 500
 description: An internal error occurred when handling the request.
 message: HTTP/1.1 500 Internal Server Error
 summary: /edge
 tags:
 \- Browser WebSocket APIs
 /edge/playwright:
 get:
 definitions: {}
 description: Connect to Chromium with any playwright style library.
 parameters:
 \- in: query
 name: blockAds
 schema:
 description: \|-
 Whether or nor to load ad-blocking extensions for the session.
 This currently uses uBlock-Lite and may cause certain sites
 to not load properly.
 type: boolean
 \- in: query
 name: launch
 schema:
 description: \|-
 Launch options, which can be either an object
 of puppeteer.launch options or playwright.launchServer
 options, depending on the API. Must be either JSON
 object, or a base64-encoded JSON object.
 anyOf:
 \- $ref: '#/definitions/BrowserServerOptions'
 \- type: string
 \- in: query
 name: timeout
 schema:
 description: \|-
 Override the system-level timeout for this request.
 Accepts a value in milliseconds.
 type: number
 \- in: query
 name: token
 schema:
 description: The authorization token
 type: string
 \- in: query
 name: trackingId
 schema:
 description: Custom session identifier
 type: string
 requestBody:
 content: {}
 responses:
 '101':
 description: Indicates successful WebSocket upgrade.
 '400':
 code: 400
 description: The request contains errors or didn't properly encode content.
 message: HTTP/1.1 400 Bad Request
 '401':
 code: 401
 description: The request is missing, or contains bad, authorization credentials.
 message: HTTP/1.1 401 Unauthorized
 '404':
 code: 404
 description: Resource couldn't be found.
 message: HTTP/1.1 404 Not Found
 '408':
 code: 408
 description: The request took has taken too long to process.
 message: HTTP/1.1 408 Request Timeout
 '429':
 code: 429
 description: Too many requests are currently being processed.
 message: HTTP/1.1 429 Too Many Requests
 '500':
 code: 500
 description: An internal error occurred when handling the request.
 message: HTTP/1.1 500 Internal Server Error
 summary: /edge/playwright
 tags:
 \- Browser WebSocket APIs
 /playwright/firefox:
 get:
 definitions: {}
 description: >-
 Connect to Firefox with any playwright-compliant library.

 \*\*Note:\*\* This endpoint is also available at: \`/firefox/playwright\` for
 backwards compatibility.
 parameters:
 \- in: query
 name: blockAds
 schema:
 description: \|-
 Whether or nor to load ad-blocking extensions for the session.
 This currently uses uBlock-Lite and may cause certain sites
 to not load properly.
 type: boolean
 \- in: query
 name: launch
 schema:
 description: \|-
 Launch options, which can be either an object
 of puppeteer.launch options or playwright.launchServer
 options, depending on the API. Must be either JSON
 object, or a base64-encoded JSON object.
 additionalProperties: false
 type: object
 properties:
 args:
 type: array
 items:
 type: string
 chromiumSandbox:
 type: boolean
 devtools:
 type: boolean
 downloadsPath:
 type: string
 headless:
 type: boolean
 ignoreDefaultArgs:
 anyOf:
 \- type: array
 items:
 type: string
 \- type: boolean
 proxy:
 type: object
 properties:
 bypass:
 type: string
 password:
 type: string
 server:
 type: string
 username:
 type: string
 additionalProperties: false
 required:
 \- server
 timeout:
 type: number
 tracesDir:
 type: string
 firefoxUserPrefs:
 type: object
 additionalProperties:
 type:
 \- string
 \- number
 \- boolean
 \- in: query
 name: timeout
 schema:
 description: \|-
 Override the system-level timeout for this request.
 Accepts a value in milliseconds.
 type: number
 \- in: query
 name: token
 schema:
 description: The authorization token
 type: string
 \- in: query
 name: trackingId
 schema:
 description: Custom session identifier
 type: string
 requestBody:
 content: {}
 responses:
 '101':
 description: Indicates successful WebSocket upgrade.
 '400':
 code: 400
 description: The request contains errors or didn't properly encode content.
 message: HTTP/1.1 400 Bad Request
 '401':
 code: 401
 description: The request is missing, or contains bad, authorization credentials.
 message: HTTP/1.1 401 Unauthorized
 '404':
 code: 404
 description: Resource couldn't be found.
 message: HTTP/1.1 404 Not Found
 '408':
 code: 408
 description: The request took has taken too long to process.
 message: HTTP/1.1 408 Request Timeout
 '429':
 code: 429
 description: Too many requests are currently being processed.
 message: HTTP/1.1 429 Too Many Requests
 '500':
 code: 500
 description: An internal error occurred when handling the request.
 message: HTTP/1.1 500 Internal Server Error
 summary: /playwright/firefox
 tags:
 \- Browser WebSocket APIs
 /playwright/webkit:
 get:
 definitions: {}
 description: >-
 Connect to Webkit with any playwright-compliant library.

 \*\*Note:\*\* This endpoint is also available at: \`/webkit/playwright\` for
 backwards compatibility.
 parameters:
 \- in: query
 name: blockAds
 schema:
 description: \|-
 Whether or nor to load ad-blocking extensions for the session.
 This currently uses uBlock-Lite and may cause certain sites
 to not load properly.
 type: boolean
 \- in: query
 name: launch
 schema:
 description: \|-
 Launch options, which can be either an object
 of puppeteer.launch options or playwright.launchServer
 options, depending on the API. Must be either JSON
 object, or a base64-encoded JSON object.
 anyOf:
 \- $ref: '#/definitions/BrowserServerOptions'
 \- type: string
 \- in: query
 name: timeout
 schema:
 description: \|-
 Override the system-level timeout for this request.
 Accepts a value in milliseconds.
 type: number
 \- in: query
 name: token
 schema:
 description: The authorization token
 type: string
 \- in: query
 name: trackingId
 schema:
 description: Custom session identifier
 type: string
 requestBody:
 content: {}
 responses:
 '101':
 description: Indicates successful WebSocket upgrade.
 '400':
 code: 400
 description: The request contains errors or didn't properly encode content.
 message: HTTP/1.1 400 Bad Request
 '401':
 code: 401
 description: The request is missing, or contains bad, authorization credentials.
 message: HTTP/1.1 401 Unauthorized
 '404':
 code: 404
 description: Resource couldn't be found.
 message: HTTP/1.1 404 Not Found
 '408':
 code: 408
 description: The request took has taken too long to process.
 message: HTTP/1.1 408 Request Timeout
 '429':
 code: 429
 description: Too many requests are currently being processed.
 message: HTTP/1.1 429 Too Many Requests
 '500':
 code: 500
 description: An internal error occurred when handling the request.
 message: HTTP/1.1 500 Internal Server Error
 summary: /playwright/webkit
 tags:
 \- Browser WebSocket APIs
 /chrome/export:
 post:
 definitions: {}
 description: >-
 \> This API is only available for Enterprise, hosted and self-hosted
 plans. \[Contact us for more information\
 here.\](https://www.browserless.io/contact/)

 Exports a webpage to a PDF or image format. This API is useful for
 generating reports, screenshots, or PDFs of web pages.
 parameters:
 \- in: query
 name: blockAds
 schema:
 description: \|-
 Whether or nor to load ad-blocking extensions for the session.
 This currently uses uBlock-Lite and may cause certain sites
 to not load properly.
 type: boolean
 \- in: query
 name: launch
 schema:
 description: \|-
 Launch options, which can be either an object
 of puppeteer.launch options or playwright.launchServer
 options, depending on the API. Must be either JSON
 object, or a base64-encoded JSON object.
 anyOf:
 \- $ref: >-
 #/definitions/import("/home/runner/work/enterprise/enterprise/node\_modules/@browserless.io/browserless/build/types",{with:{"resolution-mode":"import"}}).CDPLaunchOptions
 \- type: string
 \- in: query
 name: timeout
 schema:
 description: \|-
 Override the system-level timeout for this request.
 Accepts a value in milliseconds.
 type: number
 \- in: query
 name: token
 schema:
 description: The authorization token
 type: string
 \- in: query
 name: trackingId
 schema:
 description: Custom session identifier
 type: string
 requestBody:
 content:
 application/json:
 schema:
 properties:
 bestAttempt:
 description: >-
 When bestAttempt is set to true, browserless attempt to
 proceed

 when "awaited" events fail or timeout. This includes things
 like

 goto, waitForSelector, and more.
 type: boolean
 url:
 description: The URL of the site you want to archive.
 type: string
 gotoOptions:
 $ref: '#/definitions/GoToOptions'
 description: >-
 An optional goto parameter object for considering when the
 page is done loading.
 waitForEvent:
 type: object
 properties:
 event:
 type: string
 timeout:
 type: number
 additionalProperties: false
 required:
 \- event
 waitForFunction:
 type: object
 properties:
 fn:
 description: >-
 The function, or statement, to be evaluated in browser
 context
 type: string
 polling:
 description: >-
 An interval at which the pageFunction is executed,
 defaults to raf.

 If polling is a number, then it is treated as an
 interval in milliseconds

 at which the function would be executed. If polling is a
 string,

 then it can be one of the following values: "raf" or
 "mutation"
 type:
 \- string
 \- number
 timeout:
 description: >-
 Maximum time to wait for in milliseconds. Defaults to
 30000 (30 seconds).

 Pass 0 to disable timeout.
 type: number
 additionalProperties: false
 required:
 \- fn
 waitForSelector:
 type: object
 properties:
 hidden:
 type: boolean
 selector:
 type: string
 timeout:
 type: number
 visible:
 type: boolean
 additionalProperties: false
 required:
 \- selector
 waitForTimeout:
 type: number
 headers:
 $ref: '#/definitions/Record'
 type: object
 responses:
 '200':
 content:
 application/json:
 schema:
 type: object
 properties:
 html:
 description: The HTML content of the page.
 type: string
 additionalProperties: false
 required:
 \- html
 $schema: http://json-schema.org/draft-07/schema#
 '400':
 code: 400
 description: The request contains errors or didn't properly encode content.
 message: HTTP/1.1 400 Bad Request
 '401':
 code: 401
 description: The request is missing, or contains bad, authorization credentials.
 message: HTTP/1.1 401 Unauthorized
 '404':
 code: 404
 description: Resource couldn't be found.
 message: HTTP/1.1 404 Not Found
 '408':
 code: 408
 description: The request took has taken too long to process.
 message: HTTP/1.1 408 Request Timeout
 '429':
 code: 429
 description: Too many requests are currently being processed.
 message: HTTP/1.1 429 Too Many Requests
 '500':
 code: 500
 description: An internal error occurred when handling the request.
 message: HTTP/1.1 500 Internal Server Error
 summary: /chrome/export
 tags:
 \- Browser REST APIs
 /chrome/unblock:
 post:
 definitions: {}
 description: >-
 \> This API is only available for Enterprise and Cloud-unit plans.
 \[Contact us for more information\
 here.\](https://www.browserless.io/contact/), or \[sign-up\
 here\](https://www.browserless.io/pricing/).

 Unblocks the provided URL from being blocked due to bot detection.

 Returns a payload of Cookies, HTML, a base64 encoded screenshot,

 and a "browserWSEndpoint" to allow connecting to the browser when

 specified in the JSON Payload. Only supports CDP or Puppeteer

 like libraries when connecting to the "browserWSEndpoint".
 parameters:
 \- in: query
 name: blockAds
 schema:
 description: \|-
 Whether or nor to load ad-blocking extensions for the session.
 This currently uses uBlock-Lite and may cause certain sites
 to not load properly.
 type: boolean
 \- in: query
 name: launch
 schema:
 description: \|-
 Launch options, which can be either an object
 of puppeteer.launch options or playwright.launchServer
 options, depending on the API. Must be either JSON
 object, or a base64-encoded JSON object.
 anyOf:
 \- $ref: >-
 #/definitions/import("/home/runner/work/enterprise/enterprise/node\_modules/@browserless.io/browserless/build/types",{with:{"resolution-mode":"import"}}).CDPLaunchOptions
 \- type: string
 \- in: query
 name: timeout
 schema:
 description: \|-
 Override the system-level timeout for this request.
 Accepts a value in milliseconds.
 type: number
 \- in: query
 name: token
 schema:
 description: The authorization token
 type: string
 \- in: query
 name: trackingId
 schema:
 description: Custom session identifier
 type: string
 requestBody:
 content:
 application/json:
 schema:
 properties:
 bestAttempt:
 description: >-
 When bestAttempt is set to true, browserless attempt to
 proceed

 when "awaited" events fail or timeout. This includes things
 like

 goto, waitForSelector, and more.
 type: boolean
 url:
 description: The URL of the site you want to unblock.
 type: string
 browserWSEndpoint:
 description: >-
 Whether or not to keep the underlying browser alive and
 around for

 future reconnects. Defaults to false.
 type: boolean
 cookies:
 description: >-
 Whether or not to to return cookies for the site, defaults
 to true.
 type: boolean
 content:
 description: >-
 Whether or not to to return content for the site, defaults
 to true.
 type: boolean
 screenshot:
 description: >-
 Whether or not to to return a full-page screenshot for the
 site, defaults to true.
 type: boolean
 ttl:
 description: \|-
 When the browserWSEndpoint is requested this tells
 browserless how long to keep this browser alive for
 re-connection until shutting it down completely.
 Maximum of 30000 for 30 seconds (30,000ms).
 type: number
 gotoOptions:
 $ref: '#/definitions/GoToOptions'
 description: >-
 An optional goto parameter object for considering when the
 page is done loading.
 waitForEvent:
 type: object
 properties:
 event:
 type: string
 timeout:
 type: number
 additionalProperties: false
 required:
 \- event
 waitForFunction:
 type: object
 properties:
 fn:
 description: >-
 The function, or statement, to be evaluated in browser
 context
 type: string
 polling:
 description: >-
 An interval at which the pageFunction is executed,
 defaults to raf.

 If polling is a number, then it is treated as an
 interval in milliseconds

 at which the function would be executed. If polling is a
 string,

 then it can be one of the following values: "raf" or
 "mutation"
 type:
 \- string
 \- number
 timeout:
 description: >-
 Maximum time to wait for in milliseconds. Defaults to
 30000 (30 seconds).

 Pass 0 to disable timeout.
 type: number
 additionalProperties: false
 required:
 \- fn
 waitForSelector:
 type: object
 properties:
 hidden:
 type: boolean
 selector:
 type: string
 timeout:
 type: number
 visible:
 type: boolean
 additionalProperties: false
 required:
 \- selector
 waitForTimeout:
 type: number
 type: object
 responses:
 '200':
 content:
 application/json:
 schema:
 type: object
 properties:
 cookies:
 description: >-
 A list of cookies which can be used for new connections or
 for usage elsewhere.

 Value is "null" when the request body specifies cookies:
 false.
 type: array
 items:
 $ref: '#/definitions/Cookie'
 content:
 description: >-
 The HTML content of the page once it is passed bot
 detection.

 Value is "null" when the request body specifies cookies:
 false.
 type: string
 browserWSEndpoint:
 description: >-
 The browserWSEndpoint of the response when the POST body
 contains a

 browserWSEndpoint: true property
 type: string
 ttl:
 description: >-
 The time the browser will remain alive until it is
 shutdown. Zero

 when browserWSEndpoint: false is set in the request
 payload. The limit

 is 30000 or 30 seconds, which is the maximum allowed time.
 type: number
 screenshot:
 description: A base64 encoded JPEG of the of the final site page.
 type: string
 additionalProperties: false
 required:
 \- browserWSEndpoint
 \- content
 \- cookies
 \- screenshot
 \- ttl
 definitions:
 Cookie:
 description: Represents a cookie object.
 type: object
 properties:
 name:
 description: Cookie name.
 type: string
 value:
 description: Cookie value.
 type: string
 domain:
 description: Cookie domain.
 type: string
 path:
 description: Cookie path.
 type: string
 expires:
 description: >-
 Cookie expiration date as the number of seconds since
 the UNIX epoch. Set to \`-1\` for

 session cookies
 type: number
 size:
 description: Cookie size.
 type: number
 httpOnly:
 description: True if cookie is http-only.
 type: boolean
 secure:
 description: True if cookie is secure.
 type: boolean
 session:
 description: True in case of session cookie.
 type: boolean
 sameSite:
 $ref: '#/definitions/CookieSameSite'
 description: Cookie SameSite type.
 priority:
 $ref: '#/definitions/CookiePriority'
 description: Cookie Priority. Supported only in Chrome.
 sameParty:
 description: True if cookie is SameParty. Supported only in Chrome.
 type: boolean
 sourceScheme:
 $ref: '#/definitions/CookieSourceScheme'
 description: Cookie source scheme type. Supported only in Chrome.
 partitionKey:
 description: >-
 Cookie partition key. In Chrome, it is the top-level
 site the

 partitioned cookie is available in. In Firefox, it
 matches the

 source origin in the

 {@link
 https://w3c.github.io/webdriver-bidi/#type-storage-PartitionKey
 PartitionKey}.
 anyOf:
 \- $ref: '#/definitions/CookiePartitionKey'
 \- type: string
 partitionKeyOpaque:
 description: >-
 True if cookie partition key is opaque. Supported only
 in Chrome.
 type: boolean
 additionalProperties: false
 required:
 \- domain
 \- expires
 \- httpOnly
 \- name
 \- path
 \- secure
 \- session
 \- size
 \- value
 CookieSameSite:
 description: \|-
 Represents the cookie's 'SameSite' status:
 https://tools.ietf.org/html/draft-west-first-party-cookies
 enum:
 \- Lax
 \- None
 \- Strict
 type: string
 CookiePriority:
 description: \|-
 Represents the cookie's 'Priority' status:
 https://tools.ietf.org/html/draft-west-cookie-priority-00
 enum:
 \- High
 \- Low
 \- Medium
 type: string
 CookieSourceScheme:
 description: >-
 Represents the source scheme of the origin that originally
 set the cookie. A value of

 "Unset" allows protocol clients to emulate legacy cookie
 scope for the scheme.

 This is a temporary ability and it will be removed in the
 future.
 enum:
 \- NonSecure
 \- Secure
 \- Unset
 type: string
 CookiePartitionKey:
 description: Represents a cookie partition key in Chrome.
 type: object
 properties:
 sourceOrigin:
 description: >-
 The site of the top-level URL the browser was visiting
 at the start of the request

 to the endpoint that set the cookie.

 In Chrome, maps to the CDP's \`topLevelSite\` partition
 key.
 type: string
 hasCrossSiteAncestor:
 description: >-
 Indicates if the cookie has any ancestors that are
 cross-site to

 the topLevelSite.

 Supported only in Chrome.
 type: boolean
 additionalProperties: false
 required:
 \- sourceOrigin
 $schema: http://json-schema.org/draft-07/schema#
 '400':
 code: 400
 description: The request contains errors or didn't properly encode content.
 message: HTTP/1.1 400 Bad Request
 '401':
 code: 401
 description: The request is missing, or contains bad, authorization credentials.
 message: HTTP/1.1 401 Unauthorized
 '404':
 code: 404
 description: Resource couldn't be found.
 message: HTTP/1.1 404 Not Found
 '408':
 code: 408
 description: The request took has taken too long to process.
 message: HTTP/1.1 408 Request Timeout
 '429':
 code: 429
 description: Too many requests are currently being processed.
 message: HTTP/1.1 429 Too Many Requests
 '500':
 code: 500
 description: An internal error occurred when handling the request.
 message: HTTP/1.1 500 Internal Server Error
 summary: /chrome/unblock
 tags:
 \- Browser REST APIs
 /chromium/export:
 post:
 definitions: {}
 description: >-
 \> This API is only available for Enterprise, hosted and self-hosted
 plans. \[Contact us for more information\
 here.\](https://www.browserless.io/contact/)

 Exports a webpage to a PDF or image format. This API is useful for
 generating reports, screenshots, or PDFs of web pages.

 \*\*Note:\*\* This endpoint is also available at: \`/export\` for backwards
 compatibility.
 parameters:
 \- in: query
 name: blockAds
 schema:
 description: \|-
 Whether or nor to load ad-blocking extensions for the session.
 This currently uses uBlock-Lite and may cause certain sites
 to not load properly.
 type: boolean
 \- in: query
 name: launch
 schema:
 description: \|-
 Launch options, which can be either an object
 of puppeteer.launch options or playwright.launchServer
 options, depending on the API. Must be either JSON
 object, or a base64-encoded JSON object.
 anyOf:
 \- $ref: >-
 #/definitions/import("/home/runner/work/enterprise/enterprise/node\_modules/@browserless.io/browserless/build/types",{with:{"resolution-mode":"import"}}).CDPLaunchOptions
 \- type: string
 \- in: query
 name: timeout
 schema:
 description: \|-
 Override the system-level timeout for this request.
 Accepts a value in milliseconds.
 type: number
 \- in: query
 name: token
 schema:
 description: The authorization token
 type: string
 \- in: query
 name: trackingId
 schema:
 description: Custom session identifier
 type: string
 requestBody:
 content:
 application/json:
 schema:
 properties:
 bestAttempt:
 description: >-
 When bestAttempt is set to true, browserless attempt to
 proceed

 when "awaited" events fail or timeout. This includes things
 like

 goto, waitForSelector, and more.
 type: boolean
 url:
 description: The URL of the site you want to archive.
 type: string
 gotoOptions:
 $ref: '#/definitions/GoToOptions'
 description: >-
 An optional goto parameter object for considering when the
 page is done loading.
 waitForEvent:
 type: object
 properties:
 event:
 type: string
 timeout:
 type: number
 additionalProperties: false
 required:
 \- event
 waitForFunction:
 type: object
 properties:
 fn:
 description: >-
 The function, or statement, to be evaluated in browser
 context
 type: string
 polling:
 description: >-
 An interval at which the pageFunction is executed,
 defaults to raf.

 If polling is a number, then it is treated as an
 interval in milliseconds

 at which the function would be executed. If polling is a
 string,

 then it can be one of the following values: "raf" or
 "mutation"
 type:
 \- string
 \- number
 timeout:
 description: >-
 Maximum time to wait for in milliseconds. Defaults to
 30000 (30 seconds).

 Pass 0 to disable timeout.
 type: number
 additionalProperties: false
 required:
 \- fn
 waitForSelector:
 type: object
 properties:
 hidden:
 type: boolean
 selector:
 type: string
 timeout:
 type: number
 visible:
 type: boolean
 additionalProperties: false
 required:
 \- selector
 waitForTimeout:
 type: number
 headers:
 $ref: '#/definitions/Record'
 type: object
 responses:
 '200':
 content:
 application/json:
 schema:
 type: object
 properties:
 html:
 description: The HTML content of the page.
 type: string
 additionalProperties: false
 required:
 \- html
 $schema: http://json-schema.org/draft-07/schema#
 '400':
 code: 400
 description: The request contains errors or didn't properly encode content.
 message: HTTP/1.1 400 Bad Request
 '401':
 code: 401
 description: The request is missing, or contains bad, authorization credentials.
 message: HTTP/1.1 401 Unauthorized
 '404':
 code: 404
 description: Resource couldn't be found.
 message: HTTP/1.1 404 Not Found
 '408':
 code: 408
 description: The request took has taken too long to process.
 message: HTTP/1.1 408 Request Timeout
 '429':
 code: 429
 description: Too many requests are currently being processed.
 message: HTTP/1.1 429 Too Many Requests
 '500':
 code: 500
 description: An internal error occurred when handling the request.
 message: HTTP/1.1 500 Internal Server Error
 summary: /chromium/export
 tags:
 \- Browser REST APIs
 /chromium/unblock:
 post:
 definitions: {}
 description: >-
 \> This API is only available for Enterprise and Cloud-unit plans.
 \[Contact us for more information\
 here.\](https://www.browserless.io/contact/), or \[sign-up\
 here\](https://www.browserless.io/pricing/).

 Unblocks the provided URL from being blocked due to bot detection.

 Returns a payload of Cookies, HTML, a base64 encoded screenshot,

 and a "browserWSEndpoint" to allow connecting to the browser when

 specified in the JSON Payload. Only supports CDP or Puppeteer

 like libraries when connecting to the "browserWSEndpoint".

 \*\*Note:\*\* This endpoint is also available at: \`/unblock\` for backwards
 compatibility.
 parameters:
 \- in: query
 name: blockAds
 schema:
 description: \|-
 Whether or nor to load ad-blocking extensions for the session.
 This currently uses uBlock-Lite and may cause certain sites
 to not load properly.
 type: boolean
 \- in: query
 name: launch
 schema:
 description: \|-
 Launch options, which can be either an object
 of puppeteer.launch options or playwright.launchServer
 options, depending on the API. Must be either JSON
 object, or a base64-encoded JSON object.
 anyOf:
 \- $ref: >-
 #/definitions/import("/home/runner/work/enterprise/enterprise/node\_modules/@browserless.io/browserless/build/types",{with:{"resolution-mode":"import"}}).CDPLaunchOptions
 \- type: string
 \- in: query
 name: timeout
 schema:
 description: \|-
 Override the system-level timeout for this request.
 Accepts a value in milliseconds.
 type: number
 \- in: query
 name: token
 schema:
 description: The authorization token
 type: string
 \- in: query
 name: trackingId
 schema:
 description: Custom session identifier
 type: string
 requestBody:
 content:
 application/json:
 schema:
 properties:
 bestAttempt:
 description: >-
 When bestAttempt is set to true, browserless attempt to
 proceed

 when "awaited" events fail or timeout. This includes things
 like

 goto, waitForSelector, and more.
 type: boolean
 url:
 description: The URL of the site you want to unblock.
 type: string
 browserWSEndpoint:
 description: >-
 Whether or not to keep the underlying browser alive and
 around for

 future reconnects. Defaults to false.
 type: boolean
 cookies:
 description: >-
 Whether or not to to return cookies for the site, defaults
 to true.
 type: boolean
 content:
 description: >-
 Whether or not to to return content for the site, defaults
 to true.
 type: boolean
 screenshot:
 description: >-
 Whether or not to to return a full-page screenshot for the
 site, defaults to true.
 type: boolean
 ttl:
 description: \|-
 When the browserWSEndpoint is requested this tells
 browserless how long to keep this browser alive for
 re-connection until shutting it down completely.
 Maximum of 30000 for 30 seconds (30,000ms).
 type: number
 gotoOptions:
 $ref: '#/definitions/GoToOptions'
 description: >-
 An optional goto parameter object for considering when the
 page is done loading.
 waitForEvent:
 type: object
 properties:
 event:
 type: string
 timeout:
 type: number
 additionalProperties: false
 required:
 \- event
 waitForFunction:
 type: object
 properties:
 fn:
 description: >-
 The function, or statement, to be evaluated in browser
 context
 type: string
 polling:
 description: >-
 An interval at which the pageFunction is executed,
 defaults to raf.

 If polling is a number, then it is treated as an
 interval in milliseconds

 at which the function would be executed. If polling is a
 string,

 then it can be one of the following values: "raf" or
 "mutation"
 type:
 \- string
 \- number
 timeout:
 description: >-
 Maximum time to wait for in milliseconds. Defaults to
 30000 (30 seconds).

 Pass 0 to disable timeout.
 type: number
 additionalProperties: false
 required:
 \- fn
 waitForSelector:
 type: object
 properties:
 hidden:
 type: boolean
 selector:
 type: string
 timeout:
 type: number
 visible:
 type: boolean
 additionalProperties: false
 required:
 \- selector
 waitForTimeout:
 type: number
 type: object
 responses:
 '200':
 content:
 application/json:
 schema:
 type: object
 properties:
 cookies:
 description: >-
 A list of cookies which can be used for new connections or
 for usage elsewhere.

 Value is "null" when the request body specifies cookies:
 false.
 type: array
 items:
 $ref: '#/definitions/Cookie'
 content:
 description: >-
 The HTML content of the page once it is passed bot
 detection.

 Value is "null" when the request body specifies cookies:
 false.
 type: string
 browserWSEndpoint:
 description: >-
 The browserWSEndpoint of the response when the POST body
 contains a

 browserWSEndpoint: true property
 type: string
 ttl:
 description: >-
 The time the browser will remain alive until it is
 shutdown. Zero

 when browserWSEndpoint: false is set in the request
 payload. The limit

 is 30000 or 30 seconds, which is the maximum allowed time.
 type: number
 screenshot:
 description: A base64 encoded JPEG of the of the final site page.
 type: string
 additionalProperties: false
 required:
 \- browserWSEndpoint
 \- content
 \- cookies
 \- screenshot
 \- ttl
 definitions:
 Cookie:
 description: Represents a cookie object.
 type: object
 properties:
 name:
 description: Cookie name.
 type: string
 value:
 description: Cookie value.
 type: string
 domain:
 description: Cookie domain.
 type: string
 path:
 description: Cookie path.
 type: string
 expires:
 description: >-
 Cookie expiration date as the number of seconds since
 the UNIX epoch. Set to \`-1\` for

 session cookies
 type: number
 size:
 description: Cookie size.
 type: number
 httpOnly:
 description: True if cookie is http-only.
 type: boolean
 secure:
 description: True if cookie is secure.
 type: boolean
 session:
 description: True in case of session cookie.
 type: boolean
 sameSite:
 $ref: '#/definitions/CookieSameSite'
 description: Cookie SameSite type.
 priority:
 $ref: '#/definitions/CookiePriority'
 description: Cookie Priority. Supported only in Chrome.
 sameParty:
 description: True if cookie is SameParty. Supported only in Chrome.
 type: boolean
 sourceScheme:
 $ref: '#/definitions/CookieSourceScheme'
 description: Cookie source scheme type. Supported only in Chrome.
 partitionKey:
 description: >-
 Cookie partition key. In Chrome, it is the top-level
 site the

 partitioned cookie is available in. In Firefox, it
 matches the

 source origin in the

 {@link
 https://w3c.github.io/webdriver-bidi/#type-storage-PartitionKey
 PartitionKey}.
 anyOf:
 \- $ref: '#/definitions/CookiePartitionKey'
 \- type: string
 partitionKeyOpaque:
 description: >-
 True if cookie partition key is opaque. Supported only
 in Chrome.
 type: boolean
 additionalProperties: false
 required:
 \- domain
 \- expires
 \- httpOnly
 \- name
 \- path
 \- secure
 \- session
 \- size
 \- value
 CookieSameSite:
 description: \|-
 Represents the cookie's 'SameSite' status:
 https://tools.ietf.org/html/draft-west-first-party-cookies
 enum:
 \- Lax
 \- None
 \- Strict
 type: string
 CookiePriority:
 description: \|-
 Represents the cookie's 'Priority' status:
 https://tools.ietf.org/html/draft-west-cookie-priority-00
 enum:
 \- High
 \- Low
 \- Medium
 type: string
 CookieSourceScheme:
 description: >-
 Represents the source scheme of the origin that originally
 set the cookie. A value of

 "Unset" allows protocol clients to emulate legacy cookie
 scope for the scheme.

 This is a temporary ability and it will be removed in the
 future.
 enum:
 \- NonSecure
 \- Secure
 \- Unset
 type: string
 CookiePartitionKey:
 description: Represents a cookie partition key in Chrome.
 type: object
 properties:
 sourceOrigin:
 description: >-
 The site of the top-level URL the browser was visiting
 at the start of the request

 to the endpoint that set the cookie.

 In Chrome, maps to the CDP's \`topLevelSite\` partition
 key.
 type: string
 hasCrossSiteAncestor:
 description: >-
 Indicates if the cookie has any ancestors that are
 cross-site to

 the topLevelSite.

 Supported only in Chrome.
 type: boolean
 additionalProperties: false
 required:
 \- sourceOrigin
 $schema: http://json-schema.org/draft-07/schema#
 '400':
 code: 400
 description: The request contains errors or didn't properly encode content.
 message: HTTP/1.1 400 Bad Request
 '401':
 code: 401
 description: The request is missing, or contains bad, authorization credentials.
 message: HTTP/1.1 401 Unauthorized
 '404':
 code: 404
 description: Resource couldn't be found.
 message: HTTP/1.1 404 Not Found
 '408':
 code: 408
 description: The request took has taken too long to process.
 message: HTTP/1.1 408 Request Timeout
 '429':
 code: 429
 description: Too many requests are currently being processed.
 message: HTTP/1.1 429 Too Many Requests
 '500':
 code: 500
 description: An internal error occurred when handling the request.
 message: HTTP/1.1 500 Internal Server Error
 summary: /chromium/unblock
 tags:
 \- Browser REST APIs
 /chrome/bql?(/\*):
 post:
 definitions: {}
 description: >-
 \> This API is only available for Enterprise, hosted and self-hosted
 plans. \[Contact us for more information\
 here.\](https://www.browserless.io/contact/)

 Parses and executes BrowserQL requests, powered by the BrowserQL Editor
 or by other API integrations. See the BrowserQL Editor for more
 documentation on this API.
 parameters:
 \- in: query
 name: blockAds
 schema:
 description: \|-
 Whether or nor to load ad-blocking extensions for the session.
 This currently uses uBlock-Lite and may cause certain sites
 to not load properly.
 type: boolean
 \- in: query
 name: blockConsentModals
 schema:
 type: boolean
 \- in: query
 name: humanlike
 schema:
 type: boolean
 \- in: query
 name: launch
 schema:
 description: \|-
 Launch options, which can be either an object
 of puppeteer.launch options or playwright.launchServer
 options, depending on the API. Must be either JSON
 object, or a base64-encoded JSON object.
 anyOf:
 \- $ref: >-
 #/definitions/import("/home/runner/work/enterprise/enterprise/node\_modules/@browserless.io/browserless/build/types",{with:{"resolution-mode":"import"}}).CDPLaunchOptions
 \- type: string
 \- in: query
 name: timeout
 schema:
 description: \|-
 Override the system-level timeout for this request.
 Accepts a value in milliseconds.
 type: number
 \- in: query
 name: token
 schema:
 description: The authorization token
 type: string
 \- in: query
 name: trackingId
 schema:
 description: Custom session identifier
 type: string
 requestBody:
 content:
 application/json:
 schema:
 properties:
 query:
 type: string
 operationName:
 type: string
 variables:
 type: object
 additionalProperties: {}
 type: object
 responses:
 '400':
 code: 400
 description: The request contains errors or didn't properly encode content.
 message: HTTP/1.1 400 Bad Request
 '401':
 code: 401
 description: The request is missing, or contains bad, authorization credentials.
 message: HTTP/1.1 401 Unauthorized
 '404':
 code: 404
 description: Resource couldn't be found.
 message: HTTP/1.1 404 Not Found
 '408':
 code: 408
 description: The request took has taken too long to process.
 message: HTTP/1.1 408 Request Timeout
 '429':
 code: 429
 description: Too many requests are currently being processed.
 message: HTTP/1.1 429 Too Many Requests
 '500':
 code: 500
 description: An internal error occurred when handling the request.
 message: HTTP/1.1 500 Internal Server Error
 summary: /chrome/bql?(/\*)
 tags:
 \- Browser REST APIs
 /chromium/bql?(/\*):
 post:
 definitions: {}
 description: >-
 \> This API is only available for Enterprise, hosted and self-hosted
 plans. \[Contact us for more information\
 here.\](https://www.browserless.io/contact/)

 Parses and executes BrowserQL requests, powered by the BrowserQL Editor
 or by other API integrations. See the BrowserQL Editor for more
 documentation on this API.
 parameters:
 \- in: query
 name: blockAds
 schema:
 description: \|-
 Whether or nor to load ad-blocking extensions for the session.
 This currently uses uBlock-Lite and may cause certain sites
 to not load properly.
 type: boolean
 \- in: query
 name: blockConsentModals
 schema:
 type: boolean
 \- in: query
 name: humanlike
 schema:
 type: boolean
 \- in: query
 name: launch
 schema:
 description: \|-
 Launch options, which can be either an object
 of puppeteer.launch options or playwright.launchServer
 options, depending on the API. Must be either JSON
 object, or a base64-encoded JSON object.
 anyOf:
 \- $ref: >-
 #/definitions/import("/home/runner/work/enterprise/enterprise/node\_modules/@browserless.io/browserless/build/types",{with:{"resolution-mode":"import"}}).CDPLaunchOptions
 \- type: string
 \- in: query
 name: timeout
 schema:
 description: \|-
 Override the system-level timeout for this request.
 Accepts a value in milliseconds.
 type: number
 \- in: query
 name: token
 schema:
 description: The authorization token
 type: string
 \- in: query
 name: trackingId
 schema:
 description: Custom session identifier
 type: string
 requestBody:
 content:
 application/json:
 schema:
 properties:
 query:
 type: string
 operationName:
 type: string
 variables:
 type: object
 additionalProperties: {}
 type: object
 responses:
 '400':
 code: 400
 description: The request contains errors or didn't properly encode content.
 message: HTTP/1.1 400 Bad Request
 '401':
 code: 401
 description: The request is missing, or contains bad, authorization credentials.
 message: HTTP/1.1 401 Unauthorized
 '404':
 code: 404
 description: Resource couldn't be found.
 message: HTTP/1.1 404 Not Found
 '408':
 code: 408
 description: The request took has taken too long to process.
 message: HTTP/1.1 408 Request Timeout
 '429':
 code: 429
 description: Too many requests are currently being processed.
 message: HTTP/1.1 429 Too Many Requests
 '500':
 code: 500
 description: An internal error occurred when handling the request.
 message: HTTP/1.1 500 Internal Server Error
 summary: /chromium/bql?(/\*)
 tags:
 \- Browser REST APIs
 /chrome/live/\*:
 get:
 definitions: {}
 description: >-
 \> This API is only available for Enterprise plans and self-hosted
 Enterprise plans. \[Contact us for more information\
 here.\](https://www.browserless.io/contact/), or \[sign-up\
 here\](https://www.browserless.io/pricing/).

 Websocket back-end that powers the live session experience.
 parameters: \[\]
 requestBody:
 content: {}
 responses:
 '101':
 description: Indicates successful WebSocket upgrade.
 '400':
 code: 400
 description: The request contains errors or didn't properly encode content.
 message: HTTP/1.1 400 Bad Request
 '401':
 code: 401
 description: The request is missing, or contains bad, authorization credentials.
 message: HTTP/1.1 401 Unauthorized
 '404':
 code: 404
 description: Resource couldn't be found.
 message: HTTP/1.1 404 Not Found
 '408':
 code: 408
 description: The request took has taken too long to process.
 message: HTTP/1.1 408 Request Timeout
 '429':
 code: 429
 description: Too many requests are currently being processed.
 message: HTTP/1.1 429 Too Many Requests
 '500':
 code: 500
 description: An internal error occurred when handling the request.
 message: HTTP/1.1 500 Internal Server Error
 summary: /chrome/live/\*
 tags:
 \- Browser WebSocket APIs
 /chrome/stealth:
 get:
 definitions: {}
 description: >-
 \> This API is only available for Enterprise and Cloud-unit plans.
 \[Contact us for more information\
 here.\](https://www.browserless.io/contact/), or \[sign-up\
 here\](https://www.browserless.io/pricing/).

 Launch and connect to Stealthy Chromium with a library like puppeteer or
 others that work over chrome-devtools-protocol for scraping in a more
 stealth-like fashion.
 parameters:
 \- in: query
 name: blockAds
 schema:
 description: \|-
 Whether or nor to load ad-blocking extensions for the session.
 This currently uses uBlock-Lite and may cause certain sites
 to not load properly.
 type: boolean
 \- in: query
 name: launch
 schema:
 description: \|-
 Launch options, which can be either an object
 of puppeteer.launch options or playwright.launchServer
 options, depending on the API. Must be either JSON
 object, or a base64-encoded JSON object.
 anyOf:
 \- $ref: >-
 #/definitions/import("/home/runner/work/enterprise/enterprise/node\_modules/@browserless.io/browserless/build/types",{with:{"resolution-mode":"import"}}).CDPLaunchOptions
 \- type: string
 \- in: query
 name: timeout
 schema:
 description: \|-
 Override the system-level timeout for this request.
 Accepts a value in milliseconds.
 type: number
 \- in: query
 name: token
 schema:
 description: The authorization token
 type: string
 \- in: query
 name: trackingId
 schema:
 description: Custom session identifier
 type: string
 requestBody:
 content: {}
 responses:
 '101':
 description: Indicates successful WebSocket upgrade.
 '400':
 code: 400
 description: The request contains errors or didn't properly encode content.
 message: HTTP/1.1 400 Bad Request
 '401':
 code: 401
 description: The request is missing, or contains bad, authorization credentials.
 message: HTTP/1.1 401 Unauthorized
 '404':
 code: 404
 description: Resource couldn't be found.
 message: HTTP/1.1 404 Not Found
 '408':
 code: 408
 description: The request took has taken too long to process.
 message: HTTP/1.1 408 Request Timeout
 '429':
 code: 429
 description: Too many requests are currently being processed.
 message: HTTP/1.1 429 Too Many Requests
 '500':
 code: 500
 description: An internal error occurred when handling the request.
 message: HTTP/1.1 500 Internal Server Error
 summary: /chrome/stealth
 tags:
 \- Browser WebSocket APIs
 /chromium/live/\*:
 get:
 definitions: {}
 description: >-
 \> This API is only available for Enterprise plans and self-hosted
 Enterprise plans. \[Contact us for more information\
 here.\](https://www.browserless.io/contact/), or \[sign-up\
 here\](https://www.browserless.io/pricing/).

 Websocket back-end that powers the live session experience.

 \*\*Note:\*\* This endpoint is also available at: \`/live/\*\` for backwards
 compatibility.
 parameters: \[\]
 requestBody:
 content: {}
 responses:
 '101':
 description: Indicates successful WebSocket upgrade.
 '400':
 code: 400
 description: The request contains errors or didn't properly encode content.
 message: HTTP/1.1 400 Bad Request
 '401':
 code: 401
 description: The request is missing, or contains bad, authorization credentials.
 message: HTTP/1.1 401 Unauthorized
 '404':
 code: 404
 description: Resource couldn't be found.
 message: HTTP/1.1 404 Not Found
 '408':
 code: 408
 description: The request took has taken too long to process.
 message: HTTP/1.1 408 Request Timeout
 '429':
 code: 429
 description: Too many requests are currently being processed.
 message: HTTP/1.1 429 Too Many Requests
 '500':
 code: 500
 description: An internal error occurred when handling the request.
 message: HTTP/1.1 500 Internal Server Error
 summary: /chromium/live/\*
 tags:
 \- Browser WebSocket APIs
 /chromium/stealth:
 get:
 definitions: {}
 description: >-
 \> This API is only available for Enterprise and Cloud-unit plans.
 \[Contact us for more information\
 here.\](https://www.browserless.io/contact/), or \[sign-up\
 here\](https://www.browserless.io/pricing/).

 Launch and connect to Stealthy Chromium with a library like puppeteer or
 others that work over chrome-devtools-protocol for scraping in a more
 stealth-like fashion.

 \*\*Note:\*\* This endpoint is also available at: \`/stealth\` for backwards
 compatibility.
 parameters:
 \- in: query
 name: blockAds
 schema:
 description: \|-
 Whether or nor to load ad-blocking extensions for the session.
 This currently uses uBlock-Lite and may cause certain sites
 to not load properly.
 type: boolean
 \- in: query
 name: launch
 schema:
 description: \|-
 Launch options, which can be either an object
 of puppeteer.launch options or playwright.launchServer
 options, depending on the API. Must be either JSON
 object, or a base64-encoded JSON object.
 anyOf:
 \- $ref: >-
 #/definitions/import("/home/runner/work/enterprise/enterprise/node\_modules/@browserless.io/browserless/build/types",{with:{"resolution-mode":"import"}}).CDPLaunchOptions
 \- type: string
 \- in: query
 name: timeout
 schema:
 description: \|-
 Override the system-level timeout for this request.
 Accepts a value in milliseconds.
 type: number
 \- in: query
 name: token
 schema:
 description: The authorization token
 type: string
 \- in: query
 name: trackingId
 schema:
 description: Custom session identifier
 type: string
 requestBody:
 content: {}
 responses:
 '101':
 description: Indicates successful WebSocket upgrade.
 '400':
 code: 400
 description: The request contains errors or didn't properly encode content.
 message: HTTP/1.1 400 Bad Request
 '401':
 code: 401
 description: The request is missing, or contains bad, authorization credentials.
 message: HTTP/1.1 401 Unauthorized
 '404':
 code: 404
 description: Resource couldn't be found.
 message: HTTP/1.1 404 Not Found
 '408':
 code: 408
 description: The request took has taken too long to process.
 message: HTTP/1.1 408 Request Timeout
 '429':
 code: 429
 description: Too many requests are currently being processed.
 message: HTTP/1.1 429 Too Many Requests
 '500':
 code: 500
 description: An internal error occurred when handling the request.
 message: HTTP/1.1 500 Internal Server Error
 summary: /chromium/stealth
 tags:
 \- Browser WebSocket APIs
 /reconnect/\*:
 get:
 definitions: {}
 description: >-
 Reconnect to an existing Chromium or Chrome session with a library like
 puppeteer or others that work over chrome-devtools-protocol.
 parameters:
 \- in: query
 name: blockAds
 schema:
 description: \|-
 Whether or nor to load ad-blocking extensions for the session.
 This currently uses uBlock-Lite and may cause certain sites
 to not load properly.
 type: boolean
 \- in: query
 name: launch
 schema:
 description: \|-
 Launch options, which can be either an object
 of puppeteer.launch options or playwright.launchServer
 options, depending on the API. Must be either JSON
 object, or a base64-encoded JSON object.
 anyOf:
 \- $ref: >-
 #/definitions/import("/home/runner/work/enterprise/enterprise/node\_modules/@browserless.io/browserless/build/types",{with:{"resolution-mode":"import"}}).CDPLaunchOptions
 \- $ref: >-
 #/definitions/import("/home/runner/work/enterprise/enterprise/node\_modules/@browserless.io/browserless/build/types",{with:{"resolution-mode":"import"}}).BrowserServerOptions
 \- type: string
 \- in: query
 name: timeout
 schema:
 description: \|-
 Override the system-level timeout for this request.
 Accepts a value in milliseconds.
 type: number
 \- in: query
 name: token
 schema:
 description: The authorization token
 type: string
 \- in: query
 name: trackingId
 schema:
 description: Custom session identifier
 type: string
 requestBody:
 content: {}
 responses:
 '101':
 description: Indicates successful WebSocket upgrade.
 '400':
 code: 400
 description: The request contains errors or didn't properly encode content.
 message: HTTP/1.1 400 Bad Request
 '401':
 code: 401
 description: The request is missing, or contains bad, authorization credentials.
 message: HTTP/1.1 401 Unauthorized
 '404':
 code: 404
 description: Resource couldn't be found.
 message: HTTP/1.1 404 Not Found
 '408':
 code: 408
 description: The request took has taken too long to process.
 message: HTTP/1.1 408 Request Timeout
 '429':
 code: 429
 description: Too many requests are currently being processed.
 message: HTTP/1.1 429 Too Many Requests
 '500':
 code: 500
 description: An internal error occurred when handling the request.
 message: HTTP/1.1 500 Internal Server Error
 summary: /reconnect/\*
 tags:
 \- Browser WebSocket APIs
servers: \[\]
components: {}

---

### Connection URLs and Endpoints | Browserless.io
Original URL: https://docs.browserless.io/rest-apis/connection-urls

[Skip to main content](https://docs.browserless.io/rest-apis/connection-urls#__docusaurus_skipToContent_fallback)


This page explains all the connection URLs and endpoints available for **BrowserQL**, including how to authenticate with your API token, choose the right regional base URL, and interact with the BQL service. Whether you're using the BQL IDE or making direct API calls, this guide covers everything you need to connect and start automating.

## Base URL and Regions [â€‹](https://docs.browserless.io/rest-apis/connection-urls\#base-url-and-regions "Direct link to Base URL and Regions")

Browserless has multiple regional base URLs:

- `https://production-sfo.browserless.io` (US West)
- `https://production-lon.browserless.io` (Europe UK)
- `https://production-ams.browserless.io` (Europe Amsterdam)

Choose the region closest to you to reduce latency (see [Load Balancers](https://docs.browserless.io/baas/load-balancers)). All require the token query parameter.

## Using Your API Token in URLs [â€‹](https://docs.browserless.io/rest-apis/connection-urls\#using-your-api-token-in-urls "Direct link to Using Your API Token in URLs")

Add your API token to the URL query string as `?token=YOUR_TOKEN`. Required for authentication (see see [BQL Connection URL Builder](https://docs.browserless.io/browserql/connection-urls)). Invalid tokens result in HTTP 401/403 errors. Keep this URL secure and never expose it in client-side code or logs.

Example:
`https://production-sfo.browserless.io/chromium/bql?token=094632bb-e326-4c63-b953-82b55700b14c` is a basic connection string for a new Chromium session on the SFO cluster using the given token.

Below you can select your preferences of region and browser to define your URL:

### REST API Connection URL Builder

Service Type:

REST API

Endpoint:

ScreenshotPDFContentDownloadExportfunctionUnblockScrapePerformance

Region:

US WestEurope UKEurope Amsterdam

API Token:

#### Connection URL:

Copy

```
https://production-sfo.browserless.io/screenshot?token=YOUR_TOKEN
```

#### Code Snippet:

Copy

```
curl -X POST \
  'https://production-sfo.browserless.io/screenshot?token=YOUR_TOKEN' \
  -H 'Content-Type: application/json' \
  -d '{
    "url": "https://example.com"
  }'
```

- [Base URL and Regions](https://docs.browserless.io/rest-apis/connection-urls#base-url-and-regions)
- [Using Your API Token in URLs](https://docs.browserless.io/rest-apis/connection-urls#using-your-api-token-in-urls)

---

### /content API | Browserless.io
Original URL: https://docs.browserless.io/rest-apis/content

[Skip to main content](https://docs.browserless.io/rest-apis/content#__docusaurus_skipToContent_fallback)


BrowserQL

We recommended using [**BrowserQL**](https://docs.browserless.io/browserql/start), Browserless' first-class browser automation API, to capture content from any website.

The content API allows for simple navigation to a site and capturing the page's content (including the `<head>` section). Browserless will respond with a `Content-Type` of `text/html`, and string of the site's HTML after it has been rendered and evaluated inside the browser. This is useful for capturing the content of a page that has a lot of JavaScript or other interactivity.

You can [check the full Open API schema here](https://docs.browserless.io/open-api#tag/Browser-REST-APIs/paths/~1chrome~1content/post).

## Basic Usage [â€‹](https://docs.browserless.io/rest-apis/content\#basic-usage "Direct link to Basic Usage")

- JSON payload
- cURL
- Javascript
- Python
- Java
- C#

```codeBlockLines_p187
{
  "url": "https://example.com/"
}

```

```codeBlockLines_p187
curl -X POST \
  https://production-sfo.browserless.io/content?token=YOUR_API_TOKEN_HERE \
  -H 'Cache-Control: no-cache' \
  -H 'Content-Type: application/json' \
  -d '{
  "url": "https://example.com/"
}'

```

```codeBlockLines_p187
const TOKEN = "YOUR_API_TOKEN_HERE";
const url = `https://production-sfo.browserless.io/content?token=${TOKEN}`;
const headers = {
    "Cache-Control": "no-cache",
    "Content-Type": "application/json"
};
const data = {
    url: "https://example.com/"
};

const fetchContent = async () => {
    const response = await fetch(url, {
        method: 'POST',
        headers: headers,
        body: JSON.stringify(data)
    });

    const content = await response.text();
    console.log(content);
};

fetchContent();

```

```codeBlockLines_p187
import requests

TOKEN = "YOUR_API_TOKEN_HERE"
url = f"https://production-sfo.browserless.io/content?token={TOKEN}"
headers = {
    "Cache-Control": "no-cache",
    "Content-Type": "application/json"
}
data = {
    "url": "https://example.com/"
}

response = requests.post(url, headers=headers, json=data)
print(response.text)

```

```codeBlockLines_p187
import java.io.*;
import java.net.http.*;
import java.net.URI;

public class FetchContent {
    public static void main(String[] args) {
        String TOKEN = "YOUR_API_TOKEN_HERE";
        String url = "https://production-sfo.browserless.io/content?token=" + TOKEN;

        HttpClient client = HttpClient.newHttpClient();

        String jsonData = """
            {
                "url": "https://example.com/"
            }
        """;

        HttpRequest request = HttpRequest.newBuilder()
            .uri(URI.create(url))
            .header("Content-Type", "application/json")
            .header("Cache-Control", "no-cache")
            .POST(HttpRequest.BodyPublishers.ofString(jsonData))
            .build();

        try {
            HttpResponse<String> response = client.send(request, HttpResponse.BodyHandlers.ofString());
            System.out.println("Response: " + response.body());
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

```

```codeBlockLines_p187
  using System.Text;
  using System.Text.Json;

  class Program
  {
      static async Task Main(string[] args)
      {
          string TOKEN = "YOUR_API_TOKEN_HERE";
          string url = $"https://production-sfo.browserless.io/content?token={TOKEN}";

          var payload = new
          {
              url = "https://example.com/"
          };

          var jsonContent = new StringContent(JsonSerializer.Serialize(payload), Encoding.UTF8, "application/json");

          using var httpClient = new HttpClient();
          try
          {
              var request = new HttpRequestMessage(HttpMethod.Post, url)
              {
                  Content = jsonContent
              };

              request.Headers.Add("Cache-Control", "no-cache");

              var response = await httpClient.SendAsync(request);
              response.EnsureSuccessStatusCode();
              var result = await response.Content.ReadAsStringAsync();
              Console.WriteLine("Response: " + result);
          }
          catch (Exception e)
          {
              Console.WriteLine("Error: " + e.Message);
          }
      }
  }

```

## Rejecting Undesired Requests [â€‹](https://docs.browserless.io/rest-apis/content\#rejecting-undesired-requests "Direct link to Rejecting Undesired Requests")

You can use `rejectResourceTypes` and `rejectRequestPattern` to block undesired content, resources and requests.

- JSON payload
- cURL
- Javascript
- Python
- Java
- C#

```codeBlockLines_p187
// Will reject any images and .css files
{
  "url": "https://browserless.io/"
  "rejectResourceTypes": ["image"],
  "rejectRequestPattern": ["/^.*\\.(css)"]
}

```

```codeBlockLines_p187
curl -X POST \
  https://production-sfo.browserless.io/content?token=YOUR_API_TOKEN_HERE \
  -H 'Cache-Control: no-cache' \
  -H 'Content-Type: application/json' \
  -d '{
  "url": "https://browserless.io/"
  "rejectResourceTypes": ["image"],
  "rejectRequestPattern": ["/^.*\\.(css)"]
}'

```

```codeBlockLines_p187
const TOKEN = "YOUR_API_TOKEN_HERE";
const url = `https://production-sfo.browserless.io/content?token=${TOKEN}`;
const headers = {
    "Cache-Control": "no-cache",
    "Content-Type": "application/json"
};
const data = {
    url: "https://example.com/",
    rejectResourceTypes: ["image"],
    rejectRequestPattern: ["/^.*\\.(css)"]
};

const fetchContent = async () => {
    const response = await fetch(url, {
        method: 'POST',
        headers: headers,
        body: JSON.stringify(data)
    });

    const content = await response.text();
    console.log(content);
};

fetchContent();

```

```codeBlockLines_p187
import requests

TOKEN = "YOUR_API_TOKEN_HERE"
url = f"https://production-sfo.browserless.io/content?token={TOKEN}"
headers = {
    "Cache-Control": "no-cache",
    "Content-Type": "application/json"
}
data = {
    "url": "https://example.com/",
    "rejectResourceTypes": ["image"],
    "rejectRequestPattern": ["/^.*\\.(css)"]
}

response = requests.post(url, headers=headers, json=data)
print(response.text)

```

```codeBlockLines_p187
import java.io.*;
import java.net.http.*;
import java.net.URI;
import com.google.gson.*;

public class FetchContentWithRejection {
    public static void main(String[] args) {
        String TOKEN = "YOUR_API_TOKEN_HERE";
        String url = "https://production-sfo.browserless.io/content?token=" + TOKEN;

        HttpClient client = HttpClient.newHttpClient();

        String jsonData = new Gson().toJson(Map.of(
            "url", "https://browserless.io/",
            "rejectResourceTypes", new String[] { "image" },
            "rejectRequestPattern", new String[] { "/^.*\\.(css)/" }
        ));

        HttpRequest request = HttpRequest.newBuilder()
            .uri(URI.create(url))
            .header("Content-Type", "application/json")
            .header("Cache-Control", "no-cache")
            .POST(HttpRequest.BodyPublishers.ofString(jsonData))
            .build();

        try {
            HttpResponse<String> response = client.send(request, HttpResponse.BodyHandlers.ofString());
            System.out.println("Response: " + response.body());
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

```

```codeBlockLines_p187
using System.Text;
  using System.Text.Json;

  class Program
  {
  		static async Task Main(string[] args)
  		{
  				string TOKEN = "YOUR_API_TOKEN_HERE";
  				string url = $"https://production-sfo.browserless.io/content?token={TOKEN}";

  				var payload = new
  				{
  						url = "https://browserless.io/",
  						rejectResourceTypes = new[] { "image" },
  						rejectRequestPattern = new[] { "/^.*\\.(css)/" }
  				};

  				var jsonContent = new StringContent(JsonSerializer.Serialize(payload), Encoding.UTF8, "application/json");

  				using var httpClient = new HttpClient();
  				try
  				{
  						var request = new HttpRequestMessage(HttpMethod.Post, url)
  						{
  								Content = jsonContent
  						};

  						request.Headers.Add("Cache-Control", "no-cache");

  						var response = await httpClient.SendAsync(request);
  						response.EnsureSuccessStatusCode();
  						var result = await response.Content.ReadAsStringAsync();
  						Console.WriteLine("Response: " + result);
  				}
  				catch (Exception e)
  				{
  						Console.WriteLine("Error: " + e.Message);
  				}
  		}
  }

```

## Navigation Options [â€‹](https://docs.browserless.io/rest-apis/content\#navigation-options "Direct link to Navigation Options")

You can use the `gotoOptions` to modify the default navigation behavior for the requested URL. The objects mirror [Puppeteer's `GoToOptions` interface](https://pptr.dev/api/puppeteer.gotooptions).

- JSON payload
- cURL
- Javascript
- Python
- Java
- C#

```codeBlockLines_p187
{
  "url": "https://example.com/",
  "gotoOptions": { "waitUntil": "networkidle2" },
}

```

```codeBlockLines_p187
curl -X POST \
  https://production-sfo.browserless.io/content?token=YOUR_API_TOKEN_HERE \
  -H 'Cache-Control: no-cache' \
  -H 'Content-Type: application/json' \
  -d '{
  "url": "https://example.com/",
  "gotoOptions": { "waitUntil": "networkidle2" }
}'

```

```codeBlockLines_p187
const TOKEN = "YOUR_API_TOKEN_HERE";
const url = `https://production-sfo.browserless.io/content?token=${TOKEN}`;
const headers = {
    "Cache-Control": "no-cache",
    "Content-Type": "application/json"
};
const data = {
    url: "https://example.com/",
    gotoOptions: { "waitUntil": "networkidle2" },
};

const fetchContent = async () => {
    const response = await fetch(url, {
        method: 'POST',
        headers: headers,
        body: JSON.stringify(data)
    });

    const content = await response.text();
    console.log(content);
};

fetchContent();

```

```codeBlockLines_p187
import requests

TOKEN = "YOUR_API_TOKEN_HERE"
url = f"https://production-sfo.browserless.io/content?token={TOKEN}"
headers = {
    "Cache-Control": "no-cache",
    "Content-Type": "application/json"
}
data = {
    "url": "https://example.com/",
    "gotoOptions": { "waitUntil": "networkidle2" }
}

response = requests.post(url, headers=headers, json=data)
print(response.text)

```

```codeBlockLines_p187
import java.io.*;
import java.net.http.*;
import java.net.URI;
import com.google.gson.*;

public class FetchContent {
    public static void main(String[] args) {
        String TOKEN = "YOUR_API_TOKEN_HERE";
        String url = "https://production-sfo.browserless.io/content?token=" + TOKEN;

        HttpClient client = HttpClient.newHttpClient();

        String jsonData = new Gson().toJson(Map.of(
            "url", "https://example.com/",
            "gotoOptions", Map.of("waitUntil", "networkidle2")
        ));

        HttpRequest request = HttpRequest.newBuilder()
            .uri(URI.create(url))
            .header("Content-Type", "application/json")
            .header("Cache-Control", "no-cache")
            .POST(HttpRequest.BodyPublishers.ofString(jsonData))
            .build();

        try {
            HttpResponse<String> response = client.send(request, HttpResponse.BodyHandlers.ofString());
            System.out.println("Response: " + response.body());
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

```

```codeBlockLines_p187
using System.Text;
	using System.Text.Json;

	class Program
	{
			static async Task Main(string[] args)
			{
					string TOKEN = "YOUR_API_TOKEN_HERE";
					string url = $"https://production-sfo.browserless.io/content?token={TOKEN}";

					var payload = new
					{
							url = "https://example.com/",
							gotoOptions = new { waitUntil = "networkidle2" }
					};

					var jsonContent = new StringContent(JsonSerializer.Serialize(payload), Encoding.UTF8, "application/json");

					using var httpClient = new HttpClient();
					try
					{
							var request = new HttpRequestMessage(HttpMethod.Post, url)
							{
									Content = jsonContent
							};

							request.Headers.Add("Cache-Control", "no-cache");

							var response = await httpClient.SendAsync(request);
							response.EnsureSuccessStatusCode();
							var result = await response.Content.ReadAsStringAsync();
							Console.WriteLine("Response: " + result);
					}
					catch (Exception e)
					{
							Console.WriteLine("Error: " + e.Message);
					}
			}
	}

```

## Continue on error [â€‹](https://docs.browserless.io/rest-apis/content\#continue-on-error "Direct link to Continue on error")

You can use `bestAttempt` to make Browserless attempt to proceed when async events fail or timeout. This includes things like the `goto` or `waitForSelector` proprieties in the JSON payload.

- JSON payload
- cURL
- Javascript
- Python
- Java
- C#

```codeBlockLines_p187
{
  "url": "https://example.com/",
  "bestAttempt": true,

  // This would fail without bestAttempt
  "waitForSelector": { "selector": "table", "timeout": 500 }
}

```

```codeBlockLines_p187
curl -X POST \
  https://production-sfo.browserless.io/content?token=YOUR_API_TOKEN_HERE \
  -H 'Cache-Control: no-cache' \
  -H 'Content-Type: application/json' \
  -d '{
  "url": "https://example.com/",
  "bestAttempt": true,
  "waitForSelector": { "selector": "table", "timeout": 500 }
}'

```

```codeBlockLines_p187
const TOKEN = "YOUR_API_TOKEN_HERE";
const url = `https://production-sfo.browserless.io/content?token=${TOKEN}`;
const headers = {
    "Cache-Control": "no-cache",
    "Content-Type": "application/json"
};
const data = {
    url: "https://example.com/",
    bestAttempt: true,
    waitForSelector: { "selector": "table", "timeout": 500 }
};

const fetchContent = async () => {
    const response = await fetch(url, {
        method: 'POST',
        headers: headers,
        body: JSON.stringify(data)
    });

    const content = await response.text();
    console.log(content);
};

fetchContent();

```

```codeBlockLines_p187
import requests

TOKEN = "YOUR_API_TOKEN_HERE"
url = f"https://production-sfo.browserless.io/content?token={TOKEN}"
headers = {
    "Cache-Control": "no-cache",
    "Content-Type": "application/json"
}
data = {
    "url": "https://example.com/",
    "bestAttempt": True,
    "waitForSelector": { "selector": "table", "timeout": 500 }
}

response = requests.post(url, headers=headers, json=data)
print(response.text)

```

```codeBlockLines_p187
import java.io.*;
import java.net.http.*;
import java.net.URI;
import com.google.gson.*;

public class FetchContentWithWait {
    public static void main(String[] args) {
        String TOKEN = "YOUR_API_TOKEN_HERE";
        String url = "https://production-sfo.browserless.io/content?token=" + TOKEN;

        HttpClient client = HttpClient.newHttpClient();

        String jsonData = new Gson().toJson(Map.of(
            "url", "https://example.com/",
            "bestAttempt", true,
            "waitForSelector", Map.of(
                "selector", "table",
                "timeout", 500
            )
        ));

        HttpRequest request = HttpRequest.newBuilder()
            .uri(URI.create(url))
            .header("Content-Type", "application/json")
            .header("Cache-Control", "no-cache")
            .POST(HttpRequest.BodyPublishers.ofString(jsonData))
            .build();

        try {
            HttpResponse<String> response = client.send(request, HttpResponse.BodyHandlers.ofString());
            System.out.println("Response: " + response.body());
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

```

```codeBlockLines_p187
using System.Text;
	using System.Text.Json;

	class Program
	{
			static async Task Main(string[] args)
			{
					string TOKEN = "YOUR_API_TOKEN_HERE";
					string url = $"https://production-sfo.browserless.io/content?token={TOKEN}";

					var payload = new
					{
							url = "https://example.com/",
							bestAttempt = true,
							waitForSelector = new
							{
									selector = "table",
									timeout = 500
							}
					};

					var jsonContent = new StringContent(JsonSerializer.Serialize(payload), Encoding.UTF8, "application/json");

					using var httpClient = new HttpClient();
					try
					{
							var request = new HttpRequestMessage(HttpMethod.Post, url)
							{
									Content = jsonContent
							};

							request.Headers.Add("Cache-Control", "no-cache");

							var response = await httpClient.SendAsync(request);
							response.EnsureSuccessStatusCode();
							var result = await response.Content.ReadAsStringAsync();
							Console.WriteLine("Response: " + result);
					}
					catch (Exception e)
					{
							Console.WriteLine("Error: " + e.Message);
					}
			}
	}

```

## Waiting for Things [â€‹](https://docs.browserless.io/rest-apis/content\#waiting-for-things "Direct link to Waiting for Things")

Browserless offers 4 different ways to wait for preconditions to be met on page. These are events, functions, selectors and timeouts.

### waitForEvent [â€‹](https://docs.browserless.io/rest-apis/content\#waitforevent "Direct link to waitForEvent")

Waits for an event to happen on the page before cotinue

#### Example [â€‹](https://docs.browserless.io/rest-apis/content\#example "Direct link to Example")

- JSON payload
- cURL
- Javascript
- Python
- Java
- C#

```codeBlockLines_p187
// Will fail since the event never fires
{
  "url": "https://example.com/",
  "waitForEvent": {
    "event": "fullscreenchange",
    "timeout": 5000
  }
}

```

```codeBlockLines_p187
curl -X POST \
  https://production-sfo.browserless.io/content?token=YOUR_API_TOKEN_HERE \
  -H 'Cache-Control: no-cache' \
  -H 'Content-Type: application/json' \
  -d '{
  "url": "https://example.com/",
  "waitForEvent": {
    "event": "fullscreenchange",
    "timeout": 5000
  }
}'

```

```codeBlockLines_p187
const TOKEN = "YOUR_API_TOKEN_HERE";
const url = `https://production-sfo.browserless.io/content?token=${TOKEN}`;
const headers = {
    "Cache-Control": "no-cache",
    "Content-Type": "application/json"
};
const data = {
    url: "https://example.com/",
    waitForEvent: {
      event: "fullscreenchange",
      timeout: 5000
    }
};

const fetchContent = async () => {
    const response = await fetch(url, {
        method: 'POST',
        headers: headers,
        body: JSON.stringify(data)
    });

    const content = await response.text();
    console.log(content);
};

fetchContent();

```

```codeBlockLines_p187
import requests

TOKEN = "YOUR_API_TOKEN_HERE"
url = f"https://production-sfo.browserless.io/content?token={TOKEN}"
headers = {
    "Cache-Control": "no-cache",
    "Content-Type": "application/json"
}
data = {
    "url": "https://example.com/",
    "waitForEvent": {
      "event": "fullscreenchange",
      "timeout": 5000
    }
}

response = requests.post(url, headers=headers, json=data)
print(response.text)

```

```codeBlockLines_p187
import java.io.*;
import java.net.http.*;
import java.net.URI;
import com.google.gson.*;

public class FetchContentWithEvent {
    public static void main(String[] args) {
        String TOKEN = "YOUR_API_TOKEN_HERE";
        String url = "https://production-sfo.browserless.io/content?token=" + TOKEN;

        HttpClient client = HttpClient.newHttpClient();

        String jsonData = new Gson().toJson(Map.of(
            "url", "https://example.com/",
            "waitForEvent", Map.of(
                "event", "fullscreenchange",
                "timeout", 5000
            )
        ));

        HttpRequest request = HttpRequest.newBuilder()
            .uri(URI.create(url))
            .header("Content-Type", "application/json")
            .header("Cache-Control", "no-cache")
            .POST(HttpRequest.BodyPublishers.ofString(jsonData))
            .build();

        try {
            HttpResponse<String> response = client.send(request, HttpResponse.BodyHandlers.ofString());
            System.out.println("Response: " + response.body());
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

```

```codeBlockLines_p187
using System.Text;
	using System.Text.Json;

	class Program
	{
			static async Task Main(string[] args)
			{
					string TOKEN = "YOUR_API_TOKEN_HERE";
					string url = $"https://production-sfo.browserless.io/content?token={TOKEN}";

					var payload = new
					{
							url = "https://example.com/",
							waitForEvent = new
							{
									@event = "fullscreenchange",
									timeout = 5000
							}
					};

					var jsonContent = new StringContent(JsonSerializer.Serialize(payload), Encoding.UTF8, "application/json");

					using var httpClient = new HttpClient();
					try
					{
							var request = new HttpRequestMessage(HttpMethod.Post, url)
							{
									Content = jsonContent
							};

							request.Headers.Add("Cache-Control", "no-cache");

							var response = await httpClient.SendAsync(request);
							response.EnsureSuccessStatusCode();
							var result = await response.Content.ReadAsStringAsync();
							Console.WriteLine("Response: " + result);
					}
					catch (Exception e)
					{
							Console.WriteLine("Error: " + e.Message);
					}
			}
	}

```

### waitForFunction [â€‹](https://docs.browserless.io/rest-apis/content\#waitforfunction "Direct link to waitForFunction")

Waits for the provided function to return before cotinue. The function can be any valid JavaScript or EcmaScript function, and `async` functions are supported.

#### Example [â€‹](https://docs.browserless.io/rest-apis/content\#example-1 "Direct link to Example")

**JS function**

```codeBlockLines_p187
async () => {
  const res = await fetch('https://jsonplaceholder.typicode.com/todos/1');
  const json = await res.json();

  document.querySelector("h1").innerText = json.title;
}

```

- JSON payload
- cURL
- Javascript
- Python
- Java
- C#

```codeBlockLines_p187
{
  "url": "https://example.com/",
  "waitForFunction": {
    "fn": "async()=>{let t=await fetch('https://jsonplaceholder.typicode.com/todos/1'),e=await t.json();document.querySelector('h1').innerText=e.title}",
    "timeout": 5000
  }
}

```

```codeBlockLines_p187
curl -X POST \
  https://production-sfo.browserless.io/content?token=YOUR_API_TOKEN_HERE \
  -H 'Cache-Control: no-cache' \
  -H 'Content-Type: application/json' \
  -d '{
  "url": "https://example.com/",
  "waitForFunction": {
    "fn": "async()=>{let t=await fetch('https://jsonplaceholder.typicode.com/todos/1'),e=await t.json();document.querySelector('h1').innerText=e.title}",
    "timeout": 5000
  }
}'

```

```codeBlockLines_p187
const TOKEN = "YOUR_API_TOKEN_HERE";
const url = `https://production-sfo.browserless.io/content?token=${TOKEN}`;
const headers = {
    "Cache-Control": "no-cache",
    "Content-Type": "application/json"
};
const data = {
    url: "https://example.com/",
    waitForFunction: {
        fn: "async()=>{let t=await fetch('https://jsonplaceholder.typicode.com/todos/1'),e=await t.json();document.querySelector('h1').innerText=e.title}",
        timeout: 5000
    }
};

const fetchContent = async () => {
    const response = await fetch(url, {
        method: 'POST',
        headers: headers,
        body: JSON.stringify(data)
    });

    const content = await response.text();
    console.log(content);
};

fetchContent();

```

```codeBlockLines_p187
import requests

TOKEN = "YOUR_API_TOKEN_HERE"
url = f"https://production-sfo.browserless.io/content?token={TOKEN}"
headers = {
    "Cache-Control": "no-cache",
    "Content-Type": "application/json"
}
data = {
    "url": "https://example.com/",
    "waitForFunction": {
        "fn": "async()=>{let t=await fetch('https://jsonplaceholder.typicode.com/todos/1'),e=await t.json();document.querySelector('h1').innerText=e.title}",
        "timeout": 5000
    }
}

response = requests.post(url, headers=headers, json=data)
print(response.text)

```

```codeBlockLines_p187
import java.io.*;
import java.net.http.*;
import java.net.URI;
import com.google.gson.*;

public class FetchContentWithFunction {
    public static void main(String[] args) {
        String TOKEN = "YOUR_API_TOKEN_HERE";
        String url = "https://production-sfo.browserless.io/content?token=" + TOKEN;

        HttpClient client = HttpClient.newHttpClient();

        String jsonData = new Gson().toJson(Map.of(
            "url", "https://example.com/",
            "waitForFunction", Map.of(
                "fn", "async()=>{let t=await fetch('https://jsonplaceholder.typicode.com/todos/1'),e=await t.json();document.querySelector('h1').innerText=e.title}",
                "timeout", 5000
            )
        ));

        HttpRequest request = HttpRequest.newBuilder()
            .uri(URI.create(url))
            .header("Content-Type", "application/json")
            .header("Cache-Control", "no-cache")
            .POST(HttpRequest.BodyPublishers.ofString(jsonData))
            .build();

        try {
            HttpResponse<String> response = client.send(request, HttpResponse.BodyHandlers.ofString());
            System.out.println("Response: " + response.body());
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

```

```codeBlockLines_p187
using System.Text;
	using System.Text.Json;

	class Program
	{
			static async Task Main(string[] args)
			{
					string TOKEN = "YOUR_API_TOKEN_HERE";
					string url = $"https://production-sfo.browserless.io/content?token={TOKEN}";

					var payload = new
					{
							url = "https://example.com/",
							waitForFunction = new
							{
									fn = "async()=>{let t=await fetch('https://jsonplaceholder.typicode.com/todos/1'),e=await t.json();document.querySelector('h1').innerText=e.title}",
									timeout = 5000
							}
					};

					var jsonContent = new StringContent(JsonSerializer.Serialize(payload), Encoding.UTF8, "application/json");

					using var httpClient = new HttpClient();
					try
					{
							var request = new HttpRequestMessage(HttpMethod.Post, url)
							{
									Content = jsonContent
							};

							request.Headers.Add("Cache-Control", "no-cache");

							var response = await httpClient.SendAsync(request);
							response.EnsureSuccessStatusCode();
							var result = await response.Content.ReadAsStringAsync();
							Console.WriteLine("Response: " + result);
					}
					catch (Exception e)
					{
							Console.WriteLine("Error: " + e.Message);
					}
			}
	}

```

### waitForSelector [â€‹](https://docs.browserless.io/rest-apis/content\#waitforselector "Direct link to waitForSelector")

Wait for a selector to appear in page. If at the moment of calling the method the selector already exists, the method will return immediately. If the selector doesn't appear after the timeout milliseconds of waiting, the function will throw.

The object can have any of these values:

- `selector`: String, required â€” A valid CSS selector.
- `hidden` Boolean, optional â€” Wait for the selected element to not be found in the DOM or to be hidden, i.e. have `display: none` or `visibility: hidden` CSS properties.
- `timeout`: Number, optional â€” Maximum number of milliseconds to wait for the selector before failing.
- `visible`: Boolean, optional â€” Wait for the selected element to be present in DOM and to be visible, i.e. to not have `display: none` or `visibility: hidden` CSS properties.

#### Example [â€‹](https://docs.browserless.io/rest-apis/content\#example-2 "Direct link to Example")

- JSON payload
- cURL
- Javascript
- Python
- Java
- C#

```codeBlockLines_p187
// Will fail since the event never fires
{
  "url": "https://example.com/",
  "waitForEvent": {
    "event": "fullscreenchange",
    "timeout": 5000
  }
}

```

```codeBlockLines_p187
curl -X POST \
  https://production-sfo.browserless.io/content?token=YOUR_API_TOKEN_HERE \
  -H 'Cache-Control: no-cache' \
  -H 'Content-Type: application/json' \
  -d '{
  "url": "https://example.com/",
  "waitForEvent": {
    "event": "fullscreenchange",
    "timeout": 5000
  }
}'

```

```codeBlockLines_p187
const TOKEN = "YOUR_API_TOKEN_HERE";
const url = `https://production-sfo.browserless.io/content?token=${TOKEN}`;
const headers = {
    "Cache-Control": "no-cache",
    "Content-Type": "application/json"
};
const data = {
    url: "https://example.com/",
    waitForEvent: {
        event: "fullscreenchange",
        timeout: 5000
    }
};

const fetchContent = async () => {
    const response = await fetch(url, {
        method: 'POST',
        headers: headers,
        body: JSON.stringify(data)
    });

    const content = await response.text();
    console.log(content);
};

fetchContent();

```

```codeBlockLines_p187
import requests

TOKEN = "YOUR_API_TOKEN_HERE"
url = f"https://production-sfo.browserless.io/content?token={TOKEN}"
headers = {
    "Cache-Control": "no-cache",
    "Content-Type": "application/json"
}
data = {
    "url": "https://example.com/",
    "waitForEvent": {
        "event": "fullscreenchange",
        "timeout": 5000
    }
}

response = requests.post(url, headers=headers, json=data)
print(response.text)

```

```codeBlockLines_p187
import java.io.*;
import java.net.http.*;
import java.net.URI;
import com.google.gson.*;

public class FetchContentWithWaitForEvent {
    public static void main(String[] args) {
        String TOKEN = "YOUR_API_TOKEN_HERE";
        String url = "https://production-sfo.browserless.io/content?token=" + TOKEN;

        HttpClient client = HttpClient.newHttpClient();

        String jsonData = new Gson().toJson(Map.of(
            "url", "https://example.com/",
            "waitForEvent", Map.of(
                "event", "fullscreenchange",
                "timeout", 5000
            )
        ));

        HttpRequest request = HttpRequest.newBuilder()
            .uri(URI.create(url))
            .header("Content-Type", "application/json")
            .header("Cache-Control", "no-cache")
            .POST(HttpRequest.BodyPublishers.ofString(jsonData))
            .build();

        try {
            HttpResponse<String> response = client.send(request, HttpResponse.BodyHandlers.ofString());
            System.out.println("Response: " + response.body());
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

```

```codeBlockLines_p187
using System.Text;
	using System.Text.Json;

	class Program
	{
			static async Task Main(string[] args)
			{
					string TOKEN = "YOUR_API_TOKEN_HERE";
					string url = $"https://production-sfo.browserless.io/content?token={TOKEN}";

					var payload = new
					{
							url = "https://example.com/",
							waitForEvent = new
							{
									@event = "fullscreenchange",
									timeout = 5000
							}
					};

					var jsonContent = new StringContent(JsonSerializer.Serialize(payload), Encoding.UTF8, "application/json");

					using var httpClient = new HttpClient();
					try
					{
							var request = new HttpRequestMessage(HttpMethod.Post, url)
							{
									Content = jsonContent
							};

							request.Headers.Add("Cache-Control", "no-cache");

							var response = await httpClient.SendAsync(request);
							response.EnsureSuccessStatusCode();
							var result = await response.Content.ReadAsStringAsync();
							Console.WriteLine("Response: " + result);
					}
					catch (Exception e)
					{
							Console.WriteLine("Error: " + e.Message);
					}
			}
	}

```

### waitForTimeout [â€‹](https://docs.browserless.io/rest-apis/content\#waitfortimeout "Direct link to waitForTimeout")

Waits for a specified timeout before continuing.

#### Example [â€‹](https://docs.browserless.io/rest-apis/content\#example-3 "Direct link to Example")

- JSON payload
- cURL
- Javascript
- Python
- Java
- C#

```codeBlockLines_p187
{
  "url": "https://example.com/",
  "waitForTimeout": 10000
}

```

```codeBlockLines_p187
curl -X POST \
  https://production-sfo.browserless.io/content?token=YOUR_API_TOKEN_HERE \
  -H 'Cache-Control: no-cache' \
  -H 'Content-Type: application/json' \
  -d '{
  "url": "https://example.com/",
  "waitForTimeout": 10000
}'

```

```codeBlockLines_p187
const TOKEN = "YOUR_API_TOKEN_HERE";
const url = `https://production-sfo.browserless.io/content?token=${TOKEN}`;
const headers = {
    "Cache-Control": "no-cache",
    "Content-Type": "application/json"
};
const data = {
    url: "https://example.com/",
    waitForTimeout: 10000
};

const fetchContent = async () => {
    const response = await fetch(url, {
        method: 'POST',
        headers: headers,
        body: JSON.stringify(data)
    });

    const content = await response.text();
    console.log(content);
};

fetchContent();

```

```codeBlockLines_p187
import requests

TOKEN = "YOUR_API_TOKEN_HERE"
url = f"https://production-sfo.browserless.io/content?token={TOKEN}"
headers = {
    "Cache-Control": "no-cache",
    "Content-Type": "application/json"
}
data = {
    "url": "https://example.com/",
    "waitForTimeout": 10000
}

response = requests.post(url, headers=headers, json=data)
print(response.text)

```

```codeBlockLines_p187
import java.io.*;
import java.net.http.*;
import java.net.URI;
import com.google.gson.*;

public class FetchContentWithWaitForTimeout {
    public static void main(String[] args) {
        String TOKEN = "YOUR_API_TOKEN_HERE";
        String url = "https://production-sfo.browserless.io/content?token=" + TOKEN;

        HttpClient client = HttpClient.newHttpClient();

        String jsonData = new Gson().toJson(Map.of(
            "url", "https://example.com/",
            "waitForTimeout", 10000
        ));

        HttpRequest request = HttpRequest.newBuilder()
            .uri(URI.create(url))
            .header("Content-Type", "application/json")
            .header("Cache-Control", "no-cache")
            .POST(HttpRequest.BodyPublishers.ofString(jsonData))
            .build();

        try {
            HttpResponse<String> response = client.send(request, HttpResponse.BodyHandlers.ofString());
            System.out.println("Response: " + response.body());
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

```

```codeBlockLines_p187
using System.Text;
	using System.Text.Json;

	class Program
	{
			static async Task Main(string[] args)
			{
					string TOKEN = "YOUR_API_TOKEN_HERE";
					string url = $"https://production-sfo.browserless.io/content?token={TOKEN}";

					var payload = new
					{
							url = "https://example.com/",
							waitForTimeout = 10000
					};

					var jsonContent = new StringContent(JsonSerializer.Serialize(payload), Encoding.UTF8, "application/json");

					using var httpClient = new HttpClient();
					try
					{
							var request = new HttpRequestMessage(HttpMethod.Post, url)
							{
									Content = jsonContent
							};

							request.Headers.Add("Cache-Control", "no-cache");

							var response = await httpClient.SendAsync(request);
							response.EnsureSuccessStatusCode();
							var result = await response.Content.ReadAsStringAsync();
							Console.WriteLine("Response: " + result);
					}
					catch (Exception e)
					{
							Console.WriteLine("Error: " + e.Message);
					}
			}
	}

```

- [Basic Usage](https://docs.browserless.io/rest-apis/content#basic-usage)
- [Rejecting Undesired Requests](https://docs.browserless.io/rest-apis/content#rejecting-undesired-requests)
- [Navigation Options](https://docs.browserless.io/rest-apis/content#navigation-options)
- [Continue on error](https://docs.browserless.io/rest-apis/content#continue-on-error)
- [Waiting for Things](https://docs.browserless.io/rest-apis/content#waiting-for-things)
  - [waitForEvent](https://docs.browserless.io/rest-apis/content#waitforevent)
  - [waitForFunction](https://docs.browserless.io/rest-apis/content#waitforfunction)
  - [waitForSelector](https://docs.browserless.io/rest-apis/content#waitforselector)
  - [waitForTimeout](https://docs.browserless.io/rest-apis/content#waitfortimeout)

---

### /download API | Browserless.io
Original URL: https://docs.browserless.io/rest-apis/download

[Skip to main content](https://docs.browserless.io/rest-apis/download#__docusaurus_skipToContent_fallback)


The `/download` API is used for returning files Chrome has downloaded during the execution of puppeteer code, which is ran inside context of the browser. Browserless sets up a blank page, a fresh download directory, injects your puppeteer code, and then executes it. You can load external libraries via the `import` syntax, and import ESM-style modules that are written for execution inside of the browser. Once your script is finished, any downloaded files from Chromium are returned back with the appropriate content-type header.

You can [check the full Open API schema here](https://docs.browserless.io/open-api#tag/Browser-REST-APIs/paths/~1chrome~1download/post).

warning

If your download request doesn't result in a **file** being downloaded, Browserless will likely time out the function.

## Basic Usage [â€‹](https://docs.browserless.io/rest-apis/download\#basic-usage "Direct link to Basic Usage")

Here's an example of downloading a file created in the browser (a CSV file):

```codeBlockLines_p187
import puppeteer from "puppeteer";

async function run() {
  const browser = await puppeteer.launch();
  const page = await browser.newPage();

  // Here we generate a json file and have the browser download it
  await page.evaluate(() => {
    const json = {
      ping: "pong",
      rnd: [...Array(5)].map(() => Math.random()),
    };
    const jsonContent = `data:application/json,${JSON.stringify(json)}`;
    const encodedUri = encodeURI(jsonContent);
    const link = document.createElement("a");

    link.setAttribute("href", encodedUri);
    link.setAttribute("download", "data.json");
    document.body.appendChild(link);
    return link.click();
  });
  await browser.close();
}

run();

```

This might come as a surprise, but unfortunately in puppeteer there's no way to know if the file was downloaded, or an API to even get it. You'll have to _know_ ahead of time where files are kept, and watch the file system for it to complete. Instead of wiring up all that code you can send Browserless an HTTP request and it takes care of all the underlying file-system calls:

**JS Code**

```codeBlockLines_p187
export default function ({ page }){
  await page.evaluate(() => {
    const json = {
      ping: "pong",
      rnd: [...Array(5)].map(() => Math.random())
    }
    const jsonContent = `data:application/json,${JSON.stringify(json)}`;
    const encodedUri = encodeURI(jsonContent);
    const link = document.createElement("a");

    link.setAttribute("href", encodedUri);
    link.setAttribute("download", "data.json");
    document.body.appendChild(link);
    return link.click();
  });
}

```

- cURL
- Javascript
- Python
- Java
- C#

```codeBlockLines_p187
curl -X POST \
  https://production-sfo.browserless.io/download?token=YOUR_API_TOKEN_HERE \
  -H 'Content-Type: application/javascript' \
  -d 'export default function ({ page }){
  await page.evaluate(() => {
    const json = {
      ping: "pong",
      rnd: [...Array(5)].map(() => Math.random())
    }
    const jsonContent = `data:application/json,${JSON.stringify(json)}`;
    const encodedUri = encodeURI(jsonContent);
    const link = document.createElement("a");

    link.setAttribute("href", encodedUri);
    link.setAttribute("download", "data.json");
    document.body.appendChild(link);
    return link.click();
  });
};'

```

```codeBlockLines_p187
import { writeFile } from 'fs/promises';

const TOKEN = "YOUR_API_TOKEN_HERE";
const url = `https://production-sfo.browserless.io/download?token=${TOKEN}`;
const headers = {
  "Content-Type": "application/javascript"
};

const data = `
export default async function ({ page }) {
  await page.evaluate(() => {
    const json = {
      ping: "pong",
      rnd: [...Array(5)].map(() => Math.random())
    };
    const jsonContent = \`data:application/json,\${JSON.stringify(json)}\`;
    const encodedUri = encodeURI(jsonContent);
    const link = document.createElement("a");

    link.setAttribute("href", encodedUri);
    link.setAttribute("download", "data.json");
    document.body.appendChild(link);
    link.click();
  });
};
`;

const downloadFile = async () => {
  const response = await fetch(url, {
    method: 'POST',
    headers: headers,
    body: data
  });

  const buffer = await response.arrayBuffer();
  await writeFile("data.json", Buffer.from(buffer));
  console.log("File saved as data.json");
};

downloadFile();

```

```codeBlockLines_p187
import requests

TOKEN = "YOUR_API_TOKEN_HERE"
url = f"https://production-sfo.browserless.io/download?token={TOKEN}"
headers = {
    "Content-Type": "application/javascript"
}

data = """
export default async function ({ page }) {
  await page.evaluate(() => {
    const json = {
      ping: "pong",
      rnd: [...Array(5)].map(() => Math.random())
    };
    const jsonContent = `data:application/json,${JSON.stringify(json)}`;
    const encodedUri = encodeURI(jsonContent);
    const link = document.createElement("a");

    link.setAttribute("href", encodedUri);
    link.setAttribute("download", "data.json");
    document.body.appendChild(link);
    link.click();
  });
};
"""

response = requests.post(url, headers=headers, data=data)

with open("data.json", "wb") as file:
    file.write(response.content)

print("File saved as data.json")

```

```codeBlockLines_p187
import java.io.*;
import java.net.*;
import java.net.http.*;

public class DownloadJsonFile {
    public static void main(String[] args) {
        String TOKEN = "YOUR_API_TOKEN_HERE";
        String url = "https://production-sfo.browserless.io/download?token=" + TOKEN;

        String javascriptCode = """
        export default async function ({ page }) {
            await page.evaluate(() => {
                const json = {
                    ping: "pong",
                    rnd: [...Array(5)].map(() => Math.random())
                };
                const jsonContent = `data:application/json,${JSON.stringify(json)}`;
                const encodedUri = encodeURI(jsonContent);
                const link = document.createElement("a");

                link.setAttribute("href", encodedUri);
                link.setAttribute("download", "data.json");
                document.body.appendChild(link);
                link.click();
            });
        };
        """;

        HttpClient client = HttpClient.newHttpClient();

        HttpRequest request = HttpRequest.newBuilder()
            .uri(URI.create(url))
            .header("Content-Type", "application/javascript")
            .POST(HttpRequest.BodyPublishers.ofString(javascriptCode))
            .build();

        try {
            HttpResponse<InputStream> response = client.send(request, HttpResponse.BodyHandlers.ofInputStream());

            try (InputStream in = response.body();
                FileOutputStream fileOut = new FileOutputStream("data.json")) {
                in.transferTo(fileOut);
                System.out.println("File saved as data.json");
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

```

```codeBlockLines_p187
using System;
using System.IO;
using System.Net.Http;
using System.Text;
using System.Threading.Tasks;

class Program
{
    static async Task Main(string[] args)
    {
        string TOKEN = "YOUR_API_TOKEN_HERE";
        string url = $"https://production-sfo.browserless.io/download?token={TOKEN}";

        string javascriptCode = @"
        export default async function ({ page }) {
            await page.evaluate(() => {
                const json = {
                    ping: 'pong',
                    rnd: [...Array(5)].map(() => Math.random())
                };
                const jsonContent = `data:application/json,${JSON.stringify(json)}`;
                const encodedUri = encodeURI(jsonContent);
                const link = document.createElement('a');

                link.setAttribute('href', encodedUri);
                link.setAttribute('download', 'data.json');
                document.body.appendChild(link);
                link.click();
            });
        };";

        using var client = new HttpClient();
        var content = new StringContent(javascriptCode, Encoding.UTF8, "application/javascript");

        try
        {
            var response = await client.PostAsync(url, content);
            response.EnsureSuccessStatusCode();

            using var stream = await response.Content.ReadAsStreamAsync();

            using var fileStream = new FileStream("data.json", FileMode.Create, FileAccess.Write);
            await stream.CopyToAsync(fileStream);

            Console.WriteLine("File saved as data.json");
        }
        catch (Exception ex)
        {
            Console.WriteLine("Error: " + ex.Message);
        }
    }
}

```

This API is sensitive to the downloaded file and will return an appropriate `Content-Type` with the response.

## Import libraries [â€‹](https://docs.browserless.io/rest-apis/download\#import-libraries "Direct link to Import libraries")

Both the `/function` and the `/download` API environments use [Ecmascript modules](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules). This means you can use `import` syntax over HTTP. For instance, let's try leading the [Fake](https://fakerjs.dev/) module.

**JS Code**

```codeBlockLines_p187
import { faker } from "https://esm.sh/@faker-js/faker";

export default async function ({ page }) {
  const rndName = faker.person.fullName();
  const rndEmail = faker.internet.email();

  await page.evaluate(
    (name, email) => {
      const jsonStr = JSON.stringify({ name, email });
      const jsonContent = `data:application/json,${jsonStr}`;
      const encodedUri = encodeURI(jsonContent);
      const link = document.createElement("a");

      link.setAttribute("href", encodedUri);
      link.setAttribute("download", "data.json");
      document.body.appendChild(link);
      return link.click();
    },
    rndName,
    rndEmail
  );
}

```

- cURL
- Javascript
- Python
- Java
- C#

```codeBlockLines_p187
curl -X POST \
  https://production-sfo.browserless.io/download?token=YOUR_API_TOKEN_HERE \
  -H 'Content-Type: application/javascript' \
  -d 'import { faker } from '\''https://esm.sh/@faker-js/faker'\'';

export default async function ({ page }) {
  const rndName = faker.person.fullName();
  const rndEmail = faker.internet.email();

  await page.evaluate((name, email) => {
    const jsonStr = JSON.stringify({name, email});
    const jsonContent = `data:application/json,${jsonStr}`;
    const encodedUri = encodeURI(jsonContent);
    const link = document.createElement("a");

    link.setAttribute("href", encodedUri);
    link.setAttribute("download", "data.json");
    document.body.appendChild(link);
    return link.click();
  }, rndName, rndEmail);
}'

```

```codeBlockLines_p187
import { writeFile } from 'fs/promises';

const TOKEN = "YOUR_API_TOKEN_HERE";
const url = `https://production-sfo.browserless.io/download?token=${TOKEN}`;
const headers = {
  "Content-Type": "application/javascript"
};

const data = `
import { faker } from 'https://esm.sh/@faker-js/faker';

export default async function ({ page }) {
  const rndName = faker.person.fullName();
  const rndEmail = faker.internet.email();

  await page.evaluate((name, email) => {
    const jsonStr = JSON.stringify({ name, email });
    const jsonContent = \`data:application/json,\${jsonStr}\`;
    const encodedUri = encodeURI(jsonContent);
    const link = document.createElement("a");

    link.setAttribute("href", encodedUri);
    link.setAttribute("download", "data.json");
    document.body.appendChild(link);
    link.click();
  }, rndName, rndEmail);
};
`;

const downloadFile = async () => {
  const response = await fetch(url, {
    method: 'POST',
    headers: headers,
    body: data
  });

  const buffer = await response.arrayBuffer();
  await writeFile("data.json", Buffer.from(buffer));
  console.log("File saved as data.json");
};

downloadFile();

```

```codeBlockLines_p187
import requests

TOKEN = "YOUR_API_TOKEN_HERE"
url = f"https://production-sfo.browserless.io/download?token={TOKEN}"
headers = {
    "Content-Type": "application/javascript"
}

data = """
import { faker } from 'https://esm.sh/@faker-js/faker';

export default async function ({ page }) {
  const rndName = faker.person.fullName();
  const rndEmail = faker.internet.email();

  await page.evaluate((name, email) => {
    const jsonStr = JSON.stringify({ name, email });
    const jsonContent = `data:application/json,${jsonStr}`;
    const encodedUri = encodeURI(jsonContent);
    const link = document.createElement("a");

    link.setAttribute("href", encodedUri);
    link.setAttribute("download", "data.json");
    document.body.appendChild(link);
    link.click();
  }, rndName, rndEmail);
};
"""

response = requests.post(url, headers=headers, data=data)

with open("data.json", "wb") as file:
    file.write(response.content)

print("File saved as data.json")

```

```codeBlockLines_p187
import java.io.*;
import java.net.*;
import java.net.http.*;

public class DownloadJsonFileWithFaker {
    public static void main(String[] args) {
        String TOKEN = "YOUR_API_TOKEN_HERE";
        String url = "https://production-sfo.browserless.io/download?token=" + TOKEN;

        String javascriptCode = """
        import { faker } from 'https://esm.sh/@faker-js/faker';

        export default async function ({ page }) {
            const rndName = faker.person.fullName();
            const rndEmail = faker.internet.email();

            await page.evaluate((name, email) => {
                const jsonStr = JSON.stringify({ name, email });
                const jsonContent = `data:application/json,${jsonStr}`;
                const encodedUri = encodeURI(jsonContent);
                const link = document.createElement("a");

                link.setAttribute("href", encodedUri);
                link.setAttribute("download", "data.json");
                document.body.appendChild(link);
                link.click();
            }, rndName, rndEmail);
        };
        """;

        HttpClient client = HttpClient.newHttpClient();

        HttpRequest request = HttpRequest.newBuilder()
            .uri(URI.create(url))
            .header("Content-Type", "application/javascript")
            .POST(HttpRequest.BodyPublishers.ofString(javascriptCode))
            .build();

        try {
            HttpResponse<InputStream> response = client.send(request, HttpResponse.BodyHandlers.ofInputStream());

            try (InputStream in = response.body();
                 FileOutputStream fileOut = new FileOutputStream("data.json")) {
                in.transferTo(fileOut);
                System.out.println("File saved as data.json");
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

```

```codeBlockLines_p187
using System;
using System.IO;
using System.Net.Http;
using System.Text;
using System.Threading.Tasks;

class Program
{
    static async Task Main(string[] args)
    {
        string TOKEN = "YOUR_API_TOKEN_HERE";
        string url = $"https://production-sfo.browserless.io/download?token={TOKEN}";

        string javascriptCode = @"
          import { faker } from 'https://esm.sh/@faker-js/faker';

          export default async function ({ page }) {
              const rndName = faker.person.fullName();
              const rndEmail = faker.internet.email();

              await page.evaluate((name, email) => {
                  const jsonStr = JSON.stringify({ name, email });
                  const jsonContent = `data:application/json,${jsonStr}`;
                  const encodedUri = encodeURI(jsonContent);
                  const link = document.createElement('a');

                  link.setAttribute('href', encodedUri);
                  link.setAttribute('download', 'data.json');
                  document.body.appendChild(link);
                  link.click();
              }, rndName, rndEmail);
          };";

        using var client = new HttpClient();
        var content = new StringContent(javascriptCode, Encoding.UTF8, "application/javascript");

        try
        {
            var response = await client.PostAsync(url, content);
            response.EnsureSuccessStatusCode();

            using var stream = await response.Content.ReadAsStreamAsync();
            using var fileStream = new FileStream("data.json", FileMode.Create, FileAccess.Write);
            await stream.CopyToAsync(fileStream);

            Console.WriteLine("File saved as data.json");
        }
        catch (Exception ex)
        {
            Console.WriteLine("Error: " + ex.Message);
        }
    }
}

```

**Example response**

```codeBlockLines_p187
{
  "name": "Jasmine Littel",
  "email": "Giovanna26@hotmail.com"
}

```

## JSON API [â€‹](https://docs.browserless.io/rest-apis/download\#json-api "Direct link to JSON API")

You can also use the /download API sending a JSON payload. You must send an object with the following values:

- `code`: String, required â€” custom download code.
- `context`: Object, optional â€” value used to pass context values and arguments to the `code`

### Example [â€‹](https://docs.browserless.io/rest-apis/download\#example "Direct link to Example")

**JS Code**

```codeBlockLines_p187
export default async function ({ page, context }) {
  await page.evaluate((context) => {
    const json = {
      url: context.url,
      ping: "pong",
      rnd: [...Array(context.arrayLen)].map(() => Math.random()),
    };
    const jsonContent = `data:application/json,${JSON.stringify(json)}`;
    const encodedUri = encodeURI(jsonContent);
    const link = document.createElement("a");

    link.setAttribute("href", encodedUri);
    link.setAttribute("download", "data.json");
    document.body.appendChild(link);
    return link.click();
  }, context);
}

```

- cURL
- Javascript
- Python
- Java
- C#

```codeBlockLines_p187
curl --request POST \
  --url 'https://production-sfo.browserless.io/download?token=YOUR_API_TOKEN_HERE' \
  --header 'Content-Type: application/json' \
  # Minified code
  --data '{
  "code": "export default async function({page:t,context:a}){await t.evaluate(t=>{let a={url:t.url,ping:`pong`,rnd:[...Array(t.arrayLen)].map(()=>Math.random())},e=`data:application/json,${JSON.stringify(a)}`,n=encodeURI(e),r=document.createElement(`a`);return r.setAttribute(`href`,n),r.setAttribute(`download`,`data.json`),document.body.appendChild(r),r.click()},a)};",
  "context": {
    "url": "https://browserless.io/",
    "arrayLen": 10
  }
}''

```

```codeBlockLines_p187
import { writeFile } from 'fs/promises';

const TOKEN = "YOUR_API_TOKEN_HERE";
const url = `https://production-sfo.browserless.io/download?token=${TOKEN}`;
const headers = {
  'Content-Type': 'application/json'
};

// Minified code
const data = {
  code: "export default async function({page:t,context:a}){await t.evaluate(t=>{let a={url:t.url,ping:`pong`,rnd:[...Array(t.arrayLen)].map(()=>Math.random())},e=`data:application/json,${JSON.stringify(a)}`,n=encodeURI(e),r=document.createElement(`a`);return r.setAttribute(`href`,n),r.setAttribute(`download`,`data.json`),document.body.appendChild(r),r.click()},a)};",
  context: {
    url: "https://browserless.io/",
    arrayLen: 10
  }
};

const downloadFile = async () => {
  const response = await fetch(url, {
    method: 'POST',
    headers: headers,
    body: JSON.stringify(data)
  });

  const buffer = await response.arrayBuffer();
  await writeFile("data.json", Buffer.from(buffer));
  console.log("File saved as data.json");
};

downloadFile();

```

```codeBlockLines_p187
import requests

TOKEN = "YOUR_API_TOKEN_HERE"
url = f"https://production-sfo.browserless.io/download?token={TOKEN}"
headers = {
    'Content-Type': 'application/json'
}

# Minified code
data = {
    "code": "export default async function({page:t,context:a}){await t.evaluate(t=>{let a={url:t.url,ping:`pong`,rnd:[...Array(t.arrayLen)].map(()=>Math.random())},e=`data:application/json,${JSON.stringify(a)}`,n=encodeURI(e),r=document.createElement(`a`);return r.setAttribute(`href`,n),r.setAttribute(`download`,`data.json`),document.body.appendChild(r),r.click()},a)};",
    "context": {
        "url": "https://browserless.io/",
        "arrayLen": 10
    }
}

response = requests.post(url, headers=headers, json=data)

with open("data.json", "wb") as file:
    file.write(response.content)

print("File saved as data.json")

```

```codeBlockLines_p187
import java.io.*;
import java.net.http.*;
import java.net.URI;

public class DownloadJsonFileWithMinifiedCode {
    public static void main(String[] args) {
        String TOKEN = "YOUR_API_TOKEN_HERE";
        String url = "https://production-sfo.browserless.io/download?token=" + TOKEN;

        String jsonData = """
        {
            "code": "export default async function({page:t,context:a}){await t.evaluate(t=>{let a={url:t.url,ping:`pong`,rnd:[...Array(t.arrayLen)].map(()=>Math.random())},e=`data:application/json,${JSON.stringify(a)}`,n=encodeURI(e),r=document.createElement(`a`);return r.setAttribute(`href`,n),r.setAttribute(`download`,`data.json`),document.body.appendChild(r),r.click()},a)};",
            "context": {
                "url": "https://browserless.io/",
                "arrayLen": 10
            }
        }
        """;

        HttpClient client = HttpClient.newHttpClient();

        HttpRequest request = HttpRequest.newBuilder()
            .uri(URI.create(url))
            .header("Content-Type", "application/json")
            .POST(HttpRequest.BodyPublishers.ofString(jsonData))
            .build();

        try {
            HttpResponse<InputStream> response = client.send(request, HttpResponse.BodyHandlers.ofInputStream());

            try (InputStream in = response.body();
                 FileOutputStream fileOut = new FileOutputStream("data.json")) {
                in.transferTo(fileOut);
                System.out.println("File saved as data.json");
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

```

```codeBlockLines_p187
using System;
using System.IO;
using System.Net.Http;
using System.Text;
using System.Threading.Tasks;

class Program {
    static async Task Main(string[] args) {
        string TOKEN = "YOUR_API_TOKEN_HERE";
        string url = $"https://production-sfo.browserless.io/download?token={TOKEN}";

        string jsonData = @"
        {
            ""code"": ""export default async function({page:t,context:a}){await t.evaluate(t=>{let a={url:t.url,ping:`pong`,rnd:[...Array(t.arrayLen)].map(()=>Math.random())},e=`data:application/json,${JSON.stringify(a)}`,n=encodeURI(e),r=document.createElement(`a`);return r.setAttribute(`href`,n),r.setAttribute(`download`,`data.json`),document.body.appendChild(r),r.click()},a)};"",
            ""context"": {
                ""url"": ""https://browserless.io/"",
                ""arrayLen"": 10
            }
        }
        ";

        using var client = new HttpClient();
        var content = new StringContent(jsonData, Encoding.UTF8, "application/json");

        try {
            var response = await client.PostAsync(url, content);
            response.EnsureSuccessStatusCode();

            using var stream = await response.Content.ReadAsStreamAsync();
            using var fileStream = new FileStream("data.json", FileMode.Create, FileAccess.Write);
            await stream.CopyToAsync(fileStream);

            Console.WriteLine("File saved as data.json");
        } catch (Exception ex) {
            Console.WriteLine("Error: " + ex.Message);
        }
    }
}

```

- [Basic Usage](https://docs.browserless.io/rest-apis/download#basic-usage)
- [Import libraries](https://docs.browserless.io/rest-apis/download#import-libraries)
- [JSON API](https://docs.browserless.io/rest-apis/download#json-api)
  - [Example](https://docs.browserless.io/rest-apis/download#example)

---

### /export API | Browserless.io
Original URL: https://docs.browserless.io/rest-apis/export

[Skip to main content](https://docs.browserless.io/rest-apis/export#__docusaurus_skipToContent_fallback)


The export API allows you to retrieve the content of any URL in its native format (HTML, PDF, images, etc.). The response format is determined by the content type of the page being accessed, with appropriate headers set to facilitate downloading or viewing the content.

You can [check the full Open API schema here](https://docs.browserless.io/open-api#tag/Browser-REST-APIs/paths/~1chrome~1export/post).

## Basic Usage [â€‹](https://docs.browserless.io/rest-apis/export\#basic-usage "Direct link to Basic Usage")

The export API accepts a JSON payload with the target URL and configuration options.

### JSON Payload Format [â€‹](https://docs.browserless.io/rest-apis/export\#json-payload-format "Direct link to JSON Payload Format")

```codeBlockLines_p187
{
  "url": "https://example.com/",
  "headers": {
    "User-Agent": "Custom User Agent"
  },
  "gotoOptions": {
    "waitUntil": "networkidle0",
    "timeout": 30000
  },
  "waitForSelector": {
    "selector": "#main-content",
    "timeout": 5000
  },
  "waitForTimeout": 1000,
  "bestAttempt": false
}

```

## Parameters [â€‹](https://docs.browserless.io/rest-apis/export\#parameters "Direct link to Parameters")

### Required Parameters [â€‹](https://docs.browserless.io/rest-apis/export\#required-parameters "Direct link to Required Parameters")

- `url` (string) - The URL of the resource to export

### Optional Parameters [â€‹](https://docs.browserless.io/rest-apis/export\#optional-parameters "Direct link to Optional Parameters")

- `headers` (object) - Custom HTTP headers to send with the request
- `gotoOptions` (object) - Navigation options

  - `waitUntil` (string) - When to consider navigation succeeded. Options: 'load', 'domcontentloaded', 'networkidle', 'commit'. Default: 'networkidle0'
  - `timeout` (number) - Maximum navigation time in milliseconds
  - `referer` (string) - Referer header value
- `waitForEvent` (object) - Wait for a specific event before proceeding
- `waitForFunction` (object) - Wait for a specific function to return true
- `waitForSelector` (object) - Wait for a specific selector to be present

  - `selector` (string) - CSS selector to wait for
  - `timeout` (number) - Maximum time to wait in milliseconds
- `waitForTimeout` (number) - Time in milliseconds to wait after page load
- `bestAttempt` (boolean) - Whether to continue on errors. Default: false
- `includeResources` (boolean) - Whether to include all linked resources (images, CSS, JavaScript) in a zip file. Default: false

## Response [â€‹](https://docs.browserless.io/rest-apis/export\#response "Direct link to Response")

The API returns a streaming response with the content of the requested URL. The behavior depends on the content type detected and the `includeResources` parameter:

- When `includeResources` is `false` (default):
  - **HTML Content**: Returns the HTML with `Content-Type: text/html`. No attachment header is set, allowing the content to be rendered in the browser.
  - **PDF Content**: Returns a PDF buffer with `Content-Type: application/pdf` and sets a `Content-Disposition: attachment` header with an appropriate filename.
  - **Images and Other Binary Content**: Returns the binary content with the appropriate MIME type (e.g., `image/jpeg`, `image/png`) and sets a `Content-Disposition: attachment` header with an appropriate filename.
- When `includeResources` is `true`:
  - Returns a zip file containing the HTML and all linked resources (images, CSS, JavaScript) with `Content-Type: application/zip` and `Content-Disposition: attachment` header with an appropriate filename.

The streaming nature of the response means you should handle it accordingly in your code, using appropriate methods for reading streams rather than assuming all content can be processed as text.

## Handling Different Content Types [â€‹](https://docs.browserless.io/rest-apis/export\#handling-different-content-types "Direct link to Handling Different Content Types")

The export API can return various content types depending on the URL being accessed. Here's how to properly handle the different response types:

### HTML Content [â€‹](https://docs.browserless.io/rest-apis/export\#html-content "Direct link to HTML Content")

When accessing a standard web page, the API returns HTML content with `Content-Type: text/html`:

```codeBlockLines_p187
const response = await fetch(url, options);
if (response.headers.get('content-type')?.includes('text/html')) {
  const htmlContent = await response.text();
  // Process HTML content
}

```

### PDF Content [â€‹](https://docs.browserless.io/rest-apis/export\#pdf-content "Direct link to PDF Content")

When accessing PDF files or when the server returns PDF content, the API returns a PDF buffer with `Content-Type: application/pdf`:

```codeBlockLines_p187
const response = await fetch(url, options);
if (response.headers.get('content-type')?.includes('application/pdf')) {
  const arrayBuffer = await response.arrayBuffer();
  const pdfBuffer = Buffer.from(arrayBuffer);
  // Save or process PDF buffer
}

```

### Binary Content (Images, etc.) [â€‹](https://docs.browserless.io/rest-apis/export\#binary-content-images-etc "Direct link to Binary Content (Images, etc.)")

For other binary content like images, the API returns the appropriate content type and sets attachment headers:

```codeBlockLines_p187
const response = await fetch(url, options);
const contentType = response.headers.get('content-type');
if (contentType?.includes('image/') || !contentType?.includes('text/')) {
  const arrayBuffer = await response.arrayBuffer();
  const binaryBuffer = Buffer.from(arrayBuffer);
  // Save or process binary buffer
}

```

## Error Handling [â€‹](https://docs.browserless.io/rest-apis/export\#error-handling "Direct link to Error Handling")

The API may return the following error responses:

- `400 Bad Request` \- Invalid parameters, missing URL, or no content received
- `404 Not Found` \- Page not found
- `408 Request Timeout` \- Page load timeout
- `500 Internal Server Error` \- Server-side error

## Examples [â€‹](https://docs.browserless.io/rest-apis/export\#examples "Direct link to Examples")

### Basic Export Request [â€‹](https://docs.browserless.io/rest-apis/export\#basic-export-request "Direct link to Basic Export Request")

This example demonstrates how to export a web page using the most basic configuration. It shows how to properly handle the streamed response by detecting the content type and saving the content with the appropriate file extension.

- cURL
- Javascript
- Python
- Java
- C#

```codeBlockLines_p187
curl -X POST \
  https://production-sfo.browserless.io/export?token=YOUR_API_TOKEN_HERE \
  -H 'Content-Type: application/json' \
  -d '{
    "url": "https://example.com/"
  }'

```

```codeBlockLines_p187
import { writeFile } from 'fs/promises';

const TOKEN = "YOUR_API_TOKEN_HERE";
const url = `https://production-sfo.browserless.io/export?token=${TOKEN}`;
const headers = {
  'Content-Type': 'application/json'
};

const data = {
  url: "https://example.com/"
};

const exportPage = async () => {
  const response = await fetch(url, {
    method: 'POST',
    headers: headers,
    body: JSON.stringify(data)
  });

  // Get content type to determine how to handle the response
  const contentType = response.headers.get('content-type');

  // Get filename from Content-Disposition header or create a default one based on content type
  let filename = 'downloaded-content';
  const disposition = response.headers.get('content-disposition');
  if (disposition && disposition.includes('filename=')) {
    const filenameMatch = disposition.match(/filename="(.+?)"/);
    if (filenameMatch) filename = filenameMatch[1];
  } else if (contentType) {
    // Set appropriate extension based on content type
    if (contentType.includes('text/html')) filename = 'page.html';
    else if (contentType.includes('application/pdf')) filename = 'document.pdf';
    else if (contentType.includes('image/')) {
      const ext = contentType.split('/')[1];
      filename = `image.${ext}`;
    }
  }

  // Handle response based on content type
  if (contentType && contentType.includes('text/html')) {
    // Handle HTML content as text
    const content = await response.text();
    await writeFile(filename, content);
  } else {
    // Handle binary content (PDFs, images, etc.)
    const arrayBuffer = await response.arrayBuffer();
    const buffer = Buffer.from(arrayBuffer);
    await writeFile(filename, buffer);
  }

  console.log(`Content saved as ${filename}`);
};

exportPage();

```

```codeBlockLines_p187
import requests
import re

TOKEN = "YOUR_API_TOKEN_HERE"
url = f"https://production-sfo.browserless.io/export?token={TOKEN}"
headers = {
    'Content-Type': 'application/json'
}

data = {
    "url": "https://example.com/"
}

response = requests.post(url, headers=headers, json=data)

# Get content type and determine appropriate filename
content_type = response.headers.get('Content-Type', '')
disposition = response.headers.get('Content-Disposition', '')

# Try to get filename from Content-Disposition header
filename = 'downloaded-content'
if disposition and 'filename=' in disposition:
    match = re.search('filename="(.+?)"', disposition)
    if match:
        filename = match.group(1)
else:
    # Create filename based on content type
    if 'text/html' in content_type:
        filename = 'page.html'
    elif 'application/pdf' in content_type:
        filename = 'document.pdf'
    elif 'image/' in content_type:
        ext = content_type.split('/')[1]
        filename = f"image.{ext}"

# Write content to file using binary mode for all types to ensure proper handling
with open(filename, "wb") as file:
    file.write(response.content)

print(f"Content saved as {filename}")

```

```codeBlockLines_p187
import java.io.*;
import java.net.http.*;
import java.net.URI;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class ExportPage {
    public static void main(String[] args) {
        String TOKEN = "YOUR_API_TOKEN_HERE";
        String url = "https://production-sfo.browserless.io/export?token=" + TOKEN;

        String jsonData = """
        {
            "url": "https://example.com/"
        }
        """;

        HttpClient client = HttpClient.newHttpClient();

        HttpRequest request = HttpRequest.newBuilder()
            .uri(URI.create(url))
            .header("Content-Type", "application/json")
            .POST(HttpRequest.BodyPublishers.ofString(jsonData))
            .build();

        try {
            HttpResponse<byte[]> response = client.send(request, HttpResponse.BodyHandlers.ofByteArray());

            // Get content type and determine appropriate filename
            String contentType = response.headers().firstValue("Content-Type").orElse("");
            String disposition = response.headers().firstValue("Content-Disposition").orElse("");

            // Try to get filename from Content-Disposition header
            String filename = "downloaded-content";
            if (disposition.contains("filename=")) {
                Pattern pattern = Pattern.compile("filename=\"(.+?)\"");
                Matcher matcher = pattern.matcher(disposition);
                if (matcher.find()) {
                    filename = matcher.group(1);
                }
            } else {
                // Create filename based on content type
                if (contentType.contains("text/html")) {
                    filename = "page.html";
                } else if (contentType.contains("application/pdf")) {
                    filename = "document.pdf";
                } else if (contentType.contains("image/")) {
                    String ext = contentType.split("/")[1];
                    filename = "image." + ext;
                }
            }

            // Write content to file
            try (FileOutputStream fileOutputStream = new FileOutputStream(filename)) {
                fileOutputStream.write(response.body());
                System.out.println("Content saved as " + filename);
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

```

```codeBlockLines_p187
using System;
using System.IO;
using System.Net.Http;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading.Tasks;

class Program {
    static async Task Main(string[] args) {
        string TOKEN = "YOUR_API_TOKEN_HERE";
        string url = $"https://production-sfo.browserless.io/export?token={TOKEN}";

        string jsonData = @"
        {
            ""url"": ""https://example.com/""
        }
        ";

        using var client = new HttpClient();
        var content = new StringContent(jsonData, Encoding.UTF8, "application/json");

        try {
            var response = await client.PostAsync(url, content);
            response.EnsureSuccessStatusCode();

            // Get content type and determine appropriate filename
            var contentType = response.Content.Headers.ContentType?.MediaType ?? "";
            var disposition = response.Content.Headers.ContentDisposition?.ToString() ?? "";

            // Try to get filename from Content-Disposition header
            string filename = "downloaded-content";
            if (disposition.Contains("filename=")) {
                var match = Regex.Match(disposition, "filename=\"(.+?)\"");
                if (match.Success) {
                    filename = match.Groups[1].Value;
                }
            } else {
                // Create filename based on content type
                if (contentType.Contains("text/html")) {
                    filename = "page.html";
                } else if (contentType.Contains("application/pdf")) {
                    filename = "document.pdf";
                } else if (contentType.Contains("image/")) {
                    var ext = contentType.Split('/')[1];
                    filename = $"image.{ext}";
                }
            }

            // Handle all content types as binary for consistency
            var bytes = await response.Content.ReadAsByteArrayAsync();
            await File.WriteAllBytesAsync(filename, bytes);

            Console.WriteLine($"Content saved as {filename}");
        } catch (Exception ex) {
            Console.WriteLine("Error: " + ex.Message);
        }
    }
}

```

### Export with Custom Navigation Options [â€‹](https://docs.browserless.io/rest-apis/export\#export-with-custom-navigation-options "Direct link to Export with Custom Navigation Options")

This example demonstrates how to export a web page with custom navigation options, such as waiting for specific network events or DOM elements to load. These options help ensure the page is fully rendered before capturing the content.

- cURL
- Javascript
- Python
- Java
- C#

```codeBlockLines_p187
curl -X POST \
  https://production-sfo.browserless.io/export?token=YOUR_API_TOKEN_HERE \
  -H 'Content-Type: application/json' \
  -d '{
    "url": "https://example.com/",
    "gotoOptions": {
      "waitUntil": "networkidle0",
      "timeout": 60000
    },
    "waitForSelector": {
      "selector": "#main-content",
      "timeout": 5000
    }
  }'

```

```codeBlockLines_p187
import { writeFile } from 'fs/promises';

const TOKEN = "YOUR_API_TOKEN_HERE";
const url = `https://production-sfo.browserless.io/export?token=${TOKEN}`;
const headers = {
  'Content-Type': 'application/json'
};

const data = {
  url: "https://example.com/",
  gotoOptions: {
    waitUntil: "networkidle0",
    timeout: 60000
  },
  waitForSelector: {
    selector: "#main-content",
    timeout: 5000
  }
};

const exportPage = async () => {
  const response = await fetch(url, {
    method: 'POST',
    headers: headers,
    body: JSON.stringify(data)
  });

  // Get content type to determine how to handle the response
  const contentType = response.headers.get('content-type');

  // Get filename from Content-Disposition header or create a default one based on content type
  let filename = 'downloaded-content';
  const disposition = response.headers.get('content-disposition');
  if (disposition && disposition.includes('filename=')) {
    const filenameMatch = disposition.match(/filename="(.+?)"/);
    if (filenameMatch) filename = filenameMatch[1];
  } else if (contentType) {
    // Set appropriate extension based on content type
    if (contentType.includes('text/html')) filename = 'page.html';
    else if (contentType.includes('application/pdf')) filename = 'document.pdf';
    else if (contentType.includes('image/')) {
      const ext = contentType.split('/')[1];
      filename = `image.${ext}`;
    }
  }

  // Handle response based on content type
  if (contentType && contentType.includes('text/html')) {
    // Handle HTML content as text
    const content = await response.text();
    await writeFile(filename, content);
  } else {
    // Handle binary content (PDFs, images, etc.)
    const arrayBuffer = await response.arrayBuffer();
    const buffer = Buffer.from(arrayBuffer);
    await writeFile(filename, buffer);
  }

  console.log(`Content saved as ${filename}`);
};

exportPage();

```

```codeBlockLines_p187
import requests
import re

TOKEN = "YOUR_API_TOKEN_HERE"
url = f"https://production-sfo.browserless.io/export?token={TOKEN}"
headers = {
    'Content-Type': 'application/json'
}

data = {
    "url": "https://example.com/",
    "gotoOptions": {
        "waitUntil": "networkidle0",
        "timeout": 60000
    },
    "waitForSelector": {
        "selector": "#main-content",
        "timeout": 5000
    }
}

response = requests.post(url, headers=headers, json=data)

# Get content type and determine appropriate filename
content_type = response.headers.get('Content-Type', '')
disposition = response.headers.get('Content-Disposition', '')

# Try to get filename from Content-Disposition header
filename = 'downloaded-content'
if disposition and 'filename=' in disposition:
    match = re.search('filename="(.+?)"', disposition)
    if match:
        filename = match.group(1)
else:
    # Create filename based on content type
    if 'text/html' in content_type:
        filename = 'page.html'
    elif 'application/pdf' in content_type:
        filename = 'document.pdf'
    elif 'image/' in content_type:
        ext = content_type.split('/')[1]
        filename = f"image.{ext}"

# Write content to file using binary mode for all types to ensure proper handling
with open(filename, "wb") as file:
    file.write(response.content)

print(f"Content saved as {filename}")

```

```codeBlockLines_p187
import java.io.*;
import java.net.http.*;
import java.net.URI;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class ExportPageWithOptions {
    public static void main(String[] args) {
        String TOKEN = "YOUR_API_TOKEN_HERE";
        String url = "https://production-sfo.browserless.io/export?token=" + TOKEN;

        String jsonData = """
        {
            "url": "https://example.com/",
            "gotoOptions": {
                "waitUntil": "networkidle0",
                "timeout": 60000
            },
            "waitForSelector": {
                "selector": "#main-content",
                "timeout": 5000
            }
        }
        """;

        HttpClient client = HttpClient.newHttpClient();

        HttpRequest request = HttpRequest.newBuilder()
            .uri(URI.create(url))
            .header("Content-Type", "application/json")
            .POST(HttpRequest.BodyPublishers.ofString(jsonData))
            .build();

        try {
            HttpResponse<byte[]> response = client.send(request, HttpResponse.BodyHandlers.ofByteArray());

            // Get content type and determine appropriate filename
            String contentType = response.headers().firstValue("Content-Type").orElse("");
            String disposition = response.headers().firstValue("Content-Disposition").orElse("");

            // Try to get filename from Content-Disposition header
            String filename = "downloaded-content";
            if (disposition.contains("filename=")) {
                Pattern pattern = Pattern.compile("filename=\"(.+?)\"");
                Matcher matcher = pattern.matcher(disposition);
                if (matcher.find()) {
                    filename = matcher.group(1);
                }
            } else {
                // Create filename based on content type
                if (contentType.contains("text/html")) {
                    filename = "page.html";
                } else if (contentType.contains("application/pdf")) {
                    filename = "document.pdf";
                } else if (contentType.contains("image/")) {
                    String ext = contentType.split("/")[1];
                    filename = "image." + ext;
                }
            }

            // Write content to file
            try (FileOutputStream fileOutputStream = new FileOutputStream(filename)) {
                fileOutputStream.write(response.body());
                System.out.println("Content saved as " + filename);
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

```

```codeBlockLines_p187
using System;
using System.IO;
using System.Net.Http;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading.Tasks;

class Program {
    static async Task Main(string[] args) {
        string TOKEN = "YOUR_API_TOKEN_HERE";
        string url = $"https://production-sfo.browserless.io/export?token={TOKEN}";

        string jsonData = @"
        {
            ""url"": ""https://example.com/"",
            ""gotoOptions"": {
                ""waitUntil"": ""networkidle0"",
                ""timeout"": 60000
            },
            ""waitForSelector"": {
                ""selector"": ""#main-content"",
                ""timeout"": 5000
            }
        }
        ";

        using var client = new HttpClient();
        var content = new StringContent(jsonData, Encoding.UTF8, "application/json");

        try {
            var response = await client.PostAsync(url, content);
            response.EnsureSuccessStatusCode();

            // Get content type and determine appropriate filename
            var contentType = response.Content.Headers.ContentType?.MediaType ?? "";
            var disposition = response.Content.Headers.ContentDisposition?.ToString() ?? "";

            // Try to get filename from Content-Disposition header
            string filename = "downloaded-content";
            if (disposition.Contains("filename=")) {
                var match = Regex.Match(disposition, "filename=\"(.+?)\"");
                if (match.Success) {
                    filename = match.Groups[1].Value;
                }
            } else {
                // Create filename based on content type
                if (contentType.Contains("text/html")) {
                    filename = "page.html";
                } else if (contentType.Contains("application/pdf")) {
                    filename = "document.pdf";
                } else if (contentType.Contains("image/")) {
                    var ext = contentType.Split('/')[1];
                    filename = $"image.{ext}";
                }
            }

            // Handle all content types as binary for consistency
            var bytes = await response.Content.ReadAsByteArrayAsync();
            await File.WriteAllBytesAsync(filename, bytes);

            Console.WriteLine($"Content saved as {filename}");
        } catch (Exception ex) {
            Console.WriteLine("Error: " + ex.Message);
        }
    }
}

```

### Export with Custom Headers [â€‹](https://docs.browserless.io/rest-apis/export\#export-with-custom-headers "Direct link to Export with Custom Headers")

This example demonstrates how to export a web page with custom HTTP headers. Custom headers allow you to modify the browser's behavior when accessing the page, such as changing the User-Agent or setting language preferences.

- cURL
- Javascript
- Python
- Java
- C#

```codeBlockLines_p187
curl -X POST \
  https://production-sfo.browserless.io/export?token=YOUR_API_TOKEN_HERE \
  -H 'Content-Type: application/json' \
  -d '{
    "url": "https://example.com/",
    "headers": {
      "User-Agent": "Custom User Agent",
      "Accept-Language": "en-US"
    }
  }'

```

```codeBlockLines_p187
import { writeFile } from 'fs/promises';

const TOKEN = "YOUR_API_TOKEN_HERE";
const url = `https://production-sfo.browserless.io/export?token=${TOKEN}`;
const headers = {
  'Content-Type': 'application/json'
};

const data = {
  url: "https://example.com/",
  headers: {
    "User-Agent": "Custom User Agent",
    "Accept-Language": "en-US"
  }
};

const exportPage = async () => {
  const response = await fetch(url, {
    method: 'POST',
    headers: headers,
    body: JSON.stringify(data)
  });

  // Get content type to determine how to handle the response
  const contentType = response.headers.get('content-type');

  // Get filename from Content-Disposition header or create a default one based on content type
  let filename = 'downloaded-content';
  const disposition = response.headers.get('content-disposition');
  if (disposition && disposition.includes('filename=')) {
    const filenameMatch = disposition.match(/filename="(.+?)"/);
    if (filenameMatch) filename = filenameMatch[1];
  } else if (contentType) {
    // Set appropriate extension based on content type
    if (contentType.includes('text/html')) filename = 'page.html';
    else if (contentType.includes('application/pdf')) filename = 'document.pdf';
    else if (contentType.includes('image/')) {
      const ext = contentType.split('/')[1];
      filename = `image.${ext}`;
    }
  }

  // Handle response based on content type
  if (contentType && contentType.includes('text/html')) {
    // Handle HTML content as text
    const content = await response.text();
    await writeFile(filename, content);
  } else {
    // Handle binary content (PDFs, images, etc.)
    const arrayBuffer = await response.arrayBuffer();
    const buffer = Buffer.from(arrayBuffer);
    await writeFile(filename, buffer);
  }

  console.log(`Content saved as ${filename}`);
};

exportPage();

```

```codeBlockLines_p187
import requests
import re

TOKEN = "YOUR_API_TOKEN_HERE"
url = f"https://production-sfo.browserless.io/export?token={TOKEN}"
headers = {
    'Content-Type': 'application/json'
}

data = {
    "url": "https://example.com/",
    "headers": {
        "User-Agent": "Custom User Agent",
        "Accept-Language": "en-US"
    }
}

response = requests.post(url, headers=headers, json=data)

# Get content type and determine appropriate filename
content_type = response.headers.get('Content-Type', '')
disposition = response.headers.get('Content-Disposition', '')

# Try to get filename from Content-Disposition header
filename = 'downloaded-content'
if disposition and 'filename=' in disposition:
    match = re.search('filename="(.+?)"', disposition)
    if match:
        filename = match.group(1)
else:
    # Create filename based on content type
    if 'text/html' in content_type:
        filename = 'page.html'
    elif 'application/pdf' in content_type:
        filename = 'document.pdf'
    elif 'image/' in content_type:
        ext = content_type.split('/')[1]
        filename = f"image.{ext}"

# Write content to file using binary mode for all types to ensure proper handling
with open(filename, "wb") as file:
    file.write(response.content)

print(f"Content saved as {filename}")

```

```codeBlockLines_p187
import java.io.*;
import java.net.http.*;
import java.net.URI;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class ExportPageWithHeaders {
    public static void main(String[] args) {
        String TOKEN = "YOUR_API_TOKEN_HERE";
        String url = "https://production-sfo.browserless.io/export?token=" + TOKEN;

        String jsonData = """
        {
            "url": "https://example.com/",
            "headers": {
                "User-Agent": "Custom User Agent",
                "Accept-Language": "en-US"
            }
        }
        """;

        HttpClient client = HttpClient.newHttpClient();

        HttpRequest request = HttpRequest.newBuilder()
            .uri(URI.create(url))
            .header("Content-Type", "application/json")
            .POST(HttpRequest.BodyPublishers.ofString(jsonData))
            .build();

        try {
            HttpResponse<byte[]> response = client.send(request, HttpResponse.BodyHandlers.ofByteArray());

            // Get content type and determine appropriate filename
            String contentType = response.headers().firstValue("Content-Type").orElse("");
            String disposition = response.headers().firstValue("Content-Disposition").orElse("");

            // Try to get filename from Content-Disposition header
            String filename = "downloaded-content";
            if (disposition.contains("filename=")) {
                Pattern pattern = Pattern.compile("filename=\"(.+?)\"");
                Matcher matcher = pattern.matcher(disposition);
                if (matcher.find()) {
                    filename = matcher.group(1);
                }
            } else {
                // Create filename based on content type
                if (contentType.contains("text/html")) {
                    filename = "page.html";
                } else if (contentType.contains("application/pdf")) {
                    filename = "document.pdf";
                } else if (contentType.contains("image/")) {
                    String ext = contentType.split("/")[1];
                    filename = "image." + ext;
                }
            }

            // Write content to file
            try (FileOutputStream fileOutputStream = new FileOutputStream(filename)) {
                fileOutputStream.write(response.body());
                System.out.println("Content saved as " + filename);
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

```

```codeBlockLines_p187
using System;
using System.IO;
using System.Net.Http;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading.Tasks;

class Program {
    static async Task Main(string[] args) {
        string TOKEN = "YOUR_API_TOKEN_HERE";
        string url = $"https://production-sfo.browserless.io/export?token={TOKEN}";

        string jsonData = @"
        {
            ""url"": ""https://example.com/"",
            ""headers"": {
                ""User-Agent"": ""Custom User Agent"",
                ""Accept-Language"": ""en-US""
            }
        }
        ";

        using var client = new HttpClient();
        var content = new StringContent(jsonData, Encoding.UTF8, "application/json");

        try {
            var response = await client.PostAsync(url, content);
            response.EnsureSuccessStatusCode();

            // Get content type and determine appropriate filename
            var contentType = response.Content.Headers.ContentType?.MediaType ?? "";
            var disposition = response.Content.Headers.ContentDisposition?.ToString() ?? "";

            // Try to get filename from Content-Disposition header
            string filename = "downloaded-content";
            if (disposition.Contains("filename=")) {
                var match = Regex.Match(disposition, "filename=\"(.+?)\"");
                if (match.Success) {
                    filename = match.Groups[1].Value;
                }
            } else {
                // Create filename based on content type
                if (contentType.Contains("text/html")) {
                    filename = "page.html";
                } else if (contentType.Contains("application/pdf")) {
                    filename = "document.pdf";
                } else if (contentType.Contains("image/")) {
                    var ext = contentType.Split('/')[1];
                    filename = $"image.{ext}";
                }
            }

            // Handle all content types as binary for consistency
            var bytes = await response.Content.ReadAsByteArrayAsync();
            await File.WriteAllBytesAsync(filename, bytes);

            Console.WriteLine($"Content saved as {filename}");
        } catch (Exception ex) {
            Console.WriteLine("Error: " + ex.Message);
        }
    }
}

```

### Export with Resource Download [â€‹](https://docs.browserless.io/rest-apis/export\#export-with-resource-download "Direct link to Export with Resource Download")

- cURL
- Javascript
- Python
- Java
- C#

```codeBlockLines_p187
curl -X POST \
  https://production-sfo.browserless.io/export?token=YOUR_API_TOKEN_HERE \
  -H 'Content-Type: application/json' \
  -d '{
    "url": "https://example.com/",
    "includeResources": true
  }' \
  --output "webpage.zip"

```

```codeBlockLines_p187
import { writeFile } from 'fs/promises';

const TOKEN = "YOUR_API_TOKEN_HERE";
const url = `https://production-sfo.browserless.io/export?token=${TOKEN}`;
const headers = {
  'Content-Type': 'application/json'
};

const data = {
  url: "https://example.com/",
  includeResources: true
};

const exportPage = async () => {
  const response = await fetch(url, {
    method: 'POST',
    headers: headers,
    body: JSON.stringify(data)
  });

  const buffer = await response.arrayBuffer();
  await writeFile("webpage.zip", Buffer.from(buffer));
  console.log("Page with resources saved as webpage.zip");
};

exportPage();

```

```codeBlockLines_p187
import requests

TOKEN = "YOUR_API_TOKEN_HERE"
url = f"https://production-sfo.browserless.io/export?token={TOKEN}"
headers = {
    'Content-Type': 'application/json'
}

data = {
    "url": "https://example.com/",
    "includeResources": True
}

response = requests.post(url, headers=headers, json=data)

with open("webpage.zip", "wb") as file:
    file.write(response.content)

print("Page with resources saved as webpage.zip")

```

```codeBlockLines_p187
import java.io.*;
import java.net.http.*;
import java.net.URI;
import java.nio.file.Files;
import java.nio.file.Paths;

public class ExportPageWithResources {
    public static void main(String[] args) {
        String TOKEN = "YOUR_API_TOKEN_HERE";
        String url = "https://production-sfo.browserless.io/export?token=" + TOKEN;

        String jsonData = """
        {
            "url": "https://example.com/",
            "includeResources": true
        }
        """;

        HttpClient client = HttpClient.newHttpClient();

        HttpRequest request = HttpRequest.newBuilder()
            .uri(URI.create(url))
            .header("Content-Type", "application/json")
            .POST(HttpRequest.BodyPublishers.ofString(jsonData))
            .build();

        try {
            HttpResponse<byte[]> response = client.send(request, HttpResponse.BodyHandlers.ofByteArray());
            Files.write(Paths.get("webpage.zip"), response.body());
            System.out.println("Page with resources saved as webpage.zip");
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

```

```codeBlockLines_p187
using System;
using System.IO;
using System.Net.Http;
using System.Text;
using System.Threading.Tasks;

class Program {
    static async Task Main(string[] args) {
        string TOKEN = "YOUR_API_TOKEN_HERE";
        string url = $"https://production-sfo.browserless.io/export?token={TOKEN}";

        string jsonData = @"
        {
            ""url"": ""https://example.com/"",
            ""includeResources"": true
        }
        ";

        using var client = new HttpClient();
        var content = new StringContent(jsonData, Encoding.UTF8, "application/json");

        try {
            var response = await client.PostAsync(url, content);
            response.EnsureSuccessStatusCode();

            var bytes = await response.Content.ReadAsByteArrayAsync();
            await File.WriteAllBytesAsync("webpage.zip", bytes);

            Console.WriteLine("Page with resources saved as webpage.zip");
        } catch (Exception ex) {
            Console.WriteLine("Error: " + ex.Message);
        }
    }
}

```

## Handling Different Content Types [â€‹](https://docs.browserless.io/rest-apis/export\#handling-different-content-types-1 "Direct link to Handling Different Content Types")

The export API can return various content types depending on the URL being accessed. Here's how to properly handle the different response types:

### HTML Content [â€‹](https://docs.browserless.io/rest-apis/export\#html-content-1 "Direct link to HTML Content")

When accessing a standard web page, the API returns HTML content with `Content-Type: text/html`:

```codeBlockLines_p187
const response = await fetch(url, options);
if (response.headers.get('content-type')?.includes('text/html')) {
  const htmlContent = await response.text();
  // Process HTML content
}

```

### PDF Content [â€‹](https://docs.browserless.io/rest-apis/export\#pdf-content-1 "Direct link to PDF Content")

When accessing PDF files or when the server returns PDF content, the API returns a PDF buffer with `Content-Type: application/pdf`:

```codeBlockLines_p187
const response = await fetch(url, options);
if (response.headers.get('content-type')?.includes('application/pdf')) {
  const arrayBuffer = await response.arrayBuffer();
  const pdfBuffer = Buffer.from(arrayBuffer);
  // Save or process PDF buffer
}

```

### Binary Content (Images, etc.) [â€‹](https://docs.browserless.io/rest-apis/export\#binary-content-images-etc-1 "Direct link to Binary Content (Images, etc.)")

For other binary content like images, the API returns the appropriate content type and sets attachment headers:

```codeBlockLines_p187
const response = await fetch(url, options);
const contentType = response.headers.get('content-type');
if (contentType?.includes('image/') || !contentType?.includes('text/')) {
  const arrayBuffer = await response.arrayBuffer();
  const binaryBuffer = Buffer.from(arrayBuffer);
  // Save or process binary buffer
}

```

## Best Practices [â€‹](https://docs.browserless.io/rest-apis/export\#best-practices "Direct link to Best Practices")

### Navigation and Timing [â€‹](https://docs.browserless.io/rest-apis/export\#navigation-and-timing "Direct link to Navigation and Timing")

1. **Page Load Strategies**
   - Use appropriate `waitUntil` options based on your needs:

     - `load` \- Wait for the load event (good for static pages)
     - `domcontentloaded` \- Wait for the DOMContentLoaded event (faster but may miss dynamic content)
     - `networkidle0` \- Wait until there are no network connections for at least 500ms (good for single-page applications)
     - `networkidle2` \- Wait until there are no more than 2 network connections for at least 500ms (good for pages with background activity)
2. **Timeout Management**
   - Set reasonable timeout values based on your target page's complexity
   - Consider increasing timeouts for:
     - Pages with heavy JavaScript execution
     - Pages with large media files
     - Pages with complex animations
     - Pages with slow network conditions
3. **Content Waiting**
   - Use `waitForSelector` when you need to ensure specific content is loaded
   - Combine with `waitForTimeout` for additional stability
   - Consider using multiple selectors for critical content
   - Use `bestAttempt: true` for more resilient scraping, but be aware it may return incomplete content

### Resource Management [â€‹](https://docs.browserless.io/rest-apis/export\#resource-management "Direct link to Resource Management")

4. **Asset Handling**
   - Use `includeAssets` wisely to control export size
   - Consider excluding unnecessary resource types:
     - Images for text-only exports
     - Stylesheets for raw content
     - Scripts for static content
   - Use `rejectResourceTypes` to filter specific asset types
   - Implement size limits for large resources
5. **Network Optimization**
   - Use `rejectRequestPattern` to exclude unnecessary requests
   - Consider implementing request throttling
   - Cache frequently accessed resources
   - Monitor and optimize network usage

### Error Handling and Reliability [â€‹](https://docs.browserless.io/rest-apis/export\#error-handling-and-reliability "Direct link to Error Handling and Reliability")

6. **Robust Error Handling**
   - Implement proper error handling for:
     - Network timeouts
     - Resource loading failures
     - Invalid URLs
     - Rate limiting
   - Use appropriate HTTP status codes
   - Implement retry mechanisms for transient failures
7. **Content Validation**
   - Verify content completeness
   - Check for expected elements
   - Validate content structure
   - Implement checksums for critical content

### Security Considerations [â€‹](https://docs.browserless.io/rest-apis/export\#security-considerations "Direct link to Security Considerations")

8. **URL and Content Safety**
   - Always use HTTPS URLs when possible
   - Validate URLs before making requests
   - Sanitize user-provided URLs
   - Implement content size limits
   - Be cautious when setting custom headers
9. **Authentication and Authorization**
   - Use secure methods for API token storage
   - Implement proper access controls
   - Monitor and log access attempts
   - Rotate API tokens regularly

### Performance Optimization [â€‹](https://docs.browserless.io/rest-apis/export\#performance-optimization "Direct link to Performance Optimization")

10. **Export Size Management**
    - Implement compression where appropriate
    - Use appropriate export formats
    - Consider splitting large exports
    - Implement cleanup mechanisms for temporary files
11. **Concurrent Operations**
    - Implement proper rate limiting
    - Use appropriate concurrency levels
    - Monitor system resources
    - Implement queue management for high-volume operations

### Monitoring and Maintenance [â€‹](https://docs.browserless.io/rest-apis/export\#monitoring-and-maintenance "Direct link to Monitoring and Maintenance")

12. **Logging and Monitoring**
    - Implement comprehensive logging
    - Monitor success/failure rates
    - Track export sizes and durations
    - Set up alerts for failures
    - Monitor rate limit usage
13. **Maintenance**
    - Regularly review and update selectors
    - Monitor for changes in target sites
    - Update error handling as needed
    - Review and optimize timeout values
    - Maintain documentation of changes

For additional support, please refer to the [Browserless documentation](https://docs.browserless.io/) or contact support.

- [Basic Usage](https://docs.browserless.io/rest-apis/export#basic-usage)
  - [JSON Payload Format](https://docs.browserless.io/rest-apis/export#json-payload-format)
- [Parameters](https://docs.browserless.io/rest-apis/export#parameters)
  - [Required Parameters](https://docs.browserless.io/rest-apis/export#required-parameters)
  - [Optional Parameters](https://docs.browserless.io/rest-apis/export#optional-parameters)
- [Response](https://docs.browserless.io/rest-apis/export#response)
- [Handling Different Content Types](https://docs.browserless.io/rest-apis/export#handling-different-content-types)
  - [HTML Content](https://docs.browserless.io/rest-apis/export#html-content)
  - [PDF Content](https://docs.browserless.io/rest-apis/export#pdf-content)
  - [Binary Content (Images, etc.)](https://docs.browserless.io/rest-apis/export#binary-content-images-etc)
- [Error Handling](https://docs.browserless.io/rest-apis/export#error-handling)
- [Examples](https://docs.browserless.io/rest-apis/export#examples)
  - [Basic Export Request](https://docs.browserless.io/rest-apis/export#basic-export-request)
  - [Export with Custom Navigation Options](https://docs.browserless.io/rest-apis/export#export-with-custom-navigation-options)
  - [Export with Custom Headers](https://docs.browserless.io/rest-apis/export#export-with-custom-headers)
  - [Export with Resource Download](https://docs.browserless.io/rest-apis/export#export-with-resource-download)
- [Handling Different Content Types](https://docs.browserless.io/rest-apis/export#handling-different-content-types-1)
  - [HTML Content](https://docs.browserless.io/rest-apis/export#html-content-1)
  - [PDF Content](https://docs.browserless.io/rest-apis/export#pdf-content-1)
  - [Binary Content (Images, etc.)](https://docs.browserless.io/rest-apis/export#binary-content-images-etc-1)
- [Best Practices](https://docs.browserless.io/rest-apis/export#best-practices)
  - [Navigation and Timing](https://docs.browserless.io/rest-apis/export#navigation-and-timing)
  - [Resource Management](https://docs.browserless.io/rest-apis/export#resource-management)
  - [Error Handling and Reliability](https://docs.browserless.io/rest-apis/export#error-handling-and-reliability)
  - [Security Considerations](https://docs.browserless.io/rest-apis/export#security-considerations)
  - [Performance Optimization](https://docs.browserless.io/rest-apis/export#performance-optimization)
  - [Monitoring and Maintenance](https://docs.browserless.io/rest-apis/export#monitoring-and-maintenance)

---

### /function API | Browserless.io
Original URL: https://docs.browserless.io/rest-apis/function

[Skip to main content](https://docs.browserless.io/rest-apis/function#__docusaurus_skipToContent_fallback)


A quick way to run commands with Browserless is via our `/function` API. You can use Python, NodeJS or any other language that supports making HTTP requests, so you don't need to install any libraries on your end.

The `/function` endpoint allows for `POST` ing of custom code and context to run them with. The code function, which only supports puppeteer code, gets called with an object containing several properties: a `page` property, which is a puppeteer page object, and `context` which is the context you provide in the JSON body.

Functions should return an object with two properties: `data` and `type`. `data` can be whatever you'd like (Buffer, JSON, or plain text) and `type` is a string describing the Content-Type of `data`. Browserless reads both of these from your functions return value and resolves the request appropriately.

You can [view the complete Function API OpenAPI specification](https://docs.browserless.io/open-api#tag/Browser-REST-APIs/paths/~1chrome~1function/post).

## Basic Usage [â€‹](https://docs.browserless.io/rest-apis/function\#basic-usage "Direct link to Basic Usage")

Both the `/function` and the `/download` API environments use [Ecmascript modules](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules). You can use any code and native APIs available in the Chrome browser environment.

**JS Code**

```codeBlockLines_p187
export default async function ({ page }) {
  const rndNumber = () => {
    return Math.floor(Math.random() * (10**6 - 0));
  };

  await page.goto("https://example.com/");
  const url = await page.title();
  const numbers = [...Array(5)].map(() => rndNumber());

  return {
    data: {
      url,
      numbers,
    },
    // Make sure to match the appropriate content here
    type: "application/json",
  };
}

```

- cURL
- Javascript
- Python
- Java
- C#

```codeBlockLines_p187
curl -X POST \
  https://production-sfo.browserless.io/function?token=YOUR_API_TOKEN_HERE \
  -H 'Content-Type: application/javascript' \
  -d 'export default async function ({ page }) {
  const rndNumber = () => {
    return Math.floor(Math.random() * (10**6 - 0));
  };

  await page.goto("https://example.com/");
  const url = await page.title();
  const numbers = [...Array(5)].map(() => rndNumber());

  return {
    data: {
      url,
      numbers,
    },
    // Make sure to match the appropriate content here
    type: "application/json",
  };
}'

```

```codeBlockLines_p187
const TOKEN = "YOUR_API_TOKEN_HERE";
const url = `https://production-sfo.browserless.io/function?token=${TOKEN}`;
const headers = {
  "Content-Type": "application/javascript"
};

const data = `
export default async function ({ page }) {
  const rndNumber = () => {
    return Math.floor(Math.random() * (10**6 - 0));
  };

  await page.goto("https://example.com/");
  const url = await page.title();
  const numbers = [...Array(5)].map(() => rndNumber());

  return {
    data: {
      url,
      numbers,
    },
    type: "application/json",
  };
}`;

const sendRequest = async () => {
  const response = await fetch(url, {
    method: 'POST',
    headers: headers,
    body: data
  });

  const result = await response.json();
  console.log(result);
};

sendRequest();

```

```codeBlockLines_p187
import requests

TOKEN = "YOUR_API_TOKEN_HERE"
url = f"https://production-sfo.browserless.io/function?token={TOKEN}"
headers = {
    "Content-Type": "application/javascript"
}

data = """
export default async function ({ page }) {
  const rndNumber = () => {
    return Math.floor(Math.random() * (10**6 - 0));
  };

  await page.goto("https://example.com/");
  const url = await page.title();
  const numbers = [...Array(5)].map(() => rndNumber());

  return {
    data: {
      url,
      numbers,
    },
    type: "application/json",
  };
}
"""

response = requests.post(url, headers=headers, data=data)

result = response.json()
print(result)

```

```codeBlockLines_p187
import java.net.URI;
import java.net.http.*;
import org.json.JSONObject;

public class BrowserlessFunction {
    public static void main(String[] args) {
        String TOKEN = "YOUR_API_TOKEN_HERE";
        String url = "https://production-sfo.browserless.io/function?token=" + TOKEN;

        String javascriptCode = """
        export default async function ({ page }) {
            const rndNumber = () => {
                return Math.floor(Math.random() * (10**6 - 0));
            };

            await page.goto("https://example.com/");
            const url = await page.title();
            const numbers = [...Array(5)].map(() => rndNumber());

            return {
                data: {
                    url,
                    numbers,
                },
                type: "application/json",
            };
        }
        """;

        HttpClient client = HttpClient.newHttpClient();

        HttpRequest request = HttpRequest.newBuilder()
            .uri(URI.create(url))
            .header("Content-Type", "application/javascript")
            .POST(HttpRequest.BodyPublishers.ofString(javascriptCode))
            .build();

        try {
            HttpResponse<String> response = client.send(request, HttpResponse.BodyHandlers.ofString());
            JSONObject jsonResponse = new JSONObject(response.body());
            System.out.println(jsonResponse.toString(4));
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

```

```codeBlockLines_p187
using System;
using System.Net.Http;
using System.Text;
using System.Threading.Tasks;

class Program {
    static async Task Main(string[] args) {
        string TOKEN = "YOUR_API_TOKEN_HERE";
        string url = $"https://production-sfo.browserless.io/function?token={TOKEN}";

        string javascriptCode = @"
        export default async function ({ page }) {
            const rndNumber = () => {
                return Math.floor(Math.random() * (10**6 - 0));
            };

            await page.goto('https://example.com/');
            const url = await page.title();
            const numbers = [...Array(5)].map(() => rndNumber());

            return {
                data: {
                    url,
                    numbers,
                },
                type: 'application/json',
            };
        }
        ";

        using var client = new HttpClient();
        var content = new StringContent(javascriptCode, Encoding.UTF8, "application/javascript");

        try {
            var response = await client.PostAsync(url, content);
            response.EnsureSuccessStatusCode();

            var result = await response.Content.ReadAsStringAsync();
            Console.WriteLine(result);
        } catch (Exception ex) {
            Console.WriteLine("Error: " + ex.Message);
        }
    }
}

```

**Example Reponse**

```codeBlockLines_p187
{
  "data": {
    "url": "Example Domain",
    "numbers": [\
      854246,\
      114512,\
      212580,\
      482122,\
      107878\
    ]
  },
  "type": "application/json"
}

```

## Importing libraries [â€‹](https://docs.browserless.io/rest-apis/function\#importing-libraries "Direct link to Importing libraries")

Since the `/function` API uses ESM modules, you can use `import` syntax over HTTP to load moules. For instance, let's try leading the [Fake](https://fakerjs.dev/) module.

**JS Code**

```codeBlockLines_p187
import { faker } from "https://esm.sh/@faker-js/faker";

export default async function () {
  const Internet = faker.internet;
  const rndData = [...Array(5)].map(() => ({
    domain: Internet.domainName(),
    ip: Internet.ip(),
    mac: Internet.mac(),
    protocol: Internet.protocol(),
  }));

  return {
    data: { domains: rndData },
    type: "application/json",
  };
}

```

- cURL
- Javascript
- Python
- Java
- C#

```codeBlockLines_p187
curl -X POST \
https://production-sfo.browserless.io/function?token=YOUR_API_TOKEN_HERE \
-H 'Content-Type: application/javascript' \
-d 'import { faker } from "https://esm.sh/@faker-js/faker";

export default async function () {
const Internet = faker.internet;
const rndData = [...Array(5)].map(() => ({
  domain: Internet.domainName(),
  ip: Internet.ip(),
  mac: Internet.mac(),
  protocol: Internet.protocol(),
}));

return {
  data: { domains: rndData },
  type: "application/json",
};
}'

```

```codeBlockLines_p187
const TOKEN = "YOUR_API_TOKEN_HERE";
const url = `https://production-sfo.browserless.io/function?token=${TOKEN}`;
const headers = {
  "Content-Type": "application/javascript"
};

const data = `
import { faker } from "https://esm.sh/@faker-js/faker";

export default async function () {
  const Internet = faker.internet;
  const rndData = [...Array(5)].map(() => ({
    domain: Internet.domainName(),
    ip: Internet.ip(),
    mac: Internet.mac(),
    protocol: Internet.protocol(),
  }));

  return {
    data: { domains: rndData },
    type: "application/json",
  };
}`;

const sendRequest = async () => {
  const response = await fetch(url, {
    method: 'POST',
    headers: headers,
    body: data
  });

  const result = await response.json();
  console.log(result);
};

sendRequest();

```

```codeBlockLines_p187
import requests

TOKEN = "YOUR_API_TOKEN_HERE"
url = f"https://production-sfo.browserless.io/function?token={TOKEN}"
headers = {
    "Content-Type": "application/javascript"
}

data = """
import { faker } from "https://esm.sh/@faker-js/faker";

export default async function () {
  const Internet = faker.internet;
  const rndData = [...Array(5)].map(() => ({
    domain: Internet.domainName(),
    ip: Internet.ip(),
    mac: Internet.mac(),
    protocol: Internet.protocol(),
  }));

  return {
    data: { domains: rndData },
    type: "application/json",
  };
}
"""

response = requests.post(url, headers=headers, data=data)
result = response.json()
print(result)

```

```codeBlockLines_p187
import java.net.URI;
import java.net.http.*;
import org.json.JSONObject;

public class BrowserlessFakerFunction {
    public static void main(String[] args) {
        String TOKEN = "YOUR_API_TOKEN_HERE";
        String url = "https://production-sfo.browserless.io/function?token=" + TOKEN;

        String javascriptCode = """
        import { faker } from "https://esm.sh/@faker-js/faker";

        export default async function () {
            const Internet = faker.internet;
            const rndData = [...Array(5)].map(() => ({
                domain: Internet.domainName(),
                ip: Internet.ip(),
                mac: Internet.mac(),
                protocol: Internet.protocol(),
            }));

            return {
                data: { domains: rndData },
                type: "application/json",
            };
        }
        """;

        HttpClient client = HttpClient.newHttpClient();

        HttpRequest request = HttpRequest.newBuilder()
            .uri(URI.create(url))
            .header("Content-Type", "application/javascript")
            .POST(HttpRequest.BodyPublishers.ofString(javascriptCode))
            .build();

        try {
            HttpResponse<String> response = client.send(request, HttpResponse.BodyHandlers.ofString());
            JSONObject jsonResponse = new JSONObject(response.body());
            System.out.println(jsonResponse.toString(4));
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

```

```codeBlockLines_p187
using System;
using System.Net.Http;
using System.Text;
using System.Threading.Tasks;

class Program {
    static async Task Main(string[] args) {
        string TOKEN = "YOUR_API_TOKEN_HERE";
        string url = $"https://production-sfo.browserless.io/function?token={TOKEN}";

        string javascriptCode = @"
        import { faker } from 'https://esm.sh/@faker-js/faker';

        export default async function () {
            const Internet = faker.internet;
            const rndData = [...Array(5)].map(() => ({
                domain: Internet.domainName(),
                ip: Internet.ip(),
                mac: Internet.mac(),
                protocol: Internet.protocol(),
            }));

            return {
                data: { domains: rndData },
                type: 'application/json',
            };
        }
        ";

        using var client = new HttpClient();
        var content = new StringContent(javascriptCode, Encoding.UTF8, "application/javascript");

        try {
            var response = await client.PostAsync(url, content);
            response.EnsureSuccessStatusCode();

            var result = await response.Content.ReadAsStringAsync();
            Console.WriteLine(result);
        } catch (Exception ex) {
            Console.WriteLine("Error: " + ex.Message);
        }
    }
}

```

## JSON API [â€‹](https://docs.browserless.io/rest-apis/function\#json-api "Direct link to JSON API")

You can also use the /function API sending a JSON payload. You must send an object with the following values:

- `code`: String, required â€” custom function code.
- `context`: Object, optional â€” value used to pass context values and arguments to the `code`

### Example [â€‹](https://docs.browserless.io/rest-apis/function\#example "Direct link to Example")

**JS Code**

```codeBlockLines_p187
import { faker } from "https://esm.sh/@faker-js/faker";

export default async function ({ context }) {
  const Internet = faker.internet;
  const rndData = [...Array(context.len)].map(() => ({
    domain: Internet.domainName(),
    ip: Internet.ip(),
    mac: Internet.mac(),
    protocol: Internet.protocol(),
  }));

  return {
    data: {
      domains: rndData,
      length: context.len
    },
    type: "application/json",
  };
}

```

- cURL
- Javascript
- Python
- Java
- C#

```codeBlockLines_p187
curl --request POST \
  --url 'https://production-sfo.browserless.io/function?token=YOUR_API_TOKEN_HERE' \
  --header 'Content-Type: application/json' \
  # Minified code
  --data '{
  "code": "import{faker as a}from\"https://esm.sh/@faker-js/faker\";export default async function({context:o}){let t=a.internet,e=[...Array(o.len)].map(()=>({domain:t.domainName(),ip:t.ip(),mac:t.mac(),protocol:t.protocol()}));return{data:{domains:e,length:o.len},type:`application/json`}};",
  "context": {
    "len": 10
  }
}'

```

```codeBlockLines_p187
import fetch from 'node-fetch';

const TOKEN = "YOUR_API_TOKEN_HERE";
const url = `https://production-sfo.browserless.io/function?token=${TOKEN}`;
const headers = {
  "Content-Type": "application/json"
};

const data = {
  code: 'import{faker as a}from"https://esm.sh/@faker-js/faker";export default async function({context:o}){let t=a.internet,e=[...Array(o.len)].map(()=>({domain:t.domainName(),ip:t.ip(),mac:t.mac(),protocol:t.protocol()}));return{data:{domains:e,length:o.len},type:`application/json`}};',
  context: { len: 10 }
};

const sendRequest = async () => {
  const response = await fetch(url, {
    method: 'POST',
    headers: headers,
    body: JSON.stringify(data)
  });

  const result = await response.json();
  console.log(result);
};

sendRequest();

```

```codeBlockLines_p187
import requests

TOKEN = "YOUR_API_TOKEN_HERE"
url = f"https://production-sfo.browserless.io/function?token={TOKEN}"
headers = {
    "Content-Type": "application/json"
}

data = {
    "code": 'import{faker as a}from"https://esm.sh/@faker-js/faker";export default async function({context:o}){let t=a.internet,e=[...Array(o.len)].map(()=>({domain:t.domainName(),ip:t.ip(),mac:t.mac(),protocol:t.protocol()}));return{data:{domains:e,length:o.len},type:`application/json`}};',
    "context": {
        "len": 10
    }
}

response = requests.post(url, headers=headers, json=data)
result = response.json()
print(result)

```

```codeBlockLines_p187
import java.net.URI;
import java.net.http.*;
import org.json.JSONObject;

public class BrowserlessFakerMinified {
    public static void main(String[] args) {
        String TOKEN = "YOUR_API_TOKEN_HERE";
        String url = "https://production-sfo.browserless.io/function?token=" + TOKEN;

        String jsonData = """
        {
            "code": "import{faker as a}from\\\"https://esm.sh/@faker-js/faker\\\";export default async function({context:o}){let t=a.internet,e=[...Array(o.len)].map(()=>({domain:t.domainName(),ip:t.ip(),mac:t.mac(),protocol:t.protocol()}));return{data:{domains:e,length:o.len},type:`application/json`}};",
            "context": {
                "len": 10
            }
        }
        """;

        HttpClient client = HttpClient.newHttpClient();

        HttpRequest request = HttpRequest.newBuilder()
            .uri(URI.create(url))
            .header("Content-Type", "application/json")
            .POST(HttpRequest.BodyPublishers.ofString(jsonData))
            .build();

        try {
            HttpResponse<String> response = client.send(request, HttpResponse.BodyHandlers.ofString());
            JSONObject jsonResponse = new JSONObject(response.body());
            System.out.println(jsonResponse.toString(4));
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

```

```codeBlockLines_p187
using System;
using System.Net.Http;
using System.Text;
using System.Threading.Tasks;

class Program {
    static async Task Main(string[] args) {
        string TOKEN = "YOUR_API_TOKEN_HERE";
        string url = $"https://production-sfo.browserless.io/function?token={TOKEN}";

        string jsonData = @"
        {
            ""code"": ""import{faker as a}from\""https://esm.sh/@faker-js/faker\"";export default async function({context:o}){let t=a.internet,e=[...Array(o.len)].map(()=>({domain:t.domainName(),ip:t.ip(),mac:t.mac(),protocol:t.protocol()}));return{data:{domains:e,length:o.len},type:`application/json`}};"",
            ""context"": {
                ""len"": 10
            }
        }
        ";

        using var client = new HttpClient();
        var content = new StringContent(jsonData, Encoding.UTF8, "application/json");

        try {
            var response = await client.PostAsync(url, content);
            response.EnsureSuccessStatusCode();

            var result = await response.Content.ReadAsStringAsync();
            Console.WriteLine(result);
        } catch (Exception ex) {
            Console.WriteLine("Error: " + ex.Message);
        }
    }
}

```

- [Basic Usage](https://docs.browserless.io/rest-apis/function#basic-usage)
- [Importing libraries](https://docs.browserless.io/rest-apis/function#importing-libraries)
- [JSON API](https://docs.browserless.io/rest-apis/function#json-api)
  - [Example](https://docs.browserless.io/rest-apis/function#example)

---

### REST APIs | Browserless.io
Original URL: https://docs.browserless.io/rest-apis/intro

[Skip to main content](https://docs.browserless.io/rest-apis/intro#__docusaurus_skipToContent_fallback)


Browserless is a cloud-based service for running headless browsers at scale. It provides multiple offerings for different use cases, all using the same cloud infrastructure but accessed in various ways.

Browserless RESTful APIs are a set of ready-made HTTP endpoints for common browser tasks (such as generating PDFs or screenshots, scraping content, etc.). These endpoints let you perform automation via simple HTTP(S) requests without writing a full script. They are great for quick integrations or one-off tasks, although not as flexible for complex flows.

## Benefits of REST APIs [â€‹](https://docs.browserless.io/rest-apis/intro\#benefits-of-rest-apis "Direct link to Benefits of REST APIs")

- **Simplicity**: Interact with browser functionality using simple HTTP requests
- **Language Agnostic**: Use any programming language or tool that can make HTTP requests
- **Stateless Operations**: No need to maintain browser sessions for simple operations
- **Scalability**: Easily integrate browser functionality into your applications at scale
- **Low Overhead**: Minimize resource usage for simple browser tasks

## When to Use REST APIs [â€‹](https://docs.browserless.io/rest-apis/intro\#when-to-use-rest-apis "Direct link to When to Use REST APIs")

REST APIs are ideal for:

- Simple, one-off browser operations (screenshots, PDF generation, content extraction)
- Integrations where maintaining a browser session is unnecessary
- Applications written in languages without robust browser automation libraries
- Serverless functions or microservices where simplicity is paramount
- High-throughput scenarios where connection overhead should be minimized

For more complex automation scenarios, especially those involving bot detection bypass, consider using [BrowserQL](https://docs.browserless.io/browserql/start), which provides a more powerful and flexible approach.

## Getting Started [â€‹](https://docs.browserless.io/rest-apis/intro\#getting-started "Direct link to Getting Started")

To use the APIs, you need a unique token, created when you sign-up for a Browserless account:

1. [Sign up for a Browserless account](https://account.browserless.io/signup/email?plan=free) (free plan available).
2. Get your **API Key**.

Once ready you should use this token anytime you interact with the service.

You can use this token with most of our integrations by simply appending a `?token=YOUR_API_TOKEN_HERE` as a query-string parameter.

## Global Endpoints [â€‹](https://docs.browserless.io/rest-apis/intro\#global-endpoints "Direct link to Global Endpoints")

Browserless operates multiple regional endpoints for low-latency access. The primary shared clusters are in US West (SFO), EU West (London), and EU Central (Amsterdam) ( [Load Balancers](https://docs.browserless.io/baas/load-balancers)). For example:

- `https://production-sfo.browserless.io` â€“ San Francisco, USA (default US endpoint)
- `https://production-lon.browserless.io` â€“ London, UK (European endpoint)
- `https://production-ams.browserless.io` â€“ Amsterdam, NL (another EU endpoint)

You can use the endpoint closest to your servers or users. All endpoints offer the same API and require your token.

## Available REST APIs [â€‹](https://docs.browserless.io/rest-apis/intro\#available-rest-apis "Direct link to Available REST APIs")

Browserless has production ready APIs for various browser operations. Each API accepts different parameters and options.

Schemas

The schemas for each endpoint are displayed in the [Browserless OpenAPI Documentation](https://docs.browserless.io/open-api).

The Browser APIs help you execute specific tasks for your use-case, and are available for both shared and enterprise users.

- [/content](https://docs.browserless.io/rest-apis/content), to return HTML of dynamic content
- [/unblock](https://docs.browserless.io/rest-apis/unblock), to return HTML, screenshots or cookies for protected sites
- [/download](https://docs.browserless.io/rest-apis/download), return files Chrome has downloaded
- [/function](https://docs.browserless.io/rest-apis/function), run HTTP requests without installing a library
- [/pdf](https://docs.browserless.io/rest-apis/pdf), export a page as a PDF
- [/screenshot](https://docs.browserless.io/rest-apis/screenshot), capture a .png or .jpg
- [/scrape](https://docs.browserless.io/rest-apis/scrape), return the structured JSON
- [/export](https://docs.browserless.io/rest-apis/export), create self-contained exports of any URL resource for offline access, optionally including all linked resources (images, CSS, JavaScript) as a zip file
- [/performance](https://docs.browserless.io/rest-apis/performance), run parallel Google Lighthouse tests

Bot Detection

For strict bot detectors where browsers and a proxy aren't enough to get past, we would recommend using [**BrowserQL**](https://docs.browserless.io/browserql/start).

## Next Steps [â€‹](https://docs.browserless.io/rest-apis/intro\#next-steps "Direct link to Next Steps")

Before exploring all Browserless REST APIs have to offer, learn more about connecting and building an URL for your needs, and all launch parameters available:

- [Connection URLs and Endpoints](https://docs.browserless.io/rest-apis/connection-urls)
- [Launch Parameters and Options](https://docs.browserless.io/rest-apis/launch-parameters)

- [Benefits of REST APIs](https://docs.browserless.io/rest-apis/intro#benefits-of-rest-apis)
- [When to Use REST APIs](https://docs.browserless.io/rest-apis/intro#when-to-use-rest-apis)
- [Getting Started](https://docs.browserless.io/rest-apis/intro#getting-started)
- [Global Endpoints](https://docs.browserless.io/rest-apis/intro#global-endpoints)
- [Available REST APIs](https://docs.browserless.io/rest-apis/intro#available-rest-apis)
- [Next Steps](https://docs.browserless.io/rest-apis/intro#next-steps)

---

### Launch Parameters and Options | Browserless.io
Original URL: https://docs.browserless.io/rest-apis/launch-parameters

[Skip to main content](https://docs.browserless.io/rest-apis/launch-parameters#__docusaurus_skipToContent_fallback)


Browserless allows extensive configuration of how browsers are launched and behave during
your sessions. These launch parameters can be provided either via query parameters in the
URL or through a special JSON launch payload. Whether you're using BQL, BaaS v2, or REST, these
options let you tweak the browser environment to fit your needs.

## Passing Launch Options [â€‹](https://docs.browserless.io/rest-apis/launch-parameters\#passing-launch-options "Direct link to Passing Launch Options")

Two ways to specify launch options:

1. **Individual Query Parameters**: Add options directly to URLs (e.g., `&headless=false`, `&proxy=residential`). Best for simple boolean options.

2. **Combined `launch` Parameter (JSON)**: For complex configurations, use a single query param `launch` with a JSON string as its value. This JSON can include any Chrome flags or Browserless-specific settings in a structured way. It's essentially the equivalent of Puppeteer's `launch({ options })` but provided to the cloud service:







```codeBlockLines_p187
&launch={"headless":false,"stealth":true,"args":["--window-size=1920,1080"]}

```











(URL-encoded) would configure a headful, stealth-enabled browser with a specific window size.


Browserless merges both methods if used together, with individual parameters taking precedence. Use query params for simple toggles and the launch parameter for multiple settings.

## Launch Options (Query Parameters) [â€‹](https://docs.browserless.io/rest-apis/launch-parameters\#launch-options-query-parameters "Direct link to Launch Options (Query Parameters)")

Below is a list of available launch options you can use in query strings for Browserless REST APIs.

| Parameter | Description | Default |
| --- | --- | --- |
| headless | Runs the browser in headless mode. Set to false to enable headful mode (with a GUI). While the GUI isn't visible in cloud environments, headful mode may help bypass bot detection. Note: it uses more resources. | `true` |
| stealth | Enables stealth mode to reduce automation signals (similar to puppeteer-extraâ€™s stealth plugin). In BQL, stealth is always on by design and controlled via the humanlike option. In BaaS/REST, set to true to enable stealth techniques. | - `false` (for BaaS/REST)<br>- `true` (for BQL) |
| blockAds | Enables the built-in ad blocker (powered by uBlock Origin). Helps speed up scripts and reduce noise by blocking ads and trackers. Especially useful for scraping to avoid popups and clutter. | `false` |
| blockConsentModals | Automatically blocks or dismisses cookie/GDPR consent banners. Available in BQL sessions and the /screenshot and /pdf REST APIs. In BQL, toggle it via the IDE or launch JSON. Useful for cleaner scraping by removing overlays. | `false` |
| proxy | Routes browser traffic through a proxy. Options: proxy=residential for Browserlessâ€™s residential proxy pool; proxy=\`<your proxy URL>\` for your own proxy. Omit to use a direct connection. | none |
| proxyCountry | Used with proxy=residential to specify the exit nodeâ€™s country. Accepts ISO 3166 country codes (e.g., us, gb, de). If omitted, a random location is chosen. | none |
| proxySticky | Used with proxy=residential to maintain the same proxy IP across a session (when possible). Useful for sites that expect consistent IP usage. | `false` |
| timeout | Maximum session duration in milliseconds. The session will automatically close after this time to prevent overuse. | 60000 |

info

The examples below use the `/pdf` API, but it can be applied to all APIs.

### Headless [â€‹](https://docs.browserless.io/rest-apis/launch-parameters\#headless "Direct link to Headless")

- cURL
- Javascript
- Python
- Java
- C#

```codeBlockLines_p187
  curl -X POST \
  https://production-sfo.browserless.io/pdf?token=YOUR_API_TOKEN_HERE&headless=true \
  -H 'Cache-Control: no-cache' \
  -H 'Content-Type: application/json' \
  -d '{
  "url": "https://example.com/"
  }'

```

```codeBlockLines_p187
import fs from 'fs/promises';

const TOKEN = "YOUR_API_TOKEN_HERE";
const url = `https://production-sfo.browserless.io/pdf?token=${TOKEN}&headless=true`;
const headers = {
  "Cache-Control": "no-cache",
  "Content-Type": "application/json"
};

const data = {
  url: "https://example.com/",
};

const generatePDF = async () => {
  const response = await fetch(url, {
    method: 'POST',
    headers: headers,
    body: JSON.stringify(data)
  });

  const pdfBuffer = await response.arrayBuffer();
  await fs.writeFile("output.pdf", Buffer.from(pdfBuffer));
  console.log("PDF saved as output.pdf");
};

generatePDF();

```

```codeBlockLines_p187
import requests

TOKEN = "YOUR_API_TOKEN_HERE"
url = f"https://production-sfo.browserless.io/pdf?token={TOKEN}&headless=true"
headers = {
    "Cache-Control": "no-cache",
    "Content-Type": "application/json"
}

data = {
    "url": "https://example.com/",
}

response = requests.post(url, headers=headers, json=data)

with open("output.pdf", "wb") as file:
    file.write(response.content)

print("PDF saved as output.pdf")

```

```codeBlockLines_p187
import java.io.*;
import java.net.URI;
import java.net.http.*;
import java.nio.file.*;

public class GeneratePDF {
    public static void main(String[] args) {
        String TOKEN = "YOUR_API_TOKEN_HERE";
        String url = "https://production-sfo.browserless.io/pdf?token=" + TOKEN + "&headless=true";

        String jsonData = """
        {
            "url": "https://example.com/",
        }
        """;

        HttpClient client = HttpClient.newHttpClient();

        HttpRequest request = HttpRequest.newBuilder()
            .uri(URI.create(url))
            .header("Cache-Control", "no-cache")
            .header("Content-Type", "application/json")
            .POST(HttpRequest.BodyPublishers.ofString(jsonData))
            .build();

        try {
            HttpResponse<InputStream> response = client.send(request, HttpResponse.BodyHandlers.ofInputStream());
            Files.copy(response.body(), Paths.get("output.pdf"), StandardCopyOption.REPLACE_EXISTING);
            System.out.println("PDF saved as output.pdf");
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

```

```codeBlockLines_p187
using System;
using System.IO;
using System.Net.Http;
using System.Text;
using System.Threading.Tasks;

class Program
{
    static async Task Main(string[] args)
    {
        string TOKEN = "YOUR_API_TOKEN_HERE";
        string url = $"https://production-sfo.browserless.io/pdf?token={TOKEN}&headless=true";

        string jsonData = @"
          {
              ""url"": ""https://example.com/"",
          }";

        using var client = new HttpClient();

        var request = new HttpRequestMessage(HttpMethod.Post, url)
        {
            Content = new StringContent(jsonData, Encoding.UTF8, "application/json")
        };

        request.Headers.Add("Cache-Control", "no-cache");

        try
        {
            var response = await client.SendAsync(request);
            response.EnsureSuccessStatusCode();
            var pdfBytes = await response.Content.ReadAsByteArrayAsync();
            await File.WriteAllBytesAsync("output.pdf", pdfBytes);
            Console.WriteLine("PDF saved as output.pdf");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error: {ex.Message}");
        }
    }
}

```

### Stealth [â€‹](https://docs.browserless.io/rest-apis/launch-parameters\#stealth "Direct link to Stealth")

- cURL
- Javascript
- Python
- Java
- C#

```codeBlockLines_p187
  curl -X POST \
  https://production-sfo.browserless.io/pdf?token=YOUR_API_TOKEN_HERE&stealth=true \
  -H 'Cache-Control: no-cache' \
  -H 'Content-Type: application/json' \
  -d '{
  "url": "https://example.com/"
  }'

```

```codeBlockLines_p187
import fs from 'fs/promises';

const TOKEN = "YOUR_API_TOKEN_HERE";
const url = `https://production-sfo.browserless.io/pdf?token=${TOKEN}&stealth=true`;
const headers = {
  "Cache-Control": "no-cache",
  "Content-Type": "application/json"
};

const data = {
  url: "https://example.com/",
};

const generatePDF = async () => {
  const response = await fetch(url, {
    method: 'POST',
    headers: headers,
    body: JSON.stringify(data)
  });

  const pdfBuffer = await response.arrayBuffer();
  await fs.writeFile("output.pdf", Buffer.from(pdfBuffer));
  console.log("PDF saved as output.pdf");
};

generatePDF();

```

```codeBlockLines_p187
import requests

TOKEN = "YOUR_API_TOKEN_HERE"
url = f"https://production-sfo.browserless.io/pdf?token={TOKEN}&stealth=true"
headers = {
    "Cache-Control": "no-cache",
    "Content-Type": "application/json"
}

data = {
    "url": "https://example.com/",
}

response = requests.post(url, headers=headers, json=data)

with open("output.pdf", "wb") as file:
    file.write(response.content)

print("PDF saved as output.pdf")

```

```codeBlockLines_p187
import java.io.*;
import java.net.URI;
import java.net.http.*;
import java.nio.file.*;

public class GeneratePDF {
    public static void main(String[] args) {
        String TOKEN = "YOUR_API_TOKEN_HERE";
        String url = "https://production-sfo.browserless.io/pdf?token=" + TOKEN + "&stealth=true";

        String jsonData = """
        {
            "url": "https://example.com/",
        }
        """;

        HttpClient client = HttpClient.newHttpClient();

        HttpRequest request = HttpRequest.newBuilder()
            .uri(URI.create(url))
            .header("Cache-Control", "no-cache")
            .header("Content-Type", "application/json")
            .POST(HttpRequest.BodyPublishers.ofString(jsonData))
            .build();

        try {
            HttpResponse<InputStream> response = client.send(request, HttpResponse.BodyHandlers.ofInputStream());
            Files.copy(response.body(), Paths.get("output.pdf"), StandardCopyOption.REPLACE_EXISTING);
            System.out.println("PDF saved as output.pdf");
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

```

```codeBlockLines_p187
using System;
using System.IO;
using System.Net.Http;
using System.Text;
using System.Threading.Tasks;

class Program
{
    static async Task Main(string[] args)
    {
        string TOKEN = "YOUR_API_TOKEN_HERE";
        string url = $"https://production-sfo.browserless.io/pdf?token={TOKEN}&stealth=true";

        string jsonData = @"
          {
              ""url"": ""https://example.com/"",
          }";

        using var client = new HttpClient();

        var request = new HttpRequestMessage(HttpMethod.Post, url)
        {
            Content = new StringContent(jsonData, Encoding.UTF8, "application/json")
        };

        request.Headers.Add("Cache-Control", "no-cache");

        try
        {
            var response = await client.SendAsync(request);
            response.EnsureSuccessStatusCode();
            var pdfBytes = await response.Content.ReadAsByteArrayAsync();
            await File.WriteAllBytesAsync("output.pdf", pdfBytes);
            Console.WriteLine("PDF saved as output.pdf");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error: {ex.Message}");
        }
    }
}

```

### Blocking Ads [â€‹](https://docs.browserless.io/rest-apis/launch-parameters\#blocking-ads "Direct link to Blocking Ads")

- cURL
- Javascript
- Python
- Java
- C#

```codeBlockLines_p187
  curl -X POST \
  https://production-sfo.browserless.io/pdf?token=YOUR_API_TOKEN_HERE&blockAds=true \
  -H 'Cache-Control: no-cache' \
  -H 'Content-Type: application/json' \
  -d '{
  "url": "https://example.com/"
  }'

```

```codeBlockLines_p187
import fs from 'fs/promises';

const TOKEN = "YOUR_API_TOKEN_HERE";
const url = `https://production-sfo.browserless.io/pdf?token=${TOKEN}&blockAds=true`;
const headers = {
  "Cache-Control": "no-cache",
  "Content-Type": "application/json"
};

const data = {
  url: "https://example.com/",
};

const generatePDF = async () => {
  const response = await fetch(url, {
    method: 'POST',
    headers: headers,
    body: JSON.stringify(data)
  });

  const pdfBuffer = await response.arrayBuffer();
  await fs.writeFile("output.pdf", Buffer.from(pdfBuffer));
  console.log("PDF saved as output.pdf");
};

generatePDF();

```

```codeBlockLines_p187
import requests

TOKEN = "YOUR_API_TOKEN_HERE"
url = f"https://production-sfo.browserless.io/pdf?token={TOKEN}&blockAds=true"
headers = {
    "Cache-Control": "no-cache",
    "Content-Type": "application/json"
}

data = {
    "url": "https://example.com/",
}

response = requests.post(url, headers=headers, json=data)

with open("output.pdf", "wb") as file:
    file.write(response.content)

print("PDF saved as output.pdf")

```

```codeBlockLines_p187
import java.io.*;
import java.net.URI;
import java.net.http.*;
import java.nio.file.*;

public class GeneratePDF {
    public static void main(String[] args) {
        String TOKEN = "YOUR_API_TOKEN_HERE";
        String url = "https://production-sfo.browserless.io/pdf?token=" + TOKEN + "&blockAds=true";

        String jsonData = """
        {
            "url": "https://example.com/",
        }
        """;

        HttpClient client = HttpClient.newHttpClient();

        HttpRequest request = HttpRequest.newBuilder()
            .uri(URI.create(url))
            .header("Cache-Control", "no-cache")
            .header("Content-Type", "application/json")
            .POST(HttpRequest.BodyPublishers.ofString(jsonData))
            .build();

        try {
            HttpResponse<InputStream> response = client.send(request, HttpResponse.BodyHandlers.ofInputStream());
            Files.copy(response.body(), Paths.get("output.pdf"), StandardCopyOption.REPLACE_EXISTING);
            System.out.println("PDF saved as output.pdf");
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

```

```codeBlockLines_p187
using System;
using System.IO;
using System.Net.Http;
using System.Text;
using System.Threading.Tasks;

class Program
{
    static async Task Main(string[] args)
    {
        string TOKEN = "YOUR_API_TOKEN_HERE";
        string url = $"https://production-sfo.browserless.io/pdf?token={TOKEN}&blockAds=true";

        string jsonData = @"
          {
              ""url"": ""https://example.com/"",
          }";

        using var client = new HttpClient();

        var request = new HttpRequestMessage(HttpMethod.Post, url)
        {
            Content = new StringContent(jsonData, Encoding.UTF8, "application/json")
        };

        request.Headers.Add("Cache-Control", "no-cache");

        try
        {
            var response = await client.SendAsync(request);
            response.EnsureSuccessStatusCode();
            var pdfBytes = await response.Content.ReadAsByteArrayAsync();
            await File.WriteAllBytesAsync("output.pdf", pdfBytes);
            Console.WriteLine("PDF saved as output.pdf");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error: {ex.Message}");
        }
    }
}

```

Under the hood, Browserless uses UBlock Origin to block ads and filter content.

### Block Consent Modals [â€‹](https://docs.browserless.io/rest-apis/launch-parameters\#block-consent-modals "Direct link to Block Consent Modals")

- cURL
- Javascript
- Python
- Java
- C#

```codeBlockLines_p187
  curl -X POST \
  https://production-sfo.browserless.io/pdf?token=YOUR_API_TOKEN_HERE&blockConsentModals=true \
  -H 'Cache-Control: no-cache' \
  -H 'Content-Type: application/json' \
  -d '{
  "url": "https://example.com/"
  }'

```

```codeBlockLines_p187
import fs from 'fs/promises';

const TOKEN = "YOUR_API_TOKEN_HERE";
const url = `https://production-sfo.browserless.io/pdf?token=${TOKEN}&blockConsentModals=true`;
const headers = {
  "Cache-Control": "no-cache",
  "Content-Type": "application/json"
};

const data = {
  url: "https://example.com/",
};

const generatePDF = async () => {
  const response = await fetch(url, {
    method: 'POST',
    headers: headers,
    body: JSON.stringify(data)
  });

  const pdfBuffer = await response.arrayBuffer();
  await fs.writeFile("output.pdf", Buffer.from(pdfBuffer));
  console.log("PDF saved as output.pdf");
};

generatePDF();

```

```codeBlockLines_p187
import requests

TOKEN = "YOUR_API_TOKEN_HERE"
url = f"https://production-sfo.browserless.io/pdf?token={TOKEN}&blockConsentModals=true"
headers = {
    "Cache-Control": "no-cache",
    "Content-Type": "application/json"
}

data = {
    "url": "https://example.com/",
}

response = requests.post(url, headers=headers, json=data)

with open("output.pdf", "wb") as file:
    file.write(response.content)

print("PDF saved as output.pdf")

```

```codeBlockLines_p187
import java.io.*;
import java.net.URI;
import java.net.http.*;
import java.nio.file.*;

public class GeneratePDF {
    public static void main(String[] args) {
        String TOKEN = "YOUR_API_TOKEN_HERE";
        String url = "https://production-sfo.browserless.io/pdf?token=" + TOKEN + "&blockConsentModals=true";

        String jsonData = """
        {
            "url": "https://example.com/",
        }
        """;

        HttpClient client = HttpClient.newHttpClient();

        HttpRequest request = HttpRequest.newBuilder()
            .uri(URI.create(url))
            .header("Cache-Control", "no-cache")
            .header("Content-Type", "application/json")
            .POST(HttpRequest.BodyPublishers.ofString(jsonData))
            .build();

        try {
            HttpResponse<InputStream> response = client.send(request, HttpResponse.BodyHandlers.ofInputStream());
            Files.copy(response.body(), Paths.get("output.pdf"), StandardCopyOption.REPLACE_EXISTING);
            System.out.println("PDF saved as output.pdf");
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

```

```codeBlockLines_p187
using System;
using System.IO;
using System.Net.Http;
using System.Text;
using System.Threading.Tasks;

class Program
{
    static async Task Main(string[] args)
    {
        string TOKEN = "YOUR_API_TOKEN_HERE";
        string url = $"https://production-sfo.browserless.io/pdf?token={TOKEN}&blockConsentModals=true";

        string jsonData = @"
          {
              ""url"": ""https://example.com/"",
          }";

        using var client = new HttpClient();

        var request = new HttpRequestMessage(HttpMethod.Post, url)
        {
            Content = new StringContent(jsonData, Encoding.UTF8, "application/json")
        };

        request.Headers.Add("Cache-Control", "no-cache");

        try
        {
            var response = await client.SendAsync(request);
            response.EnsureSuccessStatusCode();
            var pdfBytes = await response.Content.ReadAsByteArrayAsync();
            await File.WriteAllBytesAsync("output.pdf", pdfBytes);
            Console.WriteLine("PDF saved as output.pdf");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error: {ex.Message}");
        }
    }
}

```

### Proxy [â€‹](https://docs.browserless.io/rest-apis/launch-parameters\#proxy "Direct link to Proxy")

Using `http://user:pass@host:port` as an example proxy URL:

- cURL
- Javascript
- Python
- Java
- C#

```codeBlockLines_p187
  curl -X POST \
  https://production-sfo.browserless.io/pdf?token=YOUR_API_TOKEN_HERE&proxy=http://user:pass@host:port \
  -H 'Cache-Control: no-cache' \
  -H 'Content-Type: application/json' \
  -d '{
  "url": "https://example.com/"
  }'

```

```codeBlockLines_p187
import fs from 'fs/promises';

const TOKEN = "YOUR_API_TOKEN_HERE";
const url = `https://production-sfo.browserless.io/pdf?token=${TOKEN}&proxy=http://user:pass@host:port`;
const headers = {
  "Cache-Control": "no-cache",
  "Content-Type": "application/json"
};

const data = {
  url: "https://example.com/",
};

const generatePDF = async () => {
  const response = await fetch(url, {
    method: 'POST',
    headers: headers,
    body: JSON.stringify(data)
  });

  const pdfBuffer = await response.arrayBuffer();
  await fs.writeFile("output.pdf", Buffer.from(pdfBuffer));
  console.log("PDF saved as output.pdf");
};

generatePDF();

```

```codeBlockLines_p187
import requests

TOKEN = "YOUR_API_TOKEN_HERE"
url = f"https://production-sfo.browserless.io/pdf?token={TOKEN}&proxy=http://user:pass@host:port"
headers = {
    "Cache-Control": "no-cache",
    "Content-Type": "application/json"
}

data = {
    "url": "https://example.com/",
}

response = requests.post(url, headers=headers, json=data)

with open("output.pdf", "wb") as file:
    file.write(response.content)

print("PDF saved as output.pdf")

```

```codeBlockLines_p187
import java.io.*;
import java.net.URI;
import java.net.http.*;
import java.nio.file.*;

public class GeneratePDF {
    public static void main(String[] args) {
        String TOKEN = "YOUR_API_TOKEN_HERE";
        String url = "https://production-sfo.browserless.io/pdf?token=" + TOKEN + "&proxy=http://user:pass@host:port";

        String jsonData = """
        {
            "url": "https://example.com/",
        }
        """;

        HttpClient client = HttpClient.newHttpClient();

        HttpRequest request = HttpRequest.newBuilder()
            .uri(URI.create(url))
            .header("Cache-Control", "no-cache")
            .header("Content-Type", "application/json")
            .POST(HttpRequest.BodyPublishers.ofString(jsonData))
            .build();

        try {
            HttpResponse<InputStream> response = client.send(request, HttpResponse.BodyHandlers.ofInputStream());
            Files.copy(response.body(), Paths.get("output.pdf"), StandardCopyOption.REPLACE_EXISTING);
            System.out.println("PDF saved as output.pdf");
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

```

```codeBlockLines_p187
using System;
using System.IO;
using System.Net.Http;
using System.Text;
using System.Threading.Tasks;

class Program
{
    static async Task Main(string[] args)
    {
        string TOKEN = "YOUR_API_TOKEN_HERE";
        string url = $"https://production-sfo.browserless.io/pdf?token={TOKEN}&proxy=http://user:pass@host:port";

        string jsonData = @"
          {
              ""url"": ""https://example.com/"",
          }";

        using var client = new HttpClient();

        var request = new HttpRequestMessage(HttpMethod.Post, url)
        {
            Content = new StringContent(jsonData, Encoding.UTF8, "application/json")
        };

        request.Headers.Add("Cache-Control", "no-cache");

        try
        {
            var response = await client.SendAsync(request);
            response.EnsureSuccessStatusCode();
            var pdfBytes = await response.Content.ReadAsByteArrayAsync();
            await File.WriteAllBytesAsync("output.pdf", pdfBytes);
            Console.WriteLine("PDF saved as output.pdf");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error: {ex.Message}");
        }
    }
}

```

### Proxy Country [â€‹](https://docs.browserless.io/rest-apis/launch-parameters\#proxy-country "Direct link to Proxy Country")

- cURL
- Javascript
- Python
- Java
- C#

```codeBlockLines_p187
  curl -X POST \
  https://production-sfo.browserless.io/pdf?token=YOUR_API_TOKEN_HERE&proxy=residential&proxyCountry=us \
  -H 'Cache-Control: no-cache' \
  -H 'Content-Type: application/json' \
  -d '{
  "url": "https://example.com/"
  }'

```

```codeBlockLines_p187
import fs from 'fs/promises';

const TOKEN = "YOUR_API_TOKEN_HERE";
const url = `https://production-sfo.browserless.io/pdf?token=${TOKEN}&proxy=residential&proxyCountry=us`;
const headers = {
  "Cache-Control": "no-cache",
  "Content-Type": "application/json"
};

const data = {
  url: "https://example.com/",
};

const generatePDF = async () => {
  const response = await fetch(url, {
    method: 'POST',
    headers: headers,
    body: JSON.stringify(data)
  });

  const pdfBuffer = await response.arrayBuffer();
  await fs.writeFile("output.pdf", Buffer.from(pdfBuffer));
  console.log("PDF saved as output.pdf");
};

generatePDF();

```

```codeBlockLines_p187
import requests

TOKEN = "YOUR_API_TOKEN_HERE"
url = f"https://production-sfo.browserless.io/pdf?token={TOKEN}&proxy=residential&proxyCountry=us"
headers = {
    "Cache-Control": "no-cache",
    "Content-Type": "application/json"
}

data = {
    "url": "https://example.com/",
}

response = requests.post(url, headers=headers, json=data)

with open("output.pdf", "wb") as file:
    file.write(response.content)

print("PDF saved as output.pdf")

```

```codeBlockLines_p187
import java.io.*;
import java.net.URI;
import java.net.http.*;
import java.nio.file.*;

public class GeneratePDF {
    public static void main(String[] args) {
        String TOKEN = "YOUR_API_TOKEN_HERE";
        String url = "https://production-sfo.browserless.io/pdf?token=" + TOKEN + "&proxy=residential&proxyCountry=us";

        String jsonData = """
        {
            "url": "https://example.com/",
        }
        """;

        HttpClient client = HttpClient.newHttpClient();

        HttpRequest request = HttpRequest.newBuilder()
            .uri(URI.create(url))
            .header("Cache-Control", "no-cache")
            .header("Content-Type", "application/json")
            .POST(HttpRequest.BodyPublishers.ofString(jsonData))
            .build();

        try {
            HttpResponse<InputStream> response = client.send(request, HttpResponse.BodyHandlers.ofInputStream());
            Files.copy(response.body(), Paths.get("output.pdf"), StandardCopyOption.REPLACE_EXISTING);
            System.out.println("PDF saved as output.pdf");
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

```

```codeBlockLines_p187
using System;
using System.IO;
using System.Net.Http;
using System.Text;
using System.Threading.Tasks;

class Program
{
    static async Task Main(string[] args)
    {
        string TOKEN = "YOUR_API_TOKEN_HERE";
        string url = $"https://production-sfo.browserless.io/pdf?token={TOKEN}&proxy=residential&proxyCountry=us";

        string jsonData = @"
          {
              ""url"": ""https://example.com/"",
          }";

        using var client = new HttpClient();

        var request = new HttpRequestMessage(HttpMethod.Post, url)
        {
            Content = new StringContent(jsonData, Encoding.UTF8, "application/json")
        };

        request.Headers.Add("Cache-Control", "no-cache");

        try
        {
            var response = await client.SendAsync(request);
            response.EnsureSuccessStatusCode();
            var pdfBytes = await response.Content.ReadAsByteArrayAsync();
            await File.WriteAllBytesAsync("output.pdf", pdfBytes);
            Console.WriteLine("PDF saved as output.pdf");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error: {ex.Message}");
        }
    }
}

```

### Proxy Sticky [â€‹](https://docs.browserless.io/rest-apis/launch-parameters\#proxy-sticky "Direct link to Proxy Sticky")

- cURL
- Javascript
- Python
- Java
- C#

```codeBlockLines_p187
  curl -X POST \
  https://production-sfo.browserless.io/pdf?token=YOUR_API_TOKEN_HERE&proxy=residential&proxySticky=true \
  -H 'Cache-Control: no-cache' \
  -H 'Content-Type: application/json' \
  -d '{
  "url": "https://example.com/"
  }'

```

```codeBlockLines_p187
import fs from 'fs/promises';

const TOKEN = "YOUR_API_TOKEN_HERE";
const url = `https://production-sfo.browserless.io/pdf?token=${TOKEN}&proxy=residential&proxySticky=true`;
const headers = {
  "Cache-Control": "no-cache",
  "Content-Type": "application/json"
};

const data = {
  url: "https://example.com/",
};

const generatePDF = async () => {
  const response = await fetch(url, {
    method: 'POST',
    headers: headers,
    body: JSON.stringify(data)
  });

  const pdfBuffer = await response.arrayBuffer();
  await fs.writeFile("output.pdf", Buffer.from(pdfBuffer));
  console.log("PDF saved as output.pdf");
};

generatePDF();

```

```codeBlockLines_p187
import requests

TOKEN = "YOUR_API_TOKEN_HERE"
url = f"https://production-sfo.browserless.io/pdf?token={TOKEN}&proxy=residential&proxySticky=true"
headers = {
    "Cache-Control": "no-cache",
    "Content-Type": "application/json"
}

data = {
    "url": "https://example.com/",
}

response = requests.post(url, headers=headers, json=data)

with open("output.pdf", "wb") as file:
    file.write(response.content)

print("PDF saved as output.pdf")

```

```codeBlockLines_p187
import java.io.*;
import java.net.URI;
import java.net.http.*;
import java.nio.file.*;

public class GeneratePDF {
    public static void main(String[] args) {
        String TOKEN = "YOUR_API_TOKEN_HERE";
        String url = "https://production-sfo.browserless.io/pdf?token=" + TOKEN + "&proxy=residential&proxySticky=true";

        String jsonData = """
        {
            "url": "https://example.com/",
        }
        """;

        HttpClient client = HttpClient.newHttpClient();

        HttpRequest request = HttpRequest.newBuilder()
            .uri(URI.create(url))
            .header("Cache-Control", "no-cache")
            .header("Content-Type", "application/json")
            .POST(HttpRequest.BodyPublishers.ofString(jsonData))
            .build();

        try {
            HttpResponse<InputStream> response = client.send(request, HttpResponse.BodyHandlers.ofInputStream());
            Files.copy(response.body(), Paths.get("output.pdf"), StandardCopyOption.REPLACE_EXISTING);
            System.out.println("PDF saved as output.pdf");
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

```

```codeBlockLines_p187
using System;
using System.IO;
using System.Net.Http;
using System.Text;
using System.Threading.Tasks;

class Program
{
    static async Task Main(string[] args)
    {
        string TOKEN = "YOUR_API_TOKEN_HERE";
        string url = $"https://production-sfo.browserless.io/pdf?token={TOKEN}&proxy=residential&proxySticky=true";

        string jsonData = @"
          {
              ""url"": ""https://example.com/"",
          }";

        using var client = new HttpClient();

        var request = new HttpRequestMessage(HttpMethod.Post, url)
        {
            Content = new StringContent(jsonData, Encoding.UTF8, "application/json")
        };

        request.Headers.Add("Cache-Control", "no-cache");

        try
        {
            var response = await client.SendAsync(request);
            response.EnsureSuccessStatusCode();
            var pdfBytes = await response.Content.ReadAsByteArrayAsync();
            await File.WriteAllBytesAsync("output.pdf", pdfBytes);
            Console.WriteLine("PDF saved as output.pdf");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error: {ex.Message}");
        }
    }
}

```

### Timeout [â€‹](https://docs.browserless.io/rest-apis/launch-parameters\#timeout "Direct link to Timeout")

- cURL
- Javascript
- Python
- Java
- C#

```codeBlockLines_p187
  curl -X POST \
  https://production-sfo.browserless.io/pdf?token=YOUR_API_TOKEN_HERE&timeout=25000 \
  -H 'Cache-Control: no-cache' \
  -H 'Content-Type: application/json' \
  -d '{
  "url": "https://example.com/"
  }'

```

```codeBlockLines_p187
import fs from 'fs/promises';

const TOKEN = "YOUR_API_TOKEN_HERE";
const url = `https://production-sfo.browserless.io/pdf?token=${TOKEN}&timeout=25000`;
const headers = {
  "Cache-Control": "no-cache",
  "Content-Type": "application/json"
};

const data = {
  url: "https://example.com/",
};

const generatePDF = async () => {
  const response = await fetch(url, {
    method: 'POST',
    headers: headers,
    body: JSON.stringify(data)
  });

  const pdfBuffer = await response.arrayBuffer();
  await fs.writeFile("output.pdf", Buffer.from(pdfBuffer));
  console.log("PDF saved as output.pdf");
};

generatePDF();

```

```codeBlockLines_p187
import requests

TOKEN = "YOUR_API_TOKEN_HERE"
url = f"https://production-sfo.browserless.io/pdf?token={TOKEN}&timeout=25000"
headers = {
    "Cache-Control": "no-cache",
    "Content-Type": "application/json"
}

data = {
    "url": "https://example.com/",
}

response = requests.post(url, headers=headers, json=data)

with open("output.pdf", "wb") as file:
    file.write(response.content)

print("PDF saved as output.pdf")

```

```codeBlockLines_p187
import java.io.*;
import java.net.URI;
import java.net.http.*;
import java.nio.file.*;

public class GeneratePDF {
    public static void main(String[] args) {
        String TOKEN = "YOUR_API_TOKEN_HERE";
        String url = "https://production-sfo.browserless.io/pdf?token=" + TOKEN + "&timeout=25000";

        String jsonData = """
        {
            "url": "https://example.com/",
        }
        """;

        HttpClient client = HttpClient.newHttpClient();

        HttpRequest request = HttpRequest.newBuilder()
            .uri(URI.create(url))
            .header("Cache-Control", "no-cache")
            .header("Content-Type", "application/json")
            .POST(HttpRequest.BodyPublishers.ofString(jsonData))
            .build();

        try {
            HttpResponse<InputStream> response = client.send(request, HttpResponse.BodyHandlers.ofInputStream());
            Files.copy(response.body(), Paths.get("output.pdf"), StandardCopyOption.REPLACE_EXISTING);
            System.out.println("PDF saved as output.pdf");
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

```

```codeBlockLines_p187
using System;
using System.IO;
using System.Net.Http;
using System.Text;
using System.Threading.Tasks;

class Program
{
    static async Task Main(string[] args)
    {
        string TOKEN = "YOUR_API_TOKEN_HERE";
        string url = $"https://production-sfo.browserless.io/pdf?token={TOKEN}&timeout=25000";

        string jsonData = @"
          {
              ""url"": ""https://example.com/"",
          }";

        using var client = new HttpClient();

        var request = new HttpRequestMessage(HttpMethod.Post, url)
        {
            Content = new StringContent(jsonData, Encoding.UTF8, "application/json")
        };

        request.Headers.Add("Cache-Control", "no-cache");

        try
        {
            var response = await client.SendAsync(request);
            response.EnsureSuccessStatusCode();
            var pdfBytes = await response.Content.ReadAsByteArrayAsync();
            await File.WriteAllBytesAsync("output.pdf", pdfBytes);
            Console.WriteLine("PDF saved as output.pdf");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error: {ex.Message}");
        }
    }
}

```

- [Passing Launch Options](https://docs.browserless.io/rest-apis/launch-parameters#passing-launch-options)
- [Launch Options (Query Parameters)](https://docs.browserless.io/rest-apis/launch-parameters#launch-options-query-parameters)
  - [Headless](https://docs.browserless.io/rest-apis/launch-parameters#headless)
  - [Stealth](https://docs.browserless.io/rest-apis/launch-parameters#stealth)
  - [Blocking Ads](https://docs.browserless.io/rest-apis/launch-parameters#blocking-ads)
  - [Block Consent Modals](https://docs.browserless.io/rest-apis/launch-parameters#block-consent-modals)
  - [Proxy](https://docs.browserless.io/rest-apis/launch-parameters#proxy)
  - [Proxy Country](https://docs.browserless.io/rest-apis/launch-parameters#proxy-country)
  - [Proxy Sticky](https://docs.browserless.io/rest-apis/launch-parameters#proxy-sticky)
  - [Timeout](https://docs.browserless.io/rest-apis/launch-parameters#timeout)

---

### /pdf API | Browserless.io
Original URL: https://docs.browserless.io/rest-apis/pdf

[Skip to main content](https://docs.browserless.io/rest-apis/pdf#__docusaurus_skipToContent_fallback)


The `/pdf` API allows for simple navigation to a site and capturing a PDF. Browserless will respond with a `Content-Type` of `application/pdf` and a Buffer of the PDF file. Similar to screenshots, this REST API also exposes puppeteer's `pdf` options via an `options` property in the JSON body for granular control.

You can [view the complete PDF API OpenAPI specification](https://docs.browserless.io/open-api#tag/Browser-REST-APIs/paths/~1chrome~1pdf/post) for all options and properties.

info

This route requires either a `url` or `html` property in the JSON body. When `html` is present Browserless will render the HTML for you and capture the PDF

## Basic Usage [â€‹](https://docs.browserless.io/rest-apis/pdf\#basic-usage "Direct link to Basic Usage")

- JSON payload
- cURL
- Javascript
- Python
- Java
- C#

```codeBlockLines_p187
// JSON body
// `options` are the options available via puppeteer's Page.pdf() method
// (see our Open API documentation)
{
  "url": "https://example.com/",
  "options": {
    "displayHeaderFooter": true,
    "printBackground": false,
    "format": "A0"
    // Queue the lack of a `path` parameter
  }
}

```

```codeBlockLines_p187
curl -X POST \
  https://production-sfo.browserless.io/pdf?token=YOUR_API_TOKEN_HERE \
  -H 'Cache-Control: no-cache' \
  -H 'Content-Type: application/json' \
  -d '{
  "url": "https://example.com/",
  "options": {
    "displayHeaderFooter": true,
    "printBackground": false,
    "format": "A0"
  }
}'

```

```codeBlockLines_p187
import fs from 'fs/promises';

const TOKEN = "YOUR_API_TOKEN_HERE";
const url = `https://production-sfo.browserless.io/pdf?token=${TOKEN}`;
const headers = {
  "Cache-Control": "no-cache",
  "Content-Type": "application/json"
};

const data = {
  url: "https://example.com/",
  options: {
    displayHeaderFooter: true,
    printBackground: false,
    format: "A0"
  }
};

const generatePDF = async () => {
  const response = await fetch(url, {
    method: 'POST',
    headers: headers,
    body: JSON.stringify(data)
  });

  const pdfBuffer = await response.arrayBuffer();
  await fs.writeFile("output.pdf", Buffer.from(pdfBuffer));
  console.log("PDF saved as output.pdf");
};

generatePDF();

```

```codeBlockLines_p187
import requests

TOKEN = "YOUR_API_TOKEN_HERE"
url = f"https://production-sfo.browserless.io/pdf?token={TOKEN}"
headers = {
    "Cache-Control": "no-cache",
    "Content-Type": "application/json"
}

data = {
    "url": "https://example.com/",
    "options": {
        "displayHeaderFooter": True,
        "printBackground": False,
        "format": "A0"
    }
}

response = requests.post(url, headers=headers, json=data)

with open("output.pdf", "wb") as file:
    file.write(response.content)

print("PDF saved as output.pdf")

```

```codeBlockLines_p187
import java.io.*;
import java.net.URI;
import java.net.http.*;
import java.nio.file.*;

public class GeneratePDF {
    public static void main(String[] args) {
        String TOKEN = "YOUR_API_TOKEN_HERE";
        String url = "https://production-sfo.browserless.io/pdf?token=" + TOKEN;

        String jsonData = """
        {
            "url": "https://example.com/",
            "options": {
                "displayHeaderFooter": true,
                "printBackground": false,
                "format": "A0"
            }
        }
        """;

        HttpClient client = HttpClient.newHttpClient();

        HttpRequest request = HttpRequest.newBuilder()
            .uri(URI.create(url))
            .header("Cache-Control", "no-cache")
            .header("Content-Type", "application/json")
            .POST(HttpRequest.BodyPublishers.ofString(jsonData))
            .build();

        try {
            HttpResponse<InputStream> response = client.send(request, HttpResponse.BodyHandlers.ofInputStream());
            Files.copy(response.body(), Paths.get("output.pdf"), StandardCopyOption.REPLACE_EXISTING);
            System.out.println("PDF saved as output.pdf");
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

```

```codeBlockLines_p187
using System;
using System.IO;
using System.Net.Http;
using System.Text;
using System.Threading.Tasks;

class Program
{
    static async Task Main(string[] args)
    {
        string TOKEN = "YOUR_API_TOKEN_HERE";
        string url = $"https://production-sfo.browserless.io/pdf?token={TOKEN}";

        string jsonData = @"
          {
              ""url"": ""https://example.com/"",
              ""options"": {
                  ""displayHeaderFooter"": true,
                  ""printBackground"": false,
                  ""format"": ""A0""
              }
          }";

        using var client = new HttpClient();

        var request = new HttpRequestMessage(HttpMethod.Post, url)
        {
            Content = new StringContent(jsonData, Encoding.UTF8, "application/json")
        };

        request.Headers.Add("Cache-Control", "no-cache");

        try
        {
            var response = await client.SendAsync(request);
            response.EnsureSuccessStatusCode();
            var pdfBytes = await response.Content.ReadAsByteArrayAsync();
            await File.WriteAllBytesAsync("output.pdf", pdfBytes);
            Console.WriteLine("PDF saved as output.pdf");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error: {ex.Message}");
        }
    }
}

```

warning

We do not allow setting a `options.path`

## Setting HTML content [â€‹](https://docs.browserless.io/rest-apis/pdf\#setting-html-content "Direct link to Setting HTML content")

You can set the HTML content of the page to render dynamically generated content as well.

danger

**When this propriety is set, the `url` propriety must not be present.**

Hereâ€™s the request in the specified format, with examples for `curl`, JavaScript, and Python.

- JSON payload
- cURL
- Javascript
- Python
- Java
- C#

```codeBlockLines_p187
// JSON body
// `options` are the options available via puppeteer's Page.pdf() method
// (see our Open API documentation)
{
  "html": "<h1>Hello World!</h1>",
  "options": {
    "displayHeaderFooter": true,
    "printBackground": false,
    "format": "A0"
    // Queue the lack of a `path` parameter
  }
}

```

```codeBlockLines_p187
curl -X POST \
  https://production-sfo.browserless.io/pdf?token=YOUR_API_TOKEN_HERE \
  -H 'Cache-Control: no-cache' \
  -H 'Content-Type: application/json' \
  -d '{
  "html": "<h1>Hello World!</h1>",
  "options": {
    "displayHeaderFooter": true,
    "printBackground": false,
    "format": "A0"
  }
}'

```

```codeBlockLines_p187
import fs from 'fs/promises';

const TOKEN = "YOUR_API_TOKEN_HERE";
const url = `https://production-sfo.browserless.io/pdf?token=${TOKEN}`;
const headers = {
  "Cache-Control": "no-cache",
  "Content-Type": "application/json"
};

const data = {
  html: "<h1>Hello World!</h1>",
  options: {
    displayHeaderFooter: true,
    printBackground: false,
    format: "A0"
  }
};

const generatePDF = async () => {
  const response = await fetch(url, {
    method: 'POST',
    headers: headers,
    body: JSON.stringify(data)
  });

  const pdfBuffer = await response.arrayBuffer();
  await fs.writeFile("output.pdf", Buffer.from(pdfBuffer));
  console.log("PDF saved as output.pdf");
};

generatePDF();

```

```codeBlockLines_p187
import requests

TOKEN = "YOUR_API_TOKEN_HERE"
url = f"https://production-sfo.browserless.io/pdf?token={TOKEN}"
headers = {
    "Cache-Control": "no-cache",
    "Content-Type": "application/json"
}

data = {
    "html": "<h1>Hello World!</h1>",
    "options": {
        "displayHeaderFooter": True,
        "printBackground": False,
        "format": "A0"
    }
}

response = requests.post(url, headers=headers, json=data)

with open("output.pdf", "wb") as file:
    file.write(response.content)

print("PDF saved as output.pdf")

```

```codeBlockLines_p187
import java.io.*;
import java.net.URI;
import java.net.http.*;
import java.nio.file.*;

public class GeneratePDFWithHTML {
    public static void main(String[] args) {
        String TOKEN = "YOUR_API_TOKEN_HERE";
        String url = "https://production-sfo.browserless.io/pdf?token=" + TOKEN;

        String jsonData = """
        {
            "html": "<h1>Hello World!</h1>",
            "options": {
                "displayHeaderFooter": true,
                "printBackground": false,
                "format": "A0"
            }
        }
        """;

        HttpClient client = HttpClient.newHttpClient();

        HttpRequest request = HttpRequest.newBuilder()
            .uri(URI.create(url))
            .header("Cache-Control", "no-cache")
            .header("Content-Type", "application/json")
            .POST(HttpRequest.BodyPublishers.ofString(jsonData))
            .build();

        try {
            HttpResponse<InputStream> response = client.send(request, HttpResponse.BodyHandlers.ofInputStream());
            Files.copy(response.body(), Paths.get("output.pdf"), StandardCopyOption.REPLACE_EXISTING);
            System.out.println("PDF saved as output.pdf");
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

```

```codeBlockLines_p187
using System;
using System.IO;
using System.Net.Http;
using System.Text;
using System.Threading.Tasks;

class Program
{
    static async Task Main(string[] args)
    {
        string TOKEN = "YOUR_API_TOKEN_HERE";
        string url = $"https://production-sfo.browserless.io/pdf?token={TOKEN}";

        string jsonData = @"
          {
              ""html"": ""<h1>Hello World!</h1>"",
              ""options"": {
                  ""displayHeaderFooter"": true,
                  ""printBackground"": false,
                  ""format"": ""A0""
              }
          }";

        using var client = new HttpClient();

        var request = new HttpRequestMessage(HttpMethod.Post, url)
        {
            Content = new StringContent(jsonData, Encoding.UTF8, "application/json")
        };

        request.Headers.Add("Cache-Control", "no-cache");

        try
        {
            var response = await client.SendAsync(request);
            response.EnsureSuccessStatusCode();
            var pdfBytes = await response.Content.ReadAsByteArrayAsync();

            await File.WriteAllBytesAsync("output.pdf", pdfBytes);
            Console.WriteLine("PDF saved as output.pdf");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error: {ex.Message}");
        }
    }
}

```

warning

We do not allow to set a `options.path`

## Adding custom styles and scripts [â€‹](https://docs.browserless.io/rest-apis/pdf\#adding-custom-styles-and-scripts "Direct link to Adding custom styles and scripts")

Browserless offers ways to load additional stylesheets and script tags to the page as well. This give you full control and allows you to override page elements to suite your needs.

- JSON payload
- cURL
- Javascript
- Python
- Java
- C#

```codeBlockLines_p187
{
  "url": "https://example.com/",
  "addScriptTag": [\
    { "url": "https://code.jquery.com/jquery-3.7.1.min.js" },\
    { "content": "document.querySelector(`h1`).innerText = `Hello Word!`" }\
  ],
  "addStyleTag": [\
    {\
      "content": "body { height: 100vh;  background: linear-gradient(45deg, #da5a44, #a32784);}"\
    },\
    {\
      "url": "https://interactive-examples.mdn.mozilla.net/live-examples/css-examples/text-decoration/text-decoration-color.css"\
    }\
  ]
}

```

```codeBlockLines_p187
curl -X POST \
  https://production-sfo.browserless.io/pdf?token=YOUR_API_TOKEN_HERE \
  -H 'Cache-Control: no-cache' \
  -H 'Content-Type: application/json' \
  -d '{
  "url": "https://example.com/",
  "addScriptTag": [\
    { "url": "https://code.jquery.com/jquery-3.7.1.min.js" },\
    { "content": "document.querySelector(`h1`).innerText = `Hello World!`" }\
  ],
  "addStyleTag": [\
    {\
      "content": "body { height: 100vh; background: linear-gradient(45deg, #da5a44, #a32784); }"\
    },\
    {\
      "url": "https://interactive-examples.mdn.mozilla.net/live-examples/css-examples/text-decoration/text-decoration-color.css"\
    }\
  ]
}'

```

```codeBlockLines_p187
import fs from 'fs/promises';

const TOKEN = "YOUR_API_TOKEN_HERE";
const url = `https://production-sfo.browserless.io/pdf?token=${TOKEN}`;
const headers = {
  "Cache-Control": "no-cache",
  "Content-Type": "application/json"
};

const data = {
  url: "https://example.com/",
  addScriptTag: [\
    { url: "https://code.jquery.com/jquery-3.7.1.min.js" },\
    { content: "document.querySelector(`h1`).innerText = `Hello World!`" }\
  ],
  addStyleTag: [\
    {\
      content: "body { height: 100vh; background: linear-gradient(45deg, #da5a44, #a32784); }"\
    },\
    {\
      url: "https://interactive-examples.mdn.mozilla.net/live-examples/css-examples/text-decoration/text-decoration-color.css"\
    }\
  ]
};

const generatePDF = async () => {
  const response = await fetch(url, {
    method: 'POST',
    headers: headers,
    body: JSON.stringify(data)
  });

  const pdfBuffer = await response.arrayBuffer();
  await fs.writeFile("output.pdf", Buffer.from(pdfBuffer));
  console.log("PDF saved as output.pdf");
};

generatePDF();

```

```codeBlockLines_p187
import requests

TOKEN = "YOUR_API_TOKEN_HERE"
url = f"https://production-sfo.browserless.io/pdf?token={TOKEN}"
headers = {
    "Cache-Control": "no-cache",
    "Content-Type": "application/json"
}

data = {
    "url": "https://example.com/",
    "addScriptTag": [\
        { "url": "https://code.jquery.com/jquery-3.7.1.min.js" },\
        { "content": "document.querySelector(`h1`).innerText = `Hello World!`" }\
    ],
    "addStyleTag": [\
        {\
            "content": "body { height: 100vh; background: linear-gradient(45deg, #da5a44, #a32784); }"\
        },\
        {\
            "url": "https://interactive-examples.mdn.mozilla.net/live-examples/css-examples/text-decoration/text-decoration-color.css"\
        }\
    ]
}

response = requests.post(url, headers=headers, json=data)

with open("output.pdf", "wb") as file:
    file.write(response.content)

print("PDF saved as output.pdf")

```

```codeBlockLines_p187
import java.io.*;
import java.net.URI;
import java.net.http.*;
import java.nio.file.*;

public class GeneratePDFWithScriptAndStyle {
    public static void main(String[] args) {
        String TOKEN = "YOUR_API_TOKEN_HERE";
        String url = "https://production-sfo.browserless.io/pdf?token=" + TOKEN;

        String jsonData = """
        {
            "url": "https://example.com/",
            "addScriptTag": [\
                { "url": "https://code.jquery.com/jquery-3.7.1.min.js" },\
                { "content": "document.querySelector(`h1`).innerText = `Hello World!`" }\
            ],
            "addStyleTag": [\
                {\
                    "content": "body { height: 100vh; background: linear-gradient(45deg, #da5a44, #a32784); }"\
                },\
                {\
                    "url": "https://interactive-examples.mdn.mozilla.net/live-examples/css-examples/text-decoration/text-decoration-color.css"\
                }\
            ]
        }
        """;

        HttpClient client = HttpClient.newHttpClient();

        HttpRequest request = HttpRequest.newBuilder()
            .uri(URI.create(url))
            .header("Cache-Control", "no-cache")
            .header("Content-Type", "application/json")
            .POST(HttpRequest.BodyPublishers.ofString(jsonData))
            .build();

        try {
            HttpResponse<InputStream> response = client.send(request, HttpResponse.BodyHandlers.ofInputStream());
            Files.copy(response.body(), Paths.get("output.pdf"), StandardCopyOption.REPLACE_EXISTING);
            System.out.println("PDF saved as output.pdf");
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

```

```codeBlockLines_p187
using System;
using System.IO;
using System.Net.Http;
using System.Text;
using System.Threading.Tasks;

class Program
{
    static async Task Main(string[] args)
    {
        string TOKEN = "YOUR_API_TOKEN_HERE";
        string url = $"https://production-sfo.browserless.io/pdf?token={TOKEN}";

        string jsonData = @"
          {
              ""url"": ""https://example.com/"",
              ""addScriptTag"": [\
                  { ""url"": ""https://code.jquery.com/jquery-3.7.1.min.js"" },\
                  { ""content"": ""document.querySelector(`h1`).innerText = `Hello World!`"" }\
              ],
              ""addStyleTag"": [\
                  {\
                      ""content"": ""body { height: 100vh; background: linear-gradient(45deg, #da5a44, #a32784); }""\
                  },\
                  {\
                      ""url"": ""https://interactive-examples.mdn.mozilla.net/live-examples/css-examples/text-decoration/text-decoration-color.css""\
                  }\
              ]
          }";

        using var client = new HttpClient();

        var request = new HttpRequestMessage(HttpMethod.Post, url)
        {
            Content = new StringContent(jsonData, Encoding.UTF8, "application/json")
        };

        request.Headers.Add("Cache-Control", "no-cache");

        try
        {
            var response = await client.SendAsync(request);
            response.EnsureSuccessStatusCode();
            var pdfBytes = await response.Content.ReadAsByteArrayAsync();

            await File.WriteAllBytesAsync("output.pdf", pdfBytes);
            Console.WriteLine("PDF saved as output.pdf");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error: {ex.Message}");
        }
    }
}

```

## Rejecting Undesired Requests [â€‹](https://docs.browserless.io/rest-apis/pdf\#rejecting-undesired-requests "Direct link to Rejecting Undesired Requests")

You can use `rejectResourceTypes` and `rejectRequestPattern` to block undesired content, resources and requests.

- JSON payload
- cURL
- Javascript
- Python
- Java
- C#

```codeBlockLines_p187
// Will reject any images and .css files
{
  "url": "https://browserless.io/"
  "rejectResourceTypes": ["image"],
  "rejectRequestPattern": ["/^.*\\.(css)"]
}

```

```codeBlockLines_p187
curl -X POST \
  https://production-sfo.browserless.io/pdf?token=YOUR_API_TOKEN_HERE \
  -H 'Cache-Control: no-cache' \
  -H 'Content-Type': 'application/json' \
  -d '{
  "url": "https://browserless.io/",
  "rejectResourceTypes": ["image"],
  "rejectRequestPattern": ["/^.*\\.(css)"]
}'

```

```codeBlockLines_p187
import fs from 'fs/promises';

const TOKEN = "YOUR_API_TOKEN_HERE";
const url = `https://production-sfo.browserless.io/pdf?token=${TOKEN}`;
const headers = {
  "Cache-Control": "no-cache",
  "Content-Type": "application/json"
};

const data = {
  url: "https://browserless.io/",
  rejectResourceTypes: ["image"],
  rejectRequestPattern: ["^.*\\.(css)"]
};

const generatePDF = async () => {
  const response = await fetch(url, {
    method: 'POST',
    headers: headers,
    body: JSON.stringify(data)
  });

  const pdfBuffer = await response.arrayBuffer();
  await fs.writeFile("output.pdf", Buffer.from(pdfBuffer));
  console.log("PDF saved as output.pdf");
};

generatePDF();

```

```codeBlockLines_p187
import requests

TOKEN = "YOUR_API_TOKEN_HERE"
url = f"https://production-sfo.browserless.io/pdf?token={TOKEN}"
headers = {
    "Cache-Control": "no-cache",
    "Content-Type": "application/json"
}

data = {
    "url": "https://browserless.io/",
    "rejectResourceTypes": ["image"],
    "rejectRequestPattern": ["^.*\\.(css)"]
}

response = requests.post(url, headers=headers, json=data)

with open("output.pdf", "wb") as file:
    file.write(response.content)

print("PDF saved as output.pdf")

```

```codeBlockLines_p187
import java.io.*;
import java.net.URI;
import java.net.http.*;
import java.nio.file.*;

public class GeneratePDFWithRejections {
    public static void main(String[] args) {
        String TOKEN = "YOUR_API_TOKEN_HERE";
        String url = "https://production-sfo.browserless.io/pdf?token=" + TOKEN;

        String jsonData = """
        {
            "url": "https://browserless.io/",
            "rejectResourceTypes": ["image"],
            "rejectRequestPattern": ["^.*\\\\.(css)"]
        }
        """;

        HttpClient client = HttpClient.newHttpClient();

        HttpRequest request = HttpRequest.newBuilder()
            .uri(URI.create(url))
            .header("Cache-Control", "no-cache")
            .header("Content-Type", "application/json")
            .POST(HttpRequest.BodyPublishers.ofString(jsonData))
            .build();

        try {
            HttpResponse<InputStream> response = client.send(request, HttpResponse.BodyHandlers.ofInputStream());
            Files.copy(response.body(), Paths.get("output.pdf"), StandardCopyOption.REPLACE_EXISTING);
            System.out.println("PDF saved as output.pdf");
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

```

```codeBlockLines_p187
using System;
using System.IO;
using System.Net.Http;
using System.Text;
using System.Threading.Tasks;

class Program
{
    static async Task Main(string[] args)
    {
        string TOKEN = "YOUR_API_TOKEN_HERE";
        string url = $"https://production-sfo.browserless.io/pdf?token={TOKEN}";

        string jsonData = @"
          {
              ""url"": ""https://browserless.io/"",
              ""rejectResourceTypes"": [""image""],
              ""rejectRequestPattern"": [""^.*\\\\.(css)""]
          }";

        using var client = new HttpClient();

        var request = new HttpRequestMessage(HttpMethod.Post, url)
        {
            Content = new StringContent(jsonData, Encoding.UTF8, "application/json")
        };

        request.Headers.Add("Cache-Control", "no-cache");

        try
        {
            var response = await client.SendAsync(request);
            response.EnsureSuccessStatusCode();
            var pdfBytes = await response.Content.ReadAsByteArrayAsync();

            await File.WriteAllBytesAsync("output.pdf", pdfBytes);
            Console.WriteLine("PDF saved as output.pdf");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error: {ex.Message}");
        }
    }
}

```

## Navigation Options [â€‹](https://docs.browserless.io/rest-apis/pdf\#navigation-options "Direct link to Navigation Options")

You can use the `gotoOptions` to modify the default navigation behavior for the requested URL. The objects mirror [Puppeteer's `GoToOptions` interface](https://pptr.dev/api/puppeteer.gotooptions).

- JSON payload
- cURL
- Javascript
- Python
- Java
- C#

```codeBlockLines_p187
{
  "url": "https://example.com/",
  "gotoOptions": { "waitUntil": "networkidle2" },
}

```

```codeBlockLines_p187
curl -X POST \
  https://production-sfo.browserless.io/pdf?token=YOUR_API_TOKEN_HERE \
  -H 'Cache-Control: no-cache' \
  -H 'Content-Type: application/json' \
  -d '{
  "url": "https://example.com/",
  "gotoOptions": { "waitUntil": "networkidle2" }
}'

```

```codeBlockLines_p187
import fs from 'fs/promises';

const TOKEN = "YOUR_API_TOKEN_HERE";
const url = `https://production-sfo.browserless.io/pdf?token=${TOKEN}`;
const headers = {
  "Cache-Control": "no-cache",
  "Content-Type": "application/json"
};

const data = {
  url: "https://example.com/",
  gotoOptions: { waitUntil: "networkidle2" }
};

const generatePDF = async () => {
  const response = await fetch(url, {
    method: 'POST',
    headers: headers,
    body: JSON.stringify(data)
  });

  const pdfBuffer = await response.arrayBuffer();
  await fs.writeFile("output.pdf", Buffer.from(pdfBuffer));
  console.log("PDF saved as output.pdf");
};

generatePDF();

```

```codeBlockLines_p187
import requests

TOKEN = "YOUR_API_TOKEN_HERE"
url = f"https://production-sfo.browserless.io/pdf?token={TOKEN}"
headers = {
    "Cache-Control": "no-cache",
    "Content-Type": "application/json"
}

data = {
    "url": "https://example.com/",
    "gotoOptions": { "waitUntil": "networkidle2" }
}

response = requests.post(url, headers=headers, json=data)

with open("output.pdf", "wb") as file:
    file.write(response.content)

print("PDF saved as output.pdf")

```

```codeBlockLines_p187
import java.io.*;
import java.net.URI;
import java.net.http.*;
import java.nio.file.*;

public class GeneratePDFWithGotoOptions {
    public static void main(String[] args) {
        String TOKEN = "YOUR_API_TOKEN_HERE";
        String url = "https://production-sfo.browserless.io/pdf?token=" + TOKEN;

        String jsonData = """
        {
            "url": "https://example.com/",
            "gotoOptions": { "waitUntil": "networkidle2" }
        }
        """;

        HttpClient client = HttpClient.newHttpClient();

        HttpRequest request = HttpRequest.newBuilder()
            .uri(URI.create(url))
            .header("Cache-Control", "no-cache")
            .header("Content-Type", "application/json")
            .POST(HttpRequest.BodyPublishers.ofString(jsonData))
            .build();

        try {
            HttpResponse<InputStream> response = client.send(request, HttpResponse.BodyHandlers.ofInputStream());
            Files.copy(response.body(), Paths.get("output.pdf"), StandardCopyOption.REPLACE_EXISTING);
            System.out.println("PDF saved as output.pdf");
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

```

```codeBlockLines_p187
using System;
using System.IO;
using System.Net.Http;
using System.Text;
using System.Threading.Tasks;

class Program
{
    static async Task Main(string[] args)
    {
        string TOKEN = "YOUR_API_TOKEN_HERE";
        string url = $"https://production-sfo.browserless.io/pdf?token={TOKEN}";

        string jsonData = @"
          {
              ""url"": ""https://example.com/"",
              ""gotoOptions"": { ""waitUntil"": ""networkidle2"" }
          }";

        using var client = new HttpClient();

        var request = new HttpRequestMessage(HttpMethod.Post, url)
        {
            Content = new StringContent(jsonData, Encoding.UTF8, "application/json")
        };

        request.Headers.Add("Cache-Control", "no-cache");

        try
        {
            var response = await client.SendAsync(request);
            response.EnsureSuccessStatusCode();
            var pdfBytes = await response.Content.ReadAsByteArrayAsync();

            await File.WriteAllBytesAsync("output.pdf", pdfBytes);
            Console.WriteLine("PDF saved as output.pdf");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error: {ex.Message}");
        }
    }
}

```

## Continue on Error [â€‹](https://docs.browserless.io/rest-apis/pdf\#continue-on-error "Direct link to Continue on Error")

You can use `bestAttempt` to make Browserless attempt to proceed when async events fail or timeout. This includes things like the `goto` or `waitForSelector` proprieties in the JSON payload.

- JSON payload
- cURL
- Javascript
- Python
- Java
- C#

```codeBlockLines_p187
{
  "url": "https://example.com/",
  "bestAttempt": true,

  // This would fail without bestAttempt
  "waitForSelector": { "selector": "table", "timeout": 500 }
}

```

```codeBlockLines_p187
curl -X POST \
  https://production-sfo.browserless.io/pdf?token=YOUR_API_TOKEN_HERE \
  -H 'Cache-Control: no-cache' \
  -H 'Content-Type: application/json' \
  -d '{
  "url": "https://example.com/",
  "bestAttempt": true,
  "waitForSelector": { "selector": "table", "timeout": 500 }
}'

```

```codeBlockLines_p187
import fs from 'fs/promises';

const TOKEN = "YOUR_API_TOKEN_HERE";
const url = `https://production-sfo.browserless.io/pdf?token=${TOKEN}`;
const headers = {
  "Cache-Control": "no-cache",
  "Content-Type": "application/json"
};

const data = {
  url: "https://example.com/",
  bestAttempt: true,
  waitForSelector: { selector: "table", timeout: 500 }
};

const generatePDF = async () => {
  const response = await fetch(url, {
    method: 'POST',
    headers: headers,
    body: JSON.stringify(data)
  });

  const pdfBuffer = await response.arrayBuffer();
  await fs.writeFile("output.pdf", Buffer.from(pdfBuffer));
  console.log("PDF saved as output.pdf");
};

generatePDF();

```

```codeBlockLines_p187
import requests

TOKEN = "YOUR_API_TOKEN_HERE"
url = f"https://production-sfo.browserless.io/pdf?token={TOKEN}"
headers = {
    "Cache-Control": "no-cache",
    "Content-Type": "application/json"
}

data = {
    "url": "https://example.com/",
    "bestAttempt": True,
    "waitForSelector": { "selector": "table", "timeout": 500 }
}

response = requests.post(url, headers=headers, json=data)

with open("output.pdf", "wb") as file:
    file.write(response.content)

print("PDF saved as output.pdf")

```

```codeBlockLines_p187
import java.io.*;
import java.net.URI;
import java.net.http.*;
import java.nio.file.*;

public class GeneratePDFWithBestAttempt {
    public static void main(String[] args) {
        String TOKEN = "YOUR_API_TOKEN_HERE";
        String url = "https://production-sfo.browserless.io/pdf?token=" + TOKEN;

        String jsonData = """
        {
            "url": "https://example.com/",
            "bestAttempt": true,
            "waitForSelector": { "selector": "table", "timeout": 500 }
        }
        """;

        HttpClient client = HttpClient.newHttpClient();

        HttpRequest request = HttpRequest.newBuilder()
            .uri(URI.create(url))
            .header("Cache-Control", "no-cache")
            .header("Content-Type", "application/json")
            .POST(HttpRequest.BodyPublishers.ofString(jsonData))
            .build();

        try {
            HttpResponse<InputStream> response = client.send(request, HttpResponse.BodyHandlers.ofInputStream());
            Files.copy(response.body(), Paths.get("output.pdf"), StandardCopyOption.REPLACE_EXISTING);
            System.out.println("PDF saved as output.pdf");
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

```

```codeBlockLines_p187
using System;
using System.IO;
using System.Net.Http;
using System.Text;
using System.Threading.Tasks;

class Program
{
    static async Task Main(string[] args)
    {
        string TOKEN = "YOUR_API_TOKEN_HERE";
        string url = $"https://production-sfo.browserless.io/pdf?token={TOKEN}";

        string jsonData = @"
          {
              ""url"": ""https://example.com/"",
              ""bestAttempt"": true,
              ""waitForSelector"": { ""selector"": ""table"", ""timeout"": 500 }
          }";

        using var client = new HttpClient();

        var request = new HttpRequestMessage(HttpMethod.Post, url)
        {
            Content = new StringContent(jsonData, Encoding.UTF8, "application/json")
        };

        request.Headers.Add("Cache-Control", "no-cache");

        try
        {
            var response = await client.SendAsync(request);
            response.EnsureSuccessStatusCode();
            var pdfBytes = await response.Content.ReadAsByteArrayAsync();

            await File.WriteAllBytesAsync("output.pdf", pdfBytes);
            Console.WriteLine("PDF saved as output.pdf");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error: {ex.Message}");
        }
    }
}

```

## Waiting for Things [â€‹](https://docs.browserless.io/rest-apis/pdf\#waiting-for-things "Direct link to Waiting for Things")

Browserless offers 4 different ways to wait for preconditions to be met on the page before returning the response. These are `events`, `functions`, `selectors` and `timeouts`.

### waitForEvent [â€‹](https://docs.browserless.io/rest-apis/pdf\#waitforevent "Direct link to waitForEvent")

Waits for an event to happen on the page before continuing:

#### Example [â€‹](https://docs.browserless.io/rest-apis/pdf\#example "Direct link to Example")

- JSON payload
- cURL
- Javascript
- Python
- Java
- C#

```codeBlockLines_p187
// Will fail since the event never fires
{
  "url": "https://example.com/",
  "waitForEvent": {
    "event": "fullscreenchange",
    "timeout": 5000
  }
}

```

```codeBlockLines_p187
curl -X POST \
  https://production-sfo.browserless.io/pdf?token=YOUR_API_TOKEN_HERE \
  -H 'Cache-Control: no-cache' \
  -H 'Content-Type: application/json' \
  -d '{
  "url": "https://example.com/",
  "waitForEvent": {
    "event": "fullscreenchange",
    "timeout": 5000
  }
}'

```

```codeBlockLines_p187
import fs from 'fs/promises';

const TOKEN = "YOUR_API_TOKEN_HERE";
const url = `https://production-sfo.browserless.io/pdf?token=${TOKEN}`;
const headers = {
  "Cache-Control": "no-cache",
  "Content-Type": "application/json"
};

const data = {
  url: "https://example.com/",
  waitForEvent: {
    event: "fullscreenchange",
    timeout: 5000
  }
};

const generatePDF = async () => {
  const response = await fetch(url, {
    method: 'POST',
    headers: headers,
    body: JSON.stringify(data)
  });

  const pdfBuffer = await response.arrayBuffer();
  await fs.writeFile("output.pdf", Buffer.from(pdfBuffer));
  console.log("PDF saved as output.pdf");
};

generatePDF();

```

```codeBlockLines_p187
import requests

TOKEN = "YOUR_API_TOKEN_HERE"
url = f"https://production-sfo.browserless.io/pdf?token={TOKEN}"
headers = {
    "Cache-Control": "no-cache",
    "Content-Type": "application/json"
}

data = {
    "url": "https://example.com/",
    "waitForEvent": {
        "event": "fullscreenchange",
        "timeout": 5000
    }
}

response = requests.post(url, headers=headers, json=data)

with open("output.pdf", "wb") as file:
    file.write(response.content)

print("PDF saved as output.pdf")

```

```codeBlockLines_p187
import java.io.*;
import java.net.URI;
import java.net.http.*;
import java.nio.file.*;

public class GeneratePDFWithWaitForEvent {
    public static void main(String[] args) {
        String TOKEN = "YOUR_API_TOKEN_HERE";
        String url = "https://production-sfo.browserless.io/pdf?token=" + TOKEN;

        String jsonData = """
        {
            "url": "https://example.com/",
            "waitForEvent": {
                "event": "fullscreenchange",
                "timeout": 5000
            }
        }
        """;

        HttpClient client = HttpClient.newHttpClient();

        HttpRequest request = HttpRequest.newBuilder()
            .uri(URI.create(url))
            .header("Cache-Control", "no-cache")
            .header("Content-Type", "application/json")
            .POST(HttpRequest.BodyPublishers.ofString(jsonData))
            .build();

        try {
            HttpResponse<InputStream> response = client.send(request, HttpResponse.BodyHandlers.ofInputStream());
            Files.copy(response.body(), Paths.get("output.pdf"), StandardCopyOption.REPLACE_EXISTING);
            System.out.println("PDF saved as output.pdf");
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

```

```codeBlockLines_p187
using System;
using System.IO;
using System.Net.Http;
using System.Text;
using System.Threading.Tasks;

class Program
{
    static async Task Main(string[] args)
    {
        string TOKEN = "YOUR_API_TOKEN_HERE";
        string url = $"https://production-sfo.browserless.io/pdf?token={TOKEN}";

        string jsonData = @"
          {
              ""url"": ""https://example.com/"",
              ""waitForEvent"": {
                  ""event"": ""fullscreenchange"",
                  ""timeout"": 5000
              }
          }";

        using var client = new HttpClient();

        var request = new HttpRequestMessage(HttpMethod.Post, url)
        {
            Content = new StringContent(jsonData, Encoding.UTF8, "application/json")
        };

        request.Headers.Add("Cache-Control", "no-cache");

        try
        {
            var response = await client.SendAsync(request);
            response.EnsureSuccessStatusCode();
            var pdfBytes = await response.Content.ReadAsByteArrayAsync();

            await File.WriteAllBytesAsync("output.pdf", pdfBytes);
            Console.WriteLine("PDF saved as output.pdf");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error: {ex.Message}");
        }
    }
}

```

### waitForFunction [â€‹](https://docs.browserless.io/rest-apis/pdf\#waitforfunction "Direct link to waitForFunction")

Waits for the provided function to return before continuing. The function can be any valid JavaScript or EcmaScript function, and `async` functions are supported.

#### Example [â€‹](https://docs.browserless.io/rest-apis/pdf\#example-1 "Direct link to Example")

**JS function**

```codeBlockLines_p187
async () => {
  const res = await fetch("https://jsonplaceholder.typicode.com/todos/1");
  const json = await res.json();

  document.querySelector("h1").innerText = json.title;
};

```

- JSON payload
- cURL
- Javascript
- Python
- Java
- C#

```codeBlockLines_p187
{
  "url": "https://example.com/",
  "waitForFunction": {
    "fn": "async()=>{let t=await fetch('https://jsonplaceholder.typicode.com/todos/1'),e=await t.json();document.querySelector('h1').innerText=e.title}",
    "timeout": 5000
  }
}

```

```codeBlockLines_p187
curl -X POST \
  https://production-sfo.browserless.io/pdf?token=YOUR_API_TOKEN_HERE \
  -H 'Cache-Control: no-cache' \
  -H 'Content-Type: application/json' \
  -d '{
  "url": "https://example.com/",
  "waitForFunction": {
    "fn": "async()=>{let t=await fetch('https://jsonplaceholder.typicode.com/todos/1'),e=await t.json();document.querySelector('h1').innerText=e.title}",
    "timeout": 5000
  }
}'

```

```codeBlockLines_p187
import fs from 'fs/promises';

const TOKEN = "YOUR_API_TOKEN_HERE";
const url = `https://production-sfo.browserless.io/pdf?token=${TOKEN}`;
const headers = {
  "Cache-Control": "no-cache",
  "Content-Type": "application/json"
};

const data = {
  url: "https://example.com/",
  waitForFunction: {
    fn: "async()=>{let t=await fetch('https://jsonplaceholder.typicode.com/todos/1'),e=await t.json();document.querySelector('h1').innerText=e.title}",
    timeout: 5000
  }
};

const generatePDF = async () => {
  const response = await fetch(url, {
    method: 'POST',
    headers: headers,
    body: JSON.stringify(data)
  });

  const pdfBuffer = await response.arrayBuffer();
  await fs.writeFile("output.pdf", Buffer.from(pdfBuffer));
  console.log("PDF saved as output.pdf");
};

generatePDF();

```

```codeBlockLines_p187
import requests

TOKEN = "YOUR_API_TOKEN_HERE"
url = f"https://production-sfo.browserless.io/pdf?token={TOKEN}"
headers = {
    "Cache-Control": "no-cache",
    "Content-Type": "application/json"
}

data = {
    "url": "https://example.com/",
    "waitForFunction": {
        "fn": "async()=>{let t=await fetch('https://jsonplaceholder.typicode.com/todos/1'),e=await t.json();document.querySelector('h1').innerText=e.title}",
        "timeout": 5000
    }
}

response = requests.post(url, headers=headers, json=data)

with open("output.pdf", "wb") as file:
    file.write(response.content)

print("PDF saved as output.pdf")

```

```codeBlockLines_p187
import java.io.*;
import java.net.URI;
import java.net.http.*;
import java.nio.file.*;

public class GeneratePDFWithWaitForFunction {
    public static void main(String[] args) {
        String TOKEN = "YOUR_API_TOKEN_HERE";
        String url = "https://production-sfo.browserless.io/pdf?token=" + TOKEN;

        String jsonData = """
        {
            "url": "https://example.com/",
            "waitForFunction": {
                "fn": "async()=>{let t=await fetch('https://jsonplaceholder.typicode.com/todos/1'),e=await t.json();document.querySelector('h1').innerText=e.title}",
                "timeout": 5000
            }
        }
        """;

        HttpClient client = HttpClient.newHttpClient();

        HttpRequest request = HttpRequest.newBuilder()
            .uri(URI.create(url))
            .header("Cache-Control", "no-cache")
            .header("Content-Type", "application/json")
            .POST(HttpRequest.BodyPublishers.ofString(jsonData))
            .build();

        try {
            HttpResponse<InputStream> response = client.send(request, HttpResponse.BodyHandlers.ofInputStream());
            Files.copy(response.body(), Paths.get("output.pdf"), StandardCopyOption.REPLACE_EXISTING);
            System.out.println("PDF saved as output.pdf");
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

```

```codeBlockLines_p187
using System;
using System.IO;
using System.Net.Http;
using System.Text;
using System.Threading.Tasks;

class Program
{
    static async Task Main(string[] args)
    {
        string TOKEN = "YOUR_API_TOKEN_HERE";
        string url = $"https://production-sfo.browserless.io/pdf?token={TOKEN}";

        string jsonData = @"
          {
              ""url"": ""https://example.com/"",
              ""waitForFunction"": {
                  ""fn"": ""async()=>{let t=await fetch('https://jsonplaceholder.typicode.com/todos/1'),e=await t.json();document.querySelector('h1').innerText=e.title}"",
                  ""timeout"": 5000
              }
          }";

        using var client = new HttpClient();

        var request = new HttpRequestMessage(HttpMethod.Post, url)
        {
            Content = new StringContent(jsonData, Encoding.UTF8, "application/json")
        };

        request.Headers.Add("Cache-Control", "no-cache");

        try
        {
            var response = await client.SendAsync(request);
            response.EnsureSuccessStatusCode();
            var pdfBytes = await response.Content.ReadAsByteArrayAsync();

            await File.WriteAllBytesAsync("output.pdf", pdfBytes);
            Console.WriteLine("PDF saved as output.pdf");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error: {ex.Message}");
        }
    }
}

```

### waitForSelector [â€‹](https://docs.browserless.io/rest-apis/pdf\#waitforselector "Direct link to waitForSelector")

Wait for a selector to appear in page. If at the moment of calling the method the selector already exists, the method will return immediately. If the selector doesn't appear after the timeout milliseconds of waiting, the function will throw.

The object can have any of these values:

- `selector`: String, required â€” A valid CSS selector.
- `hidden` Boolean, optional â€” Wait for the selected element to not be found in the DOM or to be hidden, i.e. have `display: none` or `visibility: hidden` CSS properties.
- `timeout`: Number, optional â€” Maximum number of milliseconds to wait for the selector before failing.
- `visible`: Boolean, optional â€” Wait for the selected element to be present in DOM and to be visible, i.e. to not have `display: none` or `visibility: hidden` CSS properties.

#### Example [â€‹](https://docs.browserless.io/rest-apis/pdf\#example-2 "Direct link to Example")

- JSON payload
- cURL
- Javascript
- Python
- Java
- C#

```codeBlockLines_p187
{
  "url": "https://example.com/",
  "waitForSelector": {
    "selector": "h1",
    "timeout": 5000
  }
}

```

```codeBlockLines_p187
curl -X POST \
  https://production-sfo.browserless.io/pdf?token=YOUR_API_TOKEN_HERE \
  -H 'Cache-Control: no-cache' \
  -H 'Content-Type: application/json' \
  -d '{
  "url": "https://example.com/",
  "waitForSelector": {
    "selector": "h1",
    "timeout": 5000
  }
}'

```

```codeBlockLines_p187
import fs from 'fs/promises';

const TOKEN = "YOUR_API_TOKEN_HERE";
const url = `https://production-sfo.browserless.io/pdf?token=${TOKEN}`;
const headers = {
  "Cache-Control": "no-cache",
  "Content-Type": "application/json"
};

const data = {
  url: "https://example.com/",
  waitForSelector: {
    selector: "h1",
    timeout: 5000
  }
};

const generatePDF = async () => {
  const response = await fetch(url, {
    method: 'POST',
    headers: headers,
    body: JSON.stringify(data)
  });

  const pdfBuffer = await response.arrayBuffer();
  await fs.writeFile("output.pdf", Buffer.from(pdfBuffer));
  console.log("PDF saved as output.pdf");
};

generatePDF();

```

```codeBlockLines_p187
import requests

TOKEN = "YOUR_API_TOKEN_HERE"
url = f"https://production-sfo.browserless.io/pdf?token={TOKEN}"
headers = {
    "Cache-Control": "no-cache",
    "Content-Type": "application/json"
}

data = {
    "url": "https://example.com/",
    "waitForSelector": {
        "selector": "h1",
        "timeout": 5000
    }
}

response = requests.post(url, headers=headers, json=data)

with open("output.pdf", "wb") as file:
    file.write(response.content)

print("PDF saved as output.pdf")

```

```codeBlockLines_p187
import java.io.*;
import java.net.URI;
import java.net.http.*;
import java.nio.file.*;

public class GeneratePDFWithWaitForSelector {
    public static void main(String[] args) {
        String TOKEN = "YOUR_API_TOKEN_HERE";
        String url = "https://production-sfo.browserless.io/pdf?token=" + TOKEN;

        String jsonData = """
        {
            "url": "https://example.com/",
            "waitForSelector": {
                "selector": "h1",
                "timeout": 5000
            }
        }
        """;

        HttpClient client = HttpClient.newHttpClient();

        HttpRequest request = HttpRequest.newBuilder()
            .uri(URI.create(url))
            .header("Cache-Control", "no-cache")
            .header("Content-Type", "application/json")
            .POST(HttpRequest.BodyPublishers.ofString(jsonData))
            .build();

        try {
            HttpResponse<InputStream> response = client.send(request, HttpResponse.BodyHandlers.ofInputStream());
            Files.copy(response.body(), Paths.get("output.pdf"), StandardCopyOption.REPLACE_EXISTING);
            System.out.println("PDF saved as output.pdf");
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

```

```codeBlockLines_p187
using System;
using System.IO;
using System.Net.Http;
using System.Text;
using System.Threading.Tasks;

class Program
{
    static async Task Main(string[] args)
    {
        string TOKEN = "YOUR_API_TOKEN_HERE";
        string url = $"https://production-sfo.browserless.io/pdf?token={TOKEN}";

        string jsonData = @"
          {
              ""url"": ""https://example.com/"",
              ""waitForSelector"": {
                  ""selector"": ""h1"",
                  ""timeout"": 5000
              }
          }";

        using var client = new HttpClient();

        var request = new HttpRequestMessage(HttpMethod.Post, url)
        {
            Content = new StringContent(jsonData, Encoding.UTF8, "application/json")
        };

        request.Headers.Add("Cache-Control", "no-cache");

        try
        {
            var response = await client.SendAsync(request);
            response.EnsureSuccessStatusCode();
            var pdfBytes = await response.Content.ReadAsByteArrayAsync();

            await File.WriteAllBytesAsync("output.pdf", pdfBytes);
            Console.WriteLine("PDF saved as output.pdf");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error: {ex.Message}");
        }
    }
}

```

- [Basic Usage](https://docs.browserless.io/rest-apis/pdf#basic-usage)
- [Setting HTML content](https://docs.browserless.io/rest-apis/pdf#setting-html-content)
- [Adding custom styles and scripts](https://docs.browserless.io/rest-apis/pdf#adding-custom-styles-and-scripts)
- [Rejecting Undesired Requests](https://docs.browserless.io/rest-apis/pdf#rejecting-undesired-requests)
- [Navigation Options](https://docs.browserless.io/rest-apis/pdf#navigation-options)
- [Continue on Error](https://docs.browserless.io/rest-apis/pdf#continue-on-error)
- [Waiting for Things](https://docs.browserless.io/rest-apis/pdf#waiting-for-things)
  - [waitForEvent](https://docs.browserless.io/rest-apis/pdf#waitforevent)
  - [waitForFunction](https://docs.browserless.io/rest-apis/pdf#waitforfunction)
  - [waitForSelector](https://docs.browserless.io/rest-apis/pdf#waitforselector)

---

### /performance API | Browserless.io
Original URL: https://docs.browserless.io/rest-apis/performance

[Skip to main content](https://docs.browserless.io/rest-apis/performance#__docusaurus_skipToContent_fallback)


The performance API reveals key metrics about a site's accessibility, best practices, performance, PWA information, and SEO, from a performance standpoint. It includes useful metrics like latency, time-to-interaction, design contrast other recommendations. This API is powered by [Google's Lighthouse](https://github.com/GoogleChrome/lighthouse) project, and it's compatible with its CLI options.

In order to gather this data, send a `POST` request to `https://production-sfo.browserless.io/performance` if on a hosted plan, with a simple JSON payload containing a valid URL.

warning

Due to the number of checks gathered it can take anywhere from several seconds to minutes depending on the site and size of the worker.

You can [check the full Open API schema here](https://docs.browserless.io/open-api#tag/Browser-REST-APIs/paths/~1chrome~1performance/post).

### Examples [â€‹](https://docs.browserless.io/rest-apis/performance\#examples "Direct link to Examples")

1. [Basic Usage](https://docs.browserless.io/rest-apis/performance#basic-usage)
2. [Gathering metrics for a category](https://docs.browserless.io/rest-apis/performance#gathering-metrics-for-a-category)
3. [Gathering metrics from a single audit](https://docs.browserless.io/rest-apis/performance#gathering-metrics-from-a-single-audit)

## Basic Usage [â€‹](https://docs.browserless.io/rest-apis/performance\#basic-usage "Direct link to Basic Usage")

- JSON payload
- cURL
- Javascript
- Python
- Java
- C#

```codeBlockLines_p187
{
  "url": "https://example.com/"
}

```

```codeBlockLines_p187
curl -X POST \
  https://production-sfo.browserless.io/performance?token=YOUR_API_TOKEN_HERE \
  -H 'Cache-Control: no-cache' \
  -H 'Content-Type': 'application/json' \
  -d '{
  "url": "https://example.com/"
}'

```

```codeBlockLines_p187
const TOKEN = "YOUR_API_TOKEN_HERE";
const url = `https://production-sfo.browserless.io/performance?token=${TOKEN}`;
const headers = {
  "Cache-Control": "no-cache",
  "Content-Type": "application/json"
};

const data = {
  url: "https://example.com/"
};

const fetchPerformanceMetrics = async () => {
  const response = await fetch(url, {
    method: 'POST',
    headers: headers,
    body: JSON.stringify(data)
  });

  const result = await response.json();
  console.log(result);
};

fetchPerformanceMetrics();

```

```codeBlockLines_p187
import requests

TOKEN = "YOUR_API_TOKEN_HERE"
url = f"https://production-sfo.browserless.io/performance?token={TOKEN}"
headers = {
    "Cache-Control": "no-cache",
    "Content-Type": "application/json"
}

data = {
    "url": "https://example.com/"
}

response = requests.post(url, headers=headers, json=data)
result = response.json()

print(result)

```

```codeBlockLines_p187
import java.io.*;
import java.net.URI;
import java.net.http.*;

public class FetchPerformanceMetrics {
    public static void main(String[] args) {
        String TOKEN = "YOUR_API_TOKEN_HERE";
        String url = "https://production-sfo.browserless.io/performance?token=" + TOKEN;

        String jsonData = """
        {
            "url": "https://example.com/"
        }
        """;

        HttpClient client = HttpClient.newHttpClient();

        HttpRequest request = HttpRequest.newBuilder()
            .uri(URI.create(url))
            .header("Cache-Control", "no-cache")
            .header("Content-Type", "application/json")
            .POST(HttpRequest.BodyPublishers.ofString(jsonData))
            .build();

        try {
            HttpResponse<String> response = client.send(request, HttpResponse.BodyHandlers.ofString());
            System.out.println("Response: " + response.body());
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

```

```codeBlockLines_p187
using System;
using System.Net.Http;
using System.Text;
using System.Text.Json;
using System.Threading.Tasks;

class Program {
    static async Task Main(string[] args) {
        string TOKEN = "YOUR_API_TOKEN_HERE";
        string url = $"https://production-sfo.browserless.io/performance?token={TOKEN}";

        string jsonData = @"
        {
            ""url"": ""https://example.com/""
        }";

        using var client = new HttpClient();
        var content = new StringContent(jsonData, Encoding.UTF8, "application/json");

        try {
            var response = await client.PostAsync(url, content);
            response.EnsureSuccessStatusCode();

            var result = await response.Content.ReadAsStringAsync();
            Console.WriteLine("Response: " + result);
        } catch (Exception ex) {
            Console.WriteLine($"Error: {ex.Message}");
        }
    }
}

```

By default, the `/performance` API will gather **all** the metrics. This will not only result in a **really** big JSON response (350kb to 800kb on average) and it **will** take some seconds (to minutes) to complete.

Each test has a score that indicates how well it performed, where 1 is the maximum and 0 is the lowest, generating a response like this:

```codeBlockLines_p187
  // ...
  "audits": {
    "is-on-https": {
      "title": "Uses HTTPS",
      "score": 1
      // ...
    },
    "viewport": {
      "title": "Has a `<meta name=\"viewport\">` tag with `width` or `initial-scale`",
      "score": 1
      // ...
    },
    "first-contentful-paint": {
      "score": 1,
      "displayValue": "0.8Â s"
      // ...
    }
    // ...
  }

```

## Gathering metrics for a category [â€‹](https://docs.browserless.io/rest-apis/performance\#gathering-metrics-for-a-category "Direct link to Gathering metrics for a category")

You can get metrics from specific categories, using the `config` property. [Just like Lighthouse](https://github.com/GoogleChrome/lighthouse/blob/master/readme.md#cli-options), available categories are `accessibility`, `best practices`, `performance`, `pwa`, and `seo`

- JSON payload
- cURL
- Javascript
- Python
- Java
- C#

```codeBlockLines_p187
{
  "url": "https://example.com",
  "config": {
    "extends": "lighthouse:default",
    "settings": {
      "onlyCategories": ["accessibility"]
    }
  }
}

```

```codeBlockLines_p187
curl --request POST \
  --url 'https://production-sfo.browserless.io/performance?token=YOUR_API_TOKEN_HERE' \
  --header 'Cache-Control: no-cache' \
  --header 'Content-Type: application/json' \
  --data '{
  "url": "https://browserless.io",
  "config": {
    "extends": "lighthouse:default",
    "settings": {
      "onlyCategories": ["accessibility"]
    }
  }
}'

```

```codeBlockLines_p187
const TOKEN = "YOUR_API_TOKEN_HERE";
const url = `https://production-sfo.browserless.io/performance?token=${TOKEN}`;
const headers = {
  "Cache-Control": "no-cache",
  "Content-Type": "application/json"
};

const data = {
  url: "https://browserless.io",
  config: {
    extends: "lighthouse:default",
    settings: {
      onlyCategories: ["accessibility"]
    }
  }
};

const fetchPerformanceMetrics = async () => {
  const response = await fetch(url, {
    method: 'POST',
    headers: headers,
    body: JSON.stringify(data)
  });

  const result = await response.json();
  console.log(result);
};

fetchPerformanceMetrics();

```

```codeBlockLines_p187
import requests

TOKEN = "YOUR_API_TOKEN_HERE"
url = f"https://production-sfo.browserless.io/performance?token={TOKEN}"
headers = {
    "Cache-Control": "no-cache",
    "Content-Type": "application/json"
}

data = {
    "url": "https://browserless.io",
    "config": {
        "extends": "lighthouse:default",
        "settings": {
            "onlyCategories": ["accessibility"]
        }
    }
}

response = requests.post(url, headers=headers, json=data)
result = response.json()

print(result)

```

```codeBlockLines_p187
import java.io.*;
import java.net.URI;
import java.net.http.*;

public class FetchPerformanceWithConfig {
    public static void main(String[] args) {
        String TOKEN = "YOUR_API_TOKEN_HERE";
        String url = "https://production-sfo.browserless.io/performance?token=" + TOKEN;

        String jsonData = """
        {
            "url": "https://browserless.io",
            "config": {
                "extends": "lighthouse:default",
                "settings": {
                    "onlyCategories": ["accessibility"]
                }
            }
        }
        """;

        HttpClient client = HttpClient.newHttpClient();

        HttpRequest request = HttpRequest.newBuilder()
            .uri(URI.create(url))
            .header("Cache-Control", "no-cache")
            .header("Content-Type", "application/json")
            .POST(HttpRequest.BodyPublishers.ofString(jsonData))
            .build();

        try {
            HttpResponse<String> response = client.send(request, HttpResponse.BodyHandlers.ofString());
            System.out.println("Response: " + response.body());
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

```

```codeBlockLines_p187
using System;
using System.Net.Http;
using System.Text;
using System.Text.Json;
using System.Threading.Tasks;

class Program {
    static async Task Main(string[] args) {
        string TOKEN = "YOUR_API_TOKEN_HERE";
        string url = $"https://production-sfo.browserless.io/performance?token={TOKEN}";

        string jsonData = @"
        {
            ""url"": ""https://browserless.io"",
            ""config"": {
                ""extends"": ""lighthouse:default"",
                ""settings"": {
                    ""onlyCategories"": [""accessibility""]
                }
            }
        }";

        using var client = new HttpClient();
        var content = new StringContent(jsonData, Encoding.UTF8, "application/json");

        try {
            var response = await client.PostAsync(url, content);
            response.EnsureSuccessStatusCode();

            var result = await response.Content.ReadAsStringAsync();
            Console.WriteLine("Response: " + result);
        } catch (Exception ex) {
            Console.WriteLine($"Error: {ex.Message}");
        }
    }
}

```

This will gather the predefined metrics defined by Lighthouse for that category:

```codeBlockLines_p187
  // ...
  "audits": {
    "aria-command-name": {
      "title": "`button`, `link`, and `menuitem` elements have accessible names",
      "score": 1
      // ...
    },
    "aria-hidden-body": {
      "title": "`[aria-hidden=\"true\"]` is not present on the document `<body>`",
      "score": 1
      // ...
    },
    "aria-hidden-focus": {
      "title": "`[aria-hidden=\"true\"]` elements do not contain focusable descendents",
      "score": 1
      // ...
    },
    // ...
  }

```

## Gathering metrics from a single audit [â€‹](https://docs.browserless.io/rest-apis/performance\#gathering-metrics-from-a-single-audit "Direct link to Gathering metrics from a single audit")

You can get any specific metrics [valid in Lighthouse](https://github.com/GoogleChrome/lighthouse/tree/master/core/audits)

- JSON payload
- cURL
- Javascript
- Python
- Java
- C#

```codeBlockLines_p187
{
  "url": "https://browserless.io",
  "config": {
    "extends": "lighthouse:default",
    "settings": {
      "onlyAudits": ["unminified-css"]
    }
  }
}

```

```codeBlockLines_p187
curl --request POST \
  --url 'https://production-sfo.browserless.io/performance?token=YOUR_API_TOKEN_HERE' \
  --header 'Cache-Control: no-cache' \
  --header 'Content-Type: application/json' \
  --data '{
  "url": "https://browserless.io",
  "config": {
    "extends": "lighthouse:default",
    "settings": {
      "onlyCategories": ["accessibility"]
    }
  }
}'

```

```codeBlockLines_p187
const TOKEN = "YOUR_API_TOKEN_HERE";
const url = `https://production-sfo.browserless.io/performance?token=${TOKEN}`;
const headers = {
  "Cache-Control": "no-cache",
  "Content-Type": "application/json"
};

const data = {
  url: "https://browserless.io",
  config: {
    extends: "lighthouse:default",
    settings: {
      onlyCategories: ["accessibility"]
    }
  }
};

const fetchPerformanceMetrics = async () => {
  const response = await fetch(url, {
    method: 'POST',
    headers: headers,
    body: JSON.stringify(data)
  });

  const result = await response.json();
  console.log(result);
};

fetchPerformanceMetrics();

```

```codeBlockLines_p187
import requests

TOKEN = "YOUR_API_TOKEN_HERE"
url = f"https://production-sfo.browserless.io/performance?token={TOKEN}"
headers = {
    "Cache-Control": "no-cache",
    "Content-Type": "application/json"
}

data = {
    "url": "https://browserless.io",
    "config": {
        "extends": "lighthouse:default",
        "settings": {
            "onlyCategories": ["accessibility"]
        }
    }
}

response = requests.post(url, headers=headers, json=data)
result = response.json()

print(result)

```

```codeBlockLines_p187
import java.io.*;
import java.net.URI;
import java.net.http.*;

public class FetchPerformanceWithConfig {
    public static void main(String[] args) {
        String TOKEN = "YOUR_API_TOKEN_HERE";
        String url = "https://production-sfo.browserless.io/performance?token=" + TOKEN;

        String jsonData = """
        {
            "url": "https://browserless.io",
            "config": {
                "extends": "lighthouse:default",
                "settings": {
                    "onlyCategories": ["accessibility"]
                }
            }
        }
        """;

        HttpClient client = HttpClient.newHttpClient();

        HttpRequest request = HttpRequest.newBuilder()
            .uri(URI.create(url))
            .header("Cache-Control", "no-cache")
            .header("Content-Type", "application/json")
            .POST(HttpRequest.BodyPublishers.ofString(jsonData))
            .build();

        try {
            HttpResponse<String> response = client.send(request, HttpResponse.BodyHandlers.ofString());
            System.out.println("Response: " + response.body());
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

```

```codeBlockLines_p187
using System;
using System.Net.Http;
using System.Text;
using System.Text.Json;
using System.Threading.Tasks;

class Program {
    static async Task Main(string[] args) {
        string TOKEN = "YOUR_API_TOKEN_HERE";
        string url = $"https://production-sfo.browserless.io/performance?token={TOKEN}";

        string jsonData = @"
        {
            ""url"": ""https://browserless.io"",
            ""config"": {
                ""extends"": ""lighthouse:default"",
                ""settings"": {
                    ""onlyCategories"": [""accessibility""]
                }
            }
        }";

        using var client = new HttpClient();
        var content = new StringContent(jsonData, Encoding.UTF8, "application/json");

        try {
            var response = await client.PostAsync(url, content);
            response.EnsureSuccessStatusCode();

            var result = await response.Content.ReadAsStringAsync();
            Console.WriteLine("Response: " + result);
        } catch (Exception ex) {
            Console.WriteLine($"Error: {ex.Message}");
        }
    }
}

```

**Response example**

```codeBlockLines_p187
  // ...
  "audits": {
    "unminified-css": {
      "title": "Minify CSS",
      "score": 1
      // ...
    },
    // ...
  }

```

- [Examples](https://docs.browserless.io/rest-apis/performance#examples)
- [Basic Usage](https://docs.browserless.io/rest-apis/performance#basic-usage)
- [Gathering metrics for a category](https://docs.browserless.io/rest-apis/performance#gathering-metrics-for-a-category)
- [Gathering metrics from a single audit](https://docs.browserless.io/rest-apis/performance#gathering-metrics-from-a-single-audit)

---

### /scrape API | Browserless.io
Original URL: https://docs.browserless.io/rest-apis/scrape

[Skip to main content](https://docs.browserless.io/rest-apis/scrape#__docusaurus_skipToContent_fallback)


BrowserQL

We recommended using [**BrowserQL**](https://docs.browserless.io/browserql/start), Browserless' first-class browser automation API, to scrape content from any website.

The /scrape API allows for getting the contents a page, by specifying selectors you are interested in, and returning a structured JSON response. We also allow for setting a timeout option for asynchronously added elements.

The default behavior is to navigate to the URL specified, wait for the page to load (including parsing and executing of JavaScript), then waiting for the elements for a maximum of 30 seconds. All of these are configurable, and documented in detail below.

At a minimum you'll need to specify at least a `url` and an `elements` array.

You can [check the full Open API schema here](https://docs.browserless.io/open-api#tag/Browser-REST-APIs/paths/~1chrome~1scrape/post).

## Basic Usage [â€‹](https://docs.browserless.io/rest-apis/scrape\#basic-usage "Direct link to Basic Usage")

Below is the most basic usage, where we'll navigate to the example.com website (waiting for page-load) and parse out all a elements.

Internally we use document.querySelectorAll to retrieve all matches on a page. Using a more specific selector can narrow down the returned results.

- JSON payload
- cURL
- Javascript
- Python
- Java
- C#

```codeBlockLines_p187
{
  "url": "https://browserless.io/",
  "elements": [\
    { "selector": "h1" }\
  ]
}

```

```codeBlockLines_p187
curl -X POST \
  https://production-sfo.browserless.io/scrape?token=YOUR_API_TOKEN_HERE \
  -H 'Cache-Control: no-cache' \
  -H 'Content-Type': 'application/json' \
  -d '{
  "url": "https://browserless.io/",
  "elements": [\
    { "selector": "h1" }\
  ]
}'

```

```codeBlockLines_p187
const TOKEN = "YOUR_API_TOKEN_HERE";
const url = `https://production-sfo.browserless.io/scrape?token=${TOKEN}`;
const headers = {
  "Cache-Control": "no-cache",
  "Content-Type": "application/json"
};

const data = {
  url: "https://browserless.io/",
  elements: [\
    { selector: "h1" }\
  ]
};

const scrapeContent = async () => {
  const response = await fetch(url, {
    method: 'POST',
    headers: headers,
    body: JSON.stringify(data)
  });

  const result = await response.json();
  console.log(result);
};

scrapeContent();

```

```codeBlockLines_p187
import requests

TOKEN = "YOUR_API_TOKEN_HERE"
url = f"https://production-sfo.browserless.io/scrape?token={TOKEN}"
headers = {
    "Cache-Control": "no-cache",
    "Content-Type": "application/json"
}

data = {
    "url": "https://browserless.io/",
    "elements": [\
        { "selector": "h1" }\
    ]
}

response = requests.post(url, headers=headers, json=data)
result = response.json()

print(result)

```

```codeBlockLines_p187
import java.io.*;
import java.net.URI;
import java.net.http.*;

public class ScrapeContent {
    public static void main(String[] args) {
        String TOKEN = "YOUR_API_TOKEN_HERE";
        String url = "https://production-sfo.browserless.io/scrape?token=" + TOKEN;

        String jsonData = """
        {
            "url": "https://browserless.io/",
            "elements": [\
                { "selector": "h1" }\
            ]
        }
        """;

        HttpClient client = HttpClient.newHttpClient();

        HttpRequest request = HttpRequest.newBuilder()
            .uri(URI.create(url))
            .header("Cache-Control", "no-cache")
            .header("Content-Type", "application/json")
            .POST(HttpRequest.BodyPublishers.ofString(jsonData))
            .build();

        try {
            HttpResponse<String> response = client.send(request, HttpResponse.BodyHandlers.ofString());
            System.out.println("Response: " + response.body());
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

```

```codeBlockLines_p187
using System;
using System.Net.Http;
using System.Text;
using System.Text.Json;
using System.Threading.Tasks;

class Program {
    static async Task Main(string[] args) {
        string TOKEN = "YOUR_API_TOKEN_HERE";
        string url = $"https://production-sfo.browserless.io/scrape?token={TOKEN}";

        string jsonData = @"
        {
            ""url"": ""https://browserless.io/"",
            ""elements"": [\
                { ""selector"": ""h1"" }\
            ]
        }";

        using var client = new HttpClient();
        var content = new StringContent(jsonData, Encoding.UTF8, "application/json");

        try {
            var response = await client.PostAsync(url, content);
            response.EnsureSuccessStatusCode();

            var result = await response.Content.ReadAsStringAsync();
            Console.WriteLine("Response: " + result);
        } catch (Exception ex) {
            Console.WriteLine($"Error: {ex.Message}");
        }
    }
}

```

**Response Example**

```codeBlockLines_p187
{
  "data": [\
    {\
      "results": [\
        {\
          "attributes": [\
            { "name": "class", "value": "..." }\
          ],\
          "height": 120,\
          "html": "Headless browser automation, without the hosting headaches",\
          "left": 32,\
          "text": "Headless browser automation, without the hosting headaches",\
          "top": 196,\
          "width": 736\
        }\
      ],\
      "selector": "h1"\
    }\
  ]
}

```

## Specifying page-load behavior [â€‹](https://docs.browserless.io/rest-apis/scrape\#specifying-page-load-behavior "Direct link to Specifying page-load behavior")

The scrape API allows for setting specific page-load behaviors by setting a `gotoOptions` in the JSON body. This is passed directly into [puppeteer's `goto()` method](https://pptr.dev/api/puppeteer.page.goto).

In the example below, we'll set a `waitUntil` property and a `timeout`.

- JSON payload
- cURL
- Javascript
- Python
- Java
- C#

```codeBlockLines_p187
{
  "url": "https://example.com/",
  "elements": [\
    { "selector": "h1" }\
  ],
  "gotoOptions": {
    "timeout": 10000,
    "waitUntil": "networkidle2"
  }
}

```

```codeBlockLines_p187
curl -X POST \
  https://production-sfo.browserless.io/scrape?token=YOUR_API_TOKEN_HERE \
  -H 'Cache-Control: no-cache' \
  -H 'Content-Type': 'application/json' \
  -d '{
  "url": "https://example.com/",
  "elements": [\
    { "selector": "h1" }\
  ],
  "gotoOptions": {
    "timeout": 10000,
    "waitUntil": "networkidle2"
  }
}'

```

```codeBlockLines_p187
const TOKEN = "YOUR_API_TOKEN_HERE";
const url = `https://production-sfo.browserless.io/scrape?token=${TOKEN}`;
const headers = {
  "Cache-Control": "no-cache",
  "Content-Type": "application/json"
};

const data = {
  url: "https://example.com/",
  elements: [\
    { selector: "h1" }\
  ],
  gotoOptions: {
    timeout: 10000,
    waitUntil: "networkidle2"
  }
};

const scrapeContent = async () => {
  const response = await fetch(url, {
    method: 'POST',
    headers: headers,
    body: JSON.stringify(data)
  });

  const result = await response.json();
  console.log(result);
};

scrapeContent();

```

```codeBlockLines_p187
import requests

TOKEN = "YOUR_API_TOKEN_HERE"
url = f"https://production-sfo.browserless.io/scrape?token={TOKEN}"
headers = {
    "Cache-Control": "no-cache",
    "Content-Type": "application/json"
}

data = {
    "url": "https://example.com/",
    "elements": [\
        { "selector": "h1" }\
    ],
    "gotoOptions": {
        "timeout": 10000,
        "waitUntil": "networkidle2"
    }
}

response = requests.post(url, headers=headers, json=data)
result = response.json()

print(result)

```

```codeBlockLines_p187
import java.io.*;
import java.net.URI;
import java.net.http.*;

public class ScrapeContentWithOptions {
    public static void main(String[] args) {
        String TOKEN = "YOUR_API_TOKEN_HERE";
        String url = "https://production-sfo.browserless.io/scrape?token=" + TOKEN;

        String jsonData = """
        {
            "url": "https://example.com/",
            "elements": [\
                { "selector": "h1" }\
            ],
            "gotoOptions": {
                "timeout": 10000,
                "waitUntil": "networkidle2"
            }
        }
        """;

        HttpClient client = HttpClient.newHttpClient();

        HttpRequest request = HttpRequest.newBuilder()
            .uri(URI.create(url))
            .header("Cache-Control", "no-cache")
            .header("Content-Type", "application/json")
            .POST(HttpRequest.BodyPublishers.ofString(jsonData))
            .build();

        try {
            HttpResponse<String> response = client.send(request, HttpResponse.BodyHandlers.ofString());
            System.out.println("Response: " + response.body());
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

```

```codeBlockLines_p187
using System;
using System.Net.Http;
using System.Text;
using System.Text.Json;
using System.Threading.Tasks;

class Program {
    static async Task Main(string[] args) {
        string TOKEN = "YOUR_API_TOKEN_HERE";
        string url = $"https://production-sfo.browserless.io/scrape?token={TOKEN}";

        string jsonData = @"
        {
            ""url"": ""https://example.com/"",
            ""elements"": [\
                { ""selector"": ""h1"" }\
            ],
            ""gotoOptions"": {
                ""timeout"": 10000,
                ""waitUntil"": ""networkidle2""
            }
        }";

        using var client = new HttpClient();
        var content = new StringContent(jsonData, Encoding.UTF8, "application/json");

        try {
            var response = await client.PostAsync(url, content);
            response.EnsureSuccessStatusCode();

            var result = await response.Content.ReadAsStringAsync();
            Console.WriteLine("Response: " + result);
        } catch (Exception ex) {
            Console.WriteLine($"Error: {ex.Message}");
        }
    }
}

```

## Custom behavior with `waitFor` options [â€‹](https://docs.browserless.io/rest-apis/scrape\#custom-behavior-with-waitfor-options "Direct link to custom-behavior-with-waitfor-options")

Sometimes it's helpful to do further actions, or wait for custom events on the page before getting data. We allow this behavior with the `waitFor` properties.

### waitForTimeout [â€‹](https://docs.browserless.io/rest-apis/scrape\#waitfortimeout "Direct link to waitForTimeout")

Waits for the given number of milliseconds before continue execution.

- JSON payload
- cURL
- Javascript
- Python
- Java
- C#

```codeBlockLines_p187
{
  "url": "https://example.com/",
  "elements": [\
    { "selector": "h1" }\
  ],
  "waitForTimeout": 1000,
}

```

```codeBlockLines_p187
curl -X POST \
  https://production-sfo.browserless.io/scrape?token=YOUR_API_TOKEN_HERE \
  -H 'Cache-Control: no-cache' \
  -H 'Content-Type': 'application/json' \
  -d '{
  "url": "https://example.com/",
  "elements": [\
    { "selector": "h1" }\
  ],
  "waitForTimeout": 1000
}'

```

```codeBlockLines_p187
const TOKEN = "YOUR_API_TOKEN_HERE";
const url = `https://production-sfo.browserless.io/scrape?token=${TOKEN}`;
const headers = {
  "Cache-Control": "no-cache",
  "Content-Type": "application/json"
};

const data = {
  url: "https://example.com/",
  elements: [\
    { selector: "h1" }\
  ],
  waitForTimeout: 1000
};

const scrapeContent = async () => {
  const response = await fetch(url, {
    method: 'POST',
    headers: headers,
    body: JSON.stringify(data)
  });

  const result = await response.json();
  console.log(result);
};

scrapeContent();

```

```codeBlockLines_p187
import requests

TOKEN = "YOUR_API_TOKEN_HERE"
url = f"https://production-sfo.browserless.io/scrape?token={TOKEN}"
headers = {
    "Cache-Control": "no-cache",
    "Content-Type": "application/json"
}

data = {
    "url": "https://example.com/",
    "elements": [\
        { "selector": "h1" }\
    ],
    "waitForTimeout": 1000
}

response = requests.post(url, headers=headers, json=data)
result = response.json()

print(result)

```

```codeBlockLines_p187
import java.io.*;
import java.net.URI;
import java.net.http.*;

public class ScrapeContentWithTimeout {
    public static void main(String[] args) {
        String TOKEN = "YOUR_API_TOKEN_HERE";
        String url = "https://production-sfo.browserless.io/scrape?token=" + TOKEN;

        String jsonData = """
        {
            "url": "https://example.com/",
            "elements": [\
                { "selector": "h1" }\
            ],
            "waitForTimeout": 1000
        }
        """;

        HttpClient client = HttpClient.newHttpClient();

        HttpRequest request = HttpRequest.newBuilder()
            .uri(URI.create(url))
            .header("Cache-Control", "no-cache")
            .header("Content-Type", "application/json")
            .POST(HttpRequest.BodyPublishers.ofString(jsonData))
            .build();

        try {
            HttpResponse<String> response = client.send(request, HttpResponse.BodyHandlers.ofString());
            System.out.println("Response: " + response.body());
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

```

```codeBlockLines_p187
using System;
using System.Net.Http;
using System.Text;
using System.Text.Json;
using System.Threading.Tasks;

class Program {
    static async Task Main(string[] args) {
        string TOKEN = "YOUR_API_TOKEN_HERE";
        string url = $"https://production-sfo.browserless.io/scrape?token={TOKEN}";

        string jsonData = @"
        {
            ""url"": ""https://example.com/"",
            ""elements"": [\
                { ""selector"": ""h1"" }\
            ],
            ""waitForTimeout"": 1000
        }";

        using var client = new HttpClient();
        var content = new StringContent(jsonData, Encoding.UTF8, "application/json");

        try {
            var response = await client.PostAsync(url, content);
            response.EnsureSuccessStatusCode();

            var result = await response.Content.ReadAsStringAsync();
            Console.WriteLine("Response: " + result);
        } catch (Exception ex) {
            Console.WriteLine($"Error: {ex.Message}");
        }
    }
}

```

### waitForSelector [â€‹](https://docs.browserless.io/rest-apis/scrape\#waitforselector "Direct link to waitForSelector")

Wait for a selector to appear in page. If at the moment of calling the method the selector already exists, the method will return immediately. If the selector doesn't appear after the timeout milliseconds of waiting, the function will throw an exception.

#### Example [â€‹](https://docs.browserless.io/rest-apis/scrape\#example "Direct link to Example")

- JSON payload
- cURL
- Javascript
- Python
- Java
- C#

```codeBlockLines_p187
{
  "url": "https://example.com/",
  "elements": [\
    { "selector": "h1" }\
  ],
  "waitForSelector": {
    "selector": "h1",
    "timeout": 5000
  }
}

```

```codeBlockLines_p187
curl -X POST \
  https://production-sfo.browserless.io/scrape?token=YOUR_API_TOKEN_HERE \
  -H 'Cache-Control: no-cache' \
  -H 'Content-Type': 'application/json' \
  -d '{
  "url": "https://example.com/",
  "elements": [\
    { "selector": "h1" }\
  ],
  "waitForSelector": {
    "selector": "h1",
    "timeout": 5000
  }
}'

```

```codeBlockLines_p187
const TOKEN = "YOUR_API_TOKEN_HERE";
const url = `https://production-sfo.browserless.io/scrape?token=${TOKEN}`;
const headers = {
  "Cache-Control": "no-cache",
  "Content-Type": "application/json"
};

const data = {
  url: "https://example.com/",
  elements: [\
    { selector: "h1" }\
  ],
  waitForSelector: {
    selector: "h1",
    timeout: 5000
  }
};

const scrapeContent = async () => {
  const response = await fetch(url, {
    method: 'POST',
    headers: headers,
    body: JSON.stringify(data)
  });

  const result = await response.json();
  console.log(result);
};

scrapeContent();

```

```codeBlockLines_p187
import requests

TOKEN = "YOUR_API_TOKEN_HERE"
url = f"https://production-sfo.browserless.io/scrape?token={TOKEN}"
headers = {
    "Cache-Control": "no-cache",
    "Content-Type": "application/json"
}

data = {
    "url": "https://example.com/",
    "elements": [\
        { "selector": "h1" }\
    ],
    "waitForSelector": {
        "selector": "h1",
        "timeout": 5000
    }
}

response = requests.post(url, headers=headers, json=data)
result = response.json()

print(result)

```

```codeBlockLines_p187
import java.io.*;
import java.net.URI;
import java.net.http.*;

public class ScrapeContentWithWaitForSelector {
    public static void main(String[] args) {
        String TOKEN = "YOUR_API_TOKEN_HERE";
        String url = "https://production-sfo.browserless.io/scrape?token=" + TOKEN;

        String jsonData = """
        {
            "url": "https://example.com/",
            "elements": [\
                { "selector": "h1" }\
            ],
            "waitForSelector": {
                "selector": "h1",
                "timeout": 5000
            }
        }
        """;

        HttpClient client = HttpClient.newHttpClient();

        HttpRequest request = HttpRequest.newBuilder()
            .uri(URI.create(url))
            .header("Cache-Control", "no-cache")
            .header("Content-Type", "application/json")
            .POST(HttpRequest.BodyPublishers.ofString(jsonData))
            .build();

        try {
            HttpResponse<String> response = client.send(request, HttpResponse.BodyHandlers.ofString());
            System.out.println("Response: " + response.body());
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

```

```codeBlockLines_p187
using System;
using System.Net.Http;
using System.Text;
using System.Text.Json;
using System.Threading.Tasks;

class Program {
    static async Task Main(string[] args) {
        string TOKEN = "YOUR_API_TOKEN_HERE";
        string url = $"https://production-sfo.browserless.io/scrape?token={TOKEN}";

        string jsonData = @"
        {
            ""url"": ""https://example.com/"",
            ""elements"": [\
                { ""selector"": ""h1"" }\
            ],
            ""waitForSelector"": {
                ""selector"": ""h1"",
                ""timeout"": 5000
            }
        }";

        using var client = new HttpClient();
        var content = new StringContent(jsonData, Encoding.UTF8, "application/json");

        try {
            var response = await client.PostAsync(url, content);
            response.EnsureSuccessStatusCode();

            var result = await response.Content.ReadAsStringAsync();
            Console.WriteLine("Response: " + result);
        } catch (Exception ex) {
            Console.WriteLine($"Error: {ex.Message}");
        }
    }
}

```

### waitForFunction [â€‹](https://docs.browserless.io/rest-apis/scrape\#waitforfunction "Direct link to waitForFunction")

Waits for the provided function to return before cotinue. The function can be any valid JS function, including `async` functions.

#### Example [â€‹](https://docs.browserless.io/rest-apis/scrape\#example-1 "Direct link to Example")

**JS function**

```codeBlockLines_p187
async () => {
  const res = await fetch('https://jsonplaceholder.typicode.com/todos/1');
  const json = await res.json();

  document.querySelector("h1").innerText = json.title;
}

```

- JSON payload
- cURL
- Javascript
- Python
- Java
- C#

```codeBlockLines_p187
{
  "url": "https://example.com/",
  "elements": [\
    { "selector": "h1" }\
  ],
  "waitForFunction": {
    "fn": "async()=>{let t=await fetch('https://jsonplaceholder.typicode.com/todos/1'),e=await t.json();document.querySelector('h1').innerText=e.title}",
    "timeout": 5000
  }
}

```

```codeBlockLines_p187
curl -X POST \
  https://production-sfo.browserless.io/scrape?token=YOUR_API_TOKEN_HERE \
  -H 'Cache-Control: no-cache' \
  -H 'Content-Type': 'application/json' \
  -d '{
  "url": "https://example.com/",
  "waitForFunction": {
    "fn": "async()=>{let t=await fetch('https://jsonplaceholder.typicode.com/todos/1'),e=await t.json();document.querySelector('h1').innerText=e.title}",
    "timeout": 5000
  }
}'

```

```codeBlockLines_p187
const TOKEN = "YOUR_API_TOKEN_HERE";
const url = `https://production-sfo.browserless.io/scrape?token=${TOKEN}`;
const headers = {
  "Cache-Control": "no-cache",
  "Content-Type": "application/json"
};

const data = {
  url: "https://example.com/",
  waitForFunction: {
    fn: "async()=>{let t=await fetch('https://jsonplaceholder.typicode.com/todos/1'),e=await t.json();document.querySelector('h1').innerText=e.title}",
    timeout: 5000
  }
};

const scrapeContent = async () => {
  const response = await fetch(url, {
    method: 'POST',
    headers: headers,
    body: JSON.stringify(data)
  });

  const result = await response.json();
  console.log(result);
};

scrapeContent();

```

```codeBlockLines_p187
import requests

TOKEN = "YOUR_API_TOKEN_HERE"
url = f"https://production-sfo.browserless.io/scrape?token={TOKEN}"
headers = {
    "Cache-Control": "no-cache",
    "Content-Type": "application/json"
}

data = {
    "url": "https://example.com/",
    "waitForFunction": {
        "fn": "async()=>{let t=await fetch('https://jsonplaceholder.typicode.com/todos/1'),e=await t.json();document.querySelector('h1').innerText=e.title}",
        "timeout": 5000
    }
}

response = requests.post(url, headers=headers, json=data)
result = response.json()

print(result)

```

```codeBlockLines_p187
import java.io.*;
import java.net.URI;
import java.net.http.*;

public class ScrapeContentWithWaitForFunction {
    public static void main(String[] args) {
        String TOKEN = "YOUR_API_TOKEN_HERE";
        String url = "https://production-sfo.browserless.io/scrape?token=" + TOKEN;

        String jsonData = """
        {
            "url": "https://example.com/",
            "waitForFunction": {
                "fn": "async()=>{let t=await fetch('https://jsonplaceholder.typicode.com/todos/1'),e=await t.json();document.querySelector('h1').innerText=e.title}",
                "timeout": 5000
            }
        }
        """;

        HttpClient client = HttpClient.newHttpClient();

        HttpRequest request = HttpRequest.newBuilder()
            .uri(URI.create(url))
            .header("Cache-Control", "no-cache")
            .header("Content-Type", "application/json")
            .POST(HttpRequest.BodyPublishers.ofString(jsonData))
            .build();

        try {
            HttpResponse<String> response = client.send(request, HttpResponse.BodyHandlers.ofString());
            System.out.println("Response: " + response.body());
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

```

```codeBlockLines_p187
using System;
using System.Net.Http;
using System.Text;
using System.Text.Json;
using System.Threading.Tasks;

class Program {
    static async Task Main(string[] args) {
        string TOKEN = "YOUR_API_TOKEN_HERE";
        string url = $"https://production-sfo.browserless.io/scrape?token={TOKEN}";

        string jsonData = @"
        {
            ""url"": ""https://example.com/"",
            ""waitForFunction"": {
                ""fn"": ""async()=>{let t=await fetch('https://jsonplaceholder.typicode.com/todos/1'),e=await t.json();document.querySelector('h1').innerText=e.title}"",
                ""timeout"": 5000
            }
        }";

        using var client = new HttpClient();
        var content = new StringContent(jsonData, Encoding.UTF8, "application/json");

        try {
            var response = await client.PostAsync(url, content);
            response.EnsureSuccessStatusCode();

            var result = await response.Content.ReadAsStringAsync();
            Console.WriteLine("Response: " + result);
        } catch (Exception ex) {
            Console.WriteLine($"Error: {ex.Message}");
        }
    }
}

```

### waitForEvent [â€‹](https://docs.browserless.io/rest-apis/scrape\#waitforevent "Direct link to waitForEvent")

Waits for an event to happen on the page before cotinue.

#### Example [â€‹](https://docs.browserless.io/rest-apis/scrape\#example-2 "Direct link to Example")

- JSON payload
- cURL
- Javascript
- Python
- Java
- C#

```codeBlockLines_p187
// Will fail since the event never fires
{
  "url": "https://example.com/",
  "elements": [\
    { "selector": "h1" }\
  ],
  "waitForEvent": {
    "event": "fullscreenchange",
    "timeout": 5000
  }
}

```

```codeBlockLines_p187
curl -X POST \
  https://production-sfo.browserless.io/content?token=YOUR_API_TOKEN_HERE \
  -H 'Cache-Control: no-cache' \
  -H 'Content-Type': 'application/json' \
  -d '{
  "url": "https://example.com/",
  "elements": [\
    { "selector": "h1" }\
  ],
  "waitForEvent": {
    "event": "fullscreenchange",
    "timeout": 5000
  }
}'

```

```codeBlockLines_p187
const TOKEN = "YOUR_API_TOKEN_HERE";
const url = `https://production-sfo.browserless.io/content?token=${TOKEN}`;
const headers = {
  "Cache-Control": "no-cache",
  "Content-Type": "application/json"
};

const data = {
  url: "https://example.com/",
  elements: [\
    { selector: "h1" }\
  ],
  waitForEvent: {
    event: "fullscreenchange",
    timeout: 5000
  }
};

const fetchContent = async () => {
  const response = await fetch(url, {
    method: 'POST',
    headers: headers,
    body: JSON.stringify(data)
  });

  const result = await response.json();
  console.log(result);
};

fetchContent();

```

```codeBlockLines_p187
import requests

TOKEN = "YOUR_API_TOKEN_HERE"
url = f"https://production-sfo.browserless.io/content?token={TOKEN}"
headers = {
    "Cache-Control": "no-cache",
    "Content-Type": "application/json"
}

data = {
    "url": "https://example.com/",
    "elements": [\
        { "selector": "h1" }\
    ],
    "waitForEvent": {
        "event": "fullscreenchange",
        "timeout": 5000
    }
}

response = requests.post(url, headers=headers, json=data)
result = response.json()

print(result)

```

```codeBlockLines_p187
import java.io.*;
import java.net.URI;
import java.net.http.*;

public class FetchContentWithWaitForEvent {
    public static void main(String[] args) {
        String TOKEN = "YOUR_API_TOKEN_HERE";
        String url = "https://production-sfo.browserless.io/content?token=" + TOKEN;

        String jsonData = """
        {
            "url": "https://example.com/",
            "elements": [\
                { "selector": "h1" }\
            ],
            "waitForEvent": {
                "event": "fullscreenchange",
                "timeout": 5000
            }
        }
        """;

        HttpClient client = HttpClient.newHttpClient();

        HttpRequest request = HttpRequest.newBuilder()
            .uri(URI.create(url))
            .header("Cache-Control", "no-cache")
            .header("Content-Type", "application/json")
            .POST(HttpRequest.BodyPublishers.ofString(jsonData))
            .build();

        try {
            HttpResponse<String> response = client.send(request, HttpResponse.BodyHandlers.ofString());
            System.out.println("Response: " + response.body());
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

```

```codeBlockLines_p187
using System;
using System.Net.Http;
using System.Text;
using System.Text.Json;
using System.Threading.Tasks;

class Program {
    static async Task Main(string[] args) {
        string TOKEN = "YOUR_API_TOKEN_HERE";
        string url = $"https://production-sfo.browserless.io/content?token={TOKEN}";

        string jsonData = @"
        {
            ""url"": ""https://example.com/"",
            ""elements"": [\
                { ""selector"": ""h1"" }\
            ],
            ""waitForEvent"": {
                ""event"": ""fullscreenchange"",
                ""timeout"": 5000
            }
        }";

        using var client = new HttpClient();
        var content = new StringContent(jsonData, Encoding.UTF8, "application/json");

        try {
            var response = await client.PostAsync(url, content);
            response.EnsureSuccessStatusCode();

            var result = await response.Content.ReadAsStringAsync();
            Console.WriteLine("Response: " + result);
        } catch (Exception ex) {
            Console.WriteLine($"Error: {ex.Message}");
        }
    }
}

```

- [Basic Usage](https://docs.browserless.io/rest-apis/scrape#basic-usage)
- [Specifying page-load behavior](https://docs.browserless.io/rest-apis/scrape#specifying-page-load-behavior)
- [Custom behavior with `waitFor` options](https://docs.browserless.io/rest-apis/scrape#custom-behavior-with-waitfor-options)
  - [waitForTimeout](https://docs.browserless.io/rest-apis/scrape#waitfortimeout)
  - [waitForSelector](https://docs.browserless.io/rest-apis/scrape#waitforselector)
  - [waitForFunction](https://docs.browserless.io/rest-apis/scrape#waitforfunction)
  - [waitForEvent](https://docs.browserless.io/rest-apis/scrape#waitforevent)

---

### /screenshot API | Browserless.io
Original URL: https://docs.browserless.io/rest-apis/screenshot

[Skip to main content](https://docs.browserless.io/rest-apis/screenshot#__docusaurus_skipToContent_fallback)


The screenshot API allows for simple navigation to a site and capturing a screenshot. browserless will respond with either a binary or base64 encode of a `png` or `jpg` (depending on parameters). This API exposes most of puppeteer's screenshot API through the posted JSON payload.

You can [view the complete Screenshot API OpenAPI specification](https://docs.browserless.io/open-api#tag/Browser-REST-APIs/paths/~1chrome~1screenshot/post).

bot detection

If the /screenshot API is getting blocked by bot detectors, then we would recommend trying [**BrowserQL GraphQL API**](https://docs.browserless.io/browserql/start).

## Basic Usage [â€‹](https://docs.browserless.io/rest-apis/screenshot\#basic-usage "Direct link to Basic Usage")

- JSON payload
- cURL
- Javascript
- Python
- Java
- C#

```codeBlockLines_p187
// JSON body
// `options` are the options available via puppeteer's Page.screenshot() method
// (see https://pptr.dev/api/puppeteer.screenshotoptions)
{
  "url": "https://example.com/",
  "options": {
    "fullPage": true,
    "type": "png"
    // Queue the lack of a `path` parameter
  }
}

```

```codeBlockLines_p187
curl -X POST \
  https://production-sfo.browserless.io/screenshot?token=YOUR_API_TOKEN_HERE \
  -H 'Cache-Control: no-cache' \
  -H 'Content-Type: application/json' \
  -d '{
  "url": "https://example.com/",
  "options": {
    "fullPage": true,
    "type": "png"
  }
}' \
  --output "screenshot.png"

```

```codeBlockLines_p187
import fs from 'fs/promises';

const TOKEN = "YOUR_API_TOKEN_HERE";
const url = `https://production-sfo.browserless.io/screenshot?token=${TOKEN}`;
const headers = {
  "Cache-Control": "no-cache",
  "Content-Type": "application/json"
};

const data = {
  url: "https://example.com/",
  options: {
    fullPage: true,
    type: "png"
  }
};

const takeScreenshot = async () => {
  const response = await fetch(url, {
    method: 'POST',
    headers: headers,
    body: JSON.stringify(data)
  });

  const imageBuffer = await response.arrayBuffer();
  await fs.writeFile("screenshot.png", Buffer.from(imageBuffer));
  console.log("Screenshot saved as screenshot.png");
};

takeScreenshot();

```

```codeBlockLines_p187
import requests

TOKEN = "YOUR_API_TOKEN_HERE"
url = f"https://production-sfo.browserless.io/screenshot?token={TOKEN}"
headers = {
    "Cache-Control": "no-cache",
    "Content-Type": "application/json"
}

data = {
    "url": "https://example.com/",
    "options": {
        "fullPage": True,
        "type": "png"
    }
}

response = requests.post(url, headers=headers, json=data)

with open("screenshot.png", "wb") as file:
    file.write(response.content)

print("Screenshot saved as screenshot.png")

```

```codeBlockLines_p187
import java.io.*;
import java.net.URI;
import java.net.http.*;
import java.nio.file.*;

public class TakeScreenshot {
    public static void main(String[] args) {
        String TOKEN = "YOUR_API_TOKEN_HERE";
        String url = "https://production-sfo.browserless.io/screenshot?token=" + TOKEN;

        String jsonData = """
        {
            "url": "https://example.com/",
            "options": {
                "fullPage": true,
                "type": "png"
            }
        }
        """;

        HttpClient client = HttpClient.newHttpClient();

        HttpRequest request = HttpRequest.newBuilder()
            .uri(URI.create(url))
            .header("Cache-Control", "no-cache")
            .header("Content-Type", "application/json")
            .POST(HttpRequest.BodyPublishers.ofString(jsonData))
            .build();

        try {
            HttpResponse<InputStream> response = client.send(request, HttpResponse.BodyHandlers.ofInputStream());
            Files.copy(response.body(), Paths.get("screenshot.png"), StandardCopyOption.REPLACE_EXISTING);
            System.out.println("Screenshot saved as screenshot.png");
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

```

```codeBlockLines_p187
using System;
using System.IO;
using System.Net.Http;
using System.Text;
using System.Threading.Tasks;

class Program
{
    static async Task Main(string[] args)
    {
        string TOKEN = "YOUR_API_TOKEN_HERE";
        string url = $"https://production-sfo.browserless.io/screenshot?token={TOKEN}";

        string jsonData = @"
        {
            ""url"": ""https://example.com/"",
            ""options"": {
                ""fullPage"": true,
                ""type"": ""png""
            }
        }";

        using var client = new HttpClient();


        var request = new HttpRequestMessage(HttpMethod.Post, url)
        {
            Content = new StringContent(jsonData, Encoding.UTF8, "application/json")
        };


        request.Headers.Add("Cache-Control", "no-cache");

        try
        {
            var response = await client.SendAsync(request);
            response.EnsureSuccessStatusCode();

            var imageBytes = await response.Content.ReadAsByteArrayAsync();

            await File.WriteAllBytesAsync("screenshot.png", imageBytes);

            Console.WriteLine("Screenshot saved as screenshot.png");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error: {ex.Message}");
        }
    }
}

```

## Setting HTML content [â€‹](https://docs.browserless.io/rest-apis/screenshot\#setting-html-content "Direct link to Setting HTML content")

You can set the HTML content of the page to render dynamically generated content.

danger

**When this propriety is set, the `url` propriety must not be present.**

- JSON payload
- cURL
- Javascript
- Python
- Java
- C#

```codeBlockLines_p187
// JSON body
// `options` are the options available via puppeteer's Page.screenshot() method
// (see our Open API documentation)
{
  "url": "https://example.com/",
  "options": {
    "type": "webp",
    "omitBackground": true
  }
}

```

```codeBlockLines_p187
curl -X POST \
  https://production-sfo.browserless.io/screenshot?token=YOUR_API_TOKEN_HERE \
  -H 'Cache-Control: no-cache' \
  -H 'Content-Type: application/json' \
  -d '{
  "url": "https://example.com/",
  "options": {
    "type": "webp",
    "omitBackground": true
  }
}' \
  --output "screenshot.webp"

```

```codeBlockLines_p187
import fs from 'fs/promises';

const TOKEN = "YOUR_API_TOKEN_HERE";
const url = `https://production-sfo.browserless.io/screenshot?token=${TOKEN}`;
const headers = {
  "Cache-Control": "no-cache",
  "Content-Type": "application/json"
};

const data = {
  url: "https://example.com/",
  options: {
    type: "webp",
    omitBackground: true
  }
};

const takeScreenshot = async () => {
  const response = await fetch(url, {
    method: 'POST',
    headers: headers,
    body: JSON.stringify(data)
  });

  const imageBuffer = await response.arrayBuffer();
  await fs.writeFile("screenshot.webp", Buffer.from(imageBuffer));
  console.log("Screenshot saved as screenshot.webp");
};

takeScreenshot();

```

```codeBlockLines_p187
import requests

TOKEN = "YOUR_API_TOKEN_HERE"
url = f"https://production-sfo.browserless.io/screenshot?token={TOKEN}"
headers = {
    "Cache-Control": "no-cache",
    "Content-Type": "application/json"
}

data = {
    "url": "https://example.com/",
    "options": {
        "type": "webp",
        "omitBackground": True
    }
}

response = requests.post(url, headers=headers, json=data)

with open("screenshot.webp", "wb") as file:
    file.write(response.content)

print("Screenshot saved as screenshot.webp")

```

```codeBlockLines_p187
import java.io.*;
import java.net.URI;
import java.net.http.*;
import java.nio.file.*;

public class TakeWebpScreenshot {
    public static void main(String[] args) {
        String TOKEN = "YOUR_API_TOKEN_HERE";
        String url = "https://production-sfo.browserless.io/screenshot?token=" + TOKEN;

        String jsonData = """
        {
            "url": "https://example.com/",
            "options": {
                "type": "webp",
                "omitBackground": true
            }
        }
        """;

        HttpClient client = HttpClient.newHttpClient();

        HttpRequest request = HttpRequest.newBuilder()
            .uri(URI.create(url))
            .header("Cache-Control", "no-cache")
            .header("Content-Type", "application/json")
            .POST(HttpRequest.BodyPublishers.ofString(jsonData))
            .build();

        try {
            HttpResponse<InputStream> response = client.send(request, HttpResponse.BodyHandlers.ofInputStream());
            Files.copy(response.body(), Paths.get("screenshot.webp"), StandardCopyOption.REPLACE_EXISTING);
            System.out.println("Screenshot saved as screenshot.webp");
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

```

```codeBlockLines_p187
using System;
using System.IO;
using System.Net.Http;
using System.Text;
using System.Threading.Tasks;

class Program
{
    static async Task Main(string[] args)
    {
        string TOKEN = "YOUR_API_TOKEN_HERE";
        string url = $"https://production-sfo.browserless.io/screenshot?token={TOKEN}";

        string jsonData = @"
          {
              ""url"": ""https://example.com/"",
              ""options"": {
                  ""type"": ""webp"",
                  ""omitBackground"": true
              }
          }";

        using var client = new HttpClient();


        var request = new HttpRequestMessage(HttpMethod.Post, url)
        {
            Content = new StringContent(jsonData, Encoding.UTF8, "application/json")
        };


        request.Headers.Add("Cache-Control", "no-cache");

        try
        {
            var response = await client.SendAsync(request);
            response.EnsureSuccessStatusCode();

            var imageBytes = await response.Content.ReadAsByteArrayAsync();

            await File.WriteAllBytesAsync("screenshot.png", imageBytes);

            Console.WriteLine("Screenshot saved as screenshot.png");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error: {ex.Message}");
        }
    }
}

```

warning

We do not allow to set a `options.path`

## Adding custom styles and scripts [â€‹](https://docs.browserless.io/rest-apis/screenshot\#adding-custom-styles-and-scripts "Direct link to Adding custom styles and scripts")

Browserless offers ways to load additional stylesheets and script tags to the page.

- JSON payload
- cURL
- Javascript
- Python
- Java
- C#

```codeBlockLines_p187
{
  "url": "https://example.com/",
  "addScriptTag": [\
    { "url": "https://code.jquery.com/jquery-3.7.1.min.js" },\
    { "content": "document.querySelector(`h1`).innerText = `Hello Word!`" }\
  ],
  "addStyleTag": [\
    {\
      "content": "body { height: 100vh;  background: linear-gradient(45deg, #da5a44, #a32784);}"\
    },\
    {\
      "url": "https://interactive-examples.mdn.mozilla.net/live-examples/css-examples/text-decoration/text-decoration-color.css"\
    }\
  ]
}

```

```codeBlockLines_p187
curl -X POST \
  https://production-sfo.browserless.io/screenshot?token=YOUR_API_TOKEN_HERE \
  -H 'Cache-Control: no-cache' \
  -H 'Content-Type': 'application/json' \
  -d '{
  "url": "https://example.com/",
  "addScriptTag": [\
    { "url": "https://code.jquery.com/jquery-3.7.1.min.js" },\
    { "content": "document.querySelector(`h1`).innerText = `Hello Word!`" }\
  ],
  "addStyleTag": [\
    {\
      "content": "body { height: 100vh; background: linear-gradient(45deg, #da5a44, #a32784); }"\
    },\
    {\
      "url": "https://interactive-examples.mdn.mozilla.net/live-examples/css-examples/text-decoration/text-decoration-color.css"\
    }\
  ]
}' \
  --output "screenshot.png"

```

```codeBlockLines_p187
import fs from 'fs/promises';

const TOKEN = "YOUR_API_TOKEN_HERE";
const url = `https://production-sfo.browserless.io/screenshot?token=${TOKEN}`;
const headers = {
  "Cache-Control": "no-cache",
  "Content-Type": "application/json"
};

const data = {
  url: "https://example.com/",
  addScriptTag: [\
    { url: "https://code.jquery.com/jquery-3.7.1.min.js" },\
    { content: "document.querySelector(`h1`).innerText = `Hello Word!`" }\
  ],
  addStyleTag: [\
    {\
      content: "body { height: 100vh; background: linear-gradient(45deg, #da5a44, #a32784); }"\
    },\
    {\
      url: "https://interactive-examples.mdn.mozilla.net/live-examples/css-examples/text-decoration/text-decoration-color.css"\
    }\
  ]
};

const takeScreenshot = async () => {
  const response = await fetch(url, {
    method: 'POST',
    headers: headers,
    body: JSON.stringify(data)
  });

  const imageBuffer = await response.arrayBuffer();
  await fs.writeFile("screenshot.png", Buffer.from(imageBuffer));
  console.log("Screenshot saved as screenshot.png");
};

takeScreenshot();

```

```codeBlockLines_p187
import requests

TOKEN = "YOUR_API_TOKEN_HERE"
url = f"https://production-sfo.browserless.io/screenshot?token={TOKEN}"
headers = {
    "Cache-Control": "no-cache",
    "Content-Type": "application/json"
}

data = {
    "url": "https://example.com/",
    "addScriptTag": [\
        { "url": "https://code.jquery.com/jquery-3.7.1.min.js" },\
        { "content": "document.querySelector(`h1`).innerText = `Hello Word!`" }\
    ],
    "addStyleTag": [\
        {\
            "content": "body { height: 100vh; background: linear-gradient(45deg, #da5a44, #a32784); }"\
        },\
        {\
            "url": "https://interactive-examples.mdn.mozilla.net/live-examples/css-examples/text-decoration/text-decoration-color.css"\
        }\
    ]
}

response = requests.post(url, headers=headers, json=data)

with open("screenshot.png", "wb") as file:
    file.write(response.content)

print("Screenshot saved as screenshot.png")

```

```codeBlockLines_p187
import java.io.*;
import java.net.URI;
import java.net.http.*;
import java.nio.file.*;

public class TakeStyledScreenshot {
    public static void main(String[] args) {
        String TOKEN = "YOUR_API_TOKEN_HERE";
        String url = "https://production-sfo.browserless.io/screenshot?token=" + TOKEN;

        String jsonData = """
        {
            "url": "https://example.com/",
            "addScriptTag": [\
                { "url": "https://code.jquery.com/jquery-3.7.1.min.js" },\
                { "content": "document.querySelector(`h1`).innerText = `Hello Word!`" }\
            ],
            "addStyleTag": [\
                {\
                    "content": "body { height: 100vh; background: linear-gradient(45deg, #da5a44, #a32784); }"\
                },\
                {\
                    "url": "https://interactive-examples.mdn.mozilla.net/live-examples/css-examples/text-decoration/text-decoration-color.css"\
                }\
            ]
        }
        """;

        HttpClient client = HttpClient.newHttpClient();

        HttpRequest request = HttpRequest.newBuilder()
            .uri(URI.create(url))
            .header("Cache-Control", "no-cache")
            .header("Content-Type", "application/json")
            .POST(HttpRequest.BodyPublishers.ofString(jsonData))
            .build();

        try {
            HttpResponse<InputStream> response = client.send(request, HttpResponse.BodyHandlers.ofInputStream());
            Files.copy(response.body(), Paths.get("screenshot.png"), StandardCopyOption.REPLACE_EXISTING);
            System.out.println("Screenshot saved as screenshot.png");
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

```

```codeBlockLines_p187
  using System;
  using System.IO;
  using System.Net.Http;
  using System.Text;
  using System.Threading.Tasks;

  class Program
  {
      static async Task Main(string[] args)
      {
          string TOKEN = "YOUR_API_TOKEN_HERE";
          string url = $"https://production-sfo.browserless.io/screenshot?token={TOKEN}";

          string jsonData = @"
            {
                ""url"": ""https://example.com/"",
                ""addScriptTag"": [\
                    { ""url"": ""https://code.jquery.com/jquery-3.7.1.min.js"" },\
                    { ""content"": ""document.querySelector(`h1`).innerText = `Hello Word!`"" }\
                ],
                ""addStyleTag"": [\
                    {\
                        ""content"": ""body { height: 100vh; background: linear-gradient(45deg, #da5a44, #a32784); }""\
                    },\
                    {\
                        ""url"": ""https://interactive-examples.mdn.mozilla.net/live-examples/css-examples/text-decoration/text-decoration-color.css""\
                    }\
                ]
            }";

          using var client = new HttpClient();


          var request = new HttpRequestMessage(HttpMethod.Post, url)
          {
              Content = new StringContent(jsonData, Encoding.UTF8, "application/json")
          };


          request.Headers.Add("Cache-Control", "no-cache");

          try
          {
              var response = await client.SendAsync(request);
              response.EnsureSuccessStatusCode();

              var imageBytes = await response.Content.ReadAsByteArrayAsync();

              await File.WriteAllBytesAsync("screenshot.png", imageBytes);

              Console.WriteLine("Screenshot saved as screenshot.png");
          }
          catch (Exception ex)
          {
              Console.WriteLine($"Error: {ex.Message}");
          }
      }
  }

```

## Rejecting Undesired Requests [â€‹](https://docs.browserless.io/rest-apis/screenshot\#rejecting-undesired-requests "Direct link to Rejecting Undesired Requests")

You can use `rejectResourceTypes` and `rejectRequestPattern` to block undesired content, resources and requests.

- JSON payload
- cURL
- Javascript
- Python
- Java
- C#

```codeBlockLines_p187
// Will reject any images and .css files
{
  "url": "https://browserless.io/"
  "rejectResourceTypes": ["image"],
  "rejectRequestPattern": ["/^.*\\.(css)"]
}

```

```codeBlockLines_p187
curl -X POST \
  https://production-sfo.browserless.io/screenshot?token=YOUR_API_TOKEN_HERE \
  -H 'Cache-Control: no-cache' \
  -H 'Content-Type: application/json' \
  -d '{
  "url": "https://browserless.io/",
  "rejectResourceTypes": ["image"],
  "rejectRequestPattern": ["/^.*\\.(css)"]
}' \
  --output "screenshot.png"

```

```codeBlockLines_p187
import fs from 'fs/promises';

const TOKEN = "YOUR_API_TOKEN_HERE";
const url = `https://production-sfo.browserless.io/screenshot?token=${TOKEN}`;
const headers = {
  "Cache-Control": "no-cache",
  "Content-Type": "application/json"
};

const data = {
  url: "https://browserless.io/",
  rejectResourceTypes: ["image"],
  rejectRequestPattern: ["^.*\\.(css)"]
};

const takeScreenshot = async () => {
  const response = await fetch(url, {
    method: 'POST',
    headers: headers,
    body: JSON.stringify(data)
  });

  const imageBuffer = await response.arrayBuffer();
  await fs.writeFile("screenshot.png", Buffer.from(imageBuffer));
  console.log("Screenshot saved as screenshot.png");
};

takeScreenshot();

```

```codeBlockLines_p187
import requests

TOKEN = "YOUR_API_TOKEN_HERE"
url = f"https://production-sfo.browserless.io/screenshot?token={TOKEN}"
headers = {
    "Cache-Control": "no-cache",
    "Content-Type": "application/json"
}

data = {
    "url": "https://browserless.io/",
    "rejectResourceTypes": ["image"],
    "rejectRequestPattern": ["^.*\\.(css)"]
}

response = requests.post(url, headers=headers, json=data)

with open("screenshot.png", "wb") as file:
    file.write(response.content)

print("Screenshot saved as screenshot.png")

```

```codeBlockLines_p187
import java.io.*;
import java.net.URI;
import java.net.http.*;
import java.nio.file.*;

public class TakeScreenshotWithRejections {
    public static void main(String[] args) {
        String TOKEN = "YOUR_API_TOKEN_HERE";
        String url = "https://production-sfo.browserless.io/screenshot?token=" + TOKEN;

        String jsonData = """
        {
            "url": "https://browserless.io/",
            "rejectResourceTypes": ["image"],
            "rejectRequestPattern": ["^.*\\\\.(css)"]
        }
        """;

        HttpClient client = HttpClient.newHttpClient();

        HttpRequest request = HttpRequest.newBuilder()
            .uri(URI.create(url))
            .header("Cache-Control", "no-cache")
            .header("Content-Type", "application/json")
            .POST(HttpRequest.BodyPublishers.ofString(jsonData))
            .build();

        try {
            HttpResponse<InputStream> response = client.send(request, HttpResponse.BodyHandlers.ofInputStream());
            Files.copy(response.body(), Paths.get("screenshot.png"), StandardCopyOption.REPLACE_EXISTING);
            System.out.println("Screenshot saved as screenshot.png");
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

```

```codeBlockLines_p187
  using System;
  using System.IO;
  using System.Net.Http;
  using System.Text;
  using System.Threading.Tasks;

  class Program
  {
      static async Task Main(string[] args)
      {
          string TOKEN = "YOUR_API_TOKEN_HERE";
          string url = $"https://production-sfo.browserless.io/screenshot?token={TOKEN}";

          string jsonData = @"
            {
                ""url"": ""https://browserless.io/"",
                ""rejectResourceTypes"": [""image""],
                ""rejectRequestPattern"": [""^.*\\\\.(css)""]
            }";

          using var client = new HttpClient();


          var request = new HttpRequestMessage(HttpMethod.Post, url)
          {
              Content = new StringContent(jsonData, Encoding.UTF8, "application/json")
          };


          request.Headers.Add("Cache-Control", "no-cache");

          try
          {
              var response = await client.SendAsync(request);
              response.EnsureSuccessStatusCode();

              var imageBytes = await response.Content.ReadAsByteArrayAsync();

              await File.WriteAllBytesAsync("screenshot.png", imageBytes);

              Console.WriteLine("Screenshot saved as screenshot.png");
          }
          catch (Exception ex)
          {
              Console.WriteLine($"Error: {ex.Message}");
          }
      }
  }

```

## Navigation Options [â€‹](https://docs.browserless.io/rest-apis/screenshot\#navigation-options "Direct link to Navigation Options")

You can use the `gotoOptions` to modify the default navigation behavior for the requested URL. The objects mirror [Puppeteer's `GoToOptions` interface](https://pptr.dev/api/puppeteer.gotooptions).

- JSON payload
- cURL
- Javascript
- Python
- Java
- C#

```codeBlockLines_p187
{
  "url": "https://example.com/",
  "gotoOptions": { "waitUntil": "networkidle2" },
}

```

```codeBlockLines_p187
curl -X POST \
  https://production-sfo.browserless.io/screenshot?token=YOUR_API_TOKEN_HERE \
  -H 'Cache-Control: no-cache' \
  -H 'Content-Type': 'application/json' \
  -d '{
  "url": "https://example.com/",
  "gotoOptions": { "waitUntil": "networkidle2" }
}' \
  --output "screenshot.png"

```

```codeBlockLines_p187
import fs from 'fs/promises';

const TOKEN = "YOUR_API_TOKEN_HERE";
const url = `https://production-sfo.browserless.io/screenshot?token=${TOKEN}`;
const headers = {
  "Cache-Control": "no-cache",
  "Content-Type": "application/json"
};

const data = {
  url: "https://example.com/",
  gotoOptions: { waitUntil: "networkidle2" }
};

const takeScreenshot = async () => {
  const response = await fetch(url, {
    method: 'POST',
    headers: headers,
    body: JSON.stringify(data)
  });

  const imageBuffer = await response.arrayBuffer();
  await fs.writeFile("screenshot.png", Buffer.from(imageBuffer));
  console.log("Screenshot saved as screenshot.png");
};

takeScreenshot();

```

```codeBlockLines_p187
import requests

TOKEN = "YOUR_API_TOKEN_HERE"
url = f"https://production-sfo.browserless.io/screenshot?token={TOKEN}"
headers = {
    "Cache-Control": "no-cache",
    "Content-Type": "application/json"
}

data = {
    "url": "https://example.com/",
    "gotoOptions": { "waitUntil": "networkidle2" }
}

response = requests.post(url, headers=headers, json=data)

with open("screenshot.png", "wb") as file:
    file.write(response.content)

print("Screenshot saved as screenshot.png")

```

```codeBlockLines_p187
import java.io.*;
import java.net.URI;
import java.net.http.*;
import java.nio.file.*;

public class TakeScreenshotWithGotoOptions {
    public static void main(String[] args) {
        String TOKEN = "YOUR_API_TOKEN_HERE";
        String url = "https://production-sfo.browserless.io/screenshot?token=" + TOKEN;

        String jsonData = """
        {
            "url": "https://example.com/",
            "gotoOptions": { "waitUntil": "networkidle2" }
        }
        """;

        HttpClient client = HttpClient.newHttpClient();

        HttpRequest request = HttpRequest.newBuilder()
            .uri(URI.create(url))
            .header("Cache-Control", "no-cache")
            .header("Content-Type", "application/json")
            .POST(HttpRequest.BodyPublishers.ofString(jsonData))
            .build();

        try {
            HttpResponse<InputStream> response = client.send(request, HttpResponse.BodyHandlers.ofInputStream());
            Files.copy(response.body(), Paths.get("screenshot.png"), StandardCopyOption.REPLACE_EXISTING);
            System.out.println("Screenshot saved as screenshot.png");
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

```

```codeBlockLines_p187
  using System;
  using System.IO;
  using System.Net.Http;
  using System.Text;
  using System.Threading.Tasks;

  class Program
  {
      static async Task Main(string[] args)
      {
          string TOKEN = "YOUR_API_TOKEN_HERE";
          string url = $"https://production-sfo.browserless.io/screenshot?token={TOKEN}";

          string jsonData = @"
            {
                ""url"": ""https://example.com/"",
                ""gotoOptions"": { ""waitUntil"": ""networkidle2"" }
            }";

          using var client = new HttpClient();


          var request = new HttpRequestMessage(HttpMethod.Post, url)
          {
              Content = new StringContent(jsonData, Encoding.UTF8, "application/json")
          };


          request.Headers.Add("Cache-Control", "no-cache");

          try
          {
              var response = await client.SendAsync(request);
              response.EnsureSuccessStatusCode();

              var imageBytes = await response.Content.ReadAsByteArrayAsync();

              await File.WriteAllBytesAsync("screenshot.png", imageBytes);

              Console.WriteLine("Screenshot saved as screenshot.png");
          }
          catch (Exception ex)
          {
              Console.WriteLine($"Error: {ex.Message}");
          }
      }
  }

```

## Continue on Error [â€‹](https://docs.browserless.io/rest-apis/screenshot\#continue-on-error "Direct link to Continue on Error")

You can use `bestAttempt` to make Browserless attempt to proceed when async events fail or timeout. This includes things like the `goto` or `waitForSelector` proprieties in the JSON payload.

- JSON payload
- cURL
- Javascript
- Python
- Java
- C#

```codeBlockLines_p187
{
  "url": "https://example.com/",
  "bestAttempt": true,

  // This would fail without bestAttempt
  "waitForSelector": { "selector": "table", "timeout": 500 }
}

```

```codeBlockLines_p187
curl -X POST \
  https://production-sfo.browserless.io/screenshot?token=YOUR_API_TOKEN_HERE \
  -H 'Cache-Control: no-cache' \
  -H 'Content-Type': 'application/json' \
  -d '{
  "url": "https://example.com/",
  "bestAttempt": true,
  "waitForSelector": { "selector": "table", "timeout": 500 }
}' \
  --output "screenshot.png"

```

```codeBlockLines_p187
import fs from 'fs/promises';

const TOKEN = "YOUR_API_TOKEN_HERE";
const url = `https://production-sfo.browserless.io/screenshot?token=${TOKEN}`;
const headers = {
  "Cache-Control": "no-cache",
  "Content-Type": "application/json"
};

const data = {
  url: "https://example.com/",
  bestAttempt: true,
  waitForSelector: { selector: "table", timeout: 500 }
};

const takeScreenshot = async () => {
  const response = await fetch(url, {
    method: 'POST',
    headers: headers,
    body: JSON.stringify(data)
  });

  const imageBuffer = await response.arrayBuffer();
  await fs.writeFile("screenshot.png", Buffer.from(imageBuffer));
  console.log("Screenshot saved as screenshot.png");
};

takeScreenshot();

```

```codeBlockLines_p187
import requests

TOKEN = "YOUR_API_TOKEN_HERE"
url = f"https://production-sfo.browserless.io/screenshot?token={TOKEN}"
headers = {
    "Cache-Control": "no-cache",
    "Content-Type": "application/json"
}

data = {
    "url": "https://example.com/",
    "bestAttempt": True,
    "waitForSelector": { "selector": "table", "timeout": 500 }
}

response = requests.post(url, headers=headers, json=data)

with open("screenshot.png", "wb") as file:
    file.write(response.content)

print("Screenshot saved as screenshot.png")

```

```codeBlockLines_p187
import java.io.*;
import java.net.URI;
import java.net.http.*;
import java.nio.file.*;

public class TakeScreenshotWithBestAttempt {
    public static void main(String[] args) {
        String TOKEN = "YOUR_API_TOKEN_HERE";
        String url = "https://production-sfo.browserless.io/screenshot?token=" + TOKEN;

        String jsonData = """
        {
            "url": "https://example.com/",
            "bestAttempt": true,
            "waitForSelector": { "selector": "table", "timeout": 500 }
        }
        """;

        HttpClient client = HttpClient.newHttpClient();

        HttpRequest request = HttpRequest.newBuilder()
            .uri(URI.create(url))
            .header("Cache-Control", "no-cache")
            .header("Content-Type", "application/json")
            .POST(HttpRequest.BodyPublishers.ofString(jsonData))
            .build();

        try {
            HttpResponse<InputStream> response = client.send(request, HttpResponse.BodyHandlers.ofInputStream());
            Files.copy(response.body(), Paths.get("screenshot.png"), StandardCopyOption.REPLACE_EXISTING);
            System.out.println("Screenshot saved as screenshot.png");
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

```

```codeBlockLines_p187
  using System;
  using System.IO;
  using System.Net.Http;
  using System.Text;
  using System.Threading.Tasks;

  class Program
  {
      static async Task Main(string[] args)
      {
          string TOKEN = "YOUR_API_TOKEN_HERE";
          string url = $"https://production-sfo.browserless.io/screenshot?token={TOKEN}";

          string jsonData = @"
            {
                ""url"": ""https://example.com/"",
                ""bestAttempt"": true,
                ""waitForSelector"": { ""selector"": ""table"", ""timeout"": 500 }
            }";

          using var client = new HttpClient();


          var request = new HttpRequestMessage(HttpMethod.Post, url)
          {
              Content = new StringContent(jsonData, Encoding.UTF8, "application/json")
          };


          request.Headers.Add("Cache-Control", "no-cache");

          try
          {
              var response = await client.SendAsync(request);
              response.EnsureSuccessStatusCode();

              var imageBytes = await response.Content.ReadAsByteArrayAsync();

              await File.WriteAllBytesAsync("screenshot.png", imageBytes);

              Console.WriteLine("Screenshot saved as screenshot.png");
          }
          catch (Exception ex)
          {
              Console.WriteLine($"Error: {ex.Message}");
          }
      }
  }

```

## Waiting for Things [â€‹](https://docs.browserless.io/rest-apis/screenshot\#waiting-for-things "Direct link to Waiting for Things")

Browserless offers 4 different ways to wait for preconditions to be met on page. These are events, functions, selectors and timeouts

### waitForEvent [â€‹](https://docs.browserless.io/rest-apis/screenshot\#waitforevent "Direct link to waitForEvent")

Waits for an event to happen on the page before cotinue

#### Example [â€‹](https://docs.browserless.io/rest-apis/screenshot\#example "Direct link to Example")

- JSON payload
- cURL
- Javascript
- Python
- Java
- C#

```codeBlockLines_p187
// Will fail since the event never fires
{
  "url": "https://example.com/",
  "waitForEvent": {
    "event": "fullscreenchange",
    "timeout": 5000
  }
}

```

```codeBlockLines_p187
curl -X POST \
  https://production-sfo.browserless.io/screenshot?token=YOUR_API_TOKEN_HERE \
  -H 'Cache-Control: no-cache' \
  -H 'Content-Type': 'application/json' \
  -d '{
  "url": "https://example.com/",
  "waitForEvent": {
    "event": "fullscreenchange",
    "timeout": 5000
  }
}' \
  --output "screenshot.png"

```

```codeBlockLines_p187
import fs from 'fs/promises';

const TOKEN = "YOUR_API_TOKEN_HERE";
const url = `https://production-sfo.browserless.io/screenshot?token=${TOKEN}`;
const headers = {
  "Cache-Control": "no-cache",
  "Content-Type": "application/json"
};

const data = {
  url: "https://example.com/",
  waitForEvent: {
    event: "fullscreenchange",
    timeout: 5000
  }
};

const takeScreenshot = async () => {
  const response = await fetch(url, {
    method: 'POST',
    headers: headers,
    body: JSON.stringify(data)
  });

  const imageBuffer = await response.arrayBuffer();
  await fs.writeFile("screenshot.png", Buffer.from(imageBuffer));
  console.log("Screenshot saved as screenshot.png");
};

takeScreenshot();

```

```codeBlockLines_p187
import requests

TOKEN = "YOUR_API_TOKEN_HERE"
url = f"https://production-sfo.browserless.io/screenshot?token={TOKEN}"
headers = {
    "Cache-Control": "no-cache",
    "Content-Type": "application/json"
}

data = {
    "url": "https://example.com/",
    "waitForEvent": {
        "event": "fullscreenchange",
        "timeout": 5000
    }
}

response = requests.post(url, headers=headers, json=data)

with open("screenshot.png", "wb") as file:
    file.write(response.content)

print("Screenshot saved as screenshot.png")

```

```codeBlockLines_p187
import java.io.*;
import java.net.URI;
import java.net.http.*;
import java.nio.file.*;

public class TakeScreenshotWithWaitForEvent {
    public static void main(String[] args) {
        String TOKEN = "YOUR_API_TOKEN_HERE";
        String url = "https://production-sfo.browserless.io/screenshot?token=" + TOKEN;

        String jsonData = """
        {
            "url": "https://example.com/",
            "waitForEvent": {
                "event": "fullscreenchange",
                "timeout": 5000
            }
        }
        """;

        HttpClient client = HttpClient.newHttpClient();

        HttpRequest request = HttpRequest.newBuilder()
            .uri(URI.create(url))
            .header("Cache-Control", "no-cache")
            .header("Content-Type", "application/json")
            .POST(HttpRequest.BodyPublishers.ofString(jsonData))
            .build();

        try {
            HttpResponse<InputStream> response = client.send(request, HttpResponse.BodyHandlers.ofInputStream());
            Files.copy(response.body(), Paths.get("screenshot.png"), StandardCopyOption.REPLACE_EXISTING);
            System.out.println("Screenshot saved as screenshot.png");
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

```

```codeBlockLines_p187
  using System;
  using System.IO;
  using System.Net.Http;
  using System.Text;
  using System.Threading.Tasks;

  class Program
  {
      static async Task Main(string[] args)
      {
          string TOKEN = "YOUR_API_TOKEN_HERE";
          string url = $"https://production-sfo.browserless.io/screenshot?token={TOKEN}";

          string jsonData = @"
            {
                ""url"": ""https://example.com/"",
                ""waitForEvent"": {
                    ""event"": ""fullscreenchange"",
                    ""timeout"": 5000
                }
            }";

          using var client = new HttpClient();


          var request = new HttpRequestMessage(HttpMethod.Post, url)
          {
              Content = new StringContent(jsonData, Encoding.UTF8, "application/json")
          };


          request.Headers.Add("Cache-Control", "no-cache");

          try
          {
              var response = await client.SendAsync(request);
              response.EnsureSuccessStatusCode();

              var imageBytes = await response.Content.ReadAsByteArrayAsync();

              await File.WriteAllBytesAsync("screenshot.png", imageBytes);

              Console.WriteLine("Screenshot saved as screenshot.png");
          }
          catch (Exception ex)
          {
              Console.WriteLine($"Error: {ex.Message}");
          }
      }
  }

```

### waitForFunction [â€‹](https://docs.browserless.io/rest-apis/screenshot\#waitforfunction "Direct link to waitForFunction")

Waits for the provided function to return before cotinue. The function can be any valid JavaScript or EcmaScript function, and `async` functions are supported.

#### Example [â€‹](https://docs.browserless.io/rest-apis/screenshot\#example-1 "Direct link to Example")

**JS function**

```codeBlockLines_p187
async () => {
  const res = await fetch("https://jsonplaceholder.typicode.com/todos/1");
  const json = await res.json();

  document.querySelector("h1").innerText = json.title;
};

```

- JSON payload
- cURL
- Javascript
- Python
- Java
- C#

```codeBlockLines_p187
{
  "url": "https://example.com/",
  "waitForFunction": {
    "fn": "async()=>{let t=await fetch('https://jsonplaceholder.typicode.com/todos/1'),e=await t.json();document.querySelector('h1').innerText=e.title}",
    "timeout": 5000
  }
}

```

```codeBlockLines_p187
curl -X POST \
  https://production-sfo.browserless.io/screenshot?token=YOUR_API_TOKEN_HERE \
  -H 'Cache-Control: no-cache' \
  -H 'Content-Type': 'application/json' \
  -d '{
  "url": "https://example.com/",
  "waitForFunction": {
    "fn": "async()=>{let t=await fetch('https://jsonplaceholder.typicode.com/todos/1'),e=await t.json();document.querySelector('h1').innerText=e.title}",
    "timeout": 5000
  }
}' \
  --output "screenshot.png"

```

```codeBlockLines_p187
import fs from 'fs/promises';

const TOKEN = "YOUR_API_TOKEN_HERE";
const url = `https://production-sfo.browserless.io/screenshot?token=${TOKEN}`;
const headers = {
  "Cache-Control": "no-cache",
  "Content-Type": "application/json"
};

const data = {
  url: "https://example.com/",
  waitForFunction: {
    fn: "async()=>{let t=await fetch('https://jsonplaceholder.typicode.com/todos/1'),e=await t.json();document.querySelector('h1').innerText=e.title}",
    timeout: 5000
  }
};

const takeScreenshot = async () => {
  const response = await fetch(url, {
    method: 'POST',
    headers: headers,
    body: JSON.stringify(data)
  });

  const imageBuffer = await response.arrayBuffer();
  await fs.writeFile("screenshot.png", Buffer.from(imageBuffer));
  console.log("Screenshot saved as screenshot.png");
};

takeScreenshot();

```

```codeBlockLines_p187
import requests

TOKEN = "YOUR_API_TOKEN_HERE"
url = f"https://production-sfo.browserless.io/screenshot?token={TOKEN}"
headers = {
    "Cache-Control": "no-cache",
    "Content-Type": "application/json"
}

data = {
    "url": "https://example.com/",
    "waitForFunction": {
        "fn": "async()=>{let t=await fetch('https://jsonplaceholder.typicode.com/todos/1'),e=await t.json();document.querySelector('h1').innerText=e.title}",
        "timeout": 5000
    }
}

response = requests.post(url, headers=headers, json=data)

with open("screenshot.png", "wb") as file:
    file.write(response.content)

print("Screenshot saved as screenshot.png")

```

```codeBlockLines_p187
import java.io.*;
import java.net.URI;
import java.net.http.*;
import java.nio.file.*;

public class TakeScreenshotWithWaitForFunction {
    public static void main(String[] args) {
        String TOKEN = "YOUR_API_TOKEN_HERE";
        String url = "https://production-sfo.browserless.io/screenshot?token=" + TOKEN;

        String jsonData = """
        {
            "url": "https://example.com/",
            "waitForFunction": {
                "fn": "async()=>{let t=await fetch('https://jsonplaceholder.typicode.com/todos/1'),e=await t.json();document.querySelector('h1').innerText=e.title}",
                "timeout": 5000
            }
        }
        """;

        HttpClient client = HttpClient.newHttpClient();

        HttpRequest request = HttpRequest.newBuilder()
            .uri(URI.create(url))
            .header("Cache-Control", "no-cache")
            .header("Content-Type", "application/json")
            .POST(HttpRequest.BodyPublishers.ofString(jsonData))
            .build();

        try {
            HttpResponse<InputStream> response = client.send(request, HttpResponse.BodyHandlers.ofInputStream());
            Files.copy(response.body(), Paths.get("screenshot.png"), StandardCopyOption.REPLACE_EXISTING);
            System.out.println("Screenshot saved as screenshot.png");
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

```

```codeBlockLines_p187
  using System;
  using System.IO;
  using System.Net.Http;
  using System.Text;
  using System.Threading.Tasks;

  class Program
  {
      static async Task Main(string[] args)
      {
          string TOKEN = "YOUR_API_TOKEN_HERE";
          string url = $"https://production-sfo.browserless.io/screenshot?token={TOKEN}";

          string jsonData = @"
            {
                ""url"": ""https://example.com/"",
                ""waitForFunction"": {
                    ""fn"": ""async()=>{let t=await fetch('https://jsonplaceholder.typicode.com/todos/1'),e=await t.json();document.querySelector('h1').innerText=e.title}"",
                    ""timeout"": 5000
                }
            }";

          using var client = new HttpClient();


          var request = new HttpRequestMessage(HttpMethod.Post, url)
          {
              Content = new StringContent(jsonData, Encoding.UTF8, "application/json")
          };


          request.Headers.Add("Cache-Control", "no-cache");

          try
          {
              var response = await client.SendAsync(request);
              response.EnsureSuccessStatusCode();

              var imageBytes = await response.Content.ReadAsByteArrayAsync();

              await File.WriteAllBytesAsync("screenshot.png", imageBytes);

              Console.WriteLine("Screenshot saved as screenshot.png");
          }
          catch (Exception ex)
          {
              Console.WriteLine($"Error: {ex.Message}");
          }
      }
  }

```

### waitForSelector [â€‹](https://docs.browserless.io/rest-apis/screenshot\#waitforselector "Direct link to waitForSelector")

Wait for a selector to appear in page. If at the moment of calling the method the selector already exists, the method will return immediately. If the selector doesn't appear after the timeout milliseconds of waiting, the function will throw.

The object can have any of these values:

- `selector`: String, required â€” A valid CSS selector.
- `hidden` Boolean, optional â€” Wait for the selected element to not be found in the DOM or to be hidden, i.e. have `display: none` or `visibility: hidden` CSS properties.
- `timeout`: Number, optional â€” Maximum number of milliseconds to wait for the selector before failing.
- `visible`: Boolean, optional â€” Wait for the selected element to be present in DOM and to be visible, i.e. to not have `display: none` or `visibility: hidden` CSS properties.

#### Example [â€‹](https://docs.browserless.io/rest-apis/screenshot\#example-2 "Direct link to Example")

- JSON payload
- cURL
- Javascript
- Python
- Java
- C#

```codeBlockLines_p187
// Will fail since the event never fires
{
  "url": "https://example.com/",
  "waitForEvent": {
    "event": "fullscreenchange",
    "timeout": 5000
  }
}

```

```codeBlockLines_p187
curl -X POST \
  https://production-sfo.browserless.io/screenshot?token=YOUR_API_TOKEN_HERE \
  -H 'Cache-Control: no-cache' \
  -H 'Content-Type': 'application/json' \
  -d '{
  "url": "https://example.com/",
  "waitForEvent": {
    "event": "fullscreenchange",
    "timeout": 5000
  }
}' \
  --output "screenshot.png"

```

```codeBlockLines_p187
import fs from 'fs/promises';

const TOKEN = "YOUR_API_TOKEN_HERE";
const url = `https://production-sfo.browserless.io/screenshot?token=${TOKEN}`;
const headers = {
  "Cache-Control": "no-cache",
  "Content-Type": "application/json"
};

const data = {
  url: "https://example.com/",
  waitForEvent: {
    event: "fullscreenchange",
    timeout: 5000
  }
};

const takeScreenshot = async () => {
  const response = await fetch(url, {
    method: 'POST',
    headers: headers,
    body: JSON.stringify(data)
  });

  const imageBuffer = await response.arrayBuffer();
  await fs.writeFile("screenshot.png", Buffer.from(imageBuffer));
  console.log("Screenshot saved as screenshot.png");
};

takeScreenshot();

```

```codeBlockLines_p187
import requests

TOKEN = "YOUR_API_TOKEN_HERE"
url = f"https://production-sfo.browserless.io/screenshot?token={TOKEN}"
headers = {
    "Cache-Control": "no-cache",
    "Content-Type": "application/json"
}

data = {
    "url": "https://example.com/",
    "waitForEvent": {
        "event": "fullscreenchange",
        "timeout": 5000
    }
}

response = requests.post(url, headers=headers, json=data)

with open("screenshot.png", "wb") as file:
    file.write(response.content)

print("Screenshot saved as screenshot.png")

```

```codeBlockLines_p187
import java.io.*;
import java.net.URI;
import java.net.http.*;
import java.nio.file.*;

public class TakeScreenshotWithWaitForEvent {
    public static void main(String[] args) {
        String TOKEN = "YOUR_API_TOKEN_HERE";
        String url = "https://production-sfo.browserless.io/screenshot?token=" + TOKEN;

        String jsonData = """
        {
            "url": "https://example.com/",
            "waitForEvent": {
                "event": "fullscreenchange",
                "timeout": 5000
            }
        }
        """;

        HttpClient client = HttpClient.newHttpClient();

        HttpRequest request = HttpRequest.newBuilder()
            .uri(URI.create(url))
            .header("Cache-Control", "no-cache")
            .header("Content-Type", "application/json")
            .POST(HttpRequest.BodyPublishers.ofString(jsonData))
            .build();

        try {
            HttpResponse<InputStream> response = client.send(request, HttpResponse.BodyHandlers.ofInputStream());
            Files.copy(response.body(), Paths.get("screenshot.png"), StandardCopyOption.REPLACE_EXISTING);
            System.out.println("Screenshot saved as screenshot.png");
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

```

```codeBlockLines_p187
  using System;
  using System.IO;
  using System.Net.Http;
  using System.Text;
  using System.Threading.Tasks;

  class Program
  {
      static async Task Main(string[] args)
      {
          string TOKEN = "YOUR_API_TOKEN_HERE";
          string url = $"https://production-sfo.browserless.io/screenshot?token={TOKEN}";

          string jsonData = @"
            {
                ""url"": ""https://example.com/"",
                ""waitForEvent"": {
                    ""event"": ""fullscreenchange"",
                    ""timeout"": 5000
                }
            }";

          using var client = new HttpClient();


          var request = new HttpRequestMessage(HttpMethod.Post, url)
          {
              Content = new StringContent(jsonData, Encoding.UTF8, "application/json")
          };


          request.Headers.Add("Cache-Control", "no-cache");

          try
          {
              var response = await client.SendAsync(request);
              response.EnsureSuccessStatusCode();

              var imageBytes = await response.Content.ReadAsByteArrayAsync();

              await File.WriteAllBytesAsync("screenshot.png", imageBytes);

              Console.WriteLine("Screenshot saved as screenshot.png");
          }
          catch (Exception ex)
          {
              Console.WriteLine($"Error: {ex.Message}");
          }
      }
  }

```

- [Basic Usage](https://docs.browserless.io/rest-apis/screenshot#basic-usage)
- [Setting HTML content](https://docs.browserless.io/rest-apis/screenshot#setting-html-content)
- [Adding custom styles and scripts](https://docs.browserless.io/rest-apis/screenshot#adding-custom-styles-and-scripts)
- [Rejecting Undesired Requests](https://docs.browserless.io/rest-apis/screenshot#rejecting-undesired-requests)
- [Navigation Options](https://docs.browserless.io/rest-apis/screenshot#navigation-options)
- [Continue on Error](https://docs.browserless.io/rest-apis/screenshot#continue-on-error)
- [Waiting for Things](https://docs.browserless.io/rest-apis/screenshot#waiting-for-things)
  - [waitForEvent](https://docs.browserless.io/rest-apis/screenshot#waitforevent)
  - [waitForFunction](https://docs.browserless.io/rest-apis/screenshot#waitforfunction)
  - [waitForSelector](https://docs.browserless.io/rest-apis/screenshot#waitforselector)

---

### /unblock API | Browserless.io
Original URL: https://docs.browserless.io/rest-apis/unblock

[Skip to main content](https://docs.browserless.io/rest-apis/unblock#__docusaurus_skipToContent_fallback)


BrowserQL

We recommended using [**BrowserQL**](https://docs.browserless.io/browserql/start), Browserless' first-class browser automation API, to bypass any bot detection mechanisms.

The `/unblock` API is designed to bypass bot detection mechanisms such as Datadome and other passive CAPTCHAs. There are two main ways to use the API

For solving Cloudflare turnstiles, reCAPTCHA, or hCAPTCHA, you'll want to use our BrowserQL tool with the `verify` mutation. See [BrowserQL CAPTCHA Solving Guide](https://docs.browserless.io/browserql/bot-detection/solving-captchas#verify) for more details.

- Grab the HTML or screenshot of a page with `content` or `screenshot` set to true.
- Generate a WebSocket endpoint to perform automations with Playwright, Puppeteer or another CDP library.

Using the /unblock API is charged at 10 units per page. It works best when combined with our [Browserless Residential Proxy Service](https://docs.browserless.io/baas/proxies).

This API is particularly useful for developers who need to automate web interactions on sites that employ sophisticated bot detection and blocking techniques. It offers four different ways to wait for preconditions to be met before returning a response.

You can [view the complete Unblock API OpenAPI specification](https://docs.browserless.io/open-api#tag/Browser-REST-APIs/paths/~1unblock%20~1chromium~1unblock/post) for all properties and documentation.

## Retrieving HTML [â€‹](https://docs.browserless.io/rest-apis/unblock\#retrieving-html "Direct link to Retrieving HTML")

If you'd like to retrieve the HTML of a page for scraping, you can set the `content` field to `true` in the JSON payload. With a proxy enabled, this would be:

- cURL
- Javascript
- Python
- Java
- C#

```codeBlockLines_p187
curl --request POST \
  --url 'https://production-sfo.browserless.io/unblock?token=YOUR_API_TOKEN_HERE&proxy=residential' \
  --header 'Content-Type: application/json' \
  --data '{
  "url": "https://example.com/",
  "browserWSEndpoint": false,
  "cookies": false,
  "content": true,
  "screenshot": false
}'

```

```codeBlockLines_p187
const TOKEN = "YOUR_API_TOKEN_HERE";
const url = `https://production-sfo.browserless.io/unblock?token=${TOKEN}&proxy=residential`;
const headers = {
  "Content-Type": "application/json"
};

const data = {
  url: "https://example.com/",
  browserWSEndpoint: false,
  cookies: false,
  content: true,
  screenshot: false
};

const fetchContent = async () => {
  const response = await fetch(url, {
    method: 'POST',
    headers: headers,
    body: JSON.stringify(data)
  });

  const content = await response.json();
  console.log(content);
};

fetchContent();

```

```codeBlockLines_p187
import requests

TOKEN = "YOUR_API_TOKEN_HERE"
url = f"https://production-sfo.browserless.io/unblock?token={TOKEN}&proxy=residential"
headers = {
    "Content-Type": "application/json"
}

data = {
    "url": "https://example.com/",
    "browserWSEndpoint": False,
    "cookies": False,
    "content": True,
    "screenshot": False
}

response = requests.post(url, headers=headers, json=data)

print(response.json())

```

```codeBlockLines_p187
import java.io.*;
import java.net.URI;
import java.net.http.*;

public class FetchUnblockedContent {
    public static void main(String[] args) {
        String TOKEN = "YOUR_API_TOKEN_HERE";
        String url = "https://production-sfo.browserless.io/unblock?token=" + TOKEN + "&proxy=residential";

        String jsonData = """
        {
            "url": "https://example.com/",
            "browserWSEndpoint": false,
            "cookies": false,
            "content": true,
            "screenshot": false
        }
        """;

        HttpClient client = HttpClient.newHttpClient();

        HttpRequest request = HttpRequest.newBuilder()
            .uri(URI.create(url))
            .header("Content-Type", "application/json")
            .POST(HttpRequest.BodyPublishers.ofString(jsonData))
            .build();

        try {
            HttpResponse<String> response = client.send(request, HttpResponse.BodyHandlers.ofString());
            System.out.println("Response: " + response.body());
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

```

```codeBlockLines_p187
using System;
using System.Net.Http;
using System.Text;
using System.Threading.Tasks;

class Program
{
    static async Task Main(string[] args)
    {
        string TOKEN = "YOUR_API_TOKEN_HERE";
        string url = $"https://production-sfo.browserless.io/unblock?token={TOKEN}&proxy=residential";

        string jsonData = @"
        {
            ""url"": ""https://example.com/"",
            ""browserWSEndpoint"": false,
            ""cookies"": false,
            ""content"": true,
            ""screenshot"": false
        }";

        using var client = new HttpClient();
        var content = new StringContent(jsonData, Encoding.UTF8, "application/json");

        try
        {
            var response = await client.PostAsync(url, content);
            response.EnsureSuccessStatusCode();

            var result = await response.Content.ReadAsStringAsync();
            Console.WriteLine("Response: " + result);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error: {ex.Message}");
        }
    }
}

```

Which will result in a response containing the unblocked page's HTML:

```codeBlockLines_p187
{
  "browserWSEndpoint": "wss://production-sfo.browserless.io/e/53616c7465645f5fa57aca44763bd816bb1aa1f1210ed871a908fd60235848ce6e4bcc0a8fcfe08c6d96eff8d68d556e/devtools/browser/646b292c-bd2a-4964-af18-9c1a6081c32e",
  "content": "<!DOCTYPE html><html>...</html>",
  "cookies": [],
  "screenshot": null,
  "ttl": 60000
}

```

You can then process this HTML with libraries such as [Scrapy](https://docs.browserless.io/baas/libraries/scrapy) or [Beautiful Soup](https://docs.browserless.io/baas/libraries/beautifulsoup).

## Creating an endpoint [â€‹](https://docs.browserless.io/rest-apis/unblock\#creating-an-endpoint "Direct link to Creating an endpoint")

The /unblock API can get past a bot detector, then give you the cookies and a connection to the browser instance to use in your automations.

**JSON Payload**

This is a JSON object containing the URL of the site you wish to unblock, along with the parameters you want in the response. If you're reconnecting to the browser, you **always** want to set the `ttl` the `browserWSEndpoint` and `cookies`.

```codeBlockLines_p187
{
  "url": "https://example.com",
  "browserWSEndpoint": true,
  "cookies": true,
  "content": false,
  "screenshot": false,
  "ttl": 30000
}

```

We would recommend using /unblock with a residential proxy, such as in this example.

- cURL
- Javascript
- Python
- Java
- C#

```codeBlockLines_p187
curl --request POST \
  --url 'https://production-sfo.browserless.io/unblock?token=YOUR_API_TOKEN_HERE&proxy=residential' \
  --header 'Content-Type: application/json' \
  --data '{
  "url": "https://example.com",
  "browserWSEndpoint": true,
  "cookies": true,
  "content": false,
  "screenshot": false,
  "ttl": 30000
}'

```

```codeBlockLines_p187
const TOKEN = "YOUR_API_TOKEN_HERE";
const url = `https://production-sfo.browserless.io/unblock?token=${TOKEN}&proxy=residential`;
const headers = {
  "Content-Type": "application/json"
};

const data = {
  url: "https://example.com",
  browserWSEndpoint: true,
  cookies: true,
  content: false,
  screenshot: false,
  ttl: 30000
};

const fetchBrowserWSEndpoint = async () => {
  const response = await fetch(url, {
    method: 'POST',
    headers: headers,
    body: JSON.stringify(data)
  });

  const result = await response.json();
  console.log(result);
};

fetchBrowserWSEndpoint();

```

```codeBlockLines_p187
import requests

TOKEN = "YOUR_API_TOKEN_HERE"
url = f"https://production-sfo.browserless.io/unblock?token={TOKEN}&proxy=residential"
headers = {
    "Content-Type": "application/json"
}

data = {
    "url": "https://example.com",
    "browserWSEndpoint": True,
    "cookies": True,
    "content": False,
    "screenshot": False,
    "ttl": 30000
}

response = requests.post(url, headers=headers, json=data)
result = response.json()

print(result)

```

```codeBlockLines_p187
import java.io.*;
import java.net.URI;
import java.net.http.*;

public class FetchBrowserWSEndpoint {
    public static void main(String[] args) {
        String TOKEN = "YOUR_API_TOKEN_HERE";
        String url = "https://production-sfo.browserless.io/unblock?token=" + TOKEN + "&proxy=residential";

        String jsonData = """
        {
            "url": "https://example.com",
            "browserWSEndpoint": true,
            "cookies": true,
            "content": false,
            "screenshot": false,
            "ttl": 30000
        }
        """;

        HttpClient client = HttpClient.newHttpClient();

        HttpRequest request = HttpRequest.newBuilder()
            .uri(URI.create(url))
            .header("Content-Type", "application/json")
            .POST(HttpRequest.BodyPublishers.ofString(jsonData))
            .build();

        try {
            HttpResponse<String> response = client.send(request, HttpResponse.BodyHandlers.ofString());
            System.out.println("Response: " + response.body());
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

```

```codeBlockLines_p187
  using System;
  using System.Net.Http;
  using System.Text;
  using System.Threading.Tasks;

  class Program
  {
      static async Task Main(string[] args)
      {
          string TOKEN = "YOUR_API_TOKEN_HERE";
          string url = $"https://production-sfo.browserless.io/unblock?token={TOKEN}&proxy=residential";

          string jsonData = @"
          {
              ""url"": ""https://example.com"",
              ""browserWSEndpoint"": true,
              ""cookies"": true,
              ""content"": false,
              ""screenshot"": false,
              ""ttl"": 30000
          }";

          using var client = new HttpClient();
          var content = new StringContent(jsonData, Encoding.UTF8, "application/json");

          try
          {
              var response = await client.PostAsync(url, content);
              response.EnsureSuccessStatusCode();

              var result = await response.Content.ReadAsStringAsync();
              Console.WriteLine("Response: " + result);
          }
          catch (Exception ex)
          {
              Console.WriteLine($"Error: {ex.Message}");
          }
      }
  }

```

Which will return a JSON response like this:

```codeBlockLines_p187
{
  "browserWSEndpoint": "wss://production-sfo.browserless.io/p/53616c7465645f5f0d2e4012516859fdda7cc1ae0b16c6c5ec739d5d9f19a3d3c9b49c8a814b0fd1beae934b2e8050a0/devtools/browser/102ea3e9-74d7-42c9-a856-1bf254649b9a",
  "content": null,
  "cookies": [\
    {\
      name: "session_id",\
      value: "XYZ123",\
      domain: "example.com",\
      path: "/",\
      secure: true,\
      httpOnly: true,\
    },\
  ],
  "screenshot": null,
  "ttl": 30000
}

```

After receiving the response with the `browserWSEndpoint` and `cookies`, you can use Puppeteer, Playwright or another CDP library to connect to the browser instance and inject the cookies to continue your scraping process:

- Puppeteer
- Playwright

```codeBlockLines_p187
import puppeteer from "puppeteer-core";

const TOKEN = "YOUR_API_TOKEN_HERE";

const unblock = async (url) => {
  const opts = {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
    },
    body: JSON.stringify({
      url: url,
      browserWSEndpoint: true,
      cookies: false,
      content: false,
      screenshot: false,
      ttl: 10000,
    }),
  };

  const response = await fetch(
    `https://production-sfo.browserless.io/chromium/unblock?token=${TOKEN}`,
    opts,
  );

  return await response.json();
};

// Reconnect
const { browserWSEndpoint, cookies } = await unblock("https://browserless.io/");

const browser = await puppeteer.connect({
  browserWSEndpoint: browserWSEndpoint + `?token=${TOKEN}`,
});
const page = (await browser.pages())[0];

// Or inject cookies into the page
// await page.setCookie(...response.cookies);
// await page.goto("https://browserless.io/");
// await page.screenshot({ path: "screenshot.png" });

await page.screenshot({ path: `screenshot-${Date.now()}.png` });
await browser.close();

```

- Javascript
- Python
- Java
- C#

```codeBlockLines_p187
import playwright from "playwright-core";

const TOKEN = "YOUR_API_TOKEN_HERE";

const unblock = async (url) => {
  const opts = {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
    },
    body: JSON.stringify({
      url: url,
      browserWSEndpoint: true,
      cookies: false,
      content: false,
      screenshot: false,
      ttl: 10000,
    }),
  };

  const response = await fetch(
    `https://production-sfo.browserless.io/chromium/unblock?token=${TOKEN}`,
    opts
  );

  return await response.json();
};

// Reconnect
const { browserWSEndpoint, cookies } = await unblock("https://browserless.io/");

const browser = await playwright.chromium.connect(`${browserWSEndpoint}?token=${TOKEN}`);
const context = await browser.newContext();

const page = await context.newPage();

// Or inject cookies into the page
// await page.context().addCookies(cookies);
// await page.goto("https://browserless.io/");
// await page.screenshot({ path: "screenshot.png" });

await page.screenshot({ path: `screenshot-${Date.now()}.png` });
await browser.close();

```

```codeBlockLines_p187
from playwright.sync_api import sync_playwright
import requests
import json

TOKEN = "YOUR_API_TOKEN_HERE"

def unblock(url):
    opts = {
        "url": url,
        "browserWSEndpoint": True,
        "cookies": False,
        "content": False,
        "screenshot": False,
        "ttl": 10000
    }

    response = requests.post(
        f"https://production-sfo.browserless.io/chromium/unblock?token={TOKEN}",
        headers={"Content-Type": "application/json"},
        data=json.dumps(opts)
    )

    return response.json()

with sync_playwright() as p:
    unblock_response = unblock("https://browserless.io/")
    browserWSEndpoint = unblock_response["browserWSEndpoint"]
    cookies = unblock_response.get("cookies", [])

    browser = p.chromium.connect(f"{browserWSEndpoint}?token={TOKEN}")
    context = browser.new_context()

    page = context.new_page()
    # Inject cookies if needed
    # context.add_cookies(cookies)
    # page.goto("https://browserless.io/")
    # page.screenshot(path="screenshot.png")

    page.screenshot(path=f"screenshot-{int(time.time())}.png")
    browser.close()

```

```codeBlockLines_p187
import com.microsoft.playwright.*;
import org.json.JSONObject;

import java.net.http.*;
import java.net.URI;

public class PlaywrightUnblock {
    private static final String TOKEN = "YOUR_API_TOKEN_HERE";

    public static JSONObject unblock(String url) throws Exception {
        HttpClient client = HttpClient.newHttpClient();
        String requestBody = new JSONObject()
                .put("url", url)
                .put("browserWSEndpoint", true)
                .put("cookies", false)
                .put("content", false)
                .put("screenshot", false)
                .put("ttl", 10000)
                .toString();

        HttpRequest request = HttpRequest.newBuilder()
                .uri(new URI("https://production-sfo.browserless.io/chromium/unblock?token=" + TOKEN))
                .header("Content-Type", "application/json")
                .POST(HttpRequest.BodyPublishers.ofString(requestBody))
                .build();

        HttpResponse<String> response = client.send(request, HttpResponse.BodyHandlers.ofString());
        return new JSONObject(response.body());
    }

    public static void main(String[] args) throws Exception {
        JSONObject unblockResponse = unblock("https://browserless.io/");
        String browserWSEndpoint = unblockResponse.getString("browserWSEndpoint");

        try (Playwright playwright = Playwright.create()) {
            Browser browser = playwright.chromium().connect(browserWSEndpoint + "?token=" + TOKEN);
            BrowserContext context = browser.newContext();
            Page page = context.newPage();

            // Inject cookies if needed
            // context.addCookies(cookiesArray);
            // page.navigate("https://browserless.io/");
            // page.screenshot(new Page.ScreenshotOptions().setPath(Paths.get("screenshot.png")));

            page.screenshot(new Page.ScreenshotOptions().setPath(Paths.get("screenshot-" + System.currentTimeMillis() + ".png")));
            browser.close();
        }
    }
}

```

```codeBlockLines_p187
  using System;
  using System.Net.Http;
  using System.Text;
  using System.Text.Json;
  using System.Threading.Tasks;
  using Microsoft.Playwright;

  class Program
  {
      private const string TOKEN = "YOUR_API_TOKEN_HERE";

      static async Task<JsonElement> UnblockAsync(string url)
      {
          using var client = new HttpClient();
          var opts = new
          {
              url = url,
              browserWSEndpoint = true,
              cookies = false,
              content = false,
              screenshot = false,
              ttl = 10000
          };

          var response = await client.PostAsync(
              $"https://production-sfo.browserless.io/chromium/unblock?token={TOKEN}",
              new StringContent(JsonSerializer.Serialize(opts), Encoding.UTF8, "application/json")
          );

          response.EnsureSuccessStatusCode();
          var jsonResponse = await response.Content.ReadAsStringAsync();
          return JsonSerializer.Deserialize<JsonElement>(jsonResponse);
      }

      static async Task Main(string[] args)
      {
          try
          {
              var unblockResponse = await UnblockAsync("https://browserless.io/");
              Console.WriteLine("Unblock Response:");
              Console.WriteLine(unblockResponse);

              string browserWSEndpoint = unblockResponse.GetProperty("browserWSEndpoint").GetString();
              Console.WriteLine($"Connecting to WebSocket: {browserWSEndpoint}");

              var playwright = await Playwright.CreateAsync();
              var browser = await playwright.Chromium.ConnectOverCDPAsync($"{browserWSEndpoint}?token={TOKEN}");

              var context = await browser.NewContextAsync();
              var page = await context.NewPageAsync();

              Console.WriteLine("Taking screenshot...");
              await page.ScreenshotAsync(new PageScreenshotOptions { Path = $"screenshot-{DateTimeOffset.UtcNow.ToUnixTimeMilliseconds()}.png" });

              await browser.CloseAsync();
              Console.WriteLine("Browser closed successfully.");
          }
          catch (Exception ex)
          {
              Console.WriteLine($"Error: {ex.Message}");
          }
      }
  }

```

## Waiting for Things [â€‹](https://docs.browserless.io/rest-apis/unblock\#waiting-for-things "Direct link to Waiting for Things")

Browserless offers 4 different ways to wait for preconditions to be met on the page before returning the response. These are `events`, `functions`, `selectors` and `timeouts`.

### waitForEvent [â€‹](https://docs.browserless.io/rest-apis/unblock\#waitforevent "Direct link to waitForEvent")

Waits for an event to happen on the page before continuing:

#### Example [â€‹](https://docs.browserless.io/rest-apis/unblock\#example "Direct link to Example")

- JSON payload
- cURL
- Javascript
- Python
- Java
- C#

```codeBlockLines_p187
// Will fail since the event never fires // but used for demonstration purposes
{
  "url": "https://example.com/",
  "waitForEvent": {
    "event": "fullscreenchange",
    "timeout": 5000
  }
}

```

```codeBlockLines_p187
curl -X POST \
  https://production-sfo.browserless.io/unblock?token=YOUR_API_TOKEN_HERE \
  -H 'Cache-Control: no-cache' \
  -H 'Content-Type': 'application/json' \
  -d '{
  "url": "https://example.com/",
  "waitForEvent": {
    "event": "fullscreenchange",
    "timeout": 5000
  }
}'

```

```codeBlockLines_p187
const TOKEN = "YOUR_API_TOKEN_HERE";
const url = `https://production-sfo.browserless.io/unblock?token=${TOKEN}`;
const headers = {
  "Cache-Control": "no-cache",
  "Content-Type": "application/json"
};

const data = {
  url: "https://example.com/",
  waitForEvent: {
    event: "fullscreenchange",
    timeout: 5000
  }
};

const unblockRequest = async () => {
  const response = await fetch(url, {
    method: 'POST',
    headers: headers,
    body: JSON.stringify(data)
  });

  const result = await response.json();
  console.log(result);
};

unblockRequest();

```

```codeBlockLines_p187
import requests

TOKEN = "YOUR_API_TOKEN_HERE"
url = f"https://production-sfo.browserless.io/unblock?token={TOKEN}"
headers = {
    "Cache-Control": "no-cache",
    "Content-Type": "application/json"
}

data = {
    "url": "https://example.com/",
    "waitForEvent": {
        "event": "fullscreenchange",
        "timeout": 5000
    }
}

response = requests.post(url, headers=headers, json=data)
result = response.json()

print(result)

```

```codeBlockLines_p187
import java.io.*;
import java.net.URI;
import java.net.http.*;

public class UnblockRequestWithWaitForEvent {
    public static void main(String[] args) {
        String TOKEN = "YOUR_API_TOKEN_HERE";
        String url = "https://production-sfo.browserless.io/unblock?token=" + TOKEN;

        String jsonData = """
        {
            "url": "https://example.com/",
            "waitForEvent": {
                "event": "fullscreenchange",
                "timeout": 5000
            }
        }
        """;

        HttpClient client = HttpClient.newHttpClient();

        HttpRequest request = HttpRequest.newBuilder()
            .uri(URI.create(url))
            .header("Cache-Control", "no-cache")
            .header("Content-Type", "application/json")
            .POST(HttpRequest.BodyPublishers.ofString(jsonData))
            .build();

        try {
            HttpResponse<String> response = client.send(request, HttpResponse.BodyHandlers.ofString());
            System.out.println("Response: " + response.body());
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

```

```codeBlockLines_p187
using System;
using System.Net.Http;
using System.Text;
using System.Threading.Tasks;

class Program {
    static async Task Main(string[] args) {
        string TOKEN = "YOUR_API_TOKEN_HERE";
        string url = $"https://production-sfo.browserless.io/unblock?token={TOKEN}";

        string jsonData = @"
        {
            ""url"": ""https://example.com/"",
            ""waitForEvent"": {
                ""event"": ""fullscreenchange"",
                ""timeout"": 5000
            }
        }";

        using var client = new HttpClient();
        var content = new StringContent(jsonData, Encoding.UTF8, "application/json");

        try {
            var response = await client.PostAsync(url, content);
            response.EnsureSuccessStatusCode();

            var result = await response.Content.ReadAsStringAsync();
            Console.WriteLine("Response: " + result);
        } catch (Exception ex) {
            Console.WriteLine($"Error: {ex.Message}");
        }
    }
}

```

### waitForFunction [â€‹](https://docs.browserless.io/rest-apis/unblock\#waitforfunction "Direct link to waitForFunction")

Waits for the provided function to return before continuing. The function can be any valid JavaScript function including `async` functions.

#### Example [â€‹](https://docs.browserless.io/rest-apis/unblock\#example-1 "Direct link to Example")

**JS function**

```codeBlockLines_p187
async () => {
  const res = await fetch("https://jsonplaceholder.typicode.com/todos/1");
  const json = await res.json();

  document.querySelector("h1").innerText = json.title;
};

```

- JSON payload
- cURL
- Javascript
- Python
- Java
- C#

```codeBlockLines_p187
{
  "url": "https://example.com/",
  "waitForFunction": {
    "fn": "async()=>{let t=await fetch('https://jsonplaceholder.typicode.com/todos/1'),e=await t.json();document.querySelector('h1').innerText=e.title}",
    "timeout": 5000
  }
}

```

```codeBlockLines_p187
curl -X POST \
  https://production-sfo.browserless.io/unblock?token=YOUR_API_TOKEN_HERE \
  -H 'Cache-Control: no-cache' \
  -H 'Content-Type': 'application/json' \
  -d '{
  "url": "https://example.com/",
  "waitForFunction": {
    "fn": "async()=>{let t=await fetch('https://jsonplaceholder.typicode.com/todos/1'),e=await t.json();document.querySelector('h1').innerText=e.title}",
    "timeout": 5000
  }
}'

```

```codeBlockLines_p187
const TOKEN = "YOUR_API_TOKEN_HERE";
const url = `https://production-sfo.browserless.io/unblock?token=${TOKEN}`;
const headers = {
  "Cache-Control": "no-cache",
  "Content-Type": "application/json"
};

const data = {
  url: "https://example.com/",
  waitForFunction: {
    fn: "async()=>{let t=await fetch('https://jsonplaceholder.typicode.com/todos/1'),e=await t.json();document.querySelector('h1').innerText=e.title}",
    timeout: 5000
  }
};

const unblockRequest = async () => {
  const response = await fetch(url, {
    method: 'POST',
    headers: headers,
    body: JSON.stringify(data)
  });

  const result = await response.json();
  console.log(result);
};

unblockRequest();

```

```codeBlockLines_p187
import requests

TOKEN = "YOUR_API_TOKEN_HERE"
url = f"https://production-sfo.browserless.io/unblock?token={TOKEN}"
headers = {
    "Cache-Control": "no-cache",
    "Content-Type": "application/json"
}

data = {
    "url": "https://example.com/",
    "waitForFunction": {
        "fn": "async()=>{let t=await fetch('https://jsonplaceholder.typicode.com/todos/1'),e=await t.json();document.querySelector('h1').innerText=e.title}",
        "timeout": 5000
    }
}

response = requests.post(url, headers=headers, json=data)
result = response.json()

print(result)

```

```codeBlockLines_p187
import java.io.*;
import java.net.URI;
import java.net.http.*;

public class UnblockRequestWithWaitForFunction {
    public static void main(String[] args) {
        String TOKEN = "YOUR_API_TOKEN_HERE";
        String url = "https://production-sfo.browserless.io/unblock?token=" + TOKEN;

        String jsonData = """
        {
            "url": "https://example.com/",
            "waitForFunction": {
                "fn": "async()=>{let t=await fetch('https://jsonplaceholder.typicode.com/todos/1'),e=await t.json();document.querySelector('h1').innerText=e.title}",
                "timeout": 5000
            }
        }
        """;

        HttpClient client = HttpClient.newHttpClient();

        HttpRequest request = HttpRequest.newBuilder()
            .uri(URI.create(url))
            .header("Cache-Control", "no-cache")
            .header("Content-Type", "application/json")
            .POST(HttpRequest.BodyPublishers.ofString(jsonData))
            .build();

        try {
            HttpResponse<String> response = client.send(request, HttpResponse.BodyHandlers.ofString());
            System.out.println("Response: " + response.body());
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

```

```codeBlockLines_p187
using System;
using System.Net.Http;
using System.Text;
using System.Threading.Tasks;

class Program {
    static async Task Main(string[] args) {
        string TOKEN = "YOUR_API_TOKEN_HERE";
        string url = $"https://production-sfo.browserless.io/unblock?token={TOKEN}";

        string jsonData = @"
        {
            ""url"": ""https://example.com/"",
            ""waitForFunction"": {
                ""fn"": ""async()=>{let t=await fetch('https://jsonplaceholder.typicode.com/todos/1'),e=await t.json();document.querySelector('h1').innerText=e.title}"",
                ""timeout"": 5000
            }
        }";

        using var client = new HttpClient();
        var content = new StringContent(jsonData, Encoding.UTF8, "application/json");

        try {
            var response = await client.PostAsync(url, content);
            response.EnsureSuccessStatusCode();

            var result = await response.Content.ReadAsStringAsync();
            Console.WriteLine("Response: " + result);
        } catch (Exception ex) {
            Console.WriteLine($"Error: {ex.Message}");
        }
    }
}

```

### waitForSelector [â€‹](https://docs.browserless.io/rest-apis/unblock\#waitforselector "Direct link to waitForSelector")

Waits for a selector to appear on the page. If at the moment of calling this API, the selector already exists, the method will return immediately. If the selector doesn't appear after the timeout milliseconds of waiting the API will return a non-200 response code with an error message as the body of the response.

The object can have any of these values:

- `selector`: String, required â€” A valid CSS selector.
- `hidden` Boolean, optional â€” Wait for the selected element to not be found in the DOM or to be hidden, i.e. have `display: none` or `visibility: hidden` CSS properties.
- `timeout`: Number, optional â€” Maximum number of milliseconds to wait for the selector before failing.
- `visible`: Boolean, optional â€” Wait for the selected element to be present in DOM and to be visible, i.e. to not have `display: none` or `visibility: hidden` CSS properties.

#### Example [â€‹](https://docs.browserless.io/rest-apis/unblock\#example-2 "Direct link to Example")

- JSON payload
- cURL
- Javascript
- Python
- Java
- C#

```codeBlockLines_p187
{
  "url": "https://example.com/",
  "waitForSelector": {
    "selector": "h1",
    "timeout": 5000
  }
}

```

```codeBlockLines_p187
curl -X POST \
  https://production-sfo.browserless.io/unblock?token=YOUR_API_TOKEN_HERE \
  -H 'Cache-Control: no-cache' \
  -H 'Content-Type': 'application/json' \
  -d '{
  "url": "https://example.com/",
  "waitForSelector": {
    "selector": "h1",
    "timeout": 5000
  }
}'

```

```codeBlockLines_p187
const TOKEN = "YOUR_API_TOKEN_HERE";
const url = `https://production-sfo.browserless.io/unblock?token=${TOKEN}`;
const headers = {
  "Cache-Control": "no-cache",
  "Content-Type": "application/json"
};

const data = {
  url: "https://example.com/",
  waitForSelector: {
    selector: "h1",
    timeout: 5000
  }
};

const unblockRequest = async () => {
  const response = await fetch(url, {
    method: 'POST',
    headers: headers,
    body: JSON.stringify(data)
  });

  const result = await response.json();
  console.log("Response:", result);
};

unblockRequest();

```

```codeBlockLines_p187
import requests

TOKEN = "YOUR_API_TOKEN_HERE"
url = f"https://production-sfo.browserless.io/unblock?token={TOKEN}"
headers = {
    "Cache-Control": "no-cache",
    "Content-Type": "application/json"
}

data = {
    "url": "https://example.com/",
    "waitForSelector": {
        "selector": "h1",
        "timeout": 5000
    }
}

response = requests.post(url, headers=headers, json=data)
result = response.json()

print("Response:", result)

```

```codeBlockLines_p187
import java.io.*;
import java.net.URI;
import java.net.http.*;

public class UnblockRequestWithWaitForSelector {
    public static void main(String[] args) {
        String TOKEN = "YOUR_API_TOKEN_HERE";
        String url = "https://production-sfo.browserless.io/unblock?token=" + TOKEN;

        String jsonData = """
        {
            "url": "https://example.com/",
            "waitForSelector": {
                "selector": "h1",
                "timeout": 5000
            }
        }
        """;

        HttpClient client = HttpClient.newHttpClient();

        HttpRequest request = HttpRequest.newBuilder()
            .uri(URI.create(url))
            .header("Cache-Control", "no-cache")
            .header("Content-Type", "application/json")
            .POST(HttpRequest.BodyPublishers.ofString(jsonData))
            .build();

        try {
            HttpResponse<String> response = client.send(request, HttpResponse.BodyHandlers.ofString());
            System.out.println("Response: " + response.body());
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

```

```codeBlockLines_p187
using System;
using System.Net.Http;
using System.Text;
using System.Threading.Tasks;

class Program {
    static async Task Main(string[] args) {
        string TOKEN = "YOUR_API_TOKEN_HERE";
        string url = $"https://production-sfo.browserless.io/unblock?token={TOKEN}";

        string jsonData = @"
        {
            ""url"": ""https://example.com/"",
            ""waitForSelector"": {
                ""selector"": ""h1"",
                ""timeout"": 5000
            }
        }";

        using var client = new HttpClient();
        var content = new StringContent(jsonData, Encoding.UTF8, "application/json");

        try {
            var response = await client.PostAsync(url, content);
            response.EnsureSuccessStatusCode();

            var result = await response.Content.ReadAsStringAsync();
            Console.WriteLine("Response: " + result);
        } catch (Exception ex) {
            Console.WriteLine($"Error: {ex.Message}");
        }
    }
}

```

- [Retrieving HTML](https://docs.browserless.io/rest-apis/unblock#retrieving-html)
- [Creating an endpoint](https://docs.browserless.io/rest-apis/unblock#creating-an-endpoint)
- [Waiting for Things](https://docs.browserless.io/rest-apis/unblock#waiting-for-things)
  - [waitForEvent](https://docs.browserless.io/rest-apis/unblock#waitforevent)
  - [waitForFunction](https://docs.browserless.io/rest-apis/unblock#waitforfunction)
  - [waitForSelector](https://docs.browserless.io/rest-apis/unblock#waitforselector)

---

### Browserless.io
Original URL: https://docs.browserless.io/scraping/bot-detectors

[Skip to main content](https://docs.browserless.io/scraping/bot-detectors#__docusaurus_skipToContent_fallback)

# Page Not Found

We could not find what you were looking for.

Please contact the owner of the site that linked you to the original URL and let them know their link is broken.

---

### Browserless.io
Original URL: https://docs.browserless.io/scraping/extracting-data

[Skip to main content](https://docs.browserless.io/scraping/extracting-data#__docusaurus_skipToContent_fallback)

# Page Not Found

We could not find what you were looking for.

Please contact the owner of the site that linked you to the original URL and let them know their link is broken.

---

### Browserless.io
Original URL: https://docs.browserless.io/scraping/performing-searches

[Skip to main content](https://docs.browserless.io/scraping/performing-searches#__docusaurus_skipToContent_fallback)

# Page Not Found

We could not find what you were looking for.

Please contact the owner of the site that linked you to the original URL and let them know their link is broken.

---

### Browserless.io
Original URL: https://docs.browserless.io/scraping/scraping-responses

[Skip to main content](https://docs.browserless.io/scraping/scraping-responses#__docusaurus_skipToContent_fallback)

# Page Not Found

We could not find what you were looking for.

Please contact the owner of the site that linked you to the original URL and let them know their link is broken.

---

### Search the documentation
Original URL: https://docs.browserless.io/search

[Skip to main content](https://docs.browserless.io/search#__docusaurus_skipToContent_fallback)

# Search the documentation

---

### Browserless.io
Original URL: https://docs.browserless.io/ui-automation

[Skip to main content](https://docs.browserless.io/ui-automation#__docusaurus_skipToContent_fallback)

# Page Not Found

We could not find what you were looking for.

Please contact the owner of the site that linked you to the original URL and let them know their link is broken.

---

